(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0; i < l; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

},{}],2:[function(require,module,exports){
"use strict";

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

var base64 = require('base64-js');
var ieee754 = require('ieee754');
var isArray = require('isarray');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":1,"ieee754":28,"isarray":32}],4:[function(require,module,exports){
'use strict';

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],5:[function(require,module,exports){
(function (Buffer){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":31}],6:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;

  if (!this._events) this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events || !this._events[type]) return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;

  if (!this._events) return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
(function (global){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (a, b) {
  if ("function" == typeof define && define.amd) define([], b);else if ("undefined" != typeof exports) b();else {
    b(), a.FileSaver = { exports: {} }.exports;
  }
})(undefined, function () {
  "use strict";
  function b(a, b) {
    return "undefined" == typeof b ? b = { autoBom: !1 } : "object" != (typeof b === "undefined" ? "undefined" : _typeof(b)) && (console.warn("Depricated: Expected third argument to be a object"), b = { autoBom: !b }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], { type: a.type }) : a;
  }function c(b, c, d) {
    var e = new XMLHttpRequest();e.open("GET", b), e.responseType = "blob", e.onload = function () {
      a(e.response, c, d);
    }, e.onerror = function () {
      console.error("could not download file");
    }, e.send();
  }function d(a) {
    var b = new XMLHttpRequest();return b.open("HEAD", a, !1), b.send(), 200 <= b.status && 299 >= b.status;
  }function e(a) {
    try {
      a.dispatchEvent(new MouseEvent("click"));
    } catch (c) {
      var b = document.createEvent("MouseEvents");b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
    }
  }var f = function () {
    try {
      return Function("return this")() || (42, eval)("this");
    } catch (a) {
      return "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.window === window ? window : "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self ? self : "object" == (typeof global === "undefined" ? "undefined" : _typeof(global)) && global.global === global ? global : this;
    }
  }(),
      a = f.saveAs || "object" != (typeof window === "undefined" ? "undefined" : _typeof(window)) || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype ? function (b, g, h) {
    var i = f.URL || f.webkitURL,
        j = document.createElement("a");g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
      i.revokeObjectURL(j.href);
    }, 4E4), setTimeout(function () {
      e(j);
    }, 0));
  } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
    if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
      var i = document.createElement("a");i.href = f, i.target = "_blank", setTimeout(function () {
        e(i);
      });
    }
  } : function (a, b, d, e) {
    if (e = e || open("", "_blank"), e && (e.document.title = e.document.body.innerText = "downloading..."), "string" == typeof a) return c(a, b, d);var g = "application/octet-stream" === a.type,
        h = /constructor/i.test(f.HTMLElement) || f.safari,
        i = /CriOS\/[\d]+/.test(navigator.userAgent);if ((i || g && h) && "object" == (typeof FileReader === "undefined" ? "undefined" : _typeof(FileReader))) {
      var j = new FileReader();j.onloadend = function () {
        var a = j.result;a = i ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), e ? e.location.href = a : location = a, e = null;
      }, j.readAsDataURL(a);
    } else {
      var k = f.URL || f.webkitURL,
          l = k.createObjectURL(a);e ? e.location = l : location.href = l, e = null, setTimeout(function () {
        k.revokeObjectURL(l);
      }, 4E4);
    }
  };f.saveAs = a.saveAs = a, "undefined" != typeof module && (module.exports = a);
});



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
module.exports=[
	"a",
	"abbr",
	"address",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"bdi",
	"bdo",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"cite",
	"code",
	"col",
	"colgroup",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"div",
	"dl",
	"dt",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"img",
	"input",
	"ins",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"main",
	"map",
	"mark",
	"math",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"nav",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"picture",
	"pre",
	"progress",
	"q",
	"rb",
	"rp",
	"rt",
	"rtc",
	"ruby",
	"s",
	"samp",
	"script",
	"section",
	"select",
	"slot",
	"small",
	"source",
	"span",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"svg",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"u",
	"ul",
	"var",
	"video",
	"wbr"
]

},{}],9:[function(require,module,exports){
'use strict';

module.exports = require('./html-tags.json');

},{"./html-tags.json":8}],10:[function(require,module,exports){
'use strict';

module.exports = {
	obj: require('./lib/obj'),
	arr: require('./lib/arr'),
	str: require('./lib/str'),
	fn: require('./lib/fn')
};

},{"./lib/arr":11,"./lib/fn":12,"./lib/obj":13,"./lib/str":14}],11:[function(require,module,exports){
'use strict';

var add = function add(arr, item) {
	return [].concat(arr, [item]);
};

var remove = function remove(arr, item) {
	return arr.indexOf(item) > -1 ? [].concat(arr.slice(0, arr.indexOf(item)), arr.slice(arr.indexOf(item) + 1)) : arr;
};

var toggle = function toggle(arr, item) {
	return arr.indexOf(item) > -1 ? remove(arr, item) : add(arr, item);
};

module.exports = {
	add: add,
	remove: remove,
	toggle: toggle
};

},{}],12:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var obj = require('./obj');

// (((a, b, …, n) → o), (o → p), …, (x → y), (y → z)) → ((a, b, …, n) → z)
var pipe = function pipe(a) {
	for (var _len = arguments.length, fns = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		fns[_key - 1] = arguments[_key];
	}

	return function () {
		return fns.reduce(function (res, fn) {
			return fn(res);
		}, a.apply(undefined, arguments));
	};
};

// ((y → z), (x → y), …, (o → p), ((a, b, …, n) → o)) → ((a, b, …, n) → z)
var compose = function compose() {
	for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		fns[_key2] = arguments[_key2];
	}

	return pipe.apply(undefined, [fns.slice(-1).pop()].concat(_toConsumableArray(fns.reverse().slice(1))));
};

// switch for backwards compatibility
module.exports = {
	compose: compose,
	pipe: pipe,
	switch: obj.switch
};

},{"./obj":13}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var keyValue = function keyValue(k, v) {
	var o = {};
	o[k] = v;
	return o;
};

var clone = function clone(o) {
	return _extends(Object.create(Object.getPrototypeOf(o) || {}), o);
};

var sub = function sub(o, p) {
	return p instanceof Array ? typeof o[p[0]] !== 'undefined' && p.length > 1 ? sub(o[p[0]], p.slice(1)) : o[p[0]] : o[p];
};

var patch = function patch(o, k, v) {
	return _extends(clone(o), k instanceof Array ? keyValue(k[0], k.length > 1 ? patch(o[k[0]] || {}, k.slice(1), v) : _typeof(o[k[0]]) === 'object' && o[k[0]].constructor === Object && _extends(clone(o[k[0]]), v) || v) : keyValue(k, _typeof(o[k]) === 'object' && o[k].constructor === Object && _extends(clone(o[k]), v) || v));
};

var reduce = function reduce(o, reduceFn, initial) {
	return Object.keys(o).reduce(function (accumulator, key, index) {
		return reduceFn(accumulator, key, o[key], index, o);
	}, typeof initial === 'undefined' ? o[Object.keys(o)[0]] // to confirm with the array reduce spec in this case the firts property is used
	: initial);
};

var map = function map(o, mapFn) {
	return reduce(o, function (o2, key, value, index) {
		return patch(o2, key, mapFn(key, value, index, o));
	}, {});
};

var filter = function filter(o, filterFn) {
	return reduce(o, function (o2, key, value, index) {
		return filterFn(key, value, index, o) ? patch(o2, key, value) : o2;
	}, {});
};

var traverse = function traverse(tree, fn) {
	return Object.keys(tree).reduce(function (o, k) {
		return patch(o, k, _typeof(tree[k]) === 'object' && tree[k].constructor === Object ? traverse(tree[k], fn) : fn(tree[k], k));
	}, {});
};

var chainCall = function chainCall(o, chain) {
	return chain.reduce(function (o, link) {
		return typeof link[1] === 'undefined' ? o[link[0]]() : o[link[0]](link[1]);
	}, o);
};

var _switch = function _switch(value, cases) {
	return sub(cases, value) && sub(cases, value)['default'] || sub(cases, value) || value instanceof Array && value.length > 1 && _switch(value.slice(0, value.length - 1), cases) || cases['default'] || false;
};

module.exports = {
	keyValue: keyValue,
	clone: clone,
	sub: sub,
	patch: patch,
	reduce: reduce,
	map: map,
	filter: filter,
	traverse: traverse,
	chainCall: chainCall,
	switch: _switch
};

},{}],14:[function(require,module,exports){
'use strict';

var capitalize = function capitalize(chunk) {
	return chunk.charAt(0).toUpperCase() + chunk.slice(1);
};

var toCamelCase = function toCamelCase(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	return str.split(glue).map(function (chunk, i) {
		return i === 0 ? chunk : capitalize(chunk);
	}).join('');
};

var fromCamelCase = function fromCamelCase(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	return str.replace(/([A-Z])/g, ' $1').split(' ').map(function (chunk) {
		return chunk.toLowerCase();
	}).join(glue);
};

var singularToPlural = function singularToPlural(str) {
	return str.replace(/y$/, 'ie').concat('s');
};

var pluralToSingular = function pluralToSingular(str) {
	return str.replace(/ies$/, 'y').replace(/s$/, '');
};

var toDocumentId = function toDocumentId(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Id';
	var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
	return prefix.concat(pluralToSingular(toCamelCase(str, glue)), suffix);
};

module.exports = {
	capitalize: capitalize,
	toCamelCase: toCamelCase,
	fromCamelCase: fromCamelCase,
	singularToPlural: singularToPlural,
	pluralToSingular: pluralToSingular,
	toDocumentId: toDocumentId
};

},{}],15:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var snabbdom = require('snabbdom');
var h = require('snabbdom/h').default;

var _require = require('iblokz-data'),
    obj = _require.obj;

var htmlTags = require('html-tags');

var attrs = require('./util/attrs');

var patch = snabbdom.init([// Init patch function with choosen modules
require('snabbdom/modules/class').default, // makes it easy to toggle classes
require('snabbdom/modules/props').default, // for setting properties on DOM elements
require('snabbdom/modules/attributes').default, // for setting properties on DOM elements
require('snabbdom/modules/style').default, // handles styling on elements with support for animations
require('snabbdom/modules/eventlisteners').default // attaches event listeners
]);

var patchStream = function patchStream(stream, dom) {
	dom = typeof dom === 'string' ? document.querySelector(dom) : dom;
	stream.scan(function (vnode, newVnode) {
		return patch(vnode, newVnode);
	}, dom).subscribe();
};

var hyperHelpers = htmlTags.reduce(function (o, tag) {
	o[tag] = function () {
		var _this = this;

		return [Array.from(arguments)].map(attrs.process).map(function (args) {
			return (
				// is the first argument a selector
				args[0] && typeof args[0] === 'string' && args[0].match(/^(\.|#)[a-zA-Z\-_0-9]+/ig) ? [].concat(tag + args[0], args.slice(1)) : [tag].concat(args)
			);
		}).map(function (args) {
			return h.apply(_this, args);
		}).pop();
	};
	return o;
}, {});

module.exports = _extends({
	h: h,
	patch: patch,
	patchStream: patchStream
}, hyperHelpers);

},{"./util/attrs":27,"html-tags":9,"iblokz-data":10,"snabbdom":24,"snabbdom/h":16,"snabbdom/modules/attributes":19,"snabbdom/modules/class":20,"snabbdom/modules/eventlisteners":21,"snabbdom/modules/props":22,"snabbdom/modules/style":23}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {},
        children,
        text,
        i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        } else if (is.primitive(c)) {
            text = c;
        } else if (c && c.sel) {
            children = [c];
        }
    } else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        } else if (is.primitive(b)) {
            text = b;
        } else if (b && b.sel) {
            children = [b];
        } else {
            data = b;
        }
    }
    if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i])) children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i]);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' && (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;


},{"./is":18,"./vnode":26}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
exports.htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment
};
exports.default = exports.htmlDomApi;


},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;


},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", "truespeed", "typemustmatch", "visible"];
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
var booleanAttrsDict = Object.create(null);
for (var i = 0, len = booleanAttrs.length; i < len; i++) {
    booleanAttrsDict[booleanAttrs[i]] = true;
}
function updateAttrs(oldVnode, vnode) {
    var key,
        elm = vnode.elm,
        oldAttrs = oldVnode.data.attrs,
        attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs) return;
    if (oldAttrs === attrs) return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (booleanAttrsDict[key]) {
                if (cur) {
                    elm.setAttribute(key, "");
                } else {
                    elm.removeAttribute(key);
                }
            } else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                } else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                } else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                } else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;


},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur,
        name,
        elm = vnode.elm,
        oldClass = oldVnode.data.class,
        klass = vnode.data.class;
    if (!oldClass && !klass) return;
    if (oldClass === klass) return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;


},{}],21:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    } else if ((typeof handler === "undefined" ? "undefined" : _typeof(handler)) === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            } else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        } else {
            // call multiple handlers
            for (var i = 0; i < handler.length; i++) {
                invokeHandler(handler[i]);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type,
        on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) {
        invokeHandler(on[name], vnode, event);
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on,
        oldListener = oldVnode.listener,
        oldElm = oldVnode.elm,
        on = vnode && vnode.data.on,
        elm = vnode && vnode.elm,
        name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                oldElm.removeEventListener(name, oldListener, false);
            }
        } else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                elm.addEventListener(name, listener, false);
            }
        } else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    elm.addEventListener(name, listener, false);
                }
            }
        }
    }
}
exports.eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
exports.default = exports.eventListenersModule;


},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key,
        cur,
        old,
        elm = vnode.elm,
        oldProps = oldVnode.data.props,
        props = vnode.data.props;
    if (!oldProps && !props) return;
    if (oldProps === props) return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;


},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var raf = typeof window !== 'undefined' && window.requestAnimationFrame || setTimeout;
var nextFrame = function nextFrame(fn) {
    raf(function () {
        raf(fn);
    });
};
function setNextFrame(obj, prop, val) {
    nextFrame(function () {
        obj[prop] = val;
    });
}
function updateStyle(oldVnode, vnode) {
    var cur,
        name,
        elm = vnode.elm,
        oldStyle = oldVnode.data.style,
        style = vnode.data.style;
    if (!oldStyle && !style) return;
    if (oldStyle === style) return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            } else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        } else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            } else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style,
        name,
        elm = vnode.elm,
        s = vnode.data.style;
    if (!s || !(style = s.destroy)) return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    var name,
        elm = vnode.elm,
        i = 0,
        compStyle,
        style = s.remove,
        amount = 0,
        applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1) amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm) --amount;
        if (amount === 0) rm();
    });
}
exports.styleModule = {
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;


},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
var htmldomapi_1 = require("./htmldomapi");
function isUndef(s) {
    return s === undefined;
}
function isDef(s) {
    return s !== undefined;
}
var emptyNode = vnode_1.default('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i,
        map = {},
        key,
        ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined) map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
var h_1 = require("./h");
exports.h = h_1.h;
var thunk_1 = require("./thunk");
exports.thunk = thunk_1.thunk;
function init(modules, domApi) {
    var i,
        j,
        cbs = {};
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i,
            data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children,
            sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        } else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag) : api.createElement(tag);
            if (hash < dot) elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, vnode);
            }if (is.array(children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            } else if (is.primitive(vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create) i.create(emptyNode, vnode);
                if (i.insert) insertedVnodeQueue.push(vnode);
            }
        } else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i,
            j,
            data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](vnode);
            }if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0,
                listeners = void 0,
                rm = void 0,
                ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1) {
                        cbs.remove[i_1](ch, rm);
                    }if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    } else {
                        rm();
                    }
                } else {
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0,
            newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            } else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            } else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                } else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    } else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx > oldEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode) return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i) {
                cbs.update[i](oldVnode, vnode);
            }i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        } else if (oldVnode.text !== vnode.text) {
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i) {
            cbs.pre[i]();
        }if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        } else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i) {
            cbs.post[i]();
        }return vnode;
    };
}
exports.init = init;


},{"./h":16,"./htmldomapi":17,"./is":18,"./thunk":25,"./vnode":26}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = require("./h");
function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i,
        old = oldVnode.data,
        cur = thunk.data;
    var oldArgs = old.args,
        args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
exports.thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return h_1.h(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
exports.default = exports.thunk;


},{"./h":16}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;


},{}],27:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('iblokz-data'),
    obj = _require.obj;

var strParse = function strParse(s) {
	return s.match(/^[0-9]+$/) ? parseInt(s, 10) : s.match(/^[0-9.]+$/) ? parseFloat(s) : s === 'true' ? true : s === 'false' ? false : s;
};

var process = function process(args) {
	var newArgs = args.slice();

	var selector = newArgs[0] && typeof newArgs[0] === 'string' && newArgs[0] || '';
	if (selector !== '') newArgs = newArgs.slice(1);

	var attrRegExp = /\[[a-z\-0-9]+=("[^"]+"|'[^']+'|[0-9.]+|true|false|[^\]^=^"^']+)\]/ig;

	var attrs = selector && selector.match(attrRegExp);
	selector = selector.replace(attrRegExp, '');

	attrs = attrs && attrs.map && attrs.map(function (c) {
		return c.replace(/[[\]("|')]/g, '').split('=');
	}).reduce(function (o, attr) {
		return obj.patch(o, attr[0], strParse(attr[1]));
	}, {}) || {};

	if (attrs && Object.keys(attrs).length > 0) {
		if (!newArgs[0] || newArgs[0] && _typeof(newArgs[0]) === 'object' && !(newArgs[0] instanceof Array)) {
			attrs = _extends({}, newArgs[0] && newArgs[0].attrs || {}, attrs);
			newArgs[0] = _extends({}, newArgs[0] || {}, { attrs: attrs });
		} else {
			newArgs = [{ attrs: attrs }].concat(newArgs);
		}
	}

	if (selector !== '') newArgs = [selector].concat(newArgs);

	// console.log(args, newArgs);
	return newArgs;
};

module.exports = {
	strParse: strParse,
	process: process
};

},{"iblokz-data":10}],28:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],29:[function(require,module,exports){
(function (global){
'use strict';

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function scheduleDrain() {
      element.data = called = ++called % 2;
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function scheduleDrain() {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function scheduleDrain() {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function scheduleDrain() {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
'use strict';

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],31:[function(require,module,exports){
'use strict';

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],32:[function(require,module,exports){
'use strict';

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],33:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

// public method for encoding
exports.encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0,
        len = input.length,
        remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }

    return output.join("");
};

// public method for decoding
exports.decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0,
        resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
    } else {
        output = new Array(totalLength | 0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }
    }

    return output;
};

},{"./support":62,"./utils":64}],34:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker: function getContentWorker() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker: function getCompressedWorker() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":38,"./stream/Crc32Probe":57,"./stream/DataLengthProbe":58,"./stream/DataWorker":59}],35:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function compressWorker(compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker: function uncompressWorker() {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":39,"./stream/GenericWorker":60}],36:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
    } else {
        return crc32str(crc | 0, input, input.length, 0);
    }
};

},{"./utils":64}],37:[function(require,module,exports){
'use strict';

exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],38:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)

var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":105}],39:[function(require,module,exports){
'use strict';

var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function (data) {
        self.push({
            data: data,
            meta: self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":60,"./utils":64,"pako":89}],40:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function decToHex(dec, bytes) {
    var hex = "",
        i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0) & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
        compression = streamInfo['compression'],
        useCustomEncoding = encodeFileName !== utf8.utf8encode,
        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
        comment = file.comment,
        encodedComment = utils.transformTo("string", encodeFileName(comment)),
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
        useUTF8ForComment = utfEncodedComment.length !== comment.length,
        dosTime,
        dosDate,
        extraFields = "",
        unicodePathExtraField = "",
        unicodeCommentExtraField = "",
        dir = file.dir,
        date = file.date;

    var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }

    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if (platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
        // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
        // Version
        decToHex(1, 1) +
        // NameCRC32
        decToHex(crc32(encodedFileName), 4) +
        // UnicodeName
        utfEncodedFileName;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x70" +
        // size
        decToHex(unicodePathExtraField.length, 2) +
        // content
        unicodePathExtraField;
    }

    if (useUTF8ForComment) {

        unicodeCommentExtraField =
        // Version
        decToHex(1, 1) +
        // CommentCRC32
        decToHex(crc32(encodedComment), 4) +
        // UnicodeName
        utfEncodedComment;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x63" +
        // size
        decToHex(unicodeCommentExtraField.length, 2) +
        // content
        unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);

    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
    // version made by (00: DOS)
    decToHex(versionMadeBy, 2) +
    // file header (common to file and central directory)
    header +
    // file comment length
    decToHex(encodedComment.length, 2) +
    // disk number start
    "\x00\x00" +
    // internal file attributes TODO
    "\x00\x00" +
    // external file attributes
    decToHex(extFileAttr, 4) +
    // relative offset of local header
    decToHex(offset, 4) +
    // file name
    encodedFileName +
    // extra field
    extraFields +
    // file comment
    encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
    // number of this disk
    "\x00\x00" +
    // number of the disk with the start of the central directory
    "\x00\x00" +
    // total number of entries in the central directory on this disk
    decToHex(entriesCount, 2) +
    // total number of entries in the central directory
    decToHex(entriesCount, 2) +
    // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) +
    // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) +
    // .ZIP file comment length
    decToHex(encodedComment.length, 2) +
    // .ZIP file comment
    encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function generateDataDescriptors(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
    // crc-32                          4 bytes
    decToHex(streamInfo['crc32'], 4) +
    // compressed size                 4 bytes
    decToHex(streamInfo['compressedSize'], 4) +
    // uncompressed size               4 bytes
    decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};

/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;

    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if (this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data: chunk.data,
            meta: {
                currentFile: this.currentFile,
                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data: generateDataDescriptors(streamInfo),
            meta: { percent: 100 }
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data: this.dirRecords[i],
            meta: { percent: 100 }
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data: dirEnd,
        meta: { percent: 100 }
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if (self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for (var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch (e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":36,"../signature":55,"../stream/GenericWorker":60,"../utf8":63,"../utils":64}],41:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function getCompression(fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir,
                date = file.date;

            file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                name: relativePath,
                dir: dir,
                date: date,
                comment: file.comment || "",
                unixPermissions: file.unixPermissions,
                dosPermissions: file.dosPermissions
            }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":35,"./ZipFileWorker":40}],42:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */

function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if (!(this instanceof JSZip)) {
        return new JSZip();
    }

    if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function () {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.5";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":37,"./external":38,"./load":43,"./object":47,"./support":62}],43:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        }).on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        }).resume();
    });
}

module.exports = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions: input.unixPermissions,
                dosPermissions: input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":38,"./nodejsUtils":46,"./stream/Crc32Probe":57,"./utf8":63,"./utils":64,"./zipEntries":65}],44:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function (chunk) {
        self.push({
            data: chunk,
            meta: {
                percent: 0
            }
        });
    }).on("error", function (e) {
        if (self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    }).on("end", function () {
        if (self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if (!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":60,"../utils":64}],45:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if (updateCb) {
            updateCb(meta);
        }
    }).on("error", function (e) {
        self.emit('error', e);
    }).on("end", function () {
        self.push(null);
    });
}

NodejsStreamOutputAdapter.prototype._read = function () {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":64,"readable-stream":48}],46:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode: typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function newBufferFrom(data, encoding) {
        // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`
        // in nodejs v4 (< v.4.5). It's not the expected implementation (and
        // has a different signature).
        // see https://github.com/nodejs/node/issues/8053
        // A condition on nodejs' version won't solve the issue as we don't
        // control the Buffer polyfills that may or may not be used.
        return new Buffer(data, encoding);
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function allocBuffer(size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            return new Buffer(size);
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer: function isBuffer(b) {
        return Buffer.isBuffer(b);
    },

    isStream: function isStream(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
};

}).call(this,require("buffer").Buffer)

},{"buffer":3}],47:[function(require,module,exports){
'use strict';

var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");

/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function fileAdd(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;

    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && o.unixPermissions & 0x4000) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && o.dosPermissions & 0x0010) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }

    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?
     return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function parentFolder(path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function forceTrailingSlash(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function folderAdd(name, createFolders) {
    createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function load() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function forEach(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) {
                // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function filter(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) {
                // the file matches the function
                result.push(entry);
            }
        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function file(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            } else {
                // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        } else {
            // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function folder(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function (relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function remove(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function (relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function generate(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function generateInternalStream(options) {
        var worker,
            opts = {};
        try {
            opts = utils.extend(options || {}, {
                streamFiles: false,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: 'application/zip',
                encodeFileName: utf8.utf8encode
            });

            opts.type = opts.type.toLowerCase();
            opts.compression = opts.compression.toUpperCase();

            // "binarystring" is prefered but the internals use "string".
            if (opts.type === "binarystring") {
                opts.type = "string";
            }

            if (!opts.type) {
                throw new Error("No output type specified.");
            }

            utils.checkSupport(opts.type);

            // accept nodejs `process.platform`
            if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
                opts.platform = "UNIX";
            }
            if (opts.platform === 'win32') {
                opts.platform = "DOS";
            }

            var comment = opts.comment || this.comment || "";
            worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
            worker = new GenericWorker("error");
            worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function generateAsync(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function generateNodeStream(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":34,"./defaults":37,"./generate":41,"./nodejs/NodejsStreamInputAdapter":44,"./nodejsUtils":46,"./stream/GenericWorker":60,"./stream/StreamHelper":61,"./utf8":63,"./utils":64,"./zipObject":67}],48:[function(require,module,exports){
"use strict";

/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":125}],49:[function(require,module,exports){
'use strict';

var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 0xFF;
    }
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function (i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":64,"./DataReader":50}],50:[function(require,module,exports){
'use strict';

var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function checkOffset(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function checkIndex(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function setIndex(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function skip(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function byteAt(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function readInt(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function readString(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function readData(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function lastIndexOfSignature(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function readAndCheckSignature(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function readDate() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
        (dostime >> 21 & 0x0f) - 1, // month
        dostime >> 16 & 0x1f, // day
        dostime >> 11 & 0x1f, // hour
        dostime >> 5 & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":64}],51:[function(require,module,exports){
'use strict';

var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":64,"./Uint8ArrayReader":53}],52:[function(require,module,exports){
'use strict';

var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function (i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function (sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function (size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":64,"./DataReader":50}],53:[function(require,module,exports){
'use strict';

var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":64,"./ArrayReader":49}],54:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":62,"../utils":64,"./ArrayReader":49,"./NodeBufferReader":51,"./StringReader":52,"./Uint8ArrayReader":53}],55:[function(require,module,exports){
'use strict';

exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],56:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":64,"./GenericWorker":60}],57:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
  GenericWorker.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
  this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":36,"../utils":64,"./GenericWorker":60}],58:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;

},{"../utils":64,"./GenericWorker":60}],59:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if (!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function () {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function () {

    if (this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null,
        nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch (this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
                break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
                break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
                break;
        }
        this.index = nextIndex;
        return this.push({
            data: data,
            meta: {
                percent: this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":64,"./GenericWorker":60}],60:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */

function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data': [],
        'end': [],
        'error': []
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push: function push(chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end: function end() {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error: function error(e) {
        if (this.isFinished) {
            return false;
        }

        if (this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if (this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on: function on(name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp: function cleanUp() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit: function emit(name, arg) {
        if (this._listeners[name]) {
            for (var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe: function pipe(next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious: function registerPrevious(previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous = previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause: function pause() {
        if (this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if (this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume: function resume() {
        if (!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if (this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if (this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush: function flush() {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk: function processChunk(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo: function withStreamInfo(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo: function mergeStreamInfo() {
        for (var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function lock() {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString: function toString() {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],61:[function(require,module,exports){
(function (Buffer){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch (e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch (type) {
        case "blob":
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
            return base64.encode(content);
        default:
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat(type, dataArray) {
    var i,
        index = 0,
        res = null,
        totalLength = 0;
    for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch (type) {
        case "string":
            return dataArray.join("");
        case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for (i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '" + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function _accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper.on('data', function (data, meta) {
            dataArray.push(data);
            if (updateCallback) {
                updateCallback(meta);
            }
        }).on('error', function (err) {
            dataArray = [];
            reject(err);
        }).on('end', function () {
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        }).resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
            break;
        case "base64":
            internalType = "string";
            break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate: function accumulate(updateCb) {
        return _accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on: function on(evt, fn) {
        var self = this;

        if (evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume: function resume() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause: function pause() {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream: function toNodejsStream(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
    }
};

module.exports = StreamHelper;

}).call(this,require("buffer").Buffer)

},{"../base64":33,"../external":38,"../nodejs/NodejsStreamOutputAdapter":45,"../support":62,"../utils":64,"./ConvertWorker":56,"./GenericWorker":60,"buffer":3}],62:[function(require,module,exports){
(function (Buffer){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
} else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    } catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        } catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch (e) {
    exports.nodestream = false;
}

}).call(this,require("buffer").Buffer)

},{"buffer":3,"readable-stream":48}],63:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function string2buf(str) {
    var buf,
        c,
        c2,
        m_pos,
        i,
        str_len = str.length,
        buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function utf8border(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) {
        max = buf.length;
    }

    // go back from last position, until start of sequence found
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
    }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) {
        return max;
    }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) {
        return max;
    }

    return pos + _utf8len[buf[pos]] > max ? pos : max;
};

// convert array to string
var buf2string = function buf2string(buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) {
            utf16buf[out++] = c;continue;
        }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
        }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;continue;
        }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};

// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};

/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if (this.leftOver && this.leftOver.length) {
        this.push({
            data: exports.utf8decode(this.leftOver),
            meta: {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":46,"./stream/GenericWorker":60,"./support":62,"./utils":64}],64:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('core-js/library/fn/set-immediate');
var external = require("./external");

/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
        result = new Uint8Array(str.length);
    } else {
        result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function (part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    } catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        } catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function stringifyByChunk(array, type, chunk) {
        var result = [],
            k = 0,
            len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function stringifyByChar(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        }()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;

/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function array(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function uint8array(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function nodebuffer(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function arraybuffer(input) {
        return new Uint8Array(input).buffer;
    },
    "uint8array": function uint8array(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function string(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function array(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function uint8array(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function uint8array(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function (outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function (input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function (type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function (str) {
    var res = '',
        code,
        i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function (callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function Obj() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function () {
    var result = {},
        i,
        attr;
    for (i = 0; i < arguments.length; i++) {
        // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function (data) {

        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function (e) {
                    resolve(e.target.result);
                };
                reader.onerror = function (e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function (data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            } else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":33,"./external":38,"./nodejsUtils":46,"./support":62,"core-js/library/fn/set-immediate":68}],65:[function(require,module,exports){
'use strict';

var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function checkSignature(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function isSignature(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function readBlockEndOfCentral() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function readLocalFiles() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function readCentralDir() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function readEndOfCentral() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();

        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function prepareReader(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function load(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":54,"./signature":55,"./support":62,"./utf8":63,"./utils":64,"./zipEntry":66}],66:[function(require,module,exports){
'use strict';

var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function findCompression(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function isEncrypted() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function useUTF8() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function readLocalPart(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) {
            // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function readCentralPart(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function processAttributes() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if (madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function parseZIP64ExtraField(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function readExtraFields(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function handleUTF8() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":34,"./compressions":35,"./crc32":36,"./reader/readerFor":54,"./support":62,"./utf8":63,"./utils":64}],67:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function ZipObject(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function internalStream(type) {
        var result = null,
            outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function async(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function nodeStream(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function _compressWorker(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if (!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker: function _decompressWorker() {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function removedFn() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for (var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":34,"./stream/DataWorker":59,"./stream/GenericWorker":60,"./stream/StreamHelper":61,"./utf8":63}],68:[function(require,module,exports){
'use strict';

require('../modules/web.immediate');
module.exports = require('../modules/_core').setImmediate;

},{"../modules/_core":72,"../modules/web.immediate":88}],69:[function(require,module,exports){
'use strict';

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],70:[function(require,module,exports){
'use strict';

var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":83}],71:[function(require,module,exports){
"use strict";

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],72:[function(require,module,exports){
'use strict';

var core = module.exports = { version: '2.3.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],73:[function(require,module,exports){
'use strict';

// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":69}],74:[function(require,module,exports){
'use strict';

// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_fails":77}],75:[function(require,module,exports){
'use strict';

var isObject = require('./_is-object'),
    document = require('./_global').document
// in old IE typeof document.createElement is 'object'
,
    is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":78,"./_is-object":83}],76:[function(require,module,exports){
'use strict';

var global = require('./_global'),
    core = require('./_core'),
    ctx = require('./_ctx'),
    hide = require('./_hide'),
    PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      IS_WRAP = type & $export.W,
      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
      expProto = exports[PROTOTYPE],
      target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
      key,
      own,
      out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
          }return new C(a, b, c);
        }return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
      // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

},{"./_core":72,"./_ctx":73,"./_global":78,"./_hide":79}],77:[function(require,module,exports){
"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],78:[function(require,module,exports){
'use strict';

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],79:[function(require,module,exports){
'use strict';

var dP = require('./_object-dp'),
    createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":74,"./_object-dp":84,"./_property-desc":85}],80:[function(require,module,exports){
'use strict';

module.exports = require('./_global').document && document.documentElement;

},{"./_global":78}],81:[function(require,module,exports){
'use strict';

module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_descriptors":74,"./_dom-create":75,"./_fails":77}],82:[function(require,module,exports){
"use strict";

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
                  var un = that === undefined;
                  switch (args.length) {
                                    case 0:
                                                      return un ? fn() : fn.call(that);
                                    case 1:
                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
                                    case 2:
                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                    case 3:
                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                    case 4:
                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                  }return fn.apply(that, args);
};

},{}],83:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

},{}],84:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object'),
    IE8_DOM_DEFINE = require('./_ie8-dom-define'),
    toPrimitive = require('./_to-primitive'),
    dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":70,"./_descriptors":74,"./_ie8-dom-define":81,"./_to-primitive":87}],85:[function(require,module,exports){
"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],86:[function(require,module,exports){
'use strict';

var ctx = require('./_ctx'),
    invoke = require('./_invoke'),
    html = require('./_html'),
    cel = require('./_dom-create'),
    global = require('./_global'),
    process = global.process,
    setTask = global.setImmediate,
    clearTask = global.clearImmediate,
    MessageChannel = global.MessageChannel,
    counter = 0,
    queue = {},
    ONREADYSTATECHANGE = 'onreadystatechange',
    defer,
    channel,
    port;
var run = function run() {
  var id = +this;
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [],
        i = 1;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }queue[++counter] = function () {
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    };
    // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":71,"./_ctx":73,"./_dom-create":75,"./_global":78,"./_html":80,"./_invoke":82}],87:[function(require,module,exports){
'use strict';

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":83}],88:[function(require,module,exports){
'use strict';

var $export = require('./_export'),
    $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":76,"./_task":86}],89:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign = require('./lib/utils/common').assign;

var deflate = require('./lib/deflate');
var inflate = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":90,"./lib/inflate":91,"./lib/utils/common":92,"./lib/zlib/constants":95}],90:[function(require,module,exports){
'use strict';

var zlib_deflate = require('./zlib/deflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY = 0;

var Z_DEFLATED = 8;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }

  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":92,"./utils/strings":93,"./zlib/deflate":97,"./zlib/messages":102,"./zlib/zstream":104}],91:[function(require,module,exports){
'use strict';

var zlib_inflate = require('./zlib/inflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var c = require('./zlib/constants');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');
var GZheader = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }

  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

},{"./utils/common":92,"./utils/strings":93,"./zlib/constants":95,"./zlib/gzheader":98,"./zlib/inflate":100,"./zlib/messages":102,"./zlib/zstream":104}],92:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};

// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
};

// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],93:[function(require,module,exports){
// String encode/decode helpers
'use strict';

var utils = require('./common');

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}

// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};

// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};

// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;continue;
    }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

},{"./common":92}],94:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

},{}],95:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,

  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],96:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

},{}],97:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');
var trees = require('./trees');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var msg = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;

var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/* The deflate compression method */
var Z_DEFLATED = 8;

/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS = 256;
/* number of literal bytes 0..255 */
var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES = 30;
/* number of distance codes */
var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length; /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match; /* matched string */
  var len; /* length of current match */
  var best_len = s.prev_length; /* best match length so far */
  var nice_match = s.nice_match; /* stop if match long enough */
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head; /* head of the hash chain */
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head; /* head of hash chain */
  var bflush; /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {

          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush; /* set if current block must be flushed */
  var prev; /* byte at distance one to match */
  var scan, strend; /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0; /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0; /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;

        s.status = BUSY_STATE;
        putShortMSB(s, header);

        /* Save the adler32 of the preset dictionary: */
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }
        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  }

  //#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  //#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":92,"./adler32":94,"./crc32":96,"./messages":102,"./trees":103}],98:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}

module.exports = GZheader;

},{}],99:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js

var BAD = 30; /* got a data error -- remain here until reset */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in; /* local strm.input */
  var last; /* have enough input while in < last */
  var _out; /* local strm.output */
  var beg; /* inflate()'s initial strm.output */
  var end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  var dmax; /* maximum distance from zlib header */
  //#endif
  var wsize; /* window size or zero if not using window */
  var whave; /* valid bytes in the window */
  var wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window; /* allocated sliding window, if wsize != 0 */
  var hold; /* local strm.hold */
  var bits; /* local strm.bits */
  var lcode; /* local strm.lencode */
  var dcode; /* local strm.distcode */
  var lmask; /* mask for first level of length codes */
  var dmask; /* mask for first level of distance codes */
  var here; /* retrieved table entry */
  var op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  var len; /* match length, unused bytes */
  var dist; /* match distance */
  var from; /* where to copy match from */
  var from_source;

  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],100:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var inflate_fast = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED = 8;

/* STATES ====================================================================*/
/* ===========================================================================*/

var HEAD = 1; /* i: waiting for magic header */
var FLAGS = 2; /* i: waiting for method and flags (gzip) */
var TIME = 3; /* i: waiting for modification time (gzip) */
var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
var EXLEN = 5; /* i: waiting for extra length (gzip) */
var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
var NAME = 7; /* i: waiting for end of file name (gzip) */
var COMMENT = 8; /* i: waiting for end of comment (gzip) */
var HCRC = 9; /* i: waiting for header crc (gzip) */
var DICTID = 10; /* i: waiting for dictionary check value */
var DICT = 11; /* waiting for inflateSetDictionary() call */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
var STORED = 14; /* i: waiting for stored size (length and complement) */
var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
var COPY = 16; /* i/o: waiting for input or output to copy stored block */
var TABLE = 17; /* i: waiting for dynamic block table lengths */
var LENLENS = 18; /* i: waiting for code length code lengths */
var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
var LEN_ = 20; /* i: same as LEN below, but only first time in */
var LEN = 21; /* i: waiting for length/lit/eob code */
var LENEXT = 22; /* i: waiting for length extra bits */
var DIST = 23; /* i: waiting for distance code */
var DISTEXT = 24; /* i: waiting for distance extra bits */
var MATCH = 25; /* o: waiting for output space to copy string */
var LIT = 26; /* o: waiting for output space to write literal */
var CHECK = 27; /* i: waiting for 32-bit check value */
var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
var DONE = 29; /* finished check, done -- remain here until reset */
var BAD = 30; /* got a data error -- remain here until reset */
var MEM = 31; /* got an inflate() memory error -- remain here until reset */
var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib) */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null /*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers
  var next; /* next input INDEX */
  var put; /* next output INDEX */
  var have, left; /* available input and output */
  var hold; /* bit buffer */
  var bits; /* bits in bit buffer */
  var _in, _out; /* save starting available input and output */
  var copy; /* number of stored or match bytes to copy */
  var from; /* where to copy match bytes from */
  var from_source;
  var here = 0; /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len; /* length to copy for repeats, bits to drop */
  var ret; /* return code */
  var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0; /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff) << /*BITS(8)*/8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f) !== /*BITS(4)*/Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f) + /*BITS(4)*/8;
        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(state.head.extra, input, next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03) {/*BITS(2)*/case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f) + /*BITS(5)*/257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f) + /*BITS(5)*/1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f) + /*BITS(4)*/4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
      return Z_STREAM_ERROR;
    }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":92,"./adler32":94,"./crc32":96,"./inffast":99,"./inftrees":101}],101:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

var lext = [/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];

var dbase = [/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];

var dext = [/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  var len = 0; /* a code's length in bits */
  var sym = 0; /* index of code symbols */
  var min = 0,
      max = 0; /* minimum and maximum code lengths */
  var root = 0; /* number of index bits for root table */
  var curr = 0; /* number of index bits for current table */
  var drop = 0; /* code bits to drop for sub-table */
  var left = 0; /* number of prefix codes available */
  var used = 0; /* code entries in table used */
  var huff = 0; /* Huffman code */
  var incr; /* for incrementing code, index */
  var fill; /* index for replicating entries */
  var low; /* low bits for current root entry */
  var mask; /* mask for low root bits */
  var next; /* next available space in table */
  var base = null; /* base value table to use */
  var base_index = 0;
  //  var shoextra;    /* extra bits table to use */
  var end; /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work; /* dummy value--not used */
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":92}],102:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary', /* Z_NEED_DICT       2  */
  1: 'stream end', /* Z_STREAM_END      1  */
  0: '', /* Z_OK              0  */
  '-1': 'file error', /* Z_ERRNO         (-1) */
  '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error', /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],103:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/

//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY = 0;
var Z_TEXT = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/*============================================================================*/

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits = /* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

var extra_dbits = /* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

var extra_blbits = /* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h; /* heap index */
  var n, m; /* iterate over the tree elements */
  var bits; /* bit length */
  var xbits; /* extra bits */
  var f; /* frequency */
  var overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0; /* running code value */
  var bits; /* bit index */
  var n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n; /* iterates over tree elements */
  var bits; /* bit counter */
  var length; /* length value */
  var code; /* code value */
  var dist; /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}

/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }

  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s); /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  //  while (len--) {
  //    put_byte(s, *buf++);
  //  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}

// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist; /* distance of matched string */
  var lc; /* match length or unmatched char (if dist == 0) */
  var lx = 0; /* running index in l_buf */
  var code; /* the code to send */
  var extra; /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");
    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m; /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {

      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}

var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s) {

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}

/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  var max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility

  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif

  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":92}],104:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],105:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":29}],106:[function(require,module,exports){
(function (process){
"use strict";

// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(undefined);



}).call(this,require('_process'))

},{"_process":108}],107:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

}).call(this,require('_process'))

},{"_process":108}],108:[function(require,module,exports){
'use strict';

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],109:[function(require,module,exports){
(function (global){
'use strict';

var now = require('performance-now'),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
module.exports.cancel = function () {
  caf.apply(root, arguments);
};
module.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":106}],110:[function(require,module,exports){
'use strict';

module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":111}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":113,"./_stream_writable":115,"core-util-is":5,"inherits":30,"process-nextick-args":107}],112:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":114,"core-util-is":5,"inherits":30}],113:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":111,"./internal/streams/BufferList":116,"./internal/streams/destroy":117,"./internal/streams/stream":118,"_process":108,"core-util-is":5,"events":6,"inherits":30,"isarray":32,"process-nextick-args":107,"safe-buffer":124,"string_decoder/":126,"util":2}],114:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":111,"core-util-is":5,"inherits":30}],115:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":111,"./internal/streams/destroy":117,"./internal/streams/stream":118,"_process":108,"core-util-is":5,"inherits":30,"process-nextick-args":107,"safe-buffer":124,"util-deprecate":133}],116:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

},{"safe-buffer":124,"util":2}],117:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

},{"process-nextick-args":107}],118:[function(require,module,exports){
'use strict';

module.exports = require('events').EventEmitter;

},{"events":6}],119:[function(require,module,exports){
'use strict';

module.exports = require('./readable').PassThrough;

},{"./readable":120}],120:[function(require,module,exports){
'use strict';

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":111,"./lib/_stream_passthrough.js":112,"./lib/_stream_readable.js":113,"./lib/_stream_transform.js":114,"./lib/_stream_writable.js":115}],121:[function(require,module,exports){
'use strict';

module.exports = require('./readable').Transform;

},{"./readable":120}],122:[function(require,module,exports){
'use strict';

module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":115}],123:[function(require,module,exports){
(function (process,global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.

;(function (undefined) {

  var objectTypes = {
    'function': true,
    'object': true
  };

  function checkGlobal(value) {
    return value && value.Object === Object ? value : null;
  }

  var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : null;
  var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : null;
  var freeGlobal = checkGlobal(freeExports && freeModule && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global);
  var freeSelf = checkGlobal(objectTypes[typeof self === 'undefined' ? 'undefined' : _typeof(self)] && self);
  var freeWindow = checkGlobal(objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window);
  var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;
  var thisGlobal = checkGlobal(objectTypes[_typeof(this)] && this);
  var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();

  var Rx = {
    internals: {},
    config: {
      Promise: root.Promise
    },
    helpers: {}
  };

  // Defaults
  var noop = Rx.helpers.noop = function () {},
      identity = Rx.helpers.identity = function (x) {
    return x;
  },
      defaultNow = Rx.helpers.defaultNow = Date.now,
      defaultComparer = Rx.helpers.defaultComparer = function (x, y) {
    return isEqual(x, y);
  },
      defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) {
    return x > y ? 1 : x < y ? -1 : 0;
  },
      defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) {
    return x.toString();
  },
      defaultError = Rx.helpers.defaultError = function (err) {
    throw err;
  },
      isPromise = Rx.helpers.isPromise = function (p) {
    return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
  },
      isFunction = Rx.helpers.isFunction = function () {

    var isFn = function isFn(value) {
      return typeof value == 'function' || false;
    };

    // fallback for older versions of Chrome and Safari
    if (isFn(/x/)) {
      isFn = function isFn(value) {
        return typeof value == 'function' && toString.call(value) == '[object Function]';
      };
    }

    return isFn;
  }();

  function cloneArray(arr) {
    for (var a = [], i = 0, len = arr.length; i < len; i++) {
      a.push(arr[i]);
    }return a;
  }

  var errorObj = { e: {} };

  function tryCatcherGen(tryCatchTarget) {
    return function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    };
  }

  var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {
    if (!isFunction(fn)) {
      throw new TypeError('fn must be a function');
    }
    return tryCatcherGen(fn);
  };

  function thrower(e) {
    throw e;
  }

  Rx.config.longStackSupport = false;
  var hasStacks = false,
      stacks = tryCatch(function () {
    throw new Error();
  })();
  hasStacks = !!stacks.e && !!stacks.e.stack;

  // All code after this point will be filtered from stack traces reported by RxJS
  var rStartingLine = captureLine(),
      rFileName;

  var STACK_JUMP_SEPARATOR = 'From previous event:';

  function makeStackTraceLong(error, observable) {
    // If possible, transform the error stack trace by removing Node and RxJS
    // cruft, then concatenating with the stack trace of `observable`.
    if (hasStacks && observable.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
      var stacks = [];
      for (var o = observable; !!o; o = o.source) {
        if (o.stack) {
          stacks.unshift(o.stack);
        }
      }
      stacks.unshift(error.stack);

      var concatedStacks = stacks.join('\n' + STACK_JUMP_SEPARATOR + '\n');
      error.stack = filterStackString(concatedStacks);
    }
  }

  function filterStackString(stackString) {
    var lines = stackString.split('\n'),
        desiredLines = [];
    for (var i = 0, len = lines.length; i < len; i++) {
      var line = lines[i];

      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
        desiredLines.push(line);
      }
    }
    return desiredLines.join('\n');
  }

  function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    if (!fileNameAndLineNumber) {
      return false;
    }
    var fileName = fileNameAndLineNumber[0],
        lineNumber = fileNameAndLineNumber[1];

    return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
  }

  function isNodeFrame(stackLine) {
    return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
  }

  function captureLine() {
    if (!hasStacks) {
      return;
    }

    try {
      throw new Error();
    } catch (e) {
      var lines = e.stack.split('\n');
      var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];
      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
      if (!fileNameAndLineNumber) {
        return;
      }

      rFileName = fileNameAndLineNumber[0];
      return fileNameAndLineNumber[1];
    }
  }

  function getFileNameAndLineNumber(stackLine) {
    // Named functions: 'at functionName (filename:lineNumber:columnNumber)'
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
      return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: 'at filename:lineNumber:columnNumber'
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
      return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: 'function@filename:lineNumber or @filename:lineNumber'
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
      return [attempt3[1], Number(attempt3[2])];
    }
  }

  var EmptyError = Rx.EmptyError = function () {
    this.message = 'Sequence contains no elements.';
    Error.call(this);
  };
  EmptyError.prototype = Object.create(Error.prototype);
  EmptyError.prototype.name = 'EmptyError';

  var ObjectDisposedError = Rx.ObjectDisposedError = function () {
    this.message = 'Object has been disposed';
    Error.call(this);
  };
  ObjectDisposedError.prototype = Object.create(Error.prototype);
  ObjectDisposedError.prototype.name = 'ObjectDisposedError';

  var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function () {
    this.message = 'Argument out of range';
    Error.call(this);
  };
  ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);
  ArgumentOutOfRangeError.prototype.name = 'ArgumentOutOfRangeError';

  var NotSupportedError = Rx.NotSupportedError = function (message) {
    this.message = message || 'This operation is not supported';
    Error.call(this);
  };
  NotSupportedError.prototype = Object.create(Error.prototype);
  NotSupportedError.prototype.name = 'NotSupportedError';

  var NotImplementedError = Rx.NotImplementedError = function (message) {
    this.message = message || 'This operation is not implemented';
    Error.call(this);
  };
  NotImplementedError.prototype = Object.create(Error.prototype);
  NotImplementedError.prototype.name = 'NotImplementedError';

  var notImplemented = Rx.helpers.notImplemented = function () {
    throw new NotImplementedError();
  };

  var notSupported = Rx.helpers.notSupported = function () {
    throw new NotSupportedError();
  };

  // Shim in iterator support
  var $iterator$ = typeof Symbol === 'function' && Symbol.iterator || '_es6shim_iterator_';
  // Bug for mozilla version
  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };

  var isIterable = Rx.helpers.isIterable = function (o) {
    return o && o[$iterator$] !== undefined;
  };

  var isArrayLike = Rx.helpers.isArrayLike = function (o) {
    return o && o.length !== undefined;
  };

  Rx.helpers.iterator = $iterator$;

  var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {
    if (typeof thisArg === 'undefined') {
      return func;
    }
    switch (argCount) {
      case 0:
        return function () {
          return func.call(thisArg);
        };
      case 1:
        return function (arg) {
          return func.call(thisArg, arg);
        };
      case 2:
        return function (value, index) {
          return func.call(thisArg, value, index);
        };
      case 3:
        return function (value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
    }

    return function () {
      return func.apply(thisArg, arguments);
    };
  };

  /** Used to determine if values are of the language type Object */
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
      dontEnumsLength = dontEnums.length;

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  var objectProto = Object.prototype,
      hasOwnProperty = objectProto.hasOwnProperty,
      objToString = objectProto.toString,
      MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

  var keys = Object.keys || function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
        dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [],
          prop,
          i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }();

  function equalObjects(object, other, equalFunc, isLoose, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength !== othLength && !isLoose) {
      return false;
    }
    var index = objLength,
        key;
    while (index--) {
      key = objProps[index];
      if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var skipCtor = isLoose;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key],
          result;

      if (!(result === undefined ? equalFunc(objValue, othValue, isLoose, stackA, stackB) : result)) {
        return false;
      }
      skipCtor || (skipCtor = key === 'constructor');
    }
    if (!skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor !== othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }

  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        return +object === +other;

      case errorTag:
        return object.name === other.name && object.message === other.message;

      case numberTag:
        return object !== +object ? other !== +other : object === +other;

      case regexpTag:
      case stringTag:
        return object === other + '';
    }
    return false;
  }

  var isObject = Rx.internals.isObject = function (value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return !!value && (type === 'object' || type === 'function');
  };

  function isObjectLike(value) {
    return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
  }

  function isLength(value) {
    return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
  }

  var isHostObject = function () {
    try {
      Object({ 'toString': 0 } + '');
    } catch (e) {
      return function () {
        return false;
      };
    }
    return function (value) {
      return typeof value.toString !== 'function' && typeof (value + '') === 'string';
    };
  }();

  function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
  }

  var isArray = Array.isArray || function (value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) === arrayTag;
  };

  function arraySome(array, predicate) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  function equalArrays(array, other, equalFunc, isLoose, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength !== othLength && !(isLoose && othLength > arrLength)) {
      return false;
    }
    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index],
          result;

      if (result !== undefined) {
        if (result) {
          continue;
        }
        return false;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (isLoose) {
        if (!arraySome(other, function (othValue) {
          return arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB);
        })) {
          return false;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB))) {
        return false;
      }
    }
    return true;
  }

  function baseIsEqualDeep(object, other, equalFunc, isLoose, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;

    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag === argsTag) {
        objTag = objectTag;
      } else if (objTag !== objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag === argsTag) {
        othTag = objectTag;
      }
    }
    var objIsObj = objTag === objectTag && !isHostObject(object),
        othIsObj = othTag === objectTag && !isHostObject(other),
        isSameTag = objTag === othTag;

    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    if (!isLoose) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, isLoose, stackA, stackB);
      }
    }
    if (!isSameTag) {
      return false;
    }
    // Assume cyclic values are equal.
    // For more information on detecting circular references see https://es5.github.io/#JO.
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] === object) {
        return stackB[length] === other;
      }
    }
    // Add `object` and `other` to the stack of traversed objects.
    stackA.push(object);
    stackB.push(other);

    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, isLoose, stackA, stackB);

    stackA.pop();
    stackB.pop();

    return result;
  }

  function baseIsEqual(value, other, isLoose, stackA, stackB) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, isLoose, stackA, stackB);
  }

  var isEqual = Rx.internals.isEqual = function (value, other) {
    return baseIsEqual(value, other);
  };

  var hasProp = {}.hasOwnProperty,
      slice = Array.prototype.slice;

  var inherits = Rx.internals.inherits = function (child, parent) {
    function __() {
      this.constructor = child;
    }
    __.prototype = parent.prototype;
    child.prototype = new __();
  };

  var addProperties = Rx.internals.addProperties = function (obj) {
    for (var sources = [], i = 1, len = arguments.length; i < len; i++) {
      sources.push(arguments[i]);
    }
    for (var idx = 0, ln = sources.length; idx < ln; idx++) {
      var source = sources[idx];
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  };

  // Rx Utils
  var addRef = Rx.internals.addRef = function (xs, r) {
    return new AnonymousObservable(function (observer) {
      return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));
    });
  };

  function arrayInitialize(count, factory) {
    var a = new Array(count);
    for (var i = 0; i < count; i++) {
      a[i] = factory();
    }
    return a;
  }

  function IndexedItem(id, value) {
    this.id = id;
    this.value = value;
  }

  IndexedItem.prototype.compareTo = function (other) {
    var c = this.value.compareTo(other.value);
    c === 0 && (c = this.id - other.id);
    return c;
  };

  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {
    this.items = new Array(capacity);
    this.length = 0;
  };

  var priorityProto = PriorityQueue.prototype;
  priorityProto.isHigherPriority = function (left, right) {
    return this.items[left].compareTo(this.items[right]) < 0;
  };

  priorityProto.percolate = function (index) {
    if (index >= this.length || index < 0) {
      return;
    }
    var parent = index - 1 >> 1;
    if (parent < 0 || parent === index) {
      return;
    }
    if (this.isHigherPriority(index, parent)) {
      var temp = this.items[index];
      this.items[index] = this.items[parent];
      this.items[parent] = temp;
      this.percolate(parent);
    }
  };

  priorityProto.heapify = function (index) {
    +index || (index = 0);
    if (index >= this.length || index < 0) {
      return;
    }
    var left = 2 * index + 1,
        right = 2 * index + 2,
        first = index;
    if (left < this.length && this.isHigherPriority(left, first)) {
      first = left;
    }
    if (right < this.length && this.isHigherPriority(right, first)) {
      first = right;
    }
    if (first !== index) {
      var temp = this.items[index];
      this.items[index] = this.items[first];
      this.items[first] = temp;
      this.heapify(first);
    }
  };

  priorityProto.peek = function () {
    return this.items[0].value;
  };

  priorityProto.removeAt = function (index) {
    this.items[index] = this.items[--this.length];
    this.items[this.length] = undefined;
    this.heapify();
  };

  priorityProto.dequeue = function () {
    var result = this.peek();
    this.removeAt(0);
    return result;
  };

  priorityProto.enqueue = function (item) {
    var index = this.length++;
    this.items[index] = new IndexedItem(PriorityQueue.count++, item);
    this.percolate(index);
  };

  priorityProto.remove = function (item) {
    for (var i = 0; i < this.length; i++) {
      if (this.items[i].value === item) {
        this.removeAt(i);
        return true;
      }
    }
    return false;
  };
  PriorityQueue.count = 0;

  /**
   * Represents a group of disposable resources that are disposed together.
   * @constructor
   */
  var CompositeDisposable = Rx.CompositeDisposable = function () {
    var args = [],
        i,
        len;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      len = arguments.length;
      args = new Array(len);
      for (i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    this.disposables = args;
    this.isDisposed = false;
    this.length = args.length;
  };

  var CompositeDisposablePrototype = CompositeDisposable.prototype;

  /**
   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
   * @param {Mixed} item Disposable to add.
   */
  CompositeDisposablePrototype.add = function (item) {
    if (this.isDisposed) {
      item.dispose();
    } else {
      this.disposables.push(item);
      this.length++;
    }
  };

  /**
   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
   * @param {Mixed} item Disposable to remove.
   * @returns {Boolean} true if found; false otherwise.
   */
  CompositeDisposablePrototype.remove = function (item) {
    var shouldDispose = false;
    if (!this.isDisposed) {
      var idx = this.disposables.indexOf(item);
      if (idx !== -1) {
        shouldDispose = true;
        this.disposables.splice(idx, 1);
        this.length--;
        item.dispose();
      }
    }
    return shouldDispose;
  };

  /**
   *  Disposes all disposables in the group and removes them from the group.
   */
  CompositeDisposablePrototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var len = this.disposables.length,
          currentDisposables = new Array(len);
      for (var i = 0; i < len; i++) {
        currentDisposables[i] = this.disposables[i];
      }
      this.disposables = [];
      this.length = 0;

      for (i = 0; i < len; i++) {
        currentDisposables[i].dispose();
      }
    }
  };

  /**
   * Provides a set of static methods for creating Disposables.
   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
   */
  var Disposable = Rx.Disposable = function (action) {
    this.isDisposed = false;
    this.action = action || noop;
  };

  /** Performs the task of cleaning up resources. */
  Disposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.action();
      this.isDisposed = true;
    }
  };

  /**
   * Creates a disposable object that invokes the specified action when disposed.
   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
   * @return {Disposable} The disposable object that runs the given action upon disposal.
   */
  var disposableCreate = Disposable.create = function (action) {
    return new Disposable(action);
  };

  /**
   * Gets the disposable that does nothing when disposed.
   */
  var disposableEmpty = Disposable.empty = { dispose: noop };

  /**
   * Validates whether the given object is a disposable
   * @param {Object} Object to test whether it has a dispose method
   * @returns {Boolean} true if a disposable object, else false.
   */
  var isDisposable = Disposable.isDisposable = function (d) {
    return d && isFunction(d.dispose);
  };

  var checkDisposed = Disposable.checkDisposed = function (disposable) {
    if (disposable.isDisposed) {
      throw new ObjectDisposedError();
    }
  };

  var disposableFixup = Disposable._fixup = function (result) {
    return isDisposable(result) ? result : disposableEmpty;
  };

  // Single assignment
  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function () {
    this.isDisposed = false;
    this.current = null;
  };
  SingleAssignmentDisposable.prototype.getDisposable = function () {
    return this.current;
  };
  SingleAssignmentDisposable.prototype.setDisposable = function (value) {
    if (this.current) {
      throw new Error('Disposable has already been assigned');
    }
    var shouldDispose = this.isDisposed;
    !shouldDispose && (this.current = value);
    shouldDispose && value && value.dispose();
  };
  SingleAssignmentDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old = this.current;
      this.current = null;
      old && old.dispose();
    }
  };

  // Multiple assignment disposable
  var SerialDisposable = Rx.SerialDisposable = function () {
    this.isDisposed = false;
    this.current = null;
  };
  SerialDisposable.prototype.getDisposable = function () {
    return this.current;
  };
  SerialDisposable.prototype.setDisposable = function (value) {
    var shouldDispose = this.isDisposed;
    if (!shouldDispose) {
      var old = this.current;
      this.current = value;
    }
    old && old.dispose();
    shouldDispose && value && value.dispose();
  };
  SerialDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old = this.current;
      this.current = null;
    }
    old && old.dispose();
  };

  var BinaryDisposable = Rx.BinaryDisposable = function (first, second) {
    this._first = first;
    this._second = second;
    this.isDisposed = false;
  };

  BinaryDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old1 = this._first;
      this._first = null;
      old1 && old1.dispose();
      var old2 = this._second;
      this._second = null;
      old2 && old2.dispose();
    }
  };

  var NAryDisposable = Rx.NAryDisposable = function (disposables) {
    this._disposables = disposables;
    this.isDisposed = false;
  };

  NAryDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      for (var i = 0, len = this._disposables.length; i < len; i++) {
        this._disposables[i].dispose();
      }
      this._disposables.length = 0;
    }
  };

  /**
   * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
   */
  var RefCountDisposable = Rx.RefCountDisposable = function () {

    function InnerDisposable(disposable) {
      this.disposable = disposable;
      this.disposable.count++;
      this.isInnerDisposed = false;
    }

    InnerDisposable.prototype.dispose = function () {
      if (!this.disposable.isDisposed && !this.isInnerDisposed) {
        this.isInnerDisposed = true;
        this.disposable.count--;
        if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
          this.disposable.isDisposed = true;
          this.disposable.underlyingDisposable.dispose();
        }
      }
    };

    /**
     * Initializes a new instance of the RefCountDisposable with the specified disposable.
     * @constructor
     * @param {Disposable} disposable Underlying disposable.
      */
    function RefCountDisposable(disposable) {
      this.underlyingDisposable = disposable;
      this.isDisposed = false;
      this.isPrimaryDisposed = false;
      this.count = 0;
    }

    /**
     * Disposes the underlying disposable only when all dependent disposables have been disposed
     */
    RefCountDisposable.prototype.dispose = function () {
      if (!this.isDisposed && !this.isPrimaryDisposed) {
        this.isPrimaryDisposed = true;
        if (this.count === 0) {
          this.isDisposed = true;
          this.underlyingDisposable.dispose();
        }
      }
    };

    /**
     * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
     * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.
     */
    RefCountDisposable.prototype.getDisposable = function () {
      return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
    };

    return RefCountDisposable;
  }();

  function ScheduledDisposable(scheduler, disposable) {
    this.scheduler = scheduler;
    this.disposable = disposable;
    this.isDisposed = false;
  }

  function scheduleItem(s, self) {
    if (!self.isDisposed) {
      self.isDisposed = true;
      self.disposable.dispose();
    }
  }

  ScheduledDisposable.prototype.dispose = function () {
    this.scheduler.schedule(this, scheduleItem);
  };

  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
    this.scheduler = scheduler;
    this.state = state;
    this.action = action;
    this.dueTime = dueTime;
    this.comparer = comparer || defaultSubComparer;
    this.disposable = new SingleAssignmentDisposable();
  };

  ScheduledItem.prototype.invoke = function () {
    this.disposable.setDisposable(this.invokeCore());
  };

  ScheduledItem.prototype.compareTo = function (other) {
    return this.comparer(this.dueTime, other.dueTime);
  };

  ScheduledItem.prototype.isCancelled = function () {
    return this.disposable.isDisposed;
  };

  ScheduledItem.prototype.invokeCore = function () {
    return disposableFixup(this.action(this.scheduler, this.state));
  };

  /** Provides a set of static properties to access commonly used schedulers. */
  var Scheduler = Rx.Scheduler = function () {

    function Scheduler() {}

    /** Determines whether the given object is a scheduler */
    Scheduler.isScheduler = function (s) {
      return s instanceof Scheduler;
    };

    var schedulerProto = Scheduler.prototype;

    /**
    * Schedules an action to be executed.
    * @param state State passed to the action to be executed.
    * @param {Function} action Action to be executed.
    * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
    */
    schedulerProto.schedule = function (state, action) {
      throw new NotImplementedError();
    };

    /**
     * Schedules an action to be executed after dueTime.
     * @param state State passed to the action to be executed.
     * @param {Function} action Action to be executed.
     * @param {Number} dueTime Relative time after which to execute the action.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleFuture = function (state, dueTime, action) {
      var dt = dueTime;
      dt instanceof Date && (dt = dt - this.now());
      dt = Scheduler.normalize(dt);

      if (dt === 0) {
        return this.schedule(state, action);
      }

      return this._scheduleFuture(state, dt, action);
    };

    schedulerProto._scheduleFuture = function (state, dueTime, action) {
      throw new NotImplementedError();
    };

    /** Gets the current time according to the local machine's system clock. */
    Scheduler.now = defaultNow;

    /** Gets the current time according to the local machine's system clock. */
    Scheduler.prototype.now = defaultNow;

    /**
     * Normalizes the specified TimeSpan value to a positive value.
     * @param {Number} timeSpan The time span value to normalize.
     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0
     */
    Scheduler.normalize = function (timeSpan) {
      timeSpan < 0 && (timeSpan = 0);
      return timeSpan;
    };

    return Scheduler;
  }();

  var normalizeTime = Scheduler.normalize,
      isScheduler = Scheduler.isScheduler;

  (function (schedulerProto) {

    function invokeRecImmediate(scheduler, pair) {
      var state = pair[0],
          action = pair[1],
          group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2) {
        var isAdded = false,
            isDone = false;

        var d = scheduler.schedule(state2, scheduleWork);
        if (!isDone) {
          group.add(d);
          isAdded = true;
        }

        function scheduleWork(_, state3) {
          if (isAdded) {
            group.remove(d);
          } else {
            isDone = true;
          }
          action(state3, innerAction);
          return disposableEmpty;
        }
      }
    }

    function invokeRecDate(scheduler, pair) {
      var state = pair[0],
          action = pair[1],
          group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2, dueTime1) {
        var isAdded = false,
            isDone = false;

        var d = scheduler.scheduleFuture(state2, dueTime1, scheduleWork);
        if (!isDone) {
          group.add(d);
          isAdded = true;
        }

        function scheduleWork(_, state3) {
          if (isAdded) {
            group.remove(d);
          } else {
            isDone = true;
          }
          action(state3, innerAction);
          return disposableEmpty;
        }
      }
    }

    /**
     * Schedules an action to be executed recursively.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleRecursive = function (state, action) {
      return this.schedule([state, action], invokeRecImmediate);
    };

    /**
     * Schedules an action to be executed recursively after a specified relative or absolute due time.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
     * @param {Number | Date} dueTime Relative or absolute time after which to execute the action for the first time.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleRecursiveFuture = function (state, dueTime, action) {
      return this.scheduleFuture([state, action], dueTime, invokeRecDate);
    };
  })(Scheduler.prototype);

  (function (schedulerProto) {

    /**
     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
     * @param {Mixed} state Initial state passed to the action upon the first iteration.
     * @param {Number} period Period for running the work periodically.
     * @param {Function} action Action to be executed, potentially updating the state.
     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
     */
    schedulerProto.schedulePeriodic = function (state, period, action) {
      if (typeof root.setInterval === 'undefined') {
        throw new NotSupportedError();
      }
      period = normalizeTime(period);
      var s = state,
          id = root.setInterval(function () {
        s = action(s);
      }, period);
      return disposableCreate(function () {
        root.clearInterval(id);
      });
    };
  })(Scheduler.prototype);

  (function (schedulerProto) {
    /**
     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.
     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.
     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.
     */
    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {
      return new CatchScheduler(this, handler);
    };
  })(Scheduler.prototype);

  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = function () {
    function createTick(self) {
      return function tick(command, recurse) {
        recurse(0, self._period);
        var state = tryCatch(self._action)(self._state);
        if (state === errorObj) {
          self._cancel.dispose();
          thrower(state.e);
        }
        self._state = state;
      };
    }

    function SchedulePeriodicRecursive(scheduler, state, period, action) {
      this._scheduler = scheduler;
      this._state = state;
      this._period = period;
      this._action = action;
    }

    SchedulePeriodicRecursive.prototype.start = function () {
      var d = new SingleAssignmentDisposable();
      this._cancel = d;
      d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));

      return d;
    };

    return SchedulePeriodicRecursive;
  }();

  /** Gets a scheduler that schedules work immediately on the current thread. */
  var ImmediateScheduler = function (__super__) {
    inherits(ImmediateScheduler, __super__);
    function ImmediateScheduler() {
      __super__.call(this);
    }

    ImmediateScheduler.prototype.schedule = function (state, action) {
      return disposableFixup(action(this, state));
    };

    return ImmediateScheduler;
  }(Scheduler);

  var immediateScheduler = Scheduler.immediate = new ImmediateScheduler();

  /**
   * Gets a scheduler that schedules work as soon as possible on the current thread.
   */
  var CurrentThreadScheduler = function (__super__) {
    var queue;

    function runTrampoline() {
      while (queue.length > 0) {
        var item = queue.dequeue();
        !item.isCancelled() && item.invoke();
      }
    }

    inherits(CurrentThreadScheduler, __super__);
    function CurrentThreadScheduler() {
      __super__.call(this);
    }

    CurrentThreadScheduler.prototype.schedule = function (state, action) {
      var si = new ScheduledItem(this, state, action, this.now());

      if (!queue) {
        queue = new PriorityQueue(4);
        queue.enqueue(si);

        var result = tryCatch(runTrampoline)();
        queue = null;
        if (result === errorObj) {
          thrower(result.e);
        }
      } else {
        queue.enqueue(si);
      }
      return si.disposable;
    };

    CurrentThreadScheduler.prototype.scheduleRequired = function () {
      return !queue;
    };

    return CurrentThreadScheduler;
  }(Scheduler);

  var currentThreadScheduler = Scheduler.currentThread = new CurrentThreadScheduler();

  var scheduleMethod, clearMethod;

  var localTimer = function () {
    var localSetTimeout,
        localClearTimeout = noop;
    if (!!root.setTimeout) {
      localSetTimeout = root.setTimeout;
      localClearTimeout = root.clearTimeout;
    } else if (!!root.WScript) {
      localSetTimeout = function localSetTimeout(fn, time) {
        root.WScript.Sleep(time);
        fn();
      };
    } else {
      throw new NotSupportedError();
    }

    return {
      setTimeout: localSetTimeout,
      clearTimeout: localClearTimeout
    };
  }();
  var localSetTimeout = localTimer.setTimeout,
      localClearTimeout = localTimer.clearTimeout;

  (function () {

    var nextHandle = 1,
        tasksByHandle = {},
        currentlyRunning = false;

    clearMethod = function clearMethod(handle) {
      delete tasksByHandle[handle];
    };

    function runTask(handle) {
      if (currentlyRunning) {
        localSetTimeout(function () {
          runTask(handle);
        }, 0);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunning = true;
          var result = tryCatch(task)();
          clearMethod(handle);
          currentlyRunning = false;
          if (result === errorObj) {
            thrower(result.e);
          }
        }
      }
    }

    var reNative = new RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');

    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;

    function postMessageSupported() {
      // Ensure not in a worker
      if (!root.postMessage || root.importScripts) {
        return false;
      }
      var isAsync = false,
          oldHandler = root.onmessage;
      // Test for async
      root.onmessage = function () {
        isAsync = true;
      };
      root.postMessage('', '*');
      root.onmessage = oldHandler;

      return isAsync;
    }

    // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout
    if (isFunction(setImmediate)) {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        setImmediate(function () {
          runTask(id);
        });

        return id;
      };
    } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        process.nextTick(function () {
          runTask(id);
        });

        return id;
      };
    } else if (postMessageSupported()) {
      var MSG_PREFIX = 'ms.rx.schedule' + Math.random();

      var onGlobalPostMessage = function onGlobalPostMessage(event) {
        // Only if we're a match to avoid any other global events
        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
          runTask(event.data.substring(MSG_PREFIX.length));
        }
      };

      root.addEventListener('message', onGlobalPostMessage, false);

      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        root.postMessage(MSG_PREFIX + id, '*');
        return id;
      };
    } else if (!!root.MessageChannel) {
      var channel = new root.MessageChannel();

      channel.port1.onmessage = function (e) {
        runTask(e.data);
      };

      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        channel.port2.postMessage(id);
        return id;
      };
    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {

      scheduleMethod = function scheduleMethod(action) {
        var scriptElement = root.document.createElement('script');
        var id = nextHandle++;
        tasksByHandle[id] = action;

        scriptElement.onreadystatechange = function () {
          runTask(id);
          scriptElement.onreadystatechange = null;
          scriptElement.parentNode.removeChild(scriptElement);
          scriptElement = null;
        };
        root.document.documentElement.appendChild(scriptElement);
        return id;
      };
    } else {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        localSetTimeout(function () {
          runTask(id);
        }, 0);

        return id;
      };
    }
  })();

  /**
   * Gets a scheduler that schedules work via a timed callback based upon platform.
   */
  var DefaultScheduler = function (__super__) {
    inherits(DefaultScheduler, __super__);
    function DefaultScheduler() {
      __super__.call(this);
    }

    function scheduleAction(disposable, action, scheduler, state) {
      return function schedule() {
        disposable.setDisposable(Disposable._fixup(action(scheduler, state)));
      };
    }

    function ClearDisposable(id) {
      this._id = id;
      this.isDisposed = false;
    }

    ClearDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        clearMethod(this._id);
      }
    };

    function LocalClearDisposable(id) {
      this._id = id;
      this.isDisposed = false;
    }

    LocalClearDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        localClearTimeout(this._id);
      }
    };

    DefaultScheduler.prototype.schedule = function (state, action) {
      var disposable = new SingleAssignmentDisposable(),
          id = scheduleMethod(scheduleAction(disposable, action, this, state));
      return new BinaryDisposable(disposable, new ClearDisposable(id));
    };

    DefaultScheduler.prototype._scheduleFuture = function (state, dueTime, action) {
      if (dueTime === 0) {
        return this.schedule(state, action);
      }
      var disposable = new SingleAssignmentDisposable(),
          id = localSetTimeout(scheduleAction(disposable, action, this, state), dueTime);
      return new BinaryDisposable(disposable, new LocalClearDisposable(id));
    };

    function scheduleLongRunning(state, action, disposable) {
      return function () {
        action(state, disposable);
      };
    }

    DefaultScheduler.prototype.scheduleLongRunning = function (state, action) {
      var disposable = disposableCreate(noop);
      scheduleMethod(scheduleLongRunning(state, action, disposable));
      return disposable;
    };

    return DefaultScheduler;
  }(Scheduler);

  var defaultScheduler = Scheduler['default'] = Scheduler.async = new DefaultScheduler();

  var CatchScheduler = function (__super__) {
    inherits(CatchScheduler, __super__);

    function CatchScheduler(scheduler, handler) {
      this._scheduler = scheduler;
      this._handler = handler;
      this._recursiveOriginal = null;
      this._recursiveWrapper = null;
      __super__.call(this);
    }

    CatchScheduler.prototype.schedule = function (state, action) {
      return this._scheduler.schedule(state, this._wrap(action));
    };

    CatchScheduler.prototype._scheduleFuture = function (state, dueTime, action) {
      return this._scheduler.schedule(state, dueTime, this._wrap(action));
    };

    CatchScheduler.prototype.now = function () {
      return this._scheduler.now();
    };

    CatchScheduler.prototype._clone = function (scheduler) {
      return new CatchScheduler(scheduler, this._handler);
    };

    CatchScheduler.prototype._wrap = function (action) {
      var parent = this;
      return function (self, state) {
        var res = tryCatch(action)(parent._getRecursiveWrapper(self), state);
        if (res === errorObj) {
          if (!parent._handler(res.e)) {
            thrower(res.e);
          }
          return disposableEmpty;
        }
        return disposableFixup(res);
      };
    };

    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {
      if (this._recursiveOriginal !== scheduler) {
        this._recursiveOriginal = scheduler;
        var wrapper = this._clone(scheduler);
        wrapper._recursiveOriginal = scheduler;
        wrapper._recursiveWrapper = wrapper;
        this._recursiveWrapper = wrapper;
      }
      return this._recursiveWrapper;
    };

    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {
      var self = this,
          failed = false,
          d = new SingleAssignmentDisposable();

      d.setDisposable(this._scheduler.schedulePeriodic(state, period, function (state1) {
        if (failed) {
          return null;
        }
        var res = tryCatch(action)(state1);
        if (res === errorObj) {
          failed = true;
          if (!self._handler(res.e)) {
            thrower(res.e);
          }
          d.dispose();
          return null;
        }
        return res;
      }));

      return d;
    };

    return CatchScheduler;
  }(Scheduler);

  /**
   *  Represents a notification to an observer.
   */
  var Notification = Rx.Notification = function () {
    function Notification() {}

    Notification.prototype._accept = function (onNext, onError, onCompleted) {
      throw new NotImplementedError();
    };

    Notification.prototype._acceptObserver = function (onNext, onError, onCompleted) {
      throw new NotImplementedError();
    };

    /**
     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.
     * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification on..
     * @param {Function} onError Function to invoke for an OnError notification.
     * @param {Function} onCompleted Function to invoke for an OnCompleted notification.
     * @returns {Any} Result produced by the observation.
     */
    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
      return observerOrOnNext && (typeof observerOrOnNext === 'undefined' ? 'undefined' : _typeof(observerOrOnNext)) === 'object' ? this._acceptObserver(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
    };

    /**
     * Returns an observable sequence with a single notification.
     *
     * @memberOf Notifications
     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.
     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.
     */
    Notification.prototype.toObservable = function (scheduler) {
      var self = this;
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function (o) {
        return scheduler.schedule(self, function (_, notification) {
          notification._acceptObserver(o);
          notification.kind === 'N' && o.onCompleted();
        });
      });
    };

    return Notification;
  }();

  var OnNextNotification = function (__super__) {
    inherits(OnNextNotification, __super__);
    function OnNextNotification(value) {
      this.value = value;
      this.kind = 'N';
    }

    OnNextNotification.prototype._accept = function (onNext) {
      return onNext(this.value);
    };

    OnNextNotification.prototype._acceptObserver = function (o) {
      return o.onNext(this.value);
    };

    OnNextNotification.prototype.toString = function () {
      return 'OnNext(' + this.value + ')';
    };

    return OnNextNotification;
  }(Notification);

  var OnErrorNotification = function (__super__) {
    inherits(OnErrorNotification, __super__);
    function OnErrorNotification(error) {
      this.error = error;
      this.kind = 'E';
    }

    OnErrorNotification.prototype._accept = function (onNext, onError) {
      return onError(this.error);
    };

    OnErrorNotification.prototype._acceptObserver = function (o) {
      return o.onError(this.error);
    };

    OnErrorNotification.prototype.toString = function () {
      return 'OnError(' + this.error + ')';
    };

    return OnErrorNotification;
  }(Notification);

  var OnCompletedNotification = function (__super__) {
    inherits(OnCompletedNotification, __super__);
    function OnCompletedNotification() {
      this.kind = 'C';
    }

    OnCompletedNotification.prototype._accept = function (onNext, onError, onCompleted) {
      return onCompleted();
    };

    OnCompletedNotification.prototype._acceptObserver = function (o) {
      return o.onCompleted();
    };

    OnCompletedNotification.prototype.toString = function () {
      return 'OnCompleted()';
    };

    return OnCompletedNotification;
  }(Notification);

  /**
   * Creates an object that represents an OnNext notification to an observer.
   * @param {Any} value The value contained in the notification.
   * @returns {Notification} The OnNext notification containing the value.
   */
  var notificationCreateOnNext = Notification.createOnNext = function (value) {
    return new OnNextNotification(value);
  };

  /**
   * Creates an object that represents an OnError notification to an observer.
   * @param {Any} error The exception contained in the notification.
   * @returns {Notification} The OnError notification containing the exception.
   */
  var notificationCreateOnError = Notification.createOnError = function (error) {
    return new OnErrorNotification(error);
  };

  /**
   * Creates an object that represents an OnCompleted notification to an observer.
   * @returns {Notification} The OnCompleted notification.
   */
  var notificationCreateOnCompleted = Notification.createOnCompleted = function () {
    return new OnCompletedNotification();
  };

  /**
   * Supports push-style iteration over an observable sequence.
   */
  var Observer = Rx.Observer = function () {};

  /**
   *  Creates a notification callback from an observer.
   * @returns The action that forwards its input notification to the underlying observer.
   */
  Observer.prototype.toNotifier = function () {
    var observer = this;
    return function (n) {
      return n.accept(observer);
    };
  };

  /**
   *  Hides the identity of an observer.
   * @returns An observer that hides the identity of the specified observer.
   */
  Observer.prototype.asObserver = function () {
    var self = this;
    return new AnonymousObserver(function (x) {
      self.onNext(x);
    }, function (err) {
      self.onError(err);
    }, function () {
      self.onCompleted();
    });
  };

  /**
   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
   *  If a violation is detected, an Error is thrown from the offending observer method call.
   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
   */
  Observer.prototype.checked = function () {
    return new CheckedObserver(this);
  };

  /**
   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.
   * @param {Function} [onNext] Observer's OnNext action implementation.
   * @param {Function} [onError] Observer's OnError action implementation.
   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.
   * @returns {Observer} The observer object implemented using the given actions.
   */
  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {
    onNext || (onNext = noop);
    onError || (onError = defaultError);
    onCompleted || (onCompleted = noop);
    return new AnonymousObserver(onNext, onError, onCompleted);
  };

  /**
   *  Creates an observer from a notification callback.
   * @param {Function} handler Action that handles a notification.
   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.
   */
  Observer.fromNotifier = function (handler, thisArg) {
    var cb = bindCallback(handler, thisArg, 1);
    return new AnonymousObserver(function (x) {
      return cb(notificationCreateOnNext(x));
    }, function (e) {
      return cb(notificationCreateOnError(e));
    }, function () {
      return cb(notificationCreateOnCompleted());
    });
  };

  /**
   * Schedules the invocation of observer methods on the given scheduler.
   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.
   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.
   */
  Observer.prototype.notifyOn = function (scheduler) {
    return new ObserveOnObserver(scheduler, this);
  };

  Observer.prototype.makeSafe = function (disposable) {
    return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
  };

  /**
   * Abstract base class for implementations of the Observer class.
   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.
   */
  var AbstractObserver = Rx.internals.AbstractObserver = function (__super__) {
    inherits(AbstractObserver, __super__);

    /**
     * Creates a new observer in a non-stopped state.
     */
    function AbstractObserver() {
      this.isStopped = false;
    }

    // Must be implemented by other observers
    AbstractObserver.prototype.next = notImplemented;
    AbstractObserver.prototype.error = notImplemented;
    AbstractObserver.prototype.completed = notImplemented;

    /**
     * Notifies the observer of a new element in the sequence.
     * @param {Any} value Next element in the sequence.
     */
    AbstractObserver.prototype.onNext = function (value) {
      !this.isStopped && this.next(value);
    };

    /**
     * Notifies the observer that an exception has occurred.
     * @param {Any} error The error that has occurred.
     */
    AbstractObserver.prototype.onError = function (error) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.error(error);
      }
    };

    /**
     * Notifies the observer of the end of the sequence.
     */
    AbstractObserver.prototype.onCompleted = function () {
      if (!this.isStopped) {
        this.isStopped = true;
        this.completed();
      }
    };

    /**
     * Disposes the observer, causing it to transition to the stopped state.
     */
    AbstractObserver.prototype.dispose = function () {
      this.isStopped = true;
    };

    AbstractObserver.prototype.fail = function (e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.error(e);
        return true;
      }

      return false;
    };

    return AbstractObserver;
  }(Observer);

  /**
   * Class to create an Observer instance from delegate-based implementations of the on* methods.
   */
  var AnonymousObserver = Rx.AnonymousObserver = function (__super__) {
    inherits(AnonymousObserver, __super__);

    /**
     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
     * @param {Any} onNext Observer's OnNext action implementation.
     * @param {Any} onError Observer's OnError action implementation.
     * @param {Any} onCompleted Observer's OnCompleted action implementation.
     */
    function AnonymousObserver(onNext, onError, onCompleted) {
      __super__.call(this);
      this._onNext = onNext;
      this._onError = onError;
      this._onCompleted = onCompleted;
    }

    /**
     * Calls the onNext action.
     * @param {Any} value Next element in the sequence.
     */
    AnonymousObserver.prototype.next = function (value) {
      this._onNext(value);
    };

    /**
     * Calls the onError action.
     * @param {Any} error The error that has occurred.
     */
    AnonymousObserver.prototype.error = function (error) {
      this._onError(error);
    };

    /**
     *  Calls the onCompleted action.
     */
    AnonymousObserver.prototype.completed = function () {
      this._onCompleted();
    };

    return AnonymousObserver;
  }(AbstractObserver);

  var CheckedObserver = function (__super__) {
    inherits(CheckedObserver, __super__);

    function CheckedObserver(observer) {
      __super__.call(this);
      this._observer = observer;
      this._state = 0; // 0 - idle, 1 - busy, 2 - done
    }

    var CheckedObserverPrototype = CheckedObserver.prototype;

    CheckedObserverPrototype.onNext = function (value) {
      this.checkAccess();
      var res = tryCatch(this._observer.onNext).call(this._observer, value);
      this._state = 0;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.onError = function (err) {
      this.checkAccess();
      var res = tryCatch(this._observer.onError).call(this._observer, err);
      this._state = 2;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.onCompleted = function () {
      this.checkAccess();
      var res = tryCatch(this._observer.onCompleted).call(this._observer);
      this._state = 2;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.checkAccess = function () {
      if (this._state === 1) {
        throw new Error('Re-entrancy detected');
      }
      if (this._state === 2) {
        throw new Error('Observer completed');
      }
      if (this._state === 0) {
        this._state = 1;
      }
    };

    return CheckedObserver;
  }(Observer);

  var ScheduledObserver = Rx.internals.ScheduledObserver = function (__super__) {
    inherits(ScheduledObserver, __super__);

    function ScheduledObserver(scheduler, observer) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.observer = observer;
      this.isAcquired = false;
      this.hasFaulted = false;
      this.queue = [];
      this.disposable = new SerialDisposable();
    }

    function enqueueNext(observer, x) {
      return function () {
        observer.onNext(x);
      };
    }
    function enqueueError(observer, e) {
      return function () {
        observer.onError(e);
      };
    }
    function enqueueCompleted(observer) {
      return function () {
        observer.onCompleted();
      };
    }

    ScheduledObserver.prototype.next = function (x) {
      this.queue.push(enqueueNext(this.observer, x));
    };

    ScheduledObserver.prototype.error = function (e) {
      this.queue.push(enqueueError(this.observer, e));
    };

    ScheduledObserver.prototype.completed = function () {
      this.queue.push(enqueueCompleted(this.observer));
    };

    function scheduleMethod(state, recurse) {
      var work;
      if (state.queue.length > 0) {
        work = state.queue.shift();
      } else {
        state.isAcquired = false;
        return;
      }
      var res = tryCatch(work)();
      if (res === errorObj) {
        state.queue = [];
        state.hasFaulted = true;
        return thrower(res.e);
      }
      recurse(state);
    }

    ScheduledObserver.prototype.ensureActive = function () {
      var isOwner = false;
      if (!this.hasFaulted && this.queue.length > 0) {
        isOwner = !this.isAcquired;
        this.isAcquired = true;
      }
      isOwner && this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));
    };

    ScheduledObserver.prototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this.disposable.dispose();
    };

    return ScheduledObserver;
  }(AbstractObserver);

  var ObserveOnObserver = function (__super__) {
    inherits(ObserveOnObserver, __super__);

    function ObserveOnObserver(scheduler, observer, cancel) {
      __super__.call(this, scheduler, observer);
      this._cancel = cancel;
    }

    ObserveOnObserver.prototype.next = function (value) {
      __super__.prototype.next.call(this, value);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.error = function (e) {
      __super__.prototype.error.call(this, e);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.completed = function () {
      __super__.prototype.completed.call(this);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this._cancel && this._cancel.dispose();
      this._cancel = null;
    };

    return ObserveOnObserver;
  }(ScheduledObserver);

  var observableProto;

  /**
   * Represents a push-style collection.
   */
  var Observable = Rx.Observable = function () {

    function makeSubscribe(self, subscribe) {
      return function (o) {
        var oldOnError = o.onError;
        o.onError = function (e) {
          makeStackTraceLong(e, self);
          oldOnError.call(o, e);
        };

        return subscribe.call(self, o);
      };
    }

    function Observable() {
      if (Rx.config.longStackSupport && hasStacks) {
        var oldSubscribe = this._subscribe;
        var e = tryCatch(thrower)(new Error()).e;
        this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
        this._subscribe = makeSubscribe(this, oldSubscribe);
      }
    }

    observableProto = Observable.prototype;

    /**
    * Determines whether the given object is an Observable
    * @param {Any} An object to determine whether it is an Observable
    * @returns {Boolean} true if an Observable, else false.
    */
    Observable.isObservable = function (o) {
      return o && isFunction(o.subscribe);
    };

    /**
     *  Subscribes an o to the observable sequence.
     *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.
     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
      return this._subscribe((typeof oOrOnNext === 'undefined' ? 'undefined' : _typeof(oOrOnNext)) === 'object' ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));
    };

    /**
     * Subscribes to the next value in the sequence with an optional "this" argument.
     * @param {Function} onNext The function to invoke on each element in the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnNext = function (onNext, thisArg) {
      return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function (x) {
        onNext.call(thisArg, x);
      } : onNext));
    };

    /**
     * Subscribes to an exceptional condition in the sequence with an optional "this" argument.
     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnError = function (onError, thisArg) {
      return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function (e) {
        onError.call(thisArg, e);
      } : onError));
    };

    /**
     * Subscribes to the next value in the sequence with an optional "this" argument.
     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {
      return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function () {
        onCompleted.call(thisArg);
      } : onCompleted));
    };

    return Observable;
  }();

  var ObservableBase = Rx.ObservableBase = function (__super__) {
    inherits(ObservableBase, __super__);

    function fixSubscriber(subscriber) {
      return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
    }

    function setDisposable(s, state) {
      var ado = state[0],
          self = state[1];
      var sub = tryCatch(self.subscribeCore).call(self, ado);
      if (sub === errorObj && !ado.fail(errorObj.e)) {
        thrower(errorObj.e);
      }
      ado.setDisposable(fixSubscriber(sub));
    }

    function ObservableBase() {
      __super__.call(this);
    }

    ObservableBase.prototype._subscribe = function (o) {
      var ado = new AutoDetachObserver(o),
          state = [ado, this];

      if (currentThreadScheduler.scheduleRequired()) {
        currentThreadScheduler.schedule(state, setDisposable);
      } else {
        setDisposable(null, state);
      }
      return ado;
    };

    ObservableBase.prototype.subscribeCore = notImplemented;

    return ObservableBase;
  }(Observable);

  var FlatMapObservable = Rx.FlatMapObservable = function (__super__) {

    inherits(FlatMapObservable, __super__);

    function FlatMapObservable(source, selector, resultSelector, thisArg) {
      this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
      this.selector = bindCallback(isFunction(selector) ? selector : function () {
        return selector;
      }, thisArg, 3);
      this.source = source;
      __super__.call(this);
    }

    FlatMapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(observer, selector, resultSelector, source) {
      this.i = 0;
      this.selector = selector;
      this.resultSelector = resultSelector;
      this.source = source;
      this.o = observer;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype._wrapResult = function (result, x, i) {
      return this.resultSelector ? result.map(function (y, i2) {
        return this.resultSelector(x, y, i, i2);
      }, this) : result;
    };

    InnerObserver.prototype.next = function (x) {
      var i = this.i++;
      var result = tryCatch(this.selector)(x, i, this.source);
      if (result === errorObj) {
        return this.o.onError(result.e);
      }

      isPromise(result) && (result = observableFromPromise(result));
      (isArrayLike(result) || isIterable(result)) && (result = Observable.from(result));
      this.o.onNext(this._wrapResult(result, x, i));
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return FlatMapObservable;
  }(ObservableBase);

  var Enumerable = Rx.internals.Enumerable = function () {};

  function IsDisposedDisposable(state) {
    this._s = state;
    this.isDisposed = false;
  }

  IsDisposedDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      this._s.isDisposed = true;
    }
  };

  var ConcatEnumerableObservable = function (__super__) {
    inherits(ConcatEnumerableObservable, __super__);
    function ConcatEnumerableObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    function scheduleMethod(state, recurse) {
      if (state.isDisposed) {
        return;
      }
      var currentItem = tryCatch(state.e.next).call(state.e);
      if (currentItem === errorObj) {
        return state.o.onError(currentItem.e);
      }
      if (currentItem.done) {
        return state.o.onCompleted();
      }

      // Check if promise
      var currentValue = currentItem.value;
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));
    }

    ConcatEnumerableObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var state = {
        isDisposed: false,
        o: o,
        subscription: subscription,
        e: this.sources[$iterator$]()
      };

      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);
      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);
    };

    function InnerObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      AbstractObserver.call(this);
    }

    inherits(InnerObserver, AbstractObserver);

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this._recurse(this._state);
    };

    return ConcatEnumerableObservable;
  }(ObservableBase);

  Enumerable.prototype.concat = function () {
    return new ConcatEnumerableObservable(this);
  };

  var CatchErrorObservable = function (__super__) {
    function CatchErrorObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    inherits(CatchErrorObservable, __super__);

    function scheduleMethod(state, recurse) {
      if (state.isDisposed) {
        return;
      }
      var currentItem = tryCatch(state.e.next).call(state.e);
      if (currentItem === errorObj) {
        return state.o.onError(currentItem.e);
      }
      if (currentItem.done) {
        return state.lastError !== null ? state.o.onError(state.lastError) : state.o.onCompleted();
      }

      var currentValue = currentItem.value;
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));
    }

    CatchErrorObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var state = {
        isDisposed: false,
        e: this.sources[$iterator$](),
        subscription: subscription,
        lastError: null,
        o: o
      };

      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);
      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);
    };

    function InnerObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      AbstractObserver.call(this);
    }

    inherits(InnerObserver, AbstractObserver);

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.lastError = e;this._recurse(this._state);
    };
    InnerObserver.prototype.completed = function () {
      this._state.o.onCompleted();
    };

    return CatchErrorObservable;
  }(ObservableBase);

  Enumerable.prototype.catchError = function () {
    return new CatchErrorObservable(this);
  };

  var RepeatEnumerable = function (__super__) {
    inherits(RepeatEnumerable, __super__);
    function RepeatEnumerable(v, c) {
      this.v = v;
      this.c = c == null ? -1 : c;
    }

    RepeatEnumerable.prototype[$iterator$] = function () {
      return new RepeatEnumerator(this);
    };

    function RepeatEnumerator(p) {
      this.v = p.v;
      this.l = p.c;
    }

    RepeatEnumerator.prototype.next = function () {
      if (this.l === 0) {
        return doneEnumerator;
      }
      if (this.l > 0) {
        this.l--;
      }
      return { done: false, value: this.v };
    };

    return RepeatEnumerable;
  }(Enumerable);

  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {
    return new RepeatEnumerable(value, repeatCount);
  };

  var OfEnumerable = function (__super__) {
    inherits(OfEnumerable, __super__);
    function OfEnumerable(s, fn, thisArg) {
      this.s = s;
      this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
    }
    OfEnumerable.prototype[$iterator$] = function () {
      return new OfEnumerator(this);
    };

    function OfEnumerator(p) {
      this.i = -1;
      this.s = p.s;
      this.l = this.s.length;
      this.fn = p.fn;
    }

    OfEnumerator.prototype.next = function () {
      return ++this.i < this.l ? { done: false, value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s) } : doneEnumerator;
    };

    return OfEnumerable;
  }(Enumerable);

  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {
    return new OfEnumerable(source, selector, thisArg);
  };

  var ObserveOnObservable = function (__super__) {
    inherits(ObserveOnObservable, __super__);
    function ObserveOnObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    ObserveOnObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ObserveOnObserver(this._s, o));
    };

    return ObserveOnObservable;
  }(ObservableBase);

  /**
  *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
  *
  *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects
  *  that require to be run on a scheduler, use subscribeOn.
  *
  *  @param {Scheduler} scheduler Scheduler to notify observers on.
  *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.
  */
  observableProto.observeOn = function (scheduler) {
    return new ObserveOnObservable(this, scheduler);
  };

  var SubscribeOnObservable = function (__super__) {
    inherits(SubscribeOnObservable, __super__);
    function SubscribeOnObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    function scheduleMethod(scheduler, state) {
      var source = state[0],
          d = state[1],
          o = state[2];
      d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(o)));
    }

    SubscribeOnObservable.prototype.subscribeCore = function (o) {
      var m = new SingleAssignmentDisposable(),
          d = new SerialDisposable();
      d.setDisposable(m);
      m.setDisposable(this._s.schedule([this.source, d, o], scheduleMethod));
      return d;
    };

    return SubscribeOnObservable;
  }(ObservableBase);

  /**
  *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
  *  see the remarks section for more information on the distinction between subscribeOn and observeOn.
   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer
  *  callbacks on a scheduler, use observeOn.
   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.
  *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
  */
  observableProto.subscribeOn = function (scheduler) {
    return new SubscribeOnObservable(this, scheduler);
  };

  var FromPromiseObservable = function (__super__) {
    inherits(FromPromiseObservable, __super__);
    function FromPromiseObservable(p, s) {
      this._p = p;
      this._s = s;
      __super__.call(this);
    }

    function scheduleNext(s, state) {
      var o = state[0],
          data = state[1];
      o.onNext(data);
      o.onCompleted();
    }

    function scheduleError(s, state) {
      var o = state[0],
          err = state[1];
      o.onError(err);
    }

    FromPromiseObservable.prototype.subscribeCore = function (o) {
      var sad = new SingleAssignmentDisposable(),
          self = this,
          p = this._p;

      if (isFunction(p)) {
        p = tryCatch(p)();
        if (p === errorObj) {
          o.onError(p.e);
          return sad;
        }
      }

      p.then(function (data) {
        sad.setDisposable(self._s.schedule([o, data], scheduleNext));
      }, function (err) {
        sad.setDisposable(self._s.schedule([o, err], scheduleError));
      });

      return sad;
    };

    return FromPromiseObservable;
  }(ObservableBase);

  /**
  * Converts a Promise to an Observable sequence
  * @param {Promise} An ES6 Compliant promise.
  * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.
  */
  var observableFromPromise = Observable.fromPromise = function (promise, scheduler) {
    scheduler || (scheduler = defaultScheduler);
    return new FromPromiseObservable(promise, scheduler);
  };

  /*
   * Converts an existing observable sequence to an ES6 Compatible Promise
   * @example
   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
   *
   * // With config
   * Rx.config.Promise = RSVP.Promise;
   * var promise = Rx.Observable.return(42).toPromise();
   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
   */
  observableProto.toPromise = function (promiseCtor) {
    promiseCtor || (promiseCtor = Rx.config.Promise);
    if (!promiseCtor) {
      throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
    }
    var source = this;
    return new promiseCtor(function (resolve, reject) {
      // No cancellation can be done
      var value;
      source.subscribe(function (v) {
        value = v;
      }, reject, function () {
        resolve(value);
      });
    });
  };

  var ToArrayObservable = function (__super__) {
    inherits(ToArrayObservable, __super__);
    function ToArrayObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    ToArrayObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o) {
      this.o = o;
      this.a = [];
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this.a.push(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.o.onNext(this.a);this.o.onCompleted();
    };

    return ToArrayObservable;
  }(ObservableBase);

  /**
  * Creates an array from an observable sequence.
  * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.
  */
  observableProto.toArray = function () {
    return new ToArrayObservable(this);
  };

  /**
   *  Creates an observable sequence from a specified subscribe method implementation.
   * @example
   *  var res = Rx.Observable.create(function (observer) { return function () { } );
   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );
   *  var res = Rx.Observable.create(function (observer) { } );
   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.
   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.
   */
  Observable.create = function (subscribe, parent) {
    return new AnonymousObservable(subscribe, parent);
  };

  var Defer = function (__super__) {
    inherits(Defer, __super__);
    function Defer(factory) {
      this._f = factory;
      __super__.call(this);
    }

    Defer.prototype.subscribeCore = function (o) {
      var result = tryCatch(this._f)();
      if (result === errorObj) {
        return observableThrow(result.e).subscribe(o);
      }
      isPromise(result) && (result = observableFromPromise(result));
      return result.subscribe(o);
    };

    return Defer;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
   *
   * @example
   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });
   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.
   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
   */
  var observableDefer = Observable.defer = function (observableFactory) {
    return new Defer(observableFactory);
  };

  var EmptyObservable = function (__super__) {
    inherits(EmptyObservable, __super__);
    function EmptyObservable(scheduler) {
      this.scheduler = scheduler;
      __super__.call(this);
    }

    EmptyObservable.prototype.subscribeCore = function (observer) {
      var sink = new EmptySink(observer, this.scheduler);
      return sink.run();
    };

    function EmptySink(observer, scheduler) {
      this.observer = observer;
      this.scheduler = scheduler;
    }

    function scheduleItem(s, state) {
      state.onCompleted();
      return disposableEmpty;
    }

    EmptySink.prototype.run = function () {
      var state = this.observer;
      return this.scheduler === immediateScheduler ? scheduleItem(null, state) : this.scheduler.schedule(state, scheduleItem);
    };

    return EmptyObservable;
  }(ObservableBase);

  var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);

  /**
   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
   *
   * @example
   *  var res = Rx.Observable.empty();
   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);
   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.
   * @returns {Observable} An observable sequence with no elements.
   */
  var observableEmpty = Observable.empty = function (scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);
  };

  var FromObservable = function (__super__) {
    inherits(FromObservable, __super__);
    function FromObservable(iterable, fn, scheduler) {
      this._iterable = iterable;
      this._fn = fn;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function createScheduleMethod(o, it, fn) {
      return function loopRecursive(i, recurse) {
        var next = tryCatch(it.next).call(it);
        if (next === errorObj) {
          return o.onError(next.e);
        }
        if (next.done) {
          return o.onCompleted();
        }

        var result = next.value;

        if (isFunction(fn)) {
          result = tryCatch(fn)(result, i);
          if (result === errorObj) {
            return o.onError(result.e);
          }
        }

        o.onNext(result);
        recurse(i + 1);
      };
    }

    FromObservable.prototype.subscribeCore = function (o) {
      var list = Object(this._iterable),
          it = getIterable(list);

      return this._scheduler.scheduleRecursive(0, createScheduleMethod(o, it, this._fn));
    };

    return FromObservable;
  }(ObservableBase);

  var maxSafeInteger = Math.pow(2, 53) - 1;

  function StringIterable(s) {
    this._s = s;
  }

  StringIterable.prototype[$iterator$] = function () {
    return new StringIterator(this._s);
  };

  function StringIterator(s) {
    this._s = s;
    this._l = s.length;
    this._i = 0;
  }

  StringIterator.prototype[$iterator$] = function () {
    return this;
  };

  StringIterator.prototype.next = function () {
    return this._i < this._l ? { done: false, value: this._s.charAt(this._i++) } : doneEnumerator;
  };

  function ArrayIterable(a) {
    this._a = a;
  }

  ArrayIterable.prototype[$iterator$] = function () {
    return new ArrayIterator(this._a);
  };

  function ArrayIterator(a) {
    this._a = a;
    this._l = toLength(a);
    this._i = 0;
  }

  ArrayIterator.prototype[$iterator$] = function () {
    return this;
  };

  ArrayIterator.prototype.next = function () {
    return this._i < this._l ? { done: false, value: this._a[this._i++] } : doneEnumerator;
  };

  function numberIsFinite(value) {
    return typeof value === 'number' && root.isFinite(value);
  }

  function isNan(n) {
    return n !== n;
  }

  function getIterable(o) {
    var i = o[$iterator$],
        it;
    if (!i && typeof o === 'string') {
      it = new StringIterable(o);
      return it[$iterator$]();
    }
    if (!i && o.length !== undefined) {
      it = new ArrayIterable(o);
      return it[$iterator$]();
    }
    if (!i) {
      throw new TypeError('Object is not iterable');
    }
    return o[$iterator$]();
  }

  function sign(value) {
    var number = +value;
    if (number === 0) {
      return number;
    }
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? -1 : 1;
  }

  function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
      return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
      return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
      return 0;
    }
    if (len > maxSafeInteger) {
      return maxSafeInteger;
    }
    return len;
  }

  /**
  * This method creates a new Observable sequence from an array-like or iterable object.
  * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.
  * @param {Function} [mapFn] Map function to call on every element of the array.
  * @param {Any} [thisArg] The context to use calling the mapFn if provided.
  * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
  */
  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {
    if (iterable == null) {
      throw new Error('iterable cannot be null.');
    }
    if (mapFn && !isFunction(mapFn)) {
      throw new Error('mapFn when provided must be a function');
    }
    if (mapFn) {
      var mapper = bindCallback(mapFn, thisArg, 2);
    }
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromObservable(iterable, mapper, scheduler);
  };

  var FromArrayObservable = function (__super__) {
    inherits(FromArrayObservable, __super__);
    function FromArrayObservable(args, scheduler) {
      this._args = args;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(o, args) {
      var len = args.length;
      return function loopRecursive(i, recurse) {
        if (i < len) {
          o.onNext(args[i]);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    FromArrayObservable.prototype.subscribeCore = function (o) {
      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._args));
    };

    return FromArrayObservable;
  }(ObservableBase);

  /**
  *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.
  * @deprecated use Observable.from or Observable.of
  * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
  * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.
  */
  var observableFromArray = Observable.fromArray = function (array, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromArrayObservable(array, scheduler);
  };

  var GenerateObservable = function (__super__) {
    inherits(GenerateObservable, __super__);
    function GenerateObservable(state, cndFn, itrFn, resFn, s) {
      this._initialState = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }
      var hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (hasResult === errorObj) {
        return state.o.onError(hasResult.e);
      }
      if (hasResult) {
        var result = tryCatch(state.self._resFn)(state.newState);
        if (result === errorObj) {
          return state.o.onError(result.e);
        }
        state.o.onNext(result);
        recurse(state);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        first: true,
        newState: this._initialState
      };
      return this._s.scheduleRecursive(state, scheduleRecursive);
    };

    return GenerateObservable;
  }(ObservableBase);

  /**
   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
   *
   * @example
   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });
   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.
   * @returns {Observable} The generated sequence.
   */
  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);
  };

  function observableOf(scheduler, array) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromArrayObservable(array, scheduler);
  }

  /**
  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
  */
  Observable.of = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return new FromArrayObservable(args, currentThreadScheduler);
  };

  /**
  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
  * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.
  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
  */
  Observable.ofWithScheduler = function (scheduler) {
    var len = arguments.length,
        args = new Array(len - 1);
    for (var i = 1; i < len; i++) {
      args[i - 1] = arguments[i];
    }
    return new FromArrayObservable(args, scheduler);
  };

  /**
   * Creates an Observable sequence from changes to an array using Array.observe.
   * @param {Array} array An array to observe changes.
   * @returns {Observable} An observable sequence containing changes to an array from Array.observe.
   */
  Observable.ofArrayChanges = function (array) {
    if (!Array.isArray(array)) {
      throw new TypeError('Array.observe only accepts arrays.');
    }
    if (typeof Array.observe !== 'function' && typeof Array.unobserve !== 'function') {
      throw new TypeError('Array.observe is not supported on your platform');
    }
    return new AnonymousObservable(function (observer) {
      function observerFn(changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          observer.onNext(changes[i]);
        }
      }

      Array.observe(array, observerFn);

      return function () {
        Array.unobserve(array, observerFn);
      };
    });
  };

  /**
   * Creates an Observable sequence from changes to an object using Object.observe.
   * @param {Object} obj An object to observe changes.
   * @returns {Observable} An observable sequence containing changes to an object from Object.observe.
   */
  Observable.ofObjectChanges = function (obj) {
    if (obj == null) {
      throw new TypeError('object must not be null or undefined.');
    }
    if (typeof Object.observe !== 'function' && typeof Object.unobserve !== 'function') {
      throw new TypeError('Object.observe is not supported on your platform');
    }
    return new AnonymousObservable(function (observer) {
      function observerFn(changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          observer.onNext(changes[i]);
        }
      }

      Object.observe(obj, observerFn);

      return function () {
        Object.unobserve(obj, observerFn);
      };
    });
  };

  var NeverObservable = function (__super__) {
    inherits(NeverObservable, __super__);
    function NeverObservable() {
      __super__.call(this);
    }

    NeverObservable.prototype.subscribeCore = function (observer) {
      return disposableEmpty;
    };

    return NeverObservable;
  }(ObservableBase);

  var NEVER_OBSERVABLE = new NeverObservable();

  /**
   * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
   * @returns {Observable} An observable sequence whose observers will never get called.
   */
  var observableNever = Observable.never = function () {
    return NEVER_OBSERVABLE;
  };

  var PairsObservable = function (__super__) {
    inherits(PairsObservable, __super__);
    function PairsObservable(o, scheduler) {
      this._o = o;
      this._keys = Object.keys(o);
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(o, obj, keys) {
      return function loopRecursive(i, recurse) {
        if (i < keys.length) {
          var key = keys[i];
          o.onNext([key, obj[key]]);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    PairsObservable.prototype.subscribeCore = function (o) {
      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._o, this._keys));
    };

    return PairsObservable;
  }(ObservableBase);

  /**
   * Convert an object into an observable sequence of [key, value] pairs.
   * @param {Object} obj The object to inspect.
   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
   * @returns {Observable} An observable sequence of [key, value] pairs from the object.
   */
  Observable.pairs = function (obj, scheduler) {
    scheduler || (scheduler = currentThreadScheduler);
    return new PairsObservable(obj, scheduler);
  };

  var RangeObservable = function (__super__) {
    inherits(RangeObservable, __super__);
    function RangeObservable(start, count, scheduler) {
      this.start = start;
      this.rangeCount = count;
      this.scheduler = scheduler;
      __super__.call(this);
    }

    function loopRecursive(start, count, o) {
      return function loop(i, recurse) {
        if (i < count) {
          o.onNext(start + i);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    RangeObservable.prototype.subscribeCore = function (o) {
      return this.scheduler.scheduleRecursive(0, loopRecursive(this.start, this.rangeCount, o));
    };

    return RangeObservable;
  }(ObservableBase);

  /**
  *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.
  * @param {Number} start The value of the first integer in the sequence.
  * @param {Number} count The number of sequential integers to generate.
  * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.
  * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.
  */
  Observable.range = function (start, count, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new RangeObservable(start, count, scheduler);
  };

  var RepeatObservable = function (__super__) {
    inherits(RepeatObservable, __super__);
    function RepeatObservable(value, repeatCount, scheduler) {
      this.value = value;
      this.repeatCount = repeatCount == null ? -1 : repeatCount;
      this.scheduler = scheduler;
      __super__.call(this);
    }

    RepeatObservable.prototype.subscribeCore = function (observer) {
      var sink = new RepeatSink(observer, this);
      return sink.run();
    };

    return RepeatObservable;
  }(ObservableBase);

  function RepeatSink(observer, parent) {
    this.observer = observer;
    this.parent = parent;
  }

  RepeatSink.prototype.run = function () {
    var observer = this.observer,
        value = this.parent.value;
    function loopRecursive(i, recurse) {
      if (i === -1 || i > 0) {
        observer.onNext(value);
        i > 0 && i--;
      }
      if (i === 0) {
        return observer.onCompleted();
      }
      recurse(i);
    }

    return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount, loopRecursive);
  };

  /**
   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.
   * @param {Mixed} value Element to repeat.
   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.
   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.
   */
  Observable.repeat = function (value, repeatCount, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new RepeatObservable(value, repeatCount, scheduler);
  };

  var JustObservable = function (__super__) {
    inherits(JustObservable, __super__);
    function JustObservable(value, scheduler) {
      this._value = value;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    JustObservable.prototype.subscribeCore = function (o) {
      var state = [this._value, o];
      return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);
    };

    function scheduleItem(s, state) {
      var value = state[0],
          observer = state[1];
      observer.onNext(value);
      observer.onCompleted();
      return disposableEmpty;
    }

    return JustObservable;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.
   *  There is an alias called 'just' or browsers <IE9.
   * @param {Mixed} value Single element in the resulting observable sequence.
   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} An observable sequence containing the single specified element.
   */
  var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return new JustObservable(value, scheduler);
  };

  var ThrowObservable = function (__super__) {
    inherits(ThrowObservable, __super__);
    function ThrowObservable(error, scheduler) {
      this._error = error;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    ThrowObservable.prototype.subscribeCore = function (o) {
      var state = [this._error, o];
      return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);
    };

    function scheduleItem(s, state) {
      var e = state[0],
          o = state[1];
      o.onError(e);
      return disposableEmpty;
    }

    return ThrowObservable;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.
   *  There is an alias to this method called 'throwError' for browsers <IE9.
   * @param {Mixed} error An object used for the sequence's termination.
   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.
   */
  var observableThrow = Observable['throw'] = function (error, scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return new ThrowObservable(error, scheduler);
  };

  var UsingObservable = function (__super__) {
    inherits(UsingObservable, __super__);
    function UsingObservable(resFn, obsFn) {
      this._resFn = resFn;
      this._obsFn = obsFn;
      __super__.call(this);
    }

    UsingObservable.prototype.subscribeCore = function (o) {
      var disposable = disposableEmpty;
      var resource = tryCatch(this._resFn)();
      if (resource === errorObj) {
        return new BinaryDisposable(observableThrow(resource.e).subscribe(o), disposable);
      }
      resource && (disposable = resource);
      var source = tryCatch(this._obsFn)(resource);
      if (source === errorObj) {
        return new BinaryDisposable(observableThrow(source.e).subscribe(o), disposable);
      }
      return new BinaryDisposable(source.subscribe(o), disposable);
    };

    return UsingObservable;
  }(ObservableBase);

  /**
   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
   * @param {Function} resourceFactory Factory function to obtain a resource object.
   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.
   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.
   */
  Observable.using = function (resourceFactory, observableFactory) {
    return new UsingObservable(resourceFactory, observableFactory);
  };

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @param {Observable} rightSource Second observable sequence or Promise.
   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.
   */
  observableProto.amb = function (rightSource) {
    var leftSource = this;
    return new AnonymousObservable(function (observer) {
      var choice,
          leftChoice = 'L',
          rightChoice = 'R',
          leftSubscription = new SingleAssignmentDisposable(),
          rightSubscription = new SingleAssignmentDisposable();

      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));

      function choiceL() {
        if (!choice) {
          choice = leftChoice;
          rightSubscription.dispose();
        }
      }

      function choiceR() {
        if (!choice) {
          choice = rightChoice;
          leftSubscription.dispose();
        }
      }

      var leftSubscribe = observerCreate(function (left) {
        choiceL();
        choice === leftChoice && observer.onNext(left);
      }, function (e) {
        choiceL();
        choice === leftChoice && observer.onError(e);
      }, function () {
        choiceL();
        choice === leftChoice && observer.onCompleted();
      });
      var rightSubscribe = observerCreate(function (right) {
        choiceR();
        choice === rightChoice && observer.onNext(right);
      }, function (e) {
        choiceR();
        choice === rightChoice && observer.onError(e);
      }, function () {
        choiceR();
        choice === rightChoice && observer.onCompleted();
      });

      leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
      rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));

      return new BinaryDisposable(leftSubscription, rightSubscription);
    });
  };

  function amb(p, c) {
    return p.amb(c);
  }

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
   */
  Observable.amb = function () {
    var acc = observableNever(),
        items;
    if (Array.isArray(arguments[0])) {
      items = arguments[0];
    } else {
      var len = arguments.length;
      items = new Array(items);
      for (var i = 0; i < len; i++) {
        items[i] = arguments[i];
      }
    }
    for (var i = 0, len = items.length; i < len; i++) {
      acc = amb(acc, items[i]);
    }
    return acc;
  };

  var CatchObservable = function (__super__) {
    inherits(CatchObservable, __super__);
    function CatchObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    CatchObservable.prototype.subscribeCore = function (o) {
      var d1 = new SingleAssignmentDisposable(),
          subscription = new SerialDisposable();
      subscription.setDisposable(d1);
      d1.setDisposable(this.source.subscribe(new CatchObserver(o, subscription, this._fn)));
      return subscription;
    };

    return CatchObservable;
  }(ObservableBase);

  var CatchObserver = function (__super__) {
    inherits(CatchObserver, __super__);
    function CatchObserver(o, s, fn) {
      this._o = o;
      this._s = s;
      this._fn = fn;
      __super__.call(this);
    }

    CatchObserver.prototype.next = function (x) {
      this._o.onNext(x);
    };
    CatchObserver.prototype.completed = function () {
      return this._o.onCompleted();
    };
    CatchObserver.prototype.error = function (e) {
      var result = tryCatch(this._fn)(e);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      isPromise(result) && (result = observableFromPromise(result));

      var d = new SingleAssignmentDisposable();
      this._s.setDisposable(d);
      d.setDisposable(result.subscribe(this._o));
    };

    return CatchObserver;
  }(AbstractObserver);

  /**
   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.
   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.
   */
  observableProto['catch'] = function (handlerOrSecond) {
    return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
  };

  /**
   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.
   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
   */
  var observableCatch = Observable['catch'] = function () {
    var items;
    if (Array.isArray(arguments[0])) {
      items = arguments[0];
    } else {
      var len = arguments.length;
      items = new Array(len);
      for (var i = 0; i < len; i++) {
        items[i] = arguments[i];
      }
    }
    return enumerableOf(items).catchError();
  };

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
   * This can be in the form of an argument list of observables or an array.
   *
   * @example
   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.combineLatest = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args[0].unshift(this);
    } else {
      args.unshift(this);
    }
    return combineLatest.apply(this, args);
  };

  function falseFactory() {
    return false;
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var CombineLatestObservable = function (__super__) {
    inherits(CombineLatestObservable, __super__);
    function CombineLatestObservable(params, cb) {
      this._params = params;
      this._cb = cb;
      __super__.call(this);
    }

    CombineLatestObservable.prototype.subscribeCore = function (observer) {
      var len = this._params.length,
          subscriptions = new Array(len);

      var state = {
        hasValue: arrayInitialize(len, falseFactory),
        hasValueAll: false,
        isDone: arrayInitialize(len, falseFactory),
        values: new Array(len)
      };

      for (var i = 0; i < len; i++) {
        var source = this._params[i],
            sad = new SingleAssignmentDisposable();
        subscriptions[i] = sad;
        isPromise(source) && (source = observableFromPromise(source));
        sad.setDisposable(source.subscribe(new CombineLatestObserver(observer, i, this._cb, state)));
      }

      return new NAryDisposable(subscriptions);
    };

    return CombineLatestObservable;
  }(ObservableBase);

  var CombineLatestObserver = function (__super__) {
    inherits(CombineLatestObserver, __super__);
    function CombineLatestObserver(o, i, cb, state) {
      this._o = o;
      this._i = i;
      this._cb = cb;
      this._state = state;
      __super__.call(this);
    }

    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    CombineLatestObserver.prototype.next = function (x) {
      this._state.values[this._i] = x;
      this._state.hasValue[this._i] = true;
      if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.every(identity))) {
        var res = tryCatch(this._cb).apply(null, this._state.values);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._o.onNext(res);
      } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {
        this._o.onCompleted();
      }
    };

    CombineLatestObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    CombineLatestObserver.prototype.completed = function () {
      this._state.isDone[this._i] = true;
      this._state.isDone.every(identity) && this._o.onCompleted();
    };

    return CombineLatestObserver;
  }(AbstractObserver);

  /**
  * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
  *
  * @example
  * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
  * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
  * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  */
  var combineLatest = Observable.combineLatest = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);
    return new CombineLatestObservable(args, resultSelector);
  };

  /**
   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.
   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
   */
  observableProto.concat = function () {
    for (var args = [], i = 0, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    args.unshift(this);
    return observableConcat.apply(null, args);
  };

  var ConcatObserver = function (__super__) {
    inherits(ConcatObserver, __super__);
    function ConcatObserver(s, fn) {
      this._s = s;
      this._fn = fn;
      __super__.call(this);
    }

    ConcatObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
    };
    ConcatObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    ConcatObserver.prototype.completed = function () {
      this._s.i++;this._fn(this._s);
    };

    return ConcatObserver;
  }(AbstractObserver);

  var ConcatObservable = function (__super__) {
    inherits(ConcatObservable, __super__);
    function ConcatObservable(sources) {
      this._sources = sources;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      if (state.disposable.isDisposed) {
        return;
      }
      if (state.i === state.sources.length) {
        return state.o.onCompleted();
      }

      // Check if promise
      var currentValue = state.sources[state.i];
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new ConcatObserver(state, recurse)));
    }

    ConcatObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var disposable = disposableCreate(noop);
      var state = {
        o: o,
        i: 0,
        subscription: subscription,
        disposable: disposable,
        sources: this._sources
      };

      var cancelable = immediateScheduler.scheduleRecursive(state, scheduleRecursive);
      return new NAryDisposable([subscription, disposable, cancelable]);
    };

    return ConcatObservable;
  }(ObservableBase);

  /**
   * Concatenates all the observable sequences.
   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.
   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
   */
  var observableConcat = Observable.concat = function () {
    var args;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      args = new Array(arguments.length);
      for (var i = 0, len = arguments.length; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    return new ConcatObservable(args);
  };

  /**
   * Concatenates an observable sequence of observable sequences.
   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.
   */
  observableProto.concatAll = function () {
    return this.merge(1);
  };

  var MergeObservable = function (__super__) {
    inherits(MergeObservable, __super__);

    function MergeObservable(source, maxConcurrent) {
      this.source = source;
      this.maxConcurrent = maxConcurrent;
      __super__.call(this);
    }

    MergeObservable.prototype.subscribeCore = function (observer) {
      var g = new CompositeDisposable();
      g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
      return g;
    };

    return MergeObservable;
  }(ObservableBase);

  var MergeObserver = function (__super__) {
    function MergeObserver(o, max, g) {
      this.o = o;
      this.max = max;
      this.g = g;
      this.done = false;
      this.q = [];
      this.activeCount = 0;
      __super__.call(this);
    }

    inherits(MergeObserver, __super__);

    MergeObserver.prototype.handleSubscribe = function (xs) {
      var sad = new SingleAssignmentDisposable();
      this.g.add(sad);
      isPromise(xs) && (xs = observableFromPromise(xs));
      sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
    };

    MergeObserver.prototype.next = function (innerSource) {
      if (this.activeCount < this.max) {
        this.activeCount++;
        this.handleSubscribe(innerSource);
      } else {
        this.q.push(innerSource);
      }
    };
    MergeObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    MergeObserver.prototype.completed = function () {
      this.done = true;this.activeCount === 0 && this.o.onCompleted();
    };

    function InnerObserver(parent, sad) {
      this.parent = parent;
      this.sad = sad;
      __super__.call(this);
    }

    inherits(InnerObserver, __super__);

    InnerObserver.prototype.next = function (x) {
      this.parent.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.parent.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.parent.g.remove(this.sad);
      if (this.parent.q.length > 0) {
        this.parent.handleSubscribe(this.parent.q.shift());
      } else {
        this.parent.activeCount--;
        this.parent.done && this.parent.activeCount === 0 && this.parent.o.onCompleted();
      }
    };

    return MergeObserver;
  }(AbstractObserver);

  /**
  * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.
  * Or merges two observable sequences into a single observable sequence.
  * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.
  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
  */
  observableProto.merge = function (maxConcurrentOrOther) {
    return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
  };

  /**
   * Merges all the observable sequences into a single observable sequence.
   * The scheduler is optional and if not specified, the immediate scheduler is used.
   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.
   */
  var observableMerge = Observable.merge = function () {
    var scheduler,
        sources = [],
        i,
        len = arguments.length;
    if (!arguments[0]) {
      scheduler = immediateScheduler;
      for (i = 1; i < len; i++) {
        sources.push(arguments[i]);
      }
    } else if (isScheduler(arguments[0])) {
      scheduler = arguments[0];
      for (i = 1; i < len; i++) {
        sources.push(arguments[i]);
      }
    } else {
      scheduler = immediateScheduler;
      for (i = 0; i < len; i++) {
        sources.push(arguments[i]);
      }
    }
    if (Array.isArray(sources[0])) {
      sources = sources[0];
    }
    return observableOf(scheduler, sources).mergeAll();
  };

  var MergeAllObservable = function (__super__) {
    inherits(MergeAllObservable, __super__);

    function MergeAllObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    MergeAllObservable.prototype.subscribeCore = function (o) {
      var g = new CompositeDisposable(),
          m = new SingleAssignmentDisposable();
      g.add(m);
      m.setDisposable(this.source.subscribe(new MergeAllObserver(o, g)));
      return g;
    };

    return MergeAllObservable;
  }(ObservableBase);

  var MergeAllObserver = function (__super__) {
    function MergeAllObserver(o, g) {
      this.o = o;
      this.g = g;
      this.done = false;
      __super__.call(this);
    }

    inherits(MergeAllObserver, __super__);

    MergeAllObserver.prototype.next = function (innerSource) {
      var sad = new SingleAssignmentDisposable();
      this.g.add(sad);
      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
      sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));
    };

    MergeAllObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    MergeAllObserver.prototype.completed = function () {
      this.done = true;
      this.g.length === 1 && this.o.onCompleted();
    };

    function InnerObserver(parent, sad) {
      this.parent = parent;
      this.sad = sad;
      __super__.call(this);
    }

    inherits(InnerObserver, __super__);

    InnerObserver.prototype.next = function (x) {
      this.parent.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.parent.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.parent.g.remove(this.sad);
      this.parent.done && this.parent.g.length === 1 && this.parent.o.onCompleted();
    };

    return MergeAllObserver;
  }(AbstractObserver);

  /**
  * Merges an observable sequence of observable sequences into an observable sequence.
  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
  */
  observableProto.mergeAll = function () {
    return new MergeAllObservable(this);
  };

  var CompositeError = Rx.CompositeError = function (errors) {
    this.innerErrors = errors;
    this.message = 'This contains multiple errors. Check the innerErrors';
    Error.call(this);
  };
  CompositeError.prototype = Object.create(Error.prototype);
  CompositeError.prototype.name = 'CompositeError';

  var MergeDelayErrorObservable = function (__super__) {
    inherits(MergeDelayErrorObservable, __super__);
    function MergeDelayErrorObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    MergeDelayErrorObservable.prototype.subscribeCore = function (o) {
      var group = new CompositeDisposable(),
          m = new SingleAssignmentDisposable(),
          state = { isStopped: false, errors: [], o: o };

      group.add(m);
      m.setDisposable(this.source.subscribe(new MergeDelayErrorObserver(group, state)));

      return group;
    };

    return MergeDelayErrorObservable;
  }(ObservableBase);

  var MergeDelayErrorObserver = function (__super__) {
    inherits(MergeDelayErrorObserver, __super__);
    function MergeDelayErrorObserver(group, state) {
      this._group = group;
      this._state = state;
      __super__.call(this);
    }

    function setCompletion(o, errors) {
      if (errors.length === 0) {
        o.onCompleted();
      } else if (errors.length === 1) {
        o.onError(errors[0]);
      } else {
        o.onError(new CompositeError(errors));
      }
    }

    MergeDelayErrorObserver.prototype.next = function (x) {
      var inner = new SingleAssignmentDisposable();
      this._group.add(inner);

      // Check for promises support
      isPromise(x) && (x = observableFromPromise(x));
      inner.setDisposable(x.subscribe(new InnerObserver(inner, this._group, this._state)));
    };

    MergeDelayErrorObserver.prototype.error = function (e) {
      this._state.errors.push(e);
      this._state.isStopped = true;
      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    MergeDelayErrorObserver.prototype.completed = function () {
      this._state.isStopped = true;
      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    inherits(InnerObserver, __super__);
    function InnerObserver(inner, group, state) {
      this._inner = inner;
      this._group = group;
      this._state = state;
      __super__.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.errors.push(e);
      this._group.remove(this._inner);
      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };
    InnerObserver.prototype.completed = function () {
      this._group.remove(this._inner);
      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    return MergeDelayErrorObserver;
  }(AbstractObserver);

  /**
  * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
  * receive all successfully emitted items from all of the source Observables without being interrupted by
  * an error notification from one of them.
  *
  * This behaves like Observable.prototype.mergeAll except that if any of the merged Observables notify of an
  * error via the Observer's onError, mergeDelayError will refrain from propagating that
  * error notification until all of the merged Observables have finished emitting items.
  * @param {Array | Arguments} args Arguments or an array to merge.
  * @returns {Observable} an Observable that emits all of the items emitted by the Observables emitted by the Observable
  */
  Observable.mergeDelayError = function () {
    var args;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      var len = arguments.length;
      args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    var source = observableOf(null, args);
    return new MergeDelayErrorObservable(source);
  };

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.
   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
   */
  observableProto.onErrorResumeNext = function (second) {
    if (!second) {
      throw new Error('Second observable is required');
    }
    return onErrorResumeNext([this, second]);
  };

  var OnErrorResumeNextObservable = function (__super__) {
    inherits(OnErrorResumeNextObservable, __super__);
    function OnErrorResumeNextObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    function scheduleMethod(state, recurse) {
      if (state.pos < state.sources.length) {
        var current = state.sources[state.pos++];
        isPromise(current) && (current = observableFromPromise(current));
        var d = new SingleAssignmentDisposable();
        state.subscription.setDisposable(d);
        d.setDisposable(current.subscribe(new OnErrorResumeNextObserver(state, recurse)));
      } else {
        state.o.onCompleted();
      }
    }

    OnErrorResumeNextObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable(),
          state = { pos: 0, subscription: subscription, o: o, sources: this.sources },
          cancellable = immediateScheduler.scheduleRecursive(state, scheduleMethod);

      return new BinaryDisposable(subscription, cancellable);
    };

    return OnErrorResumeNextObservable;
  }(ObservableBase);

  var OnErrorResumeNextObserver = function (__super__) {
    inherits(OnErrorResumeNextObserver, __super__);
    function OnErrorResumeNextObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      __super__.call(this);
    }

    OnErrorResumeNextObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    OnErrorResumeNextObserver.prototype.error = function () {
      this._recurse(this._state);
    };
    OnErrorResumeNextObserver.prototype.completed = function () {
      this._recurse(this._state);
    };

    return OnErrorResumeNextObserver;
  }(AbstractObserver);

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
   */
  var onErrorResumeNext = Observable.onErrorResumeNext = function () {
    var sources = [];
    if (Array.isArray(arguments[0])) {
      sources = arguments[0];
    } else {
      var len = arguments.length;
      sources = new Array(len);
      for (var i = 0; i < len; i++) {
        sources[i] = arguments[i];
      }
    }
    return new OnErrorResumeNextObservable(sources);
  };

  var SkipUntilObservable = function (__super__) {
    inherits(SkipUntilObservable, __super__);

    function SkipUntilObservable(source, other) {
      this._s = source;
      this._o = isPromise(other) ? observableFromPromise(other) : other;
      this._open = false;
      __super__.call(this);
    }

    SkipUntilObservable.prototype.subscribeCore = function (o) {
      var leftSubscription = new SingleAssignmentDisposable();
      leftSubscription.setDisposable(this._s.subscribe(new SkipUntilSourceObserver(o, this)));

      isPromise(this._o) && (this._o = observableFromPromise(this._o));

      var rightSubscription = new SingleAssignmentDisposable();
      rightSubscription.setDisposable(this._o.subscribe(new SkipUntilOtherObserver(o, this, rightSubscription)));

      return new BinaryDisposable(leftSubscription, rightSubscription);
    };

    return SkipUntilObservable;
  }(ObservableBase);

  var SkipUntilSourceObserver = function (__super__) {
    inherits(SkipUntilSourceObserver, __super__);
    function SkipUntilSourceObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipUntilSourceObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };

    SkipUntilSourceObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    SkipUntilSourceObserver.prototype.onCompleted = function () {
      this._p._open && this._o.onCompleted();
    };

    return SkipUntilSourceObserver;
  }(AbstractObserver);

  var SkipUntilOtherObserver = function (__super__) {
    inherits(SkipUntilOtherObserver, __super__);
    function SkipUntilOtherObserver(o, p, r) {
      this._o = o;
      this._p = p;
      this._r = r;
      __super__.call(this);
    }

    SkipUntilOtherObserver.prototype.next = function () {
      this._p._open = true;
      this._r.dispose();
    };

    SkipUntilOtherObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    SkipUntilOtherObserver.prototype.onCompleted = function () {
      this._r.dispose();
    };

    return SkipUntilOtherObserver;
  }(AbstractObserver);

  /**
   * Returns the values from the source observable sequence only after the other observable sequence produces a value.
   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.
   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.
   */
  observableProto.skipUntil = function (other) {
    return new SkipUntilObservable(this, other);
  };

  var SwitchObservable = function (__super__) {
    inherits(SwitchObservable, __super__);
    function SwitchObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    SwitchObservable.prototype.subscribeCore = function (o) {
      var inner = new SerialDisposable(),
          s = this.source.subscribe(new SwitchObserver(o, inner));
      return new BinaryDisposable(s, inner);
    };

    inherits(SwitchObserver, AbstractObserver);
    function SwitchObserver(o, inner) {
      this.o = o;
      this.inner = inner;
      this.stopped = false;
      this.latest = 0;
      this.hasLatest = false;
      AbstractObserver.call(this);
    }

    SwitchObserver.prototype.next = function (innerSource) {
      var d = new SingleAssignmentDisposable(),
          id = ++this.latest;
      this.hasLatest = true;
      this.inner.setDisposable(d);
      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
      d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
    };

    SwitchObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    SwitchObserver.prototype.completed = function () {
      this.stopped = true;
      !this.hasLatest && this.o.onCompleted();
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(parent, id) {
      this.parent = parent;
      this.id = id;
      AbstractObserver.call(this);
    }
    InnerObserver.prototype.next = function (x) {
      this.parent.latest === this.id && this.parent.o.onNext(x);
    };

    InnerObserver.prototype.error = function (e) {
      this.parent.latest === this.id && this.parent.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      if (this.parent.latest === this.id) {
        this.parent.hasLatest = false;
        this.parent.stopped && this.parent.o.onCompleted();
      }
    };

    return SwitchObservable;
  }(ObservableBase);

  /**
  * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
  * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
  */
  observableProto['switch'] = observableProto.switchLatest = function () {
    return new SwitchObservable(this);
  };

  var TakeUntilObservable = function (__super__) {
    inherits(TakeUntilObservable, __super__);

    function TakeUntilObservable(source, other) {
      this.source = source;
      this.other = isPromise(other) ? observableFromPromise(other) : other;
      __super__.call(this);
    }

    TakeUntilObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this.source.subscribe(o), this.other.subscribe(new TakeUntilObserver(o)));
    };

    return TakeUntilObservable;
  }(ObservableBase);

  var TakeUntilObserver = function (__super__) {
    inherits(TakeUntilObserver, __super__);
    function TakeUntilObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    TakeUntilObserver.prototype.next = function () {
      this._o.onCompleted();
    };

    TakeUntilObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    TakeUntilObserver.prototype.onCompleted = noop;

    return TakeUntilObserver;
  }(AbstractObserver);

  /**
   * Returns the values from the source observable sequence until the other observable sequence produces a value.
   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.
   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
   */
  observableProto.takeUntil = function (other) {
    return new TakeUntilObservable(this, other);
  };

  function falseFactory() {
    return false;
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var WithLatestFromObservable = function (__super__) {
    inherits(WithLatestFromObservable, __super__);
    function WithLatestFromObservable(source, sources, resultSelector) {
      this._s = source;
      this._ss = sources;
      this._cb = resultSelector;
      __super__.call(this);
    }

    WithLatestFromObservable.prototype.subscribeCore = function (o) {
      var len = this._ss.length;
      var state = {
        hasValue: arrayInitialize(len, falseFactory),
        hasValueAll: false,
        values: new Array(len)
      };

      var n = this._ss.length,
          subscriptions = new Array(n + 1);
      for (var i = 0; i < n; i++) {
        var other = this._ss[i],
            sad = new SingleAssignmentDisposable();
        isPromise(other) && (other = observableFromPromise(other));
        sad.setDisposable(other.subscribe(new WithLatestFromOtherObserver(o, i, state)));
        subscriptions[i] = sad;
      }

      var outerSad = new SingleAssignmentDisposable();
      outerSad.setDisposable(this._s.subscribe(new WithLatestFromSourceObserver(o, this._cb, state)));
      subscriptions[n] = outerSad;

      return new NAryDisposable(subscriptions);
    };

    return WithLatestFromObservable;
  }(ObservableBase);

  var WithLatestFromOtherObserver = function (__super__) {
    inherits(WithLatestFromOtherObserver, __super__);
    function WithLatestFromOtherObserver(o, i, state) {
      this._o = o;
      this._i = i;
      this._state = state;
      __super__.call(this);
    }

    WithLatestFromOtherObserver.prototype.next = function (x) {
      this._state.values[this._i] = x;
      this._state.hasValue[this._i] = true;
      this._state.hasValueAll = this._state.hasValue.every(identity);
    };

    WithLatestFromOtherObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    WithLatestFromOtherObserver.prototype.completed = noop;

    return WithLatestFromOtherObserver;
  }(AbstractObserver);

  var WithLatestFromSourceObserver = function (__super__) {
    inherits(WithLatestFromSourceObserver, __super__);
    function WithLatestFromSourceObserver(o, cb, state) {
      this._o = o;
      this._cb = cb;
      this._state = state;
      __super__.call(this);
    }

    WithLatestFromSourceObserver.prototype.next = function (x) {
      var allValues = [x].concat(this._state.values);
      if (!this._state.hasValueAll) {
        return;
      }
      var res = tryCatch(this._cb).apply(null, allValues);
      if (res === errorObj) {
        return this._o.onError(res.e);
      }
      this._o.onNext(res);
    };

    WithLatestFromSourceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    WithLatestFromSourceObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return WithLatestFromSourceObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.withLatestFrom = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);

    return new WithLatestFromObservable(this, args, resultSelector);
  };

  function falseFactory() {
    return false;
  }
  function emptyArrayFactory() {
    return [];
  }

  var ZipObservable = function (__super__) {
    inherits(ZipObservable, __super__);
    function ZipObservable(sources, resultSelector) {
      this._s = sources;
      this._cb = resultSelector;
      __super__.call(this);
    }

    ZipObservable.prototype.subscribeCore = function (observer) {
      var n = this._s.length,
          subscriptions = new Array(n),
          done = arrayInitialize(n, falseFactory),
          q = arrayInitialize(n, emptyArrayFactory);

      for (var i = 0; i < n; i++) {
        var source = this._s[i],
            sad = new SingleAssignmentDisposable();
        subscriptions[i] = sad;
        isPromise(source) && (source = observableFromPromise(source));
        sad.setDisposable(source.subscribe(new ZipObserver(observer, i, this, q, done)));
      }

      return new NAryDisposable(subscriptions);
    };

    return ZipObservable;
  }(ObservableBase);

  var ZipObserver = function (__super__) {
    inherits(ZipObserver, __super__);
    function ZipObserver(o, i, p, q, d) {
      this._o = o;
      this._i = i;
      this._p = p;
      this._q = q;
      this._d = d;
      __super__.call(this);
    }

    function notEmpty(x) {
      return x.length > 0;
    }
    function shiftEach(x) {
      return x.shift();
    }
    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    ZipObserver.prototype.next = function (x) {
      this._q[this._i].push(x);
      if (this._q.every(notEmpty)) {
        var queuedValues = this._q.map(shiftEach);
        var res = tryCatch(this._p._cb).apply(null, queuedValues);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._o.onNext(res);
      } else if (this._d.filter(notTheSame(this._i)).every(identity)) {
        this._o.onCompleted();
      }
    };

    ZipObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ZipObserver.prototype.completed = function () {
      this._d[this._i] = true;
      this._d.every(identity) && this._o.onCompleted();
    };

    return ZipObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.
   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.
   */
  observableProto.zip = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);

    var parent = this;
    args.unshift(parent);

    return new ZipObservable(args, resultSelector);
  };

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   * @param arguments Observable sources.
   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  Observable.zip = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];
    }
    var first = args.shift();
    return first.zip.apply(first, args);
  };

  function falseFactory() {
    return false;
  }
  function emptyArrayFactory() {
    return [];
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var ZipIterableObservable = function (__super__) {
    inherits(ZipIterableObservable, __super__);
    function ZipIterableObservable(sources, cb) {
      this.sources = sources;
      this._cb = cb;
      __super__.call(this);
    }

    ZipIterableObservable.prototype.subscribeCore = function (o) {
      var sources = this.sources,
          len = sources.length,
          subscriptions = new Array(len);

      var state = {
        q: arrayInitialize(len, emptyArrayFactory),
        done: arrayInitialize(len, falseFactory),
        cb: this._cb,
        o: o
      };

      for (var i = 0; i < len; i++) {
        (function (i) {
          var source = sources[i],
              sad = new SingleAssignmentDisposable();
          (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));

          subscriptions[i] = sad;
          sad.setDisposable(source.subscribe(new ZipIterableObserver(state, i)));
        })(i);
      }

      return new NAryDisposable(subscriptions);
    };

    return ZipIterableObservable;
  }(ObservableBase);

  var ZipIterableObserver = function (__super__) {
    inherits(ZipIterableObserver, __super__);
    function ZipIterableObserver(s, i) {
      this._s = s;
      this._i = i;
      __super__.call(this);
    }

    function notEmpty(x) {
      return x.length > 0;
    }
    function shiftEach(x) {
      return x.shift();
    }
    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    ZipIterableObserver.prototype.next = function (x) {
      this._s.q[this._i].push(x);
      if (this._s.q.every(notEmpty)) {
        var queuedValues = this._s.q.map(shiftEach),
            res = tryCatch(this._s.cb).apply(null, queuedValues);
        if (res === errorObj) {
          return this._s.o.onError(res.e);
        }
        this._s.o.onNext(res);
      } else if (this._s.done.filter(notTheSame(this._i)).every(identity)) {
        this._s.o.onCompleted();
      }
    };

    ZipIterableObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    ZipIterableObserver.prototype.completed = function () {
      this._s.done[this._i] = true;
      this._s.done.every(identity) && this._s.o.onCompleted();
    };

    return ZipIterableObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.
   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.
   */
  observableProto.zipIterable = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;

    var parent = this;
    args.unshift(parent);
    return new ZipIterableObservable(args, resultSelector);
  };

  function asObservable(source) {
    return function subscribe(o) {
      return source.subscribe(o);
    };
  }

  /**
   *  Hides the identity of an observable sequence.
   * @returns {Observable} An observable sequence that hides the identity of the source sequence.
   */
  observableProto.asObservable = function () {
    return new AnonymousObservable(asObservable(this), this);
  };

  function toArray(x) {
    return x.toArray();
  }
  function notEmpty(x) {
    return x.length > 0;
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
   * @param {Number} count Length of each buffer.
   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithCount = observableProto.bufferCount = function (count, skip) {
    typeof skip !== 'number' && (skip = count);
    return this.windowWithCount(count, skip).flatMap(toArray).filter(notEmpty);
  };

  var DematerializeObservable = function (__super__) {
    inherits(DematerializeObservable, __super__);
    function DematerializeObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    DematerializeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DematerializeObserver(o));
    };

    return DematerializeObservable;
  }(ObservableBase);

  var DematerializeObserver = function (__super__) {
    inherits(DematerializeObserver, __super__);

    function DematerializeObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    DematerializeObserver.prototype.next = function (x) {
      x.accept(this._o);
    };
    DematerializeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    DematerializeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return DematerializeObserver;
  }(AbstractObserver);

  /**
   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
   */
  observableProto.dematerialize = function () {
    return new DematerializeObservable(this);
  };

  var DistinctUntilChangedObservable = function (__super__) {
    inherits(DistinctUntilChangedObservable, __super__);
    function DistinctUntilChangedObservable(source, keyFn, comparer) {
      this.source = source;
      this.keyFn = keyFn;
      this.comparer = comparer;
      __super__.call(this);
    }

    DistinctUntilChangedObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));
    };

    return DistinctUntilChangedObservable;
  }(ObservableBase);

  var DistinctUntilChangedObserver = function (__super__) {
    inherits(DistinctUntilChangedObserver, __super__);
    function DistinctUntilChangedObserver(o, keyFn, comparer) {
      this.o = o;
      this.keyFn = keyFn;
      this.comparer = comparer;
      this.hasCurrentKey = false;
      this.currentKey = null;
      __super__.call(this);
    }

    DistinctUntilChangedObserver.prototype.next = function (x) {
      var key = x,
          comparerEquals;
      if (isFunction(this.keyFn)) {
        key = tryCatch(this.keyFn)(x);
        if (key === errorObj) {
          return this.o.onError(key.e);
        }
      }
      if (this.hasCurrentKey) {
        comparerEquals = tryCatch(this.comparer)(this.currentKey, key);
        if (comparerEquals === errorObj) {
          return this.o.onError(comparerEquals.e);
        }
      }
      if (!this.hasCurrentKey || !comparerEquals) {
        this.hasCurrentKey = true;
        this.currentKey = key;
        this.o.onNext(x);
      }
    };
    DistinctUntilChangedObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    DistinctUntilChangedObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return DistinctUntilChangedObserver;
  }(AbstractObserver);

  /**
  *  Returns an observable sequence that contains only distinct contiguous elements according to the keyFn and the comparer.
  * @param {Function} [keyFn] A function to compute the comparison key for each element. If not provided, it projects the value.
  * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.
  * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
  */
  observableProto.distinctUntilChanged = function (keyFn, comparer) {
    comparer || (comparer = defaultComparer);
    return new DistinctUntilChangedObservable(this, keyFn, comparer);
  };

  var TapObservable = function (__super__) {
    inherits(TapObservable, __super__);
    function TapObservable(source, observerOrOnNext, onError, onCompleted) {
      this.source = source;
      this._oN = observerOrOnNext;
      this._oE = onError;
      this._oC = onCompleted;
      __super__.call(this);
    }

    TapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, p) {
      this.o = o;
      this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;
      this.isStopped = false;
      AbstractObserver.call(this);
    }
    InnerObserver.prototype.next = function (x) {
      var res = tryCatch(this.t.onNext).call(this.t, x);
      if (res === errorObj) {
        this.o.onError(res.e);
      }
      this.o.onNext(x);
    };
    InnerObserver.prototype.error = function (err) {
      var res = tryCatch(this.t.onError).call(this.t, err);
      if (res === errorObj) {
        return this.o.onError(res.e);
      }
      this.o.onError(err);
    };
    InnerObserver.prototype.completed = function () {
      var res = tryCatch(this.t.onCompleted).call(this.t);
      if (res === errorObj) {
        return this.o.onError(res.e);
      }
      this.o.onCompleted();
    };

    return TapObservable;
  }(ObservableBase);

  /**
  *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an o.
  * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
  * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto['do'] = observableProto.tap = observableProto.doAction = function (observerOrOnNext, onError, onCompleted) {
    return new TapObservable(this, observerOrOnNext, onError, onCompleted);
  };

  /**
  *  Invokes an action for each element in the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onNext Action to invoke for each element in the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
    return this.tap(typeof thisArg !== 'undefined' ? function (x) {
      onNext.call(thisArg, x);
    } : onNext);
  };

  /**
  *  Invokes an action upon exceptional termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {
    return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) {
      onError.call(thisArg, e);
    } : onError);
  };

  /**
  *  Invokes an action upon graceful termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {
    return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () {
      onCompleted.call(thisArg);
    } : onCompleted);
  };

  var FinallyObservable = function (__super__) {
    inherits(FinallyObservable, __super__);
    function FinallyObservable(source, fn, thisArg) {
      this.source = source;
      this._fn = bindCallback(fn, thisArg, 0);
      __super__.call(this);
    }

    FinallyObservable.prototype.subscribeCore = function (o) {
      var d = tryCatch(this.source.subscribe).call(this.source, o);
      if (d === errorObj) {
        this._fn();
        thrower(d.e);
      }

      return new FinallyDisposable(d, this._fn);
    };

    function FinallyDisposable(s, fn) {
      this.isDisposed = false;
      this._s = s;
      this._fn = fn;
    }
    FinallyDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        var res = tryCatch(this._s.dispose).call(this._s);
        this._fn();
        res === errorObj && thrower(res.e);
      }
    };

    return FinallyObservable;
  }(ObservableBase);

  /**
   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.
   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.
   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.
   */
  observableProto['finally'] = function (action, thisArg) {
    return new FinallyObservable(this, action, thisArg);
  };

  var IgnoreElementsObservable = function (__super__) {
    inherits(IgnoreElementsObservable, __super__);

    function IgnoreElementsObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    IgnoreElementsObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o));
    };

    function InnerObserver(o) {
      this.o = o;
      this.isStopped = false;
    }
    InnerObserver.prototype.onNext = noop;
    InnerObserver.prototype.onError = function (err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.o.onError(err);
      }
    };
    InnerObserver.prototype.onCompleted = function () {
      if (!this.isStopped) {
        this.isStopped = true;
        this.o.onCompleted();
      }
    };
    InnerObserver.prototype.dispose = function () {
      this.isStopped = true;
    };
    InnerObserver.prototype.fail = function (e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }

      return false;
    };

    return IgnoreElementsObservable;
  }(ObservableBase);

  /**
   *  Ignores all elements in an observable sequence leaving only the termination messages.
   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.
   */
  observableProto.ignoreElements = function () {
    return new IgnoreElementsObservable(this);
  };

  var MaterializeObservable = function (__super__) {
    inherits(MaterializeObservable, __super__);
    function MaterializeObservable(source, fn) {
      this.source = source;
      __super__.call(this);
    }

    MaterializeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new MaterializeObserver(o));
    };

    return MaterializeObservable;
  }(ObservableBase);

  var MaterializeObserver = function (__super__) {
    inherits(MaterializeObserver, __super__);

    function MaterializeObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    MaterializeObserver.prototype.next = function (x) {
      this._o.onNext(notificationCreateOnNext(x));
    };
    MaterializeObserver.prototype.error = function (e) {
      this._o.onNext(notificationCreateOnError(e));this._o.onCompleted();
    };
    MaterializeObserver.prototype.completed = function () {
      this._o.onNext(notificationCreateOnCompleted());this._o.onCompleted();
    };

    return MaterializeObserver;
  }(AbstractObserver);

  /**
   *  Materializes the implicit notifications of an observable sequence as explicit notification values.
   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.
   */
  observableProto.materialize = function () {
    return new MaterializeObservable(this);
  };

  /**
   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.
   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.
   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.
   */
  observableProto.repeat = function (repeatCount) {
    return enumerableRepeat(this, repeatCount).concat();
  };

  /**
   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.
   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
   *
   * @example
   *  var res = retried = retry.repeat();
   *  var res = retried = retry.repeat(2);
   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
   */
  observableProto.retry = function (retryCount) {
    return enumerableRepeat(this, retryCount).catchError();
  };

  function repeat(value) {
    return {
      '@@iterator': function iterator() {
        return {
          next: function next() {
            return { done: false, value: value };
          }
        };
      }
    };
  }

  var RetryWhenObservable = function (__super__) {
    function createDisposable(state) {
      return {
        isDisposed: false,
        dispose: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            state.isDisposed = true;
          }
        }
      };
    }

    function RetryWhenObservable(source, notifier) {
      this.source = source;
      this._notifier = notifier;
      __super__.call(this);
    }

    inherits(RetryWhenObservable, __super__);

    RetryWhenObservable.prototype.subscribeCore = function (o) {
      var exceptions = new Subject(),
          notifier = new Subject(),
          handled = this._notifier(exceptions),
          notificationDisposable = handled.subscribe(notifier);

      var e = this.source['@@iterator']();

      var state = { isDisposed: false },
          lastError,
          subscription = new SerialDisposable();
      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, recurse) {
        if (state.isDisposed) {
          return;
        }
        var currentItem = e.next();

        if (currentItem.done) {
          if (lastError) {
            o.onError(lastError);
          } else {
            o.onCompleted();
          }
          return;
        }

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new BinaryDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(function (x) {
          o.onNext(x);
        }, function (exn) {
          inner.setDisposable(notifier.subscribe(recurse, function (ex) {
            o.onError(ex);
          }, function () {
            o.onCompleted();
          }));

          exceptions.onNext(exn);
          outer.dispose();
        }, function () {
          o.onCompleted();
        }));
      });

      return new NAryDisposable([notificationDisposable, subscription, cancelable, createDisposable(state)]);
    };

    return RetryWhenObservable;
  }(ObservableBase);

  observableProto.retryWhen = function (notifier) {
    return new RetryWhenObservable(repeat(this), notifier);
  };

  function repeat(value) {
    return {
      '@@iterator': function iterator() {
        return {
          next: function next() {
            return { done: false, value: value };
          }
        };
      }
    };
  }

  var RepeatWhenObservable = function (__super__) {
    function createDisposable(state) {
      return {
        isDisposed: false,
        dispose: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            state.isDisposed = true;
          }
        }
      };
    }

    function RepeatWhenObservable(source, notifier) {
      this.source = source;
      this._notifier = notifier;
      __super__.call(this);
    }

    inherits(RepeatWhenObservable, __super__);

    RepeatWhenObservable.prototype.subscribeCore = function (o) {
      var completions = new Subject(),
          notifier = new Subject(),
          handled = this._notifier(completions),
          notificationDisposable = handled.subscribe(notifier);

      var e = this.source['@@iterator']();

      var state = { isDisposed: false },
          lastError,
          subscription = new SerialDisposable();
      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, recurse) {
        if (state.isDisposed) {
          return;
        }
        var currentItem = e.next();

        if (currentItem.done) {
          if (lastError) {
            o.onError(lastError);
          } else {
            o.onCompleted();
          }
          return;
        }

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new BinaryDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(function (x) {
          o.onNext(x);
        }, function (exn) {
          o.onError(exn);
        }, function () {
          inner.setDisposable(notifier.subscribe(recurse, function (ex) {
            o.onError(ex);
          }, function () {
            o.onCompleted();
          }));

          completions.onNext(null);
          outer.dispose();
        }));
      });

      return new NAryDisposable([notificationDisposable, subscription, cancelable, createDisposable(state)]);
    };

    return RepeatWhenObservable;
  }(ObservableBase);

  observableProto.repeatWhen = function (notifier) {
    return new RepeatWhenObservable(repeat(this), notifier);
  };

  var ScanObservable = function (__super__) {
    inherits(ScanObservable, __super__);
    function ScanObservable(source, accumulator, hasSeed, seed) {
      this.source = source;
      this.accumulator = accumulator;
      this.hasSeed = hasSeed;
      this.seed = seed;
      __super__.call(this);
    }

    ScanObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ScanObserver(o, this));
    };

    return ScanObservable;
  }(ObservableBase);

  var ScanObserver = function (__super__) {
    inherits(ScanObserver, __super__);
    function ScanObserver(o, parent) {
      this._o = o;
      this._p = parent;
      this._fn = parent.accumulator;
      this._hs = parent.hasSeed;
      this._s = parent.seed;
      this._ha = false;
      this._a = null;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    ScanObserver.prototype.next = function (x) {
      !this._hv && (this._hv = true);
      if (this._ha) {
        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);
      } else {
        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;
        this._ha = true;
      }
      if (this._a === errorObj) {
        return this._o.onError(this._a.e);
      }
      this._o.onNext(this._a);
      this._i++;
    };

    ScanObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ScanObserver.prototype.completed = function () {
      !this._hv && this._hs && this._o.onNext(this._s);
      this._o.onCompleted();
    };

    return ScanObserver;
  }(AbstractObserver);

  /**
  *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
  *  For aggregation behavior with no intermediate results, see Observable.aggregate.
  * @param {Mixed} [seed] The initial accumulator value.
  * @param {Function} accumulator An accumulator function to be invoked on each element.
  * @returns {Observable} An observable sequence containing the accumulated values.
  */
  observableProto.scan = function () {
    var hasSeed = false,
        seed,
        accumulator = arguments[0];
    if (arguments.length === 2) {
      hasSeed = true;
      seed = arguments[1];
    }
    return new ScanObservable(this, accumulator, hasSeed, seed);
  };

  var SkipLastObservable = function (__super__) {
    inherits(SkipLastObservable, __super__);
    function SkipLastObservable(source, c) {
      this.source = source;
      this._c = c;
      __super__.call(this);
    }

    SkipLastObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipLastObserver(o, this._c));
    };

    return SkipLastObservable;
  }(ObservableBase);

  var SkipLastObserver = function (__super__) {
    inherits(SkipLastObserver, __super__);
    function SkipLastObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    SkipLastObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._o.onNext(this._q.shift());
    };

    SkipLastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    SkipLastObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipLastObserver;
  }(AbstractObserver);

  /**
   *  Bypasses a specified number of elements at the end of an observable sequence.
   * @description
   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are
   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.
   * @param count Number of elements to bypass at the end of the source sequence.
   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.
   */
  observableProto.skipLast = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new SkipLastObservable(this, count);
  };

  /**
   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.
   *  @example
   *  var res = source.startWith(1, 2, 3);
   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);
   * @param {Arguments} args The specified values to prepend to the observable sequence
   * @returns {Observable} The source sequence prepended with the specified values.
   */
  observableProto.startWith = function () {
    var values,
        scheduler,
        start = 0;
    if (!!arguments.length && isScheduler(arguments[0])) {
      scheduler = arguments[0];
      start = 1;
    } else {
      scheduler = immediateScheduler;
    }
    for (var args = [], i = start, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    return observableConcat.apply(null, [observableFromArray(args, scheduler), this]);
  };

  var TakeLastObserver = function (__super__) {
    inherits(TakeLastObserver, __super__);
    function TakeLastObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    TakeLastObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._q.shift();
    };

    TakeLastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TakeLastObserver.prototype.completed = function () {
      while (this._q.length > 0) {
        this._o.onNext(this._q.shift());
      }
      this._o.onCompleted();
    };

    return TakeLastObserver;
  }(AbstractObserver);

  /**
   *  Returns a specified number of contiguous elements from the end of an observable sequence.
   * @description
   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of
   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
   * @param {Number} count Number of elements to take from the end of the source sequence.
   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLast = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      return source.subscribe(new TakeLastObserver(o, count));
    }, source);
  };

  var TakeLastBufferObserver = function (__super__) {
    inherits(TakeLastBufferObserver, __super__);
    function TakeLastBufferObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    TakeLastBufferObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._q.shift();
    };

    TakeLastBufferObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TakeLastBufferObserver.prototype.completed = function () {
      this._o.onNext(this._q);
      this._o.onCompleted();
    };

    return TakeLastBufferObserver;
  }(AbstractObserver);

  /**
   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.
   *
   * @description
   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the
   *  source sequence, this buffer is produced on the result sequence.
   * @param {Number} count Number of elements to take from the end of the source sequence.
   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLastBuffer = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      return source.subscribe(new TakeLastBufferObserver(o, count));
    }, source);
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
   * @param {Number} count Length of each window.
   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithCount = observableProto.windowCount = function (count, skip) {
    var source = this;
    +count || (count = 0);
    Math.abs(count) === Infinity && (count = 0);
    if (count <= 0) {
      throw new ArgumentOutOfRangeError();
    }
    skip == null && (skip = count);
    +skip || (skip = 0);
    Math.abs(skip) === Infinity && (skip = 0);

    if (skip <= 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new AnonymousObservable(function (observer) {
      var m = new SingleAssignmentDisposable(),
          refCountDisposable = new RefCountDisposable(m),
          n = 0,
          q = [];

      function createWindow() {
        var s = new Subject();
        q.push(s);
        observer.onNext(addRef(s, refCountDisposable));
      }

      createWindow();

      m.setDisposable(source.subscribe(function (x) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onNext(x);
        }
        var c = n - count + 1;
        c >= 0 && c % skip === 0 && q.shift().onCompleted();
        ++n % skip === 0 && createWindow();
      }, function (e) {
        while (q.length > 0) {
          q.shift().onError(e);
        }
        observer.onError(e);
      }, function () {
        while (q.length > 0) {
          q.shift().onCompleted();
        }
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  function concatMap(source, selector, thisArg) {
    var selectorFunc = bindCallback(selector, thisArg, 3);
    return source.map(function (x, i) {
      var result = selectorFunc(x, i, source);
      isPromise(result) && (result = observableFromPromise(result));
      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
      return result;
    }).concatAll();
  }

  /**
   *  One of the Following:
   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   *
   * @example
   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });
   *  Or:
   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
   *
   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
   *  Or:
   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
   *
   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));
   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the
   * source sequence onto which could be either an observable or Promise.
   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
   */
  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {
    if (isFunction(selector) && isFunction(resultSelector)) {
      return this.concatMap(function (x, i) {
        var selectorResult = selector(x, i);
        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));

        return selectorResult.map(function (y, i2) {
          return resultSelector(x, y, i, i2);
        });
      });
    }
    return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function () {
      return selector;
    });
  };

  /**
   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.
   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
   */
  observableProto.concatMapObserver = observableProto.selectConcatObserver = function (onNext, onError, onCompleted, thisArg) {
    var source = this,
        onNextFunc = bindCallback(onNext, thisArg, 2),
        onErrorFunc = bindCallback(onError, thisArg, 1),
        onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
    return new AnonymousObservable(function (observer) {
      var index = 0;
      return source.subscribe(function (x) {
        var result;
        try {
          result = onNextFunc(x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
      }, function (err) {
        var result;
        try {
          result = onErrorFunc(err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      }, function () {
        var result;
        try {
          result = onCompletedFunc();
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
    }, this).concatAll();
  };

  var DefaultIfEmptyObserver = function (__super__) {
    inherits(DefaultIfEmptyObserver, __super__);
    function DefaultIfEmptyObserver(o, d) {
      this._o = o;
      this._d = d;
      this._f = false;
      __super__.call(this);
    }

    DefaultIfEmptyObserver.prototype.next = function (x) {
      this._f = true;
      this._o.onNext(x);
    };

    DefaultIfEmptyObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    DefaultIfEmptyObserver.prototype.completed = function () {
      !this._f && this._o.onNext(this._d);
      this._o.onCompleted();
    };

    return DefaultIfEmptyObserver;
  }(AbstractObserver);

  /**
   *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
   *
   *  var res = obs = xs.defaultIfEmpty();
   *  2 - obs = xs.defaultIfEmpty(false);
   *
   * @memberOf Observable#
   * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
   * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
   */
  observableProto.defaultIfEmpty = function (defaultValue) {
    var source = this;
    defaultValue === undefined && (defaultValue = null);
    return new AnonymousObservable(function (o) {
      return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));
    }, source);
  };

  // Swap out for Array.findIndex
  function arrayIndexOfComparer(array, item, comparer) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (comparer(array[i], item)) {
        return i;
      }
    }
    return -1;
  }

  function HashSet(comparer) {
    this.comparer = comparer;
    this.set = [];
  }
  HashSet.prototype.push = function (value) {
    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
    retValue && this.set.push(value);
    return retValue;
  };

  var DistinctObservable = function (__super__) {
    inherits(DistinctObservable, __super__);
    function DistinctObservable(source, keyFn, cmpFn) {
      this.source = source;
      this._keyFn = keyFn;
      this._cmpFn = cmpFn;
      __super__.call(this);
    }

    DistinctObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DistinctObserver(o, this._keyFn, this._cmpFn));
    };

    return DistinctObservable;
  }(ObservableBase);

  var DistinctObserver = function (__super__) {
    inherits(DistinctObserver, __super__);
    function DistinctObserver(o, keyFn, cmpFn) {
      this._o = o;
      this._keyFn = keyFn;
      this._h = new HashSet(cmpFn);
      __super__.call(this);
    }

    DistinctObserver.prototype.next = function (x) {
      var key = x;
      if (isFunction(this._keyFn)) {
        key = tryCatch(this._keyFn)(x);
        if (key === errorObj) {
          return this._o.onError(key.e);
        }
      }
      this._h.push(key) && this._o.onNext(x);
    };

    DistinctObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    DistinctObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return DistinctObserver;
  }(AbstractObserver);

  /**
   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.
   *
   * @example
   *  var res = obs = xs.distinct();
   *  2 - obs = xs.distinct(function (x) { return x.id; });
   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });
   * @param {Function} [keySelector]  A function to compute the comparison key for each element.
   * @param {Function} [comparer]  Used to compare items in the collection.
   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
   */
  observableProto.distinct = function (keySelector, comparer) {
    comparer || (comparer = defaultComparer);
    return new DistinctObservable(this, keySelector, comparer);
  };

  /**
   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
   *
   * @example
   *  var res = observable.groupBy(function (x) { return x.id; });
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   */
  observableProto.groupBy = function (keySelector, elementSelector) {
    return this.groupByUntil(keySelector, elementSelector, observableNever);
  };

  /**
   *  Groups the elements of an observable sequence according to a specified key selector function.
   *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
   *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
   *
   * @example
   *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} durationSelector A function to signal the expiration of a group.
   * @returns {Observable}
   *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
   *
   */
  observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var map = new Map(),
          groupDisposable = new CompositeDisposable(),
          refCountDisposable = new RefCountDisposable(groupDisposable),
          handleError = function handleError(e) {
        return function (item) {
          item.onError(e);
        };
      };

      groupDisposable.add(source.subscribe(function (x) {
        var key = tryCatch(keySelector)(x);
        if (key === errorObj) {
          map.forEach(handleError(key.e));
          return o.onError(key.e);
        }

        var fireNewMapEntry = false,
            writer = map.get(key);
        if (writer === undefined) {
          writer = new Subject();
          map.set(key, writer);
          fireNewMapEntry = true;
        }

        if (fireNewMapEntry) {
          var group = new GroupedObservable(key, writer, refCountDisposable),
              durationGroup = new GroupedObservable(key, writer);
          var duration = tryCatch(durationSelector)(durationGroup);
          if (duration === errorObj) {
            map.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }

          o.onNext(group);

          var md = new SingleAssignmentDisposable();
          groupDisposable.add(md);

          md.setDisposable(duration.take(1).subscribe(noop, function (e) {
            map.forEach(handleError(e));
            o.onError(e);
          }, function () {
            if (map['delete'](key)) {
              writer.onCompleted();
            }
            groupDisposable.remove(md);
          }));
        }

        var element = x;
        if (isFunction(elementSelector)) {
          element = tryCatch(elementSelector)(x);
          if (element === errorObj) {
            map.forEach(handleError(element.e));
            return o.onError(element.e);
          }
        }

        writer.onNext(element);
      }, function (e) {
        map.forEach(handleError(e));
        o.onError(e);
      }, function () {
        map.forEach(function (item) {
          item.onCompleted();
        });
        o.onCompleted();
      }));

      return refCountDisposable;
    }, source);
  };

  var MapObservable = function (__super__) {
    inherits(MapObservable, __super__);

    function MapObservable(source, selector, thisArg) {
      this.source = source;
      this.selector = bindCallback(selector, thisArg, 3);
      __super__.call(this);
    }

    function innerMap(selector, self) {
      return function (x, i, o) {
        return selector.call(this, self.selector(x, i, o), i, o);
      };
    }

    MapObservable.prototype.internalMap = function (selector, thisArg) {
      return new MapObservable(this.source, innerMap(selector, this), thisArg);
    };

    MapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.selector, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, selector, source) {
      this.o = o;
      this.selector = selector;
      this.source = source;
      this.i = 0;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      var result = tryCatch(this.selector)(x, this.i++, this.source);
      if (result === errorObj) {
        return this.o.onError(result.e);
      }
      this.o.onNext(result);
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return MapObservable;
  }(ObservableBase);

  /**
  * Projects each element of an observable sequence into a new form by incorporating the element's index.
  * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.
  */
  observableProto.map = observableProto.select = function (selector, thisArg) {
    var selectorFn = typeof selector === 'function' ? selector : function () {
      return selector;
    };
    return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
  };

  function plucker(args, len) {
    return function mapper(x) {
      var currentProp = x;
      for (var i = 0; i < len; i++) {
        var p = currentProp[args[i]];
        if (typeof p !== 'undefined') {
          currentProp = p;
        } else {
          return undefined;
        }
      }
      return currentProp;
    };
  }

  /**
   * Retrieves the value of a specified nested property from all elements in
   * the Observable sequence.
   * @param {Arguments} arguments The nested properties to pluck.
   * @returns {Observable} Returns a new Observable sequence of property values.
   */
  observableProto.pluck = function () {
    var len = arguments.length,
        args = new Array(len);
    if (len === 0) {
      throw new Error('List of properties cannot be empty.');
    }
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return this.map(plucker(args, len));
  };

  observableProto.flatMap = observableProto.selectMany = observableProto.mergeMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
  };

  /**
   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
   */
  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var index = 0;

      return source.subscribe(function (x) {
        var result;
        try {
          result = onNext.call(thisArg, x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
      }, function (err) {
        var result;
        try {
          result = onError.call(thisArg, err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      }, function () {
        var result;
        try {
          result = onCompleted.call(thisArg);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
    }, source).mergeAll();
  };

  observableProto.flatMapLatest = observableProto.switchMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
  };

  var SkipObservable = function (__super__) {
    inherits(SkipObservable, __super__);
    function SkipObservable(source, count) {
      this.source = source;
      this._count = count;
      __super__.call(this);
    }

    SkipObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipObserver(o, this._count));
    };

    function SkipObserver(o, c) {
      this._o = o;
      this._r = c;
      AbstractObserver.call(this);
    }

    inherits(SkipObserver, AbstractObserver);

    SkipObserver.prototype.next = function (x) {
      if (this._r <= 0) {
        this._o.onNext(x);
      } else {
        this._r--;
      }
    };
    SkipObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipObservable;
  }(ObservableBase);

  /**
   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
   * @param {Number} count The number of elements to skip before returning the remaining elements.
   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.
   */
  observableProto.skip = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new SkipObservable(this, count);
  };

  var SkipWhileObservable = function (__super__) {
    inherits(SkipWhileObservable, __super__);
    function SkipWhileObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SkipWhileObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipWhileObserver(o, this));
    };

    return SkipWhileObservable;
  }(ObservableBase);

  var SkipWhileObserver = function (__super__) {
    inherits(SkipWhileObserver, __super__);

    function SkipWhileObserver(o, p) {
      this._o = o;
      this._p = p;
      this._i = 0;
      this._r = false;
      __super__.call(this);
    }

    SkipWhileObserver.prototype.next = function (x) {
      if (!this._r) {
        var res = tryCatch(this._p._fn)(x, this._i++, this._p);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._r = !res;
      }
      this._r && this._o.onNext(x);
    };
    SkipWhileObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipWhileObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipWhileObserver;
  }(AbstractObserver);

  /**
   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
   *  The element's index is used in the logic of the predicate function.
   *
   *  var res = source.skipWhile(function (value) { return value < 10; });
   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });
   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
   */
  observableProto.skipWhile = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new SkipWhileObservable(this, fn);
  };

  var TakeObservable = function (__super__) {
    inherits(TakeObservable, __super__);
    function TakeObservable(source, count) {
      this.source = source;
      this._count = count;
      __super__.call(this);
    }

    TakeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeObserver(o, this._count));
    };

    function TakeObserver(o, c) {
      this._o = o;
      this._c = c;
      this._r = c;
      AbstractObserver.call(this);
    }

    inherits(TakeObserver, AbstractObserver);

    TakeObserver.prototype.next = function (x) {
      if (this._r-- > 0) {
        this._o.onNext(x);
        this._r <= 0 && this._o.onCompleted();
      }
    };

    TakeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TakeObservable;
  }(ObservableBase);

  /**
   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).
   * @param {Number} count The number of elements to return.
   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name="count count</paramref> is set to 0.
   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.
   */
  observableProto.take = function (count, scheduler) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    if (count === 0) {
      return observableEmpty(scheduler);
    }
    return new TakeObservable(this, count);
  };

  var TakeWhileObservable = function (__super__) {
    inherits(TakeWhileObservable, __super__);
    function TakeWhileObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    TakeWhileObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeWhileObserver(o, this));
    };

    return TakeWhileObservable;
  }(ObservableBase);

  var TakeWhileObserver = function (__super__) {
    inherits(TakeWhileObserver, __super__);

    function TakeWhileObserver(o, p) {
      this._o = o;
      this._p = p;
      this._i = 0;
      this._r = true;
      __super__.call(this);
    }

    TakeWhileObserver.prototype.next = function (x) {
      if (this._r) {
        this._r = tryCatch(this._p._fn)(x, this._i++, this._p);
        if (this._r === errorObj) {
          return this._o.onError(this._r.e);
        }
      }
      if (this._r) {
        this._o.onNext(x);
      } else {
        this._o.onCompleted();
      }
    };
    TakeWhileObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeWhileObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TakeWhileObserver;
  }(AbstractObserver);

  /**
   *  Returns elements from an observable sequence as long as a specified condition is true.
   *  The element's index is used in the logic of the predicate function.
   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   */
  observableProto.takeWhile = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new TakeWhileObservable(this, fn);
  };

  var FilterObservable = function (__super__) {
    inherits(FilterObservable, __super__);

    function FilterObservable(source, predicate, thisArg) {
      this.source = source;
      this.predicate = bindCallback(predicate, thisArg, 3);
      __super__.call(this);
    }

    FilterObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.predicate, this));
    };

    function innerPredicate(predicate, self) {
      return function (x, i, o) {
        return self.predicate(x, i, o) && predicate.call(this, x, i, o);
      };
    }

    FilterObservable.prototype.internalFilter = function (predicate, thisArg) {
      return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, predicate, source) {
      this.o = o;
      this.predicate = predicate;
      this.source = source;
      this.i = 0;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
      if (shouldYield === errorObj) {
        return this.o.onError(shouldYield.e);
      }
      shouldYield && this.o.onNext(x);
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return FilterObservable;
  }(ObservableBase);

  /**
  *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
  * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.
  */
  observableProto.filter = observableProto.where = function (predicate, thisArg) {
    return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
  };

  var ExtremaByObservable = function (__super__) {
    inherits(ExtremaByObservable, __super__);
    function ExtremaByObservable(source, k, c) {
      this.source = source;
      this._k = k;
      this._c = c;
      __super__.call(this);
    }

    ExtremaByObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ExtremaByObserver(o, this._k, this._c));
    };

    return ExtremaByObservable;
  }(ObservableBase);

  var ExtremaByObserver = function (__super__) {
    inherits(ExtremaByObserver, __super__);
    function ExtremaByObserver(o, k, c) {
      this._o = o;
      this._k = k;
      this._c = c;
      this._v = null;
      this._hv = false;
      this._l = [];
      __super__.call(this);
    }

    ExtremaByObserver.prototype.next = function (x) {
      var key = tryCatch(this._k)(x);
      if (key === errorObj) {
        return this._o.onError(key.e);
      }
      var comparison = 0;
      if (!this._hv) {
        this._hv = true;
        this._v = key;
      } else {
        comparison = tryCatch(this._c)(key, this._v);
        if (comparison === errorObj) {
          return this._o.onError(comparison.e);
        }
      }
      if (comparison > 0) {
        this._v = key;
        this._l = [];
      }
      if (comparison >= 0) {
        this._l.push(x);
      }
    };

    ExtremaByObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ExtremaByObserver.prototype.completed = function () {
      this._o.onNext(this._l);
      this._o.onCompleted();
    };

    return ExtremaByObserver;
  }(AbstractObserver);

  function firstOnly(x) {
    if (x.length === 0) {
      throw new EmptyError();
    }
    return x[0];
  }

  var ReduceObservable = function (__super__) {
    inherits(ReduceObservable, __super__);
    function ReduceObservable(source, accumulator, hasSeed, seed) {
      this.source = source;
      this.accumulator = accumulator;
      this.hasSeed = hasSeed;
      this.seed = seed;
      __super__.call(this);
    }

    ReduceObservable.prototype.subscribeCore = function (observer) {
      return this.source.subscribe(new ReduceObserver(observer, this));
    };

    return ReduceObservable;
  }(ObservableBase);

  var ReduceObserver = function (__super__) {
    inherits(ReduceObserver, __super__);
    function ReduceObserver(o, parent) {
      this._o = o;
      this._p = parent;
      this._fn = parent.accumulator;
      this._hs = parent.hasSeed;
      this._s = parent.seed;
      this._ha = false;
      this._a = null;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    ReduceObserver.prototype.next = function (x) {
      !this._hv && (this._hv = true);
      if (this._ha) {
        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);
      } else {
        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;
        this._ha = true;
      }
      if (this._a === errorObj) {
        return this._o.onError(this._a.e);
      }
      this._i++;
    };

    ReduceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ReduceObserver.prototype.completed = function () {
      this._hv && this._o.onNext(this._a);
      !this._hv && this._hs && this._o.onNext(this._s);
      !this._hv && !this._hs && this._o.onError(new EmptyError());
      this._o.onCompleted();
    };

    return ReduceObserver;
  }(AbstractObserver);

  /**
  * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
  * For aggregation behavior with incremental intermediate results, see Observable.scan.
  * @param {Function} accumulator An accumulator function to be invoked on each element.
  * @param {Any} [seed] The initial accumulator value.
  * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
  */
  observableProto.reduce = function () {
    var hasSeed = false,
        seed,
        accumulator = arguments[0];
    if (arguments.length === 2) {
      hasSeed = true;
      seed = arguments[1];
    }
    return new ReduceObservable(this, accumulator, hasSeed, seed);
  };

  var SomeObservable = function (__super__) {
    inherits(SomeObservable, __super__);
    function SomeObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SomeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SomeObserver(o, this._fn, this.source));
    };

    return SomeObservable;
  }(ObservableBase);

  var SomeObserver = function (__super__) {
    inherits(SomeObserver, __super__);

    function SomeObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    SomeObserver.prototype.next = function (x) {
      var result = tryCatch(this._fn)(x, this._i++, this._s);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      if (Boolean(result)) {
        this._o.onNext(true);
        this._o.onCompleted();
      }
    };
    SomeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SomeObserver.prototype.completed = function () {
      this._o.onNext(false);
      this._o.onCompleted();
    };

    return SomeObserver;
  }(AbstractObserver);

  /**
   * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.
   * @param {Function} [predicate] A function to test each element for a condition.
   * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.
   */
  observableProto.some = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new SomeObservable(this, fn);
  };

  var IsEmptyObservable = function (__super__) {
    inherits(IsEmptyObservable, __super__);
    function IsEmptyObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    IsEmptyObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new IsEmptyObserver(o));
    };

    return IsEmptyObservable;
  }(ObservableBase);

  var IsEmptyObserver = function (__super__) {
    inherits(IsEmptyObserver, __super__);
    function IsEmptyObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    IsEmptyObserver.prototype.next = function () {
      this._o.onNext(false);
      this._o.onCompleted();
    };
    IsEmptyObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IsEmptyObserver.prototype.completed = function () {
      this._o.onNext(true);
      this._o.onCompleted();
    };

    return IsEmptyObserver;
  }(AbstractObserver);

  /**
   * Determines whether an observable sequence is empty.
   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.
   */
  observableProto.isEmpty = function () {
    return new IsEmptyObservable(this);
  };

  var EveryObservable = function (__super__) {
    inherits(EveryObservable, __super__);
    function EveryObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    EveryObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new EveryObserver(o, this._fn, this.source));
    };

    return EveryObservable;
  }(ObservableBase);

  var EveryObserver = function (__super__) {
    inherits(EveryObserver, __super__);

    function EveryObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    EveryObserver.prototype.next = function (x) {
      var result = tryCatch(this._fn)(x, this._i++, this._s);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      if (!Boolean(result)) {
        this._o.onNext(false);
        this._o.onCompleted();
      }
    };
    EveryObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    EveryObserver.prototype.completed = function () {
      this._o.onNext(true);
      this._o.onCompleted();
    };

    return EveryObserver;
  }(AbstractObserver);

  /**
   * Determines whether all elements of an observable sequence satisfy a condition.
   * @param {Function} [predicate] A function to test each element for a condition.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.
   */
  observableProto.every = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new EveryObservable(this, fn);
  };

  var IncludesObservable = function (__super__) {
    inherits(IncludesObservable, __super__);
    function IncludesObservable(source, elem, idx) {
      var n = +idx || 0;
      Math.abs(n) === Infinity && (n = 0);

      this.source = source;
      this._elem = elem;
      this._n = n;
      __super__.call(this);
    }

    IncludesObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(false);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new IncludesObserver(o, this._elem, this._n));
    };

    return IncludesObservable;
  }(ObservableBase);

  var IncludesObserver = function (__super__) {
    inherits(IncludesObserver, __super__);
    function IncludesObserver(o, elem, n) {
      this._o = o;
      this._elem = elem;
      this._n = n;
      this._i = 0;
      __super__.call(this);
    }

    function comparer(a, b) {
      return a === 0 && b === 0 || a === b || isNaN(a) && isNaN(b);
    }

    IncludesObserver.prototype.next = function (x) {
      if (this._i++ >= this._n && comparer(x, this._elem)) {
        this._o.onNext(true);
        this._o.onCompleted();
      }
    };
    IncludesObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IncludesObserver.prototype.completed = function () {
      this._o.onNext(false);this._o.onCompleted();
    };

    return IncludesObserver;
  }(AbstractObserver);

  /**
   * Determines whether an observable sequence includes a specified element with an optional equality comparer.
   * @param searchElement The value to locate in the source sequence.
   * @param {Number} [fromIndex] An equality comparer to compare elements.
   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence includes an element that has the specified value from the given index.
   */
  observableProto.includes = function (searchElement, fromIndex) {
    return new IncludesObservable(this, searchElement, fromIndex);
  };

  var CountObservable = function (__super__) {
    inherits(CountObservable, __super__);
    function CountObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    CountObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new CountObserver(o, this._fn, this.source));
    };

    return CountObservable;
  }(ObservableBase);

  var CountObserver = function (__super__) {
    inherits(CountObserver, __super__);

    function CountObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      this._c = 0;
      __super__.call(this);
    }

    CountObserver.prototype.next = function (x) {
      if (this._fn) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        Boolean(result) && this._c++;
      } else {
        this._c++;
      }
    };
    CountObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    CountObserver.prototype.completed = function () {
      this._o.onNext(this._c);
      this._o.onCompleted();
    };

    return CountObserver;
  }(AbstractObserver);

  /**
   * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.
   * @example
   * res = source.count();
   * res = source.count(function (x) { return x > 3; });
   * @param {Function} [predicate]A function to test each element for a condition.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.
   */
  observableProto.count = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new CountObservable(this, fn);
  };

  var IndexOfObservable = function (__super__) {
    inherits(IndexOfObservable, __super__);
    function IndexOfObservable(source, e, n) {
      this.source = source;
      this._e = e;
      this._n = n;
      __super__.call(this);
    }

    IndexOfObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(-1);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new IndexOfObserver(o, this._e, this._n));
    };

    return IndexOfObservable;
  }(ObservableBase);

  var IndexOfObserver = function (__super__) {
    inherits(IndexOfObserver, __super__);
    function IndexOfObserver(o, e, n) {
      this._o = o;
      this._e = e;
      this._n = n;
      this._i = 0;
      __super__.call(this);
    }

    IndexOfObserver.prototype.next = function (x) {
      if (this._i >= this._n && x === this._e) {
        this._o.onNext(this._i);
        this._o.onCompleted();
      }
      this._i++;
    };
    IndexOfObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IndexOfObserver.prototype.completed = function () {
      this._o.onNext(-1);this._o.onCompleted();
    };

    return IndexOfObserver;
  }(AbstractObserver);

  /**
   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
   * @param {Any} searchElement Element to locate in the array.
   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
   */
  observableProto.indexOf = function (searchElement, fromIndex) {
    var n = +fromIndex || 0;
    Math.abs(n) === Infinity && (n = 0);
    return new IndexOfObservable(this, searchElement, n);
  };

  var SumObservable = function (__super__) {
    inherits(SumObservable, __super__);
    function SumObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SumObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SumObserver(o, this._fn, this.source));
    };

    return SumObservable;
  }(ObservableBase);

  var SumObserver = function (__super__) {
    inherits(SumObserver, __super__);

    function SumObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      this._c = 0;
      __super__.call(this);
    }

    SumObserver.prototype.next = function (x) {
      if (this._fn) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        this._c += result;
      } else {
        this._c += x;
      }
    };
    SumObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SumObserver.prototype.completed = function () {
      this._o.onNext(this._c);
      this._o.onCompleted();
    };

    return SumObserver;
  }(AbstractObserver);

  /**
   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.
   * @param {Function} [selector] A transform function to apply to each element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.
   */
  observableProto.sum = function (keySelector, thisArg) {
    var fn = bindCallback(keySelector, thisArg, 3);
    return new SumObservable(this, fn);
  };

  /**
   * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
   * @example
   * var res = source.minBy(function (x) { return x.value; });
   * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });
   * @param {Function} keySelector Key selector function.
   * @param {Function} [comparer] Comparer used to compare key values.
   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.
   */
  observableProto.minBy = function (keySelector, comparer) {
    comparer || (comparer = defaultSubComparer);
    return new ExtremaByObservable(this, keySelector, function (x, y) {
      return comparer(x, y) * -1;
    });
  };

  /**
   * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.
   * @example
   * var res = source.min();
   * var res = source.min(function (x, y) { return x.value - y.value; });
   * @param {Function} [comparer] Comparer used to compare elements.
   * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.
   */
  observableProto.min = function (comparer) {
    return this.minBy(identity, comparer).map(firstOnly);
  };

  /**
   * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.
   * @example
   * var res = source.maxBy(function (x) { return x.value; });
   * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });
   * @param {Function} keySelector Key selector function.
   * @param {Function} [comparer]  Comparer used to compare key values.
   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.
   */
  observableProto.maxBy = function (keySelector, comparer) {
    comparer || (comparer = defaultSubComparer);
    return new ExtremaByObservable(this, keySelector, comparer);
  };

  /**
   * Returns the maximum value in an observable sequence according to the specified comparer.
   * @example
   * var res = source.max();
   * var res = source.max(function (x, y) { return x.value - y.value; });
   * @param {Function} [comparer] Comparer used to compare elements.
   * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.
   */
  observableProto.max = function (comparer) {
    return this.maxBy(identity, comparer).map(firstOnly);
  };

  var AverageObservable = function (__super__) {
    inherits(AverageObservable, __super__);
    function AverageObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    AverageObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new AverageObserver(o, this._fn, this.source));
    };

    return AverageObservable;
  }(ObservableBase);

  var AverageObserver = function (__super__) {
    inherits(AverageObserver, __super__);
    function AverageObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._c = 0;
      this._t = 0;
      __super__.call(this);
    }

    AverageObserver.prototype.next = function (x) {
      if (this._fn) {
        var r = tryCatch(this._fn)(x, this._c++, this._s);
        if (r === errorObj) {
          return this._o.onError(r.e);
        }
        this._t += r;
      } else {
        this._c++;
        this._t += x;
      }
    };
    AverageObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    AverageObserver.prototype.completed = function () {
      if (this._c === 0) {
        return this._o.onError(new EmptyError());
      }
      this._o.onNext(this._t / this._c);
      this._o.onCompleted();
    };

    return AverageObserver;
  }(AbstractObserver);

  /**
   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.
   * @param {Function} [selector] A transform function to apply to each element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.
   */
  observableProto.average = function (keySelector, thisArg) {
    var source = this,
        fn;
    if (isFunction(keySelector)) {
      fn = bindCallback(keySelector, thisArg, 3);
    }
    return new AverageObservable(source, fn);
  };

  /**
   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
   *
   * @example
   * var res = res = source.sequenceEqual([1,2,3]);
   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });
   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));
   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });
   * @param {Observable} second Second observable sequence or array to compare.
   * @param {Function} [comparer] Comparer used to compare elements of both sequences.
   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
   */
  observableProto.sequenceEqual = function (second, comparer) {
    var first = this;
    comparer || (comparer = defaultComparer);
    return new AnonymousObservable(function (o) {
      var donel = false,
          doner = false,
          ql = [],
          qr = [];
      var subscription1 = first.subscribe(function (x) {
        if (qr.length > 0) {
          var v = qr.shift();
          var equal = tryCatch(comparer)(v, x);
          if (equal === errorObj) {
            return o.onError(equal.e);
          }
          if (!equal) {
            o.onNext(false);
            o.onCompleted();
          }
        } else if (doner) {
          o.onNext(false);
          o.onCompleted();
        } else {
          ql.push(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        donel = true;
        if (ql.length === 0) {
          if (qr.length > 0) {
            o.onNext(false);
            o.onCompleted();
          } else if (doner) {
            o.onNext(true);
            o.onCompleted();
          }
        }
      });

      (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
      isPromise(second) && (second = observableFromPromise(second));
      var subscription2 = second.subscribe(function (x) {
        if (ql.length > 0) {
          var v = ql.shift();
          var equal = tryCatch(comparer)(v, x);
          if (equal === errorObj) {
            return o.onError(equal.e);
          }
          if (!equal) {
            o.onNext(false);
            o.onCompleted();
          }
        } else if (donel) {
          o.onNext(false);
          o.onCompleted();
        } else {
          qr.push(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        doner = true;
        if (qr.length === 0) {
          if (ql.length > 0) {
            o.onNext(false);
            o.onCompleted();
          } else if (donel) {
            o.onNext(true);
            o.onCompleted();
          }
        }
      });
      return new BinaryDisposable(subscription1, subscription2);
    }, first);
  };

  var ElementAtObservable = function (__super__) {
    inherits(ElementAtObservable, __super__);
    function ElementAtObservable(source, i, d) {
      this.source = source;
      this._i = i;
      this._d = d;
      __super__.call(this);
    }

    ElementAtObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ElementAtObserver(o, this._i, this._d));
    };

    return ElementAtObservable;
  }(ObservableBase);

  var ElementAtObserver = function (__super__) {
    inherits(ElementAtObserver, __super__);

    function ElementAtObserver(o, i, d) {
      this._o = o;
      this._i = i;
      this._d = d;
      __super__.call(this);
    }

    ElementAtObserver.prototype.next = function (x) {
      if (this._i-- === 0) {
        this._o.onNext(x);
        this._o.onCompleted();
      }
    };
    ElementAtObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    ElementAtObserver.prototype.completed = function () {
      if (this._d === undefined) {
        this._o.onError(new ArgumentOutOfRangeError());
      } else {
        this._o.onNext(this._d);
        this._o.onCompleted();
      }
    };

    return ElementAtObserver;
  }(AbstractObserver);

  /**
   * Returns the element at a specified index in a sequence or default value if not found.
   * @param {Number} index The zero-based index of the element to retrieve.
   * @param {Any} [defaultValue] The default value to use if elementAt does not find a value.
   * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.
   */
  observableProto.elementAt = function (index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new ElementAtObservable(this, index, defaultValue);
  };

  var SingleObserver = function (__super__) {
    inherits(SingleObserver, __super__);
    function SingleObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      this._hv = false;
      this._v = null;
      __super__.call(this);
    }

    SingleObserver.prototype.next = function (x) {
      var shouldYield = false;
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        Boolean(res) && (shouldYield = true);
      } else if (!this._obj.predicate) {
        shouldYield = true;
      }
      if (shouldYield) {
        if (this._hv) {
          return this._o.onError(new Error('Sequence contains more than one matching element'));
        }
        this._hv = true;
        this._v = x;
      }
    };
    SingleObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SingleObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
        this._o.onCompleted();
      } else if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return SingleObserver;
  }(AbstractObserver);

  /**
   * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.
   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.
   */
  observableProto.single = function (predicate, thisArg) {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new AnonymousObservable(function (o) {
      return source.subscribe(new SingleObserver(o, obj, source));
    }, source);
  };

  var FirstObservable = function (__super__) {
    inherits(FirstObservable, __super__);
    function FirstObservable(source, obj) {
      this.source = source;
      this._obj = obj;
      __super__.call(this);
    }

    FirstObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new FirstObserver(o, this._obj, this.source));
    };

    return FirstObservable;
  }(ObservableBase);

  var FirstObserver = function (__super__) {
    inherits(FirstObserver, __super__);
    function FirstObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    FirstObserver.prototype.next = function (x) {
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        if (Boolean(res)) {
          this._o.onNext(x);
          this._o.onCompleted();
        }
      } else if (!this._obj.predicate) {
        this._o.onNext(x);
        this._o.onCompleted();
      }
    };
    FirstObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    FirstObserver.prototype.completed = function () {
      if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return FirstObserver;
  }(AbstractObserver);

  /**
   * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.
   * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.
   */
  observableProto.first = function () {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new FirstObservable(this, obj);
  };

  var LastObservable = function (__super__) {
    inherits(LastObservable, __super__);
    function LastObservable(source, obj) {
      this.source = source;
      this._obj = obj;
      __super__.call(this);
    }

    LastObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new LastObserver(o, this._obj, this.source));
    };

    return LastObservable;
  }(ObservableBase);

  var LastObserver = function (__super__) {
    inherits(LastObserver, __super__);
    function LastObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      this._hv = false;
      this._v = null;
      __super__.call(this);
    }

    LastObserver.prototype.next = function (x) {
      var shouldYield = false;
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        Boolean(res) && (shouldYield = true);
      } else if (!this._obj.predicate) {
        shouldYield = true;
      }
      if (shouldYield) {
        this._hv = true;
        this._v = x;
      }
    };
    LastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    LastObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
        this._o.onCompleted();
      } else if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return LastObserver;
  }(AbstractObserver);

  /**
   * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.
   * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.
   */
  observableProto.last = function () {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new LastObservable(this, obj);
  };

  var FindValueObserver = function (__super__) {
    inherits(FindValueObserver, __super__);
    function FindValueObserver(observer, source, callback, yieldIndex) {
      this._o = observer;
      this._s = source;
      this._cb = callback;
      this._y = yieldIndex;
      this._i = 0;
      __super__.call(this);
    }

    FindValueObserver.prototype.next = function (x) {
      var shouldRun = tryCatch(this._cb)(x, this._i, this._s);
      if (shouldRun === errorObj) {
        return this._o.onError(shouldRun.e);
      }
      if (shouldRun) {
        this._o.onNext(this._y ? this._i : x);
        this._o.onCompleted();
      } else {
        this._i++;
      }
    };

    FindValueObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    FindValueObserver.prototype.completed = function () {
      this._y && this._o.onNext(-1);
      this._o.onCompleted();
    };

    return FindValueObserver;
  }(AbstractObserver);

  function findValue(source, predicate, thisArg, yieldIndex) {
    var callback = bindCallback(predicate, thisArg, 3);
    return new AnonymousObservable(function (o) {
      return source.subscribe(new FindValueObserver(o, source, callback, yieldIndex));
    }, source);
  }

  /**
   * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.
   * @param {Function} predicate The predicate that defines the conditions of the element to search for.
   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
   * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.
   */
  observableProto.find = function (predicate, thisArg) {
    return findValue(this, predicate, thisArg, false);
  };

  /**
   * Searches for an element that matches the conditions defined by the specified predicate, and returns
   * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.
   * @param {Function} predicate The predicate that defines the conditions of the element to search for.
   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
   * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.
  */
  observableProto.findIndex = function (predicate, thisArg) {
    return findValue(this, predicate, thisArg, true);
  };

  var ToSetObservable = function (__super__) {
    inherits(ToSetObservable, __super__);
    function ToSetObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    ToSetObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ToSetObserver(o));
    };

    return ToSetObservable;
  }(ObservableBase);

  var ToSetObserver = function (__super__) {
    inherits(ToSetObserver, __super__);
    function ToSetObserver(o) {
      this._o = o;
      this._s = new root.Set();
      __super__.call(this);
    }

    ToSetObserver.prototype.next = function (x) {
      this._s.add(x);
    };

    ToSetObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ToSetObserver.prototype.completed = function () {
      this._o.onNext(this._s);
      this._o.onCompleted();
    };

    return ToSetObserver;
  }(AbstractObserver);

  /**
   * Converts the observable sequence to a Set if it exists.
   * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.
   */
  observableProto.toSet = function () {
    if (typeof root.Set === 'undefined') {
      throw new TypeError();
    }
    return new ToSetObservable(this);
  };

  var ToMapObservable = function (__super__) {
    inherits(ToMapObservable, __super__);
    function ToMapObservable(source, k, e) {
      this.source = source;
      this._k = k;
      this._e = e;
      __super__.call(this);
    }

    ToMapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ToMapObserver(o, this._k, this._e));
    };

    return ToMapObservable;
  }(ObservableBase);

  var ToMapObserver = function (__super__) {
    inherits(ToMapObserver, __super__);
    function ToMapObserver(o, k, e) {
      this._o = o;
      this._k = k;
      this._e = e;
      this._m = new root.Map();
      __super__.call(this);
    }

    ToMapObserver.prototype.next = function (x) {
      var key = tryCatch(this._k)(x);
      if (key === errorObj) {
        return this._o.onError(key.e);
      }
      var elem = x;
      if (this._e) {
        elem = tryCatch(this._e)(x);
        if (elem === errorObj) {
          return this._o.onError(elem.e);
        }
      }

      this._m.set(key, elem);
    };

    ToMapObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ToMapObserver.prototype.completed = function () {
      this._o.onNext(this._m);
      this._o.onCompleted();
    };

    return ToMapObserver;
  }(AbstractObserver);

  /**
  * Converts the observable sequence to a Map if it exists.
  * @param {Function} keySelector A function which produces the key for the Map.
  * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.
  * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.
  */
  observableProto.toMap = function (keySelector, elementSelector) {
    if (typeof root.Map === 'undefined') {
      throw new TypeError();
    }
    return new ToMapObservable(this, keySelector, elementSelector);
  };

  var SliceObservable = function (__super__) {
    inherits(SliceObservable, __super__);
    function SliceObservable(source, b, e) {
      this.source = source;
      this._b = b;
      this._e = e;
      __super__.call(this);
    }

    SliceObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SliceObserver(o, this._b, this._e));
    };

    return SliceObservable;
  }(ObservableBase);

  var SliceObserver = function (__super__) {
    inherits(SliceObserver, __super__);

    function SliceObserver(o, b, e) {
      this._o = o;
      this._b = b;
      this._e = e;
      this._i = 0;
      __super__.call(this);
    }

    SliceObserver.prototype.next = function (x) {
      if (this._i >= this._b) {
        if (this._e === this._i) {
          this._o.onCompleted();
        } else {
          this._o.onNext(x);
        }
      }
      this._i++;
    };
    SliceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SliceObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SliceObserver;
  }(AbstractObserver);

  /*
  * The slice() method returns a shallow copy of a portion of an Observable into a new Observable object.
  * Unlike the array version, this does not support negative numbers for being or end.
  * @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.
  * @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.
  * If omitted, this will emit the rest of the Observable object.
  * @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.
  */
  observableProto.slice = function (begin, end) {
    var start = begin || 0;
    if (start < 0) {
      throw new Rx.ArgumentOutOfRangeError();
    }
    if (typeof end === 'number' && end < start) {
      throw new Rx.ArgumentOutOfRangeError();
    }
    return new SliceObservable(this, start, end);
  };

  var LastIndexOfObservable = function (__super__) {
    inherits(LastIndexOfObservable, __super__);
    function LastIndexOfObservable(source, e, n) {
      this.source = source;
      this._e = e;
      this._n = n;
      __super__.call(this);
    }

    LastIndexOfObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(-1);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new LastIndexOfObserver(o, this._e, this._n));
    };

    return LastIndexOfObservable;
  }(ObservableBase);

  var LastIndexOfObserver = function (__super__) {
    inherits(LastIndexOfObserver, __super__);
    function LastIndexOfObserver(o, e, n) {
      this._o = o;
      this._e = e;
      this._n = n;
      this._v = 0;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    LastIndexOfObserver.prototype.next = function (x) {
      if (this._i >= this._n && x === this._e) {
        this._hv = true;
        this._v = this._i;
      }
      this._i++;
    };
    LastIndexOfObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    LastIndexOfObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
      } else {
        this._o.onNext(-1);
      }
      this._o.onCompleted();
    };

    return LastIndexOfObserver;
  }(AbstractObserver);

  /**
   * Returns the last index at which a given element can be found in the observable sequence, or -1 if it is not present.
   * @param {Any} searchElement Element to locate in the array.
   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
   * @returns {Observable} And observable sequence containing the last index at which a given element can be found in the observable sequence, or -1 if it is not present.
   */
  observableProto.lastIndexOf = function (searchElement, fromIndex) {
    var n = +fromIndex || 0;
    Math.abs(n) === Infinity && (n = 0);
    return new LastIndexOfObservable(this, searchElement, n);
  };

  Observable.wrap = function (fn) {
    function createObservable() {
      return Observable.spawn.call(this, fn.apply(this, arguments));
    }

    createObservable.__generatorFunction__ = fn;
    return createObservable;
  };

  var spawn = Observable.spawn = function () {
    var gen = arguments[0],
        self = this,
        args = [];
    for (var i = 1, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }

    return new AnonymousObservable(function (o) {
      var g = new CompositeDisposable();

      if (isFunction(gen)) {
        gen = gen.apply(self, args);
      }
      if (!gen || !isFunction(gen.next)) {
        o.onNext(gen);
        return o.onCompleted();
      }

      function processGenerator(res) {
        var ret = tryCatch(gen.next).call(gen, res);
        if (ret === errorObj) {
          return o.onError(ret.e);
        }
        next(ret);
      }

      processGenerator();

      function onError(err) {
        var ret = tryCatch(gen.next).call(gen, err);
        if (ret === errorObj) {
          return o.onError(ret.e);
        }
        next(ret);
      }

      function next(ret) {
        if (ret.done) {
          o.onNext(ret.value);
          o.onCompleted();
          return;
        }
        var obs = toObservable.call(self, ret.value);
        var value = null;
        var hasValue = false;
        if (Observable.isObservable(obs)) {
          g.add(obs.subscribe(function (val) {
            hasValue = true;
            value = val;
          }, onError, function () {
            hasValue && processGenerator(value);
          }));
        } else {
          onError(new TypeError('type not supported'));
        }
      }

      return g;
    });
  };

  function toObservable(obj) {
    if (!obj) {
      return obj;
    }
    if (Observable.isObservable(obj)) {
      return obj;
    }
    if (isPromise(obj)) {
      return Observable.fromPromise(obj);
    }
    if (isGeneratorFunction(obj) || isGenerator(obj)) {
      return spawn.call(this, obj);
    }
    if (isFunction(obj)) {
      return thunkToObservable.call(this, obj);
    }
    if (isArrayLike(obj) || isIterable(obj)) {
      return arrayToObservable.call(this, obj);
    }
    if (isObject(obj)) {
      return objectToObservable.call(this, obj);
    }
    return obj;
  }

  function arrayToObservable(obj) {
    return Observable.from(obj).concatMap(function (o) {
      if (Observable.isObservable(o) || isObject(o)) {
        return toObservable.call(null, o);
      } else {
        return Rx.Observable.just(o);
      }
    }).toArray();
  }

  function objectToObservable(obj) {
    var results = new obj.constructor(),
        keys = Object.keys(obj),
        observables = [];
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      var observable = toObservable.call(this, obj[key]);

      if (observable && Observable.isObservable(observable)) {
        defer(observable, key);
      } else {
        results[key] = obj[key];
      }
    }

    return Observable.forkJoin.apply(Observable, observables).map(function () {
      return results;
    });

    function defer(observable, key) {
      results[key] = undefined;
      observables.push(observable.map(function (next) {
        results[key] = next;
      }));
    }
  }

  function thunkToObservable(fn) {
    var self = this;
    return new AnonymousObservable(function (o) {
      fn.call(self, function () {
        var err = arguments[0],
            res = arguments[1];
        if (err) {
          return o.onError(err);
        }
        if (arguments.length > 2) {
          var args = [];
          for (var i = 1, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
          }
          res = args;
        }
        o.onNext(res);
        o.onCompleted();
      });
    });
  }

  function isGenerator(obj) {
    return isFunction(obj.next) && isFunction(obj['throw']);
  }

  function isGeneratorFunction(obj) {
    var ctor = obj.constructor;
    if (!ctor) {
      return false;
    }
    if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') {
      return true;
    }
    return isGenerator(ctor.prototype);
  }

  function isObject(val) {
    return Object == val.constructor;
  }

  /**
   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.
   *
   * @example
   * var res = Rx.Observable.start(function () { console.log('hello'); });
   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
   *
   * @param {Function} func Function to run asynchronously.
   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
   *
   * Remarks
   * * The function is called immediately, not during the subscription of the resulting sequence.
   * * Multiple subscriptions to the resulting sequence can observe the function's result.
   */
  Observable.start = function (func, context, scheduler) {
    return observableToAsync(func, context, scheduler)();
  };

  /**
   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.
   * @param {Function} function Function to convert to an asynchronous function.
   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns {Function} Asynchronous function.
   */
  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return function () {
      var args = arguments,
          subject = new AsyncSubject();

      scheduler.schedule(null, function () {
        var result;
        try {
          result = func.apply(context, args);
        } catch (e) {
          subject.onError(e);
          return;
        }
        subject.onNext(result);
        subject.onCompleted();
      });
      return subject.asObservable();
    };
  };

  function createCbObservable(fn, ctx, selector, args) {
    var o = new AsyncSubject();

    args.push(createCbHandler(o, ctx, selector));
    fn.apply(ctx, args);

    return o.asObservable();
  }

  function createCbHandler(o, ctx, selector) {
    return function handler() {
      var len = arguments.length,
          results = new Array(len);
      for (var i = 0; i < len; i++) {
        results[i] = arguments[i];
      }

      if (isFunction(selector)) {
        results = tryCatch(selector).apply(ctx, results);
        if (results === errorObj) {
          return o.onError(results.e);
        }
        o.onNext(results);
      } else {
        if (results.length <= 1) {
          o.onNext(results[0]);
        } else {
          o.onNext(results);
        }
      }

      o.onCompleted();
    };
  }

  /**
   * Converts a callback function to an observable sequence.
   *
   * @param {Function} fn Function with a callback as the last parameter to convert to an Observable sequence.
   * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.
   * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.
   */
  Observable.fromCallback = function (fn, ctx, selector) {
    return function () {
      typeof ctx === 'undefined' && (ctx = this);

      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return createCbObservable(fn, ctx, selector, args);
    };
  };

  function createNodeObservable(fn, ctx, selector, args) {
    var o = new AsyncSubject();

    args.push(createNodeHandler(o, ctx, selector));
    fn.apply(ctx, args);

    return o.asObservable();
  }

  function createNodeHandler(o, ctx, selector) {
    return function handler() {
      var err = arguments[0];
      if (err) {
        return o.onError(err);
      }

      var len = arguments.length,
          results = [];
      for (var i = 1; i < len; i++) {
        results[i - 1] = arguments[i];
      }

      if (isFunction(selector)) {
        var results = tryCatch(selector).apply(ctx, results);
        if (results === errorObj) {
          return o.onError(results.e);
        }
        o.onNext(results);
      } else {
        if (results.length <= 1) {
          o.onNext(results[0]);
        } else {
          o.onNext(results);
        }
      }

      o.onCompleted();
    };
  }

  /**
   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
   * @param {Function} fn The function to call
   * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.
   * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.
   */
  Observable.fromNodeCallback = function (fn, ctx, selector) {
    return function () {
      typeof ctx === 'undefined' && (ctx = this);
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return createNodeObservable(fn, ctx, selector, args);
    };
  };

  function isNodeList(el) {
    if (root.StaticNodeList) {
      // IE8 Specific
      // instanceof is slower than Object#toString, but Object#toString will not work as intended in IE8
      return el instanceof root.StaticNodeList || el instanceof root.NodeList;
    } else {
      return Object.prototype.toString.call(el) === '[object NodeList]';
    }
  }

  function ListenDisposable(e, n, fn) {
    this._e = e;
    this._n = n;
    this._fn = fn;
    this._e.addEventListener(this._n, this._fn, false);
    this.isDisposed = false;
  }
  ListenDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this._e.removeEventListener(this._n, this._fn, false);
      this.isDisposed = true;
    }
  };

  function createEventListener(el, eventName, handler) {
    var disposables = new CompositeDisposable();

    // Asume NodeList or HTMLCollection
    var elemToString = Object.prototype.toString.call(el);
    if (isNodeList(el) || elemToString === '[object HTMLCollection]') {
      for (var i = 0, len = el.length; i < len; i++) {
        disposables.add(createEventListener(el.item(i), eventName, handler));
      }
    } else if (el) {
      disposables.add(new ListenDisposable(el, eventName, handler));
    }

    return disposables;
  }

  /**
   * Configuration option to determine whether to use native events only
   */
  Rx.config.useNativeEvents = false;

  var EventObservable = function (__super__) {
    inherits(EventObservable, __super__);
    function EventObservable(el, name, fn) {
      this._el = el;
      this._n = name;
      this._fn = fn;
      __super__.call(this);
    }

    function createHandler(o, fn) {
      return function handler() {
        var results = arguments[0];
        if (isFunction(fn)) {
          results = tryCatch(fn).apply(null, arguments);
          if (results === errorObj) {
            return o.onError(results.e);
          }
        }
        o.onNext(results);
      };
    }

    EventObservable.prototype.subscribeCore = function (o) {
      return createEventListener(this._el, this._n, createHandler(o, this._fn));
    };

    return EventObservable;
  }(ObservableBase);

  /**
   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
   * @param {Object} element The DOMElement or NodeList to attach a listener.
   * @param {String} eventName The event name to attach the observable sequence.
   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns {Observable} An observable sequence of events from the specified element and the specified event.
   */
  Observable.fromEvent = function (element, eventName, selector) {
    // Node.js specific
    if (element.addListener) {
      return fromEventPattern(function (h) {
        element.addListener(eventName, h);
      }, function (h) {
        element.removeListener(eventName, h);
      }, selector);
    }

    // Use only if non-native events are allowed
    if (!Rx.config.useNativeEvents) {
      // Handles jq, Angular.js, Zepto, Marionette, Ember.js
      if (typeof element.on === 'function' && typeof element.off === 'function') {
        return fromEventPattern(function (h) {
          element.on(eventName, h);
        }, function (h) {
          element.off(eventName, h);
        }, selector);
      }
    }

    return new EventObservable(element, eventName, selector).publish().refCount();
  };

  var EventPatternObservable = function (__super__) {
    inherits(EventPatternObservable, __super__);
    function EventPatternObservable(add, del, fn) {
      this._add = add;
      this._del = del;
      this._fn = fn;
      __super__.call(this);
    }

    function createHandler(o, fn) {
      return function handler() {
        var results = arguments[0];
        if (isFunction(fn)) {
          results = tryCatch(fn).apply(null, arguments);
          if (results === errorObj) {
            return o.onError(results.e);
          }
        }
        o.onNext(results);
      };
    }

    EventPatternObservable.prototype.subscribeCore = function (o) {
      var fn = createHandler(o, this._fn);
      var returnValue = this._add(fn);
      return new EventPatternDisposable(this._del, fn, returnValue);
    };

    function EventPatternDisposable(del, fn, ret) {
      this._del = del;
      this._fn = fn;
      this._ret = ret;
      this.isDisposed = false;
    }

    EventPatternDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        isFunction(this._del) && this._del(this._fn, this._ret);
        this.isDisposed = true;
      }
    };

    return EventPatternObservable;
  }(ObservableBase);

  /**
   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.
   * @param {Function} addHandler The function to add a handler to the emitter.
   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.
   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns {Observable} An observable sequence which wraps an event from an event emitter
   */
  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {
    return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();
  };

  /**
   * Invokes the asynchronous function, surfacing the result through an observable sequence.
   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.
   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
   */
  Observable.startAsync = function (functionAsync) {
    var promise = tryCatch(functionAsync)();
    if (promise === errorObj) {
      return observableThrow(promise.e);
    }
    return observableFromPromise(promise);
  };

  var PausableObservable = function (__super__) {
    inherits(PausableObservable, __super__);
    function PausableObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      this.paused = true;

      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }

      __super__.call(this);
    }

    PausableObservable.prototype._subscribe = function (o) {
      var conn = this.source.publish(),
          subscription = conn.subscribe(o),
          connection = disposableEmpty;

      var pausable = this.pauser.startWith(!this.paused).distinctUntilChanged().subscribe(function (b) {
        if (b) {
          connection = conn.connect();
        } else {
          connection.dispose();
          connection = disposableEmpty;
        }
      });

      return new NAryDisposable([subscription, connection, pausable]);
    };

    PausableObservable.prototype.pause = function () {
      this.paused = true;
      this.controller.onNext(false);
    };

    PausableObservable.prototype.resume = function () {
      this.paused = false;
      this.controller.onNext(true);
    };

    return PausableObservable;
  }(Observable);

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausable(pauser);
   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
   * @returns {Observable} The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausable = function (pauser) {
    return new PausableObservable(this, pauser);
  };

  function combineLatestSource(source, subject, resultSelector) {
    return new AnonymousObservable(function (o) {
      var hasValue = [false, false],
          hasValueAll = false,
          isDone = false,
          values = new Array(2),
          err;

      function next(x, i) {
        values[i] = x;
        hasValue[i] = true;
        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
          if (err) {
            return o.onError(err);
          }
          var res = tryCatch(resultSelector).apply(null, values);
          if (res === errorObj) {
            return o.onError(res.e);
          }
          o.onNext(res);
        }
        isDone && values[1] && o.onCompleted();
      }

      return new BinaryDisposable(source.subscribe(function (x) {
        next(x, 0);
      }, function (e) {
        if (values[1]) {
          o.onError(e);
        } else {
          err = e;
        }
      }, function () {
        isDone = true;
        values[1] && o.onCompleted();
      }), subject.subscribe(function (x) {
        next(x, 1);
      }, function (e) {
        o.onError(e);
      }, function () {
        isDone = true;
        next(true, 1);
      }));
    }, source);
  }

  var PausableBufferedObservable = function (__super__) {
    inherits(PausableBufferedObservable, __super__);
    function PausableBufferedObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      this.paused = true;

      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }

      __super__.call(this);
    }

    PausableBufferedObservable.prototype._subscribe = function (o) {
      var q = [],
          previousShouldFire;

      function drainQueue() {
        while (q.length > 0) {
          o.onNext(q.shift());
        }
      }

      var subscription = combineLatestSource(this.source, this.pauser.startWith(!this.paused).distinctUntilChanged(), function (data, shouldFire) {
        return { data: data, shouldFire: shouldFire };
      }).subscribe(function (results) {
        if (previousShouldFire !== undefined && results.shouldFire !== previousShouldFire) {
          previousShouldFire = results.shouldFire;
          // change in shouldFire
          if (results.shouldFire) {
            drainQueue();
          }
        } else {
          previousShouldFire = results.shouldFire;
          // new data
          if (results.shouldFire) {
            o.onNext(results.data);
          } else {
            q.push(results.data);
          }
        }
      }, function (err) {
        drainQueue();
        o.onError(err);
      }, function () {
        drainQueue();
        o.onCompleted();
      });
      return subscription;
    };

    PausableBufferedObservable.prototype.pause = function () {
      this.paused = true;
      this.controller.onNext(false);
    };

    PausableBufferedObservable.prototype.resume = function () {
      this.paused = false;
      this.controller.onNext(true);
    };

    return PausableBufferedObservable;
  }(Observable);

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
   * and yields the values that were buffered while paused.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
   * @returns {Observable} The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausableBuffered = function (pauser) {
    return new PausableBufferedObservable(this, pauser);
  };

  var ControlledObservable = function (__super__) {
    inherits(ControlledObservable, __super__);
    function ControlledObservable(source, enableQueue, scheduler) {
      __super__.call(this);
      this.subject = new ControlledSubject(enableQueue, scheduler);
      this.source = source.multicast(this.subject).refCount();
    }

    ControlledObservable.prototype._subscribe = function (o) {
      return this.source.subscribe(o);
    };

    ControlledObservable.prototype.request = function (numberOfItems) {
      return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
    };

    return ControlledObservable;
  }(Observable);

  var ControlledSubject = function (__super__) {
    inherits(ControlledSubject, __super__);
    function ControlledSubject(enableQueue, scheduler) {
      enableQueue == null && (enableQueue = true);

      __super__.call(this);
      this.subject = new Subject();
      this.enableQueue = enableQueue;
      this.queue = enableQueue ? [] : null;
      this.requestedCount = 0;
      this.requestedDisposable = null;
      this.error = null;
      this.hasFailed = false;
      this.hasCompleted = false;
      this.scheduler = scheduler || currentThreadScheduler;
    }

    addProperties(ControlledSubject.prototype, Observer, {
      _subscribe: function _subscribe(o) {
        return this.subject.subscribe(o);
      },
      onCompleted: function onCompleted() {
        this.hasCompleted = true;
        if (!this.enableQueue || this.queue.length === 0) {
          this.subject.onCompleted();
          this.disposeCurrentRequest();
        } else {
          this.queue.push(Notification.createOnCompleted());
        }
      },
      onError: function onError(error) {
        this.hasFailed = true;
        this.error = error;
        if (!this.enableQueue || this.queue.length === 0) {
          this.subject.onError(error);
          this.disposeCurrentRequest();
        } else {
          this.queue.push(Notification.createOnError(error));
        }
      },
      onNext: function onNext(value) {
        if (this.requestedCount <= 0) {
          this.enableQueue && this.queue.push(Notification.createOnNext(value));
        } else {
          this.requestedCount-- === 0 && this.disposeCurrentRequest();
          this.subject.onNext(value);
        }
      },
      _processRequest: function _processRequest(numberOfItems) {
        if (this.enableQueue) {
          while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {
            var first = this.queue.shift();
            first.accept(this.subject);
            if (first.kind === 'N') {
              numberOfItems--;
            } else {
              this.disposeCurrentRequest();
              this.queue = [];
            }
          }
        }

        return numberOfItems;
      },
      request: function request(number) {
        this.disposeCurrentRequest();
        var self = this;

        this.requestedDisposable = this.scheduler.schedule(number, function (s, i) {
          var remaining = self._processRequest(i);
          var stopped = self.hasCompleted || self.hasFailed;
          if (!stopped && remaining > 0) {
            self.requestedCount = remaining;

            return disposableCreate(function () {
              self.requestedCount = 0;
            });
            // Scheduled item is still in progress. Return a new
            // disposable to allow the request to be interrupted
            // via dispose.
          }
        });

        return this.requestedDisposable;
      },
      disposeCurrentRequest: function disposeCurrentRequest() {
        if (this.requestedDisposable) {
          this.requestedDisposable.dispose();
          this.requestedDisposable = null;
        }
      }
    });

    return ControlledSubject;
  }(Observable);

  /**
   * Attaches a controller to the observable sequence with the ability to queue.
   * @example
   * var source = Rx.Observable.interval(100).controlled();
   * source.request(3); // Reads 3 values
   * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request
   * @param {Scheduler} scheduler determines how the requests will be scheduled
   * @returns {Observable} The observable sequence which only propagates values on request.
   */
  observableProto.controlled = function (enableQueue, scheduler) {

    if (enableQueue && isScheduler(enableQueue)) {
      scheduler = enableQueue;
      enableQueue = true;
    }

    if (enableQueue == null) {
      enableQueue = true;
    }
    return new ControlledObservable(this, enableQueue, scheduler);
  };

  var StopAndWaitObservable = function (__super__) {
    inherits(StopAndWaitObservable, __super__);
    function StopAndWaitObservable(source) {
      __super__.call(this);
      this.source = source;
    }

    function scheduleMethod(s, self) {
      return self.source.request(1);
    }

    StopAndWaitObservable.prototype._subscribe = function (o) {
      this.subscription = this.source.subscribe(new StopAndWaitObserver(o, this, this.subscription));
      return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));
    };

    var StopAndWaitObserver = function (__sub__) {
      inherits(StopAndWaitObserver, __sub__);
      function StopAndWaitObserver(observer, observable, cancel) {
        __sub__.call(this);
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.scheduleDisposable = null;
      }

      StopAndWaitObserver.prototype.completed = function () {
        this.observer.onCompleted();
        this.dispose();
      };

      StopAndWaitObserver.prototype.error = function (error) {
        this.observer.onError(error);
        this.dispose();
      };

      function innerScheduleMethod(s, self) {
        return self.observable.source.request(1);
      }

      StopAndWaitObserver.prototype.next = function (value) {
        this.observer.onNext(value);
        this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod);
      };

      StopAndWaitObserver.dispose = function () {
        this.observer = null;
        if (this.cancel) {
          this.cancel.dispose();
          this.cancel = null;
        }
        if (this.scheduleDisposable) {
          this.scheduleDisposable.dispose();
          this.scheduleDisposable = null;
        }
        __sub__.prototype.dispose.call(this);
      };

      return StopAndWaitObserver;
    }(AbstractObserver);

    return StopAndWaitObservable;
  }(Observable);

  /**
   * Attaches a stop and wait observable to the current observable.
   * @returns {Observable} A stop and wait observable.
   */
  ControlledObservable.prototype.stopAndWait = function () {
    return new StopAndWaitObservable(this);
  };

  var WindowedObservable = function (__super__) {
    inherits(WindowedObservable, __super__);
    function WindowedObservable(source, windowSize) {
      __super__.call(this);
      this.source = source;
      this.windowSize = windowSize;
    }

    function scheduleMethod(s, self) {
      return self.source.request(self.windowSize);
    }

    WindowedObservable.prototype._subscribe = function (o) {
      this.subscription = this.source.subscribe(new WindowedObserver(o, this, this.subscription));
      return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));
    };

    var WindowedObserver = function (__sub__) {
      inherits(WindowedObserver, __sub__);
      function WindowedObserver(observer, observable, cancel) {
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.received = 0;
        this.scheduleDisposable = null;
        __sub__.call(this);
      }

      WindowedObserver.prototype.completed = function () {
        this.observer.onCompleted();
        this.dispose();
      };

      WindowedObserver.prototype.error = function (error) {
        this.observer.onError(error);
        this.dispose();
      };

      function innerScheduleMethod(s, self) {
        return self.observable.source.request(self.observable.windowSize);
      }

      WindowedObserver.prototype.next = function (value) {
        this.observer.onNext(value);
        this.received = ++this.received % this.observable.windowSize;
        this.received === 0 && (this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod));
      };

      WindowedObserver.prototype.dispose = function () {
        this.observer = null;
        if (this.cancel) {
          this.cancel.dispose();
          this.cancel = null;
        }
        if (this.scheduleDisposable) {
          this.scheduleDisposable.dispose();
          this.scheduleDisposable = null;
        }
        __sub__.prototype.dispose.call(this);
      };

      return WindowedObserver;
    }(AbstractObserver);

    return WindowedObservable;
  }(Observable);

  /**
   * Creates a sliding windowed observable based upon the window size.
   * @param {Number} windowSize The number of items in the window
   * @returns {Observable} A windowed observable based upon the window size.
   */
  ControlledObservable.prototype.windowed = function (windowSize) {
    return new WindowedObservable(this, windowSize);
  };

  /**
   * Pipes the existing Observable sequence into a Node.js Stream.
   * @param {Stream} dest The destination Node.js stream.
   * @returns {Stream} The destination stream.
   */
  observableProto.pipe = function (dest) {
    var source = this.pausableBuffered();

    function onDrain() {
      source.resume();
    }

    dest.addListener('drain', onDrain);

    source.subscribe(function (x) {
      !dest.write(x) && source.pause();
    }, function (err) {
      dest.emit('error', err);
    }, function () {
      // Hack check because STDIO is not closable
      !dest._isStdio && dest.end();
      dest.removeListener('drain', onDrain);
    });

    source.resume();

    return dest;
  };

  var MulticastObservable = function (__super__) {
    inherits(MulticastObservable, __super__);
    function MulticastObservable(source, fn1, fn2) {
      this.source = source;
      this._fn1 = fn1;
      this._fn2 = fn2;
      __super__.call(this);
    }

    MulticastObservable.prototype.subscribeCore = function (o) {
      var connectable = this.source.multicast(this._fn1());
      return new BinaryDisposable(this._fn2(connectable).subscribe(o), connectable.connect());
    };

    return MulticastObservable;
  }(ObservableBase);

  /**
   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each
   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's
   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
   *
   * @example
   * 1 - res = source.multicast(observable);
   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });
   *
   * @param {Function|Subject} subjectOrSubjectSelector
   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
   * Or:
   * Subject to push source elements into.
   *
   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name="subjectOrSubjectSelector" is a factory function.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.multicast = function (subjectOrSubjectSelector, selector) {
    return isFunction(subjectOrSubjectSelector) ? new MulticastObservable(this, subjectOrSubjectSelector, selector) : new ConnectableObservable(this, subjectOrSubjectSelector);
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.
   * This operator is a specialization of Multicast using a regular Subject.
   *
   * @example
   * var resres = source.publish();
   * var res = source.publish(function (x) { return x; });
   *
   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publish = function (selector) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new Subject();
    }, selector) : this.multicast(new Subject());
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence.
   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.share = function () {
    return this.publish().refCount();
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
   * This operator is a specialization of Multicast using a AsyncSubject.
   *
   * @example
   * var res = source.publishLast();
   * var res = source.publishLast(function (x) { return x; });
   *
   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publishLast = function (selector) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new AsyncSubject();
    }, selector) : this.multicast(new AsyncSubject());
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
   * This operator is a specialization of Multicast using a BehaviorSubject.
   *
   * @example
   * var res = source.publishValue(42);
   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);
   *
   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.
   * @param {Mixed} initialValue Initial value received by observers upon subscription.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publishValue = function (initialValueOrSelector, initialValue) {
    return arguments.length === 2 ? this.multicast(function () {
      return new BehaviorSubject(initialValue);
    }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.
   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   * @param {Mixed} initialValue Initial value received by observers upon subscription.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.shareValue = function (initialValue) {
    return this.publishValue(initialValue).refCount();
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
   * This operator is a specialization of Multicast using a ReplaySubject.
   *
   * @example
   * var res = source.replay(null, 3);
   * var res = source.replay(null, 3, 500);
   * var res = source.replay(null, 3, 500, scheduler);
   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);
   *
   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
   * @param bufferSize [Optional] Maximum element count of the replay buffer.
   * @param windowSize [Optional] Maximum time length of the replay buffer.
   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.replay = function (selector, bufferSize, windowSize, scheduler) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new ReplaySubject(bufferSize, windowSize, scheduler);
    }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   *
   * @example
   * var res = source.shareReplay(3);
   * var res = source.shareReplay(3, 500);
   * var res = source.shareReplay(3, 500, scheduler);
   *
    * @param bufferSize [Optional] Maximum element count of the replay buffer.
   * @param window [Optional] Maximum time length of the replay buffer.
   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.shareReplay = function (bufferSize, windowSize, scheduler) {
    return this.replay(null, bufferSize, windowSize, scheduler).refCount();
  };

  var InnerSubscription = function InnerSubscription(s, o) {
    this._s = s;
    this._o = o;
  };

  InnerSubscription.prototype.dispose = function () {
    if (!this._s.isDisposed && this._o !== null) {
      var idx = this._s.observers.indexOf(this._o);
      this._s.observers.splice(idx, 1);
      this._o = null;
    }
  };

  var RefCountObservable = function (__super__) {
    inherits(RefCountObservable, __super__);
    function RefCountObservable(source) {
      this.source = source;
      this._count = 0;
      this._connectableSubscription = null;
      __super__.call(this);
    }

    RefCountObservable.prototype.subscribeCore = function (o) {
      var subscription = this.source.subscribe(o);
      ++this._count === 1 && (this._connectableSubscription = this.source.connect());
      return new RefCountDisposable(this, subscription);
    };

    function RefCountDisposable(p, s) {
      this._p = p;
      this._s = s;
      this.isDisposed = false;
    }

    RefCountDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        this._s.dispose();
        --this._p._count === 0 && this._p._connectableSubscription.dispose();
      }
    };

    return RefCountObservable;
  }(ObservableBase);

  var ConnectableObservable = Rx.ConnectableObservable = function (__super__) {
    inherits(ConnectableObservable, __super__);
    function ConnectableObservable(source, subject) {
      this.source = source;
      this._connection = null;
      this._source = source.asObservable();
      this._subject = subject;
      __super__.call(this);
    }

    function ConnectDisposable(parent, subscription) {
      this._p = parent;
      this._s = subscription;
    }

    ConnectDisposable.prototype.dispose = function () {
      if (this._s) {
        this._s.dispose();
        this._s = null;
        this._p._connection = null;
      }
    };

    ConnectableObservable.prototype.connect = function () {
      if (!this._connection) {
        if (this._subject.isStopped) {
          return disposableEmpty;
        }
        var subscription = this._source.subscribe(this._subject);
        this._connection = new ConnectDisposable(this, subscription);
      }
      return this._connection;
    };

    ConnectableObservable.prototype._subscribe = function (o) {
      return this._subject.subscribe(o);
    };

    ConnectableObservable.prototype.refCount = function () {
      return new RefCountObservable(this);
    };

    return ConnectableObservable;
  }(Observable);

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence
   * can be resubscribed to, even if all prior subscriptions have ended. (unlike `.publish().refCount()`)
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source.
   */
  observableProto.singleInstance = function () {
    var source = this,
        hasObservable = false,
        observable;

    function getObservable() {
      if (!hasObservable) {
        hasObservable = true;
        observable = source['finally'](function () {
          hasObservable = false;
        }).publish().refCount();
      }
      return observable;
    }

    return new AnonymousObservable(function (o) {
      return getObservable().subscribe(o);
    });
  };

  /**
   *  Correlates the elements of two sequences based on overlapping durations.
   *
   *  @param {Observable} right The right observable sequence to join elements for.
   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.
   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
   */
  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
    var left = this;
    return new AnonymousObservable(function (o) {
      var group = new CompositeDisposable();
      var leftDone = false,
          rightDone = false;
      var leftId = 0,
          rightId = 0;
      var leftMap = new Map(),
          rightMap = new Map();
      var handleError = function handleError(e) {
        o.onError(e);
      };

      group.add(left.subscribe(function (value) {
        var id = leftId++,
            md = new SingleAssignmentDisposable();

        leftMap.set(id, value);
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, handleError, function () {
          leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();
          group.remove(md);
        }));

        rightMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(value, v);
          if (result === errorObj) {
            return o.onError(result.e);
          }
          o.onNext(result);
        });
      }, handleError, function () {
        leftDone = true;
        (rightDone || leftMap.size === 0) && o.onCompleted();
      }));

      group.add(right.subscribe(function (value) {
        var id = rightId++,
            md = new SingleAssignmentDisposable();

        rightMap.set(id, value);
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, handleError, function () {
          rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();
          group.remove(md);
        }));

        leftMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(v, value);
          if (result === errorObj) {
            return o.onError(result.e);
          }
          o.onNext(result);
        });
      }, handleError, function () {
        rightDone = true;
        (leftDone || rightMap.size === 0) && o.onCompleted();
      }));
      return group;
    }, left);
  };

  /**
   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.
   *
   *  @param {Observable} right The right observable sequence to join elements for.
   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.
   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
   */
  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
    var left = this;
    return new AnonymousObservable(function (o) {
      var group = new CompositeDisposable();
      var r = new RefCountDisposable(group);
      var leftMap = new Map(),
          rightMap = new Map();
      var leftId = 0,
          rightId = 0;
      var handleError = function handleError(e) {
        return function (v) {
          v.onError(e);
        };
      };

      function handleError(e) {};

      group.add(left.subscribe(function (value) {
        var s = new Subject();
        var id = leftId++;
        leftMap.set(id, s);

        var result = tryCatch(resultSelector)(value, addRef(s, r));
        if (result === errorObj) {
          leftMap.forEach(handleError(result.e));
          return o.onError(result.e);
        }
        o.onNext(result);

        rightMap.forEach(function (v) {
          s.onNext(v);
        });

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, function (e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function () {
          leftMap['delete'](id) && s.onCompleted();
          group.remove(md);
        }));
      }, function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      }, function () {
        o.onCompleted();
      }));

      group.add(right.subscribe(function (value) {
        var id = rightId++;
        rightMap.set(id, value);

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, function (e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function () {
          rightMap['delete'](id);
          group.remove(md);
        }));

        leftMap.forEach(function (v) {
          v.onNext(value);
        });
      }, function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      }));

      return r;
    }, left);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers.
   *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns {Observable} An observable sequence of windows.
   */
  observableProto.buffer = function () {
    return this.window.apply(this, arguments).flatMap(toArray);
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows.
   *
   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns {Observable} An observable sequence of windows.
   */
  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {
    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
      return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
    }
    return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
  };

  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {
      return win;
    });
  }

  function observableWindowWithBoundaries(windowBoundaries) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var win = new Subject(),
          d = new CompositeDisposable(),
          r = new RefCountDisposable(d);

      observer.onNext(addRef(win, r));

      d.add(source.subscribe(function (x) {
        win.onNext(x);
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));

      d.add(windowBoundaries.subscribe(function (w) {
        win.onCompleted();
        win = new Subject();
        observer.onNext(addRef(win, r));
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      return r;
    }, source);
  }

  function observableWindowWithClosingSelector(windowClosingSelector) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var m = new SerialDisposable(),
          d = new CompositeDisposable(m),
          r = new RefCountDisposable(d),
          win = new Subject();
      observer.onNext(addRef(win, r));
      d.add(source.subscribe(function (x) {
        win.onNext(x);
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      function createWindowClose() {
        var windowClose;
        try {
          windowClose = windowClosingSelector();
        } catch (e) {
          observer.onError(e);
          return;
        }

        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));

        var m1 = new SingleAssignmentDisposable();
        m.setDisposable(m1);
        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {
          win.onError(err);
          observer.onError(err);
        }, function () {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
          createWindowClose();
        }));
      }

      createWindowClose();
      return r;
    }, source);
  }

  var PairwiseObservable = function (__super__) {
    inherits(PairwiseObservable, __super__);
    function PairwiseObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    PairwiseObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new PairwiseObserver(o));
    };

    return PairwiseObservable;
  }(ObservableBase);

  var PairwiseObserver = function (__super__) {
    inherits(PairwiseObserver, __super__);
    function PairwiseObserver(o) {
      this._o = o;
      this._p = null;
      this._hp = false;
      __super__.call(this);
    }

    PairwiseObserver.prototype.next = function (x) {
      if (this._hp) {
        this._o.onNext([this._p, x]);
      } else {
        this._hp = true;
      }
      this._p = x;
    };
    PairwiseObserver.prototype.error = function (err) {
      this._o.onError(err);
    };
    PairwiseObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return PairwiseObserver;
  }(AbstractObserver);

  /**
   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.
   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.
   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.
   */
  observableProto.pairwise = function () {
    return new PairwiseObservable(this);
  };

  /**
   * Returns two observables which partition the observations of the source by the given function.
   * The first will trigger observations for those values for which the predicate returns true.
   * The second will trigger observations for those values where the predicate returns false.
   * The predicate is executed once for each subscribed observer.
   * Both also propagate all error observations arising from the source and each completes
   * when the source completes.
   * @param {Function} predicate
   *    The function to determine which output Observable will trigger a particular observation.
   * @returns {Array}
   *    An array of observables. The first triggers when the predicate returns true,
   *    and the second triggers when the predicate returns false.
  */
  observableProto.partition = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return [this.filter(predicate, thisArg), this.filter(function (x, i, o) {
      return !fn(x, i, o);
    })];
  };

  var WhileEnumerable = function (__super__) {
    inherits(WhileEnumerable, __super__);
    function WhileEnumerable(c, s) {
      this.c = c;
      this.s = s;
    }
    WhileEnumerable.prototype[$iterator$] = function () {
      var self = this;
      return {
        next: function next() {
          return self.c() ? { done: false, value: self.s } : { done: true, value: void 0 };
        }
      };
    };
    return WhileEnumerable;
  }(Enumerable);

  function enumerableWhile(condition, source) {
    return new WhileEnumerable(condition, source);
  }

  /**
  *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
  *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
  *
  * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
  * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
  */
  observableProto.letBind = observableProto['let'] = function (func) {
    return func(this);
  };

  /**
  *  Determines whether an observable collection contains values. 
  *
  * @example
  *  1 - res = Rx.Observable.if(condition, obs1);
  *  2 - res = Rx.Observable.if(condition, obs1, obs2);
  *  3 - res = Rx.Observable.if(condition, obs1, scheduler);
  * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.
  * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.
  * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
  * @returns {Observable} An observable sequence which is either the thenSource or elseSource.
  */
  Observable['if'] = function (condition, thenSource, elseSourceOrScheduler) {
    return observableDefer(function () {
      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());

      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));

      // Assume a scheduler for empty only
      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
      return condition() ? thenSource : elseSourceOrScheduler;
    });
  };

  /**
  *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
  * There is an alias for this method called 'forIn' for browsers <IE9
  * @param {Array} sources An array of values to turn into an observable sequence.
  * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
  * @returns {Observable} An observable sequence from the concatenated observable sequences.
  */
  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {
    return enumerableOf(sources, resultSelector, thisArg).concat();
  };

  /**
  *  Repeats source as long as condition holds emulating a while loop.
  * There is an alias for this method called 'whileDo' for browsers <IE9
  *
  * @param {Function} condition The condition which determines if the source will be repeated.
  * @param {Observable} source The observable sequence that will be run if the condition function returns true.
  * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
  */
  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {
    isPromise(source) && (source = observableFromPromise(source));
    return enumerableWhile(condition, source).concat();
  };

  /**
  *  Repeats source as long as condition holds emulating a do while loop.
  *
  * @param {Function} condition The condition which determines if the source will be repeated.
  * @param {Observable} source The observable sequence that will be run if the condition function returns true.
  * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
  */
  observableProto.doWhile = function (condition) {
    return observableConcat([this, observableWhileDo(condition, this)]);
  };

  /**
  *  Uses selector to determine which source in sources to use.
  * @param {Function} selector The function which extracts the value for to test in a case statement.
  * @param {Array} sources A object which has keys which correspond to the case statement labels.
  * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.
  *
  * @returns {Observable} An observable sequence which is determined by a case statement.
  */
  Observable['case'] = function (selector, sources, defaultSourceOrScheduler) {
    return observableDefer(function () {
      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());

      isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));

      var result = sources[selector()];
      isPromise(result) && (result = observableFromPromise(result));

      return result || defaultSourceOrScheduler;
    });
  };

  var ExpandObservable = function (__super__) {
    inherits(ExpandObservable, __super__);
    function ExpandObservable(source, fn, scheduler) {
      this.source = source;
      this._fn = fn;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleRecursive(args, recurse) {
      var state = args[0],
          self = args[1];
      var work;
      if (state.q.length > 0) {
        work = state.q.shift();
      } else {
        state.isAcquired = false;
        return;
      }
      var m1 = new SingleAssignmentDisposable();
      state.d.add(m1);
      m1.setDisposable(work.subscribe(new ExpandObserver(state, self, m1)));
      recurse([state, self]);
    }

    ExpandObservable.prototype._ensureActive = function (state) {
      var isOwner = false;
      if (state.q.length > 0) {
        isOwner = !state.isAcquired;
        state.isAcquired = true;
      }
      isOwner && state.m.setDisposable(this._scheduler.scheduleRecursive([state, this], scheduleRecursive));
    };

    ExpandObservable.prototype.subscribeCore = function (o) {
      var m = new SerialDisposable(),
          d = new CompositeDisposable(m),
          state = {
        q: [],
        m: m,
        d: d,
        activeCount: 0,
        isAcquired: false,
        o: o
      };

      state.q.push(this.source);
      state.activeCount++;
      this._ensureActive(state);
      return d;
    };

    return ExpandObservable;
  }(ObservableBase);

  var ExpandObserver = function (__super__) {
    inherits(ExpandObserver, __super__);
    function ExpandObserver(state, parent, m1) {
      this._s = state;
      this._p = parent;
      this._m1 = m1;
      __super__.call(this);
    }

    ExpandObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
      var result = tryCatch(this._p._fn)(x);
      if (result === errorObj) {
        return this._s.o.onError(result.e);
      }
      this._s.q.push(result);
      this._s.activeCount++;
      this._p._ensureActive(this._s);
    };

    ExpandObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    ExpandObserver.prototype.completed = function () {
      this._s.d.remove(this._m1);
      this._s.activeCount--;
      this._s.activeCount === 0 && this._s.o.onCompleted();
    };

    return ExpandObserver;
  }(AbstractObserver);

  /**
  *  Expands an observable sequence by recursively invoking selector.
  *
  * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
  * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
  * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.
  */
  observableProto.expand = function (selector, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new ExpandObservable(this, selector, scheduler);
  };

  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var ForkJoinObservable = function (__super__) {
    inherits(ForkJoinObservable, __super__);
    function ForkJoinObservable(sources, cb) {
      this._sources = sources;
      this._cb = cb;
      __super__.call(this);
    }

    ForkJoinObservable.prototype.subscribeCore = function (o) {
      if (this._sources.length === 0) {
        o.onCompleted();
        return disposableEmpty;
      }

      var count = this._sources.length;
      var state = {
        finished: false,
        hasResults: new Array(count),
        hasCompleted: new Array(count),
        results: new Array(count)
      };

      var subscriptions = new CompositeDisposable();
      for (var i = 0, len = this._sources.length; i < len; i++) {
        var source = this._sources[i];
        isPromise(source) && (source = observableFromPromise(source));
        subscriptions.add(source.subscribe(new ForkJoinObserver(o, state, i, this._cb, subscriptions)));
      }

      return subscriptions;
    };

    return ForkJoinObservable;
  }(ObservableBase);

  var ForkJoinObserver = function (__super__) {
    inherits(ForkJoinObserver, __super__);
    function ForkJoinObserver(o, s, i, cb, subs) {
      this._o = o;
      this._s = s;
      this._i = i;
      this._cb = cb;
      this._subs = subs;
      __super__.call(this);
    }

    ForkJoinObserver.prototype.next = function (x) {
      if (!this._s.finished) {
        this._s.hasResults[this._i] = true;
        this._s.results[this._i] = x;
      }
    };

    ForkJoinObserver.prototype.error = function (e) {
      this._s.finished = true;
      this._o.onError(e);
      this._subs.dispose();
    };

    ForkJoinObserver.prototype.completed = function () {
      if (!this._s.finished) {
        if (!this._s.hasResults[this._i]) {
          return this._o.onCompleted();
        }
        this._s.hasCompleted[this._i] = true;
        for (var i = 0; i < this._s.results.length; i++) {
          if (!this._s.hasCompleted[i]) {
            return;
          }
        }
        this._s.finished = true;

        var res = tryCatch(this._cb).apply(null, this._s.results);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }

        this._o.onNext(res);
        this._o.onCompleted();
      }
    };

    return ForkJoinObserver;
  }(AbstractObserver);

  /**
  *  Runs all observable sequences in parallel and collect their last elements.
  *
  * @example
  *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);
  *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
  * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
  */
  Observable.forkJoin = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);
    return new ForkJoinObservable(args, resultSelector);
  };

  /**
  *  Runs two observable sequences in parallel and combines their last elemenets.
  * @param {Observable} second Second observable sequence.
  * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.
  * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.
  */
  observableProto.forkJoin = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args[0].unshift(this);
    } else {
      args.unshift(this);
    }
    return Observable.forkJoin.apply(null, args);
  };

  /**
   * Comonadic bind operator.
   * @param {Function} selector A transform function to apply to each element.
   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.
   * @returns {Observable} An observable sequence which results from the comonadic bind operation.
   */
  observableProto.manySelect = observableProto.extend = function (selector, scheduler) {
    isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);
    var source = this;
    return observableDefer(function () {
      var chain;

      return source.map(function (x) {
        var curr = new ChainObservable(x);

        chain && chain.onNext(x);
        chain = curr;

        return curr;
      }).tap(noop, function (e) {
        chain && chain.onError(e);
      }, function () {
        chain && chain.onCompleted();
      }).observeOn(scheduler).map(selector);
    }, source);
  };

  var ChainObservable = function (__super__) {
    inherits(ChainObservable, __super__);
    function ChainObservable(head) {
      __super__.call(this);
      this.head = head;
      this.tail = new AsyncSubject();
    }

    addProperties(ChainObservable.prototype, Observer, {
      _subscribe: function _subscribe(o) {
        var g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(this, function (_, self) {
          o.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(o));
        }));

        return g;
      },
      onCompleted: function onCompleted() {
        this.onNext(Observable.empty());
      },
      onError: function onError(e) {
        this.onNext(Observable['throw'](e));
      },
      onNext: function onNext(v) {
        this.tail.onNext(v);
        this.tail.onCompleted();
      }
    });

    return ChainObservable;
  }(Observable);

  var Map = root.Map || function () {
    function Map() {
      this.size = 0;
      this._values = [];
      this._keys = [];
    }

    Map.prototype['delete'] = function (key) {
      var i = this._keys.indexOf(key);
      if (i === -1) {
        return false;
      }
      this._values.splice(i, 1);
      this._keys.splice(i, 1);
      this.size--;
      return true;
    };

    Map.prototype.get = function (key) {
      var i = this._keys.indexOf(key);
      return i === -1 ? undefined : this._values[i];
    };

    Map.prototype.set = function (key, value) {
      var i = this._keys.indexOf(key);
      if (i === -1) {
        this._keys.push(key);
        this._values.push(value);
        this.size++;
      } else {
        this._values[i] = value;
      }
      return this;
    };

    Map.prototype.forEach = function (cb, thisArg) {
      for (var i = 0; i < this.size; i++) {
        cb.call(thisArg, this._values[i], this._keys[i]);
      }
    };

    return Map;
  }();

  /**
   * @constructor
   * Represents a join pattern over observable sequences.
   */
  function Pattern(patterns) {
    this.patterns = patterns;
  }

  /**
   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.
   *  @param other Observable sequence to match in addition to the current pattern.
   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.
   */
  Pattern.prototype.and = function (other) {
    return new Pattern(this.patterns.concat(other));
  };

  /**
   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.
   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.
   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  Pattern.prototype.thenDo = function (selector) {
    return new Plan(this, selector);
  };

  function Plan(expression, selector) {
    this.expression = expression;
    this.selector = selector;
  }

  function handleOnError(o) {
    return function (e) {
      o.onError(e);
    };
  }
  function handleOnNext(self, observer) {
    return function onNext() {
      var result = tryCatch(self.selector).apply(self, arguments);
      if (result === errorObj) {
        return observer.onError(result.e);
      }
      observer.onNext(result);
    };
  }

  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {
    var joinObservers = [],
        errHandler = handleOnError(observer);
    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {
      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], errHandler));
    }
    var activePlan = new ActivePlan(joinObservers, handleOnNext(this, observer), function () {
      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {
        joinObservers[j].removeActivePlan(activePlan);
      }
      deactivate(activePlan);
    });
    for (i = 0, len = joinObservers.length; i < len; i++) {
      joinObservers[i].addActivePlan(activePlan);
    }
    return activePlan;
  };

  function planCreateObserver(externalSubscriptions, observable, onError) {
    var entry = externalSubscriptions.get(observable);
    if (!entry) {
      var observer = new JoinObserver(observable, onError);
      externalSubscriptions.set(observable, observer);
      return observer;
    }
    return entry;
  }

  function ActivePlan(joinObserverArray, onNext, onCompleted) {
    this.joinObserverArray = joinObserverArray;
    this.onNext = onNext;
    this.onCompleted = onCompleted;
    this.joinObservers = new Map();
    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {
      var joinObserver = this.joinObserverArray[i];
      this.joinObservers.set(joinObserver, joinObserver);
    }
  }

  ActivePlan.prototype.dequeue = function () {
    this.joinObservers.forEach(function (v) {
      v.queue.shift();
    });
  };

  ActivePlan.prototype.match = function () {
    var i,
        len,
        hasValues = true;
    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
      if (this.joinObserverArray[i].queue.length === 0) {
        hasValues = false;
        break;
      }
    }
    if (hasValues) {
      var firstValues = [],
          isCompleted = false;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        firstValues.push(this.joinObserverArray[i].queue[0]);
        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
      }
      if (isCompleted) {
        this.onCompleted();
      } else {
        this.dequeue();
        var values = [];
        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
          values.push(firstValues[i].value);
        }
        this.onNext.apply(this, values);
      }
    }
  };

  var JoinObserver = function (__super__) {
    inherits(JoinObserver, __super__);

    function JoinObserver(source, onError) {
      __super__.call(this);
      this.source = source;
      this.onError = onError;
      this.queue = [];
      this.activePlans = [];
      this.subscription = new SingleAssignmentDisposable();
      this.isDisposed = false;
    }

    var JoinObserverPrototype = JoinObserver.prototype;

    JoinObserverPrototype.next = function (notification) {
      if (!this.isDisposed) {
        if (notification.kind === 'E') {
          return this.onError(notification.error);
        }
        this.queue.push(notification);
        var activePlans = this.activePlans.slice(0);
        for (var i = 0, len = activePlans.length; i < len; i++) {
          activePlans[i].match();
        }
      }
    };

    JoinObserverPrototype.error = noop;
    JoinObserverPrototype.completed = noop;

    JoinObserverPrototype.addActivePlan = function (activePlan) {
      this.activePlans.push(activePlan);
    };

    JoinObserverPrototype.subscribe = function () {
      this.subscription.setDisposable(this.source.materialize().subscribe(this));
    };

    JoinObserverPrototype.removeActivePlan = function (activePlan) {
      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
      this.activePlans.length === 0 && this.dispose();
    };

    JoinObserverPrototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      if (!this.isDisposed) {
        this.isDisposed = true;
        this.subscription.dispose();
      }
    };

    return JoinObserver;
  }(AbstractObserver);

  /**
   *  Creates a pattern that matches when both observable sequences have an available value.
   *
   *  @param right Observable sequence to match with the current sequence.
   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.
   */
  observableProto.and = function (right) {
    return new Pattern([this, right]);
  };

  /**
   *  Matches when the observable sequence has an available value and projects the value.
   *
   *  @param {Function} selector Selector that will be invoked for values in the source sequence.
   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  observableProto.thenDo = function (selector) {
    return new Pattern([this]).thenDo(selector);
  };

  /**
   *  Joins together the results from several patterns.
   *
   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.
   *  @returns {Observable} Observable sequence with the results form matching several patterns.
   */
  Observable.when = function () {
    var len = arguments.length,
        plans;
    if (Array.isArray(arguments[0])) {
      plans = arguments[0];
    } else {
      plans = new Array(len);
      for (var i = 0; i < len; i++) {
        plans[i] = arguments[i];
      }
    }
    return new AnonymousObservable(function (o) {
      var activePlans = [],
          externalSubscriptions = new Map();
      var outObserver = observerCreate(function (x) {
        o.onNext(x);
      }, function (err) {
        externalSubscriptions.forEach(function (v) {
          v.onError(err);
        });
        o.onError(err);
      }, function (x) {
        o.onCompleted();
      });
      try {
        for (var i = 0, len = plans.length; i < len; i++) {
          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {
            var idx = activePlans.indexOf(activePlan);
            activePlans.splice(idx, 1);
            activePlans.length === 0 && o.onCompleted();
          }));
        }
      } catch (e) {
        return observableThrow(e).subscribe(o);
      }
      var group = new CompositeDisposable();
      externalSubscriptions.forEach(function (joinObserver) {
        joinObserver.subscribe();
        group.add(joinObserver);
      });

      return group;
    });
  };

  var TimerObservable = function (__super__) {
    inherits(TimerObservable, __super__);
    function TimerObservable(dt, s) {
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    TimerObservable.prototype.subscribeCore = function (o) {
      return this._s.scheduleFuture(o, this._dt, scheduleMethod);
    };

    function scheduleMethod(s, o) {
      o.onNext(0);
      o.onCompleted();
    }

    return TimerObservable;
  }(ObservableBase);

  function _observableTimer(dueTime, scheduler) {
    return new TimerObservable(dueTime, scheduler);
  }

  function observableTimerDateAndPeriod(dueTime, period, scheduler) {
    return new AnonymousObservable(function (observer) {
      var d = dueTime,
          p = normalizeTime(period);
      return scheduler.scheduleRecursiveFuture(0, d, function (count, self) {
        if (p > 0) {
          var now = scheduler.now();
          d = new Date(d.getTime() + p);
          d.getTime() <= now && (d = new Date(now + p));
        }
        observer.onNext(count);
        self(count + 1, new Date(d));
      });
    });
  }

  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
    return dueTime === period ? new AnonymousObservable(function (observer) {
      return scheduler.schedulePeriodic(0, period, function (count) {
        observer.onNext(count);
        return count + 1;
      });
    }) : observableDefer(function () {
      return observableTimerDateAndPeriod(new Date(scheduler.now() + dueTime), period, scheduler);
    });
  }

  /**
   *  Returns an observable sequence that produces a value after each period.
   *
   * @example
   *  1 - res = Rx.Observable.interval(1000);
   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);
   *
   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).
   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.
   * @returns {Observable} An observable sequence that produces a value after each period.
   */
  var observableinterval = Observable.interval = function (period, scheduler) {
    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);
  };

  /**
   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.
   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.
   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.
   */
  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {
    var period;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {
      period = periodOrScheduler;
    } else if (isScheduler(periodOrScheduler)) {
      scheduler = periodOrScheduler;
    }
    if ((dueTime instanceof Date || typeof dueTime === 'number') && period === undefined) {
      return _observableTimer(dueTime, scheduler);
    }
    if (dueTime instanceof Date && period !== undefined) {
      return observableTimerDateAndPeriod(dueTime, periodOrScheduler, scheduler);
    }
    return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
  };

  function observableDelayRelative(source, dueTime, scheduler) {
    return new AnonymousObservable(function (o) {
      var active = false,
          cancelable = new SerialDisposable(),
          exception = null,
          q = [],
          running = false,
          subscription;
      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {
        var d, shouldRun;
        if (notification.value.kind === 'E') {
          q = [];
          q.push(notification);
          exception = notification.value.error;
          shouldRun = !running;
        } else {
          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });
          shouldRun = !active;
          active = true;
        }
        if (shouldRun) {
          if (exception !== null) {
            o.onError(exception);
          } else {
            d = new SingleAssignmentDisposable();
            cancelable.setDisposable(d);
            d.setDisposable(scheduler.scheduleRecursiveFuture(null, dueTime, function (_, self) {
              var e, recurseDueTime, result, shouldRecurse;
              if (exception !== null) {
                return;
              }
              running = true;
              do {
                result = null;
                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                  result = q.shift().value;
                }
                if (result !== null) {
                  result.accept(o);
                }
              } while (result !== null);
              shouldRecurse = false;
              recurseDueTime = 0;
              if (q.length > 0) {
                shouldRecurse = true;
                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
              } else {
                active = false;
              }
              e = exception;
              running = false;
              if (e !== null) {
                o.onError(e);
              } else if (shouldRecurse) {
                self(null, recurseDueTime);
              }
            }));
          }
        }
      });
      return new BinaryDisposable(subscription, cancelable);
    }, source);
  }

  function observableDelayAbsolute(source, dueTime, scheduler) {
    return observableDefer(function () {
      return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);
    });
  }

  function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {
    var subDelay, selector;
    if (isFunction(subscriptionDelay)) {
      selector = subscriptionDelay;
    } else {
      subDelay = subscriptionDelay;
      selector = delayDurationSelector;
    }
    return new AnonymousObservable(function (o) {
      var delays = new CompositeDisposable(),
          atEnd = false,
          subscription = new SerialDisposable();

      function start() {
        subscription.setDisposable(source.subscribe(function (x) {
          var delay = tryCatch(selector)(x);
          if (delay === errorObj) {
            return o.onError(delay.e);
          }
          var d = new SingleAssignmentDisposable();
          delays.add(d);
          d.setDisposable(delay.subscribe(function () {
            o.onNext(x);
            delays.remove(d);
            done();
          }, function (e) {
            o.onError(e);
          }, function () {
            o.onNext(x);
            delays.remove(d);
            done();
          }));
        }, function (e) {
          o.onError(e);
        }, function () {
          atEnd = true;
          subscription.dispose();
          done();
        }));
      }

      function done() {
        atEnd && delays.length === 0 && o.onCompleted();
      }

      if (!subDelay) {
        start();
      } else {
        subscription.setDisposable(subDelay.subscribe(start, function (e) {
          o.onError(e);
        }, start));
      }

      return new BinaryDisposable(subscription, delays);
    }, source);
  }

  /**
   *  Time shifts the observable sequence by dueTime.
   *  The relative time intervals between the values are preserved.
   *
   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.
   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Time-shifted sequence.
   */
  observableProto.delay = function () {
    var firstArg = arguments[0];
    if (typeof firstArg === 'number' || firstArg instanceof Date) {
      var dueTime = firstArg,
          scheduler = arguments[1];
      isScheduler(scheduler) || (scheduler = defaultScheduler);
      return dueTime instanceof Date ? observableDelayAbsolute(this, dueTime, scheduler) : observableDelayRelative(this, dueTime, scheduler);
    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
      return delayWithSelector(this, firstArg, arguments[1]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  var DebounceObservable = function (__super__) {
    inherits(DebounceObservable, __super__);
    function DebounceObservable(source, dt, s) {
      isScheduler(s) || (s = defaultScheduler);
      this.source = source;
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    DebounceObservable.prototype.subscribeCore = function (o) {
      var cancelable = new SerialDisposable();
      return new BinaryDisposable(this.source.subscribe(new DebounceObserver(o, this._dt, this._s, cancelable)), cancelable);
    };

    return DebounceObservable;
  }(ObservableBase);

  var DebounceObserver = function (__super__) {
    inherits(DebounceObserver, __super__);
    function DebounceObserver(observer, dueTime, scheduler, cancelable) {
      this._o = observer;
      this._d = dueTime;
      this._scheduler = scheduler;
      this._c = cancelable;
      this._v = null;
      this._hv = false;
      this._id = 0;
      __super__.call(this);
    }

    function scheduleFuture(s, state) {
      state.self._hv && state.self._id === state.currentId && state.self._o.onNext(state.x);
      state.self._hv = false;
    }

    DebounceObserver.prototype.next = function (x) {
      this._hv = true;
      this._v = x;
      var currentId = ++this._id,
          d = new SingleAssignmentDisposable();
      this._c.setDisposable(d);
      d.setDisposable(this._scheduler.scheduleFuture(this, this._d, function (_, self) {
        self._hv && self._id === currentId && self._o.onNext(x);
        self._hv = false;
      }));
    };

    DebounceObserver.prototype.error = function (e) {
      this._c.dispose();
      this._o.onError(e);
      this._hv = false;
      this._id++;
    };

    DebounceObserver.prototype.completed = function () {
      this._c.dispose();
      this._hv && this._o.onNext(this._v);
      this._o.onCompleted();
      this._hv = false;
      this._id++;
    };

    return DebounceObserver;
  }(AbstractObserver);

  function debounceWithSelector(source, durationSelector) {
    return new AnonymousObservable(function (o) {
      var value,
          hasValue = false,
          cancelable = new SerialDisposable(),
          id = 0;
      var subscription = source.subscribe(function (x) {
        var throttle = tryCatch(durationSelector)(x);
        if (throttle === errorObj) {
          return o.onError(throttle.e);
        }

        isPromise(throttle) && (throttle = observableFromPromise(throttle));

        hasValue = true;
        value = x;
        id++;
        var currentid = id,
            d = new SingleAssignmentDisposable();
        cancelable.setDisposable(d);
        d.setDisposable(throttle.subscribe(function () {
          hasValue && id === currentid && o.onNext(value);
          hasValue = false;
          d.dispose();
        }, function (e) {
          o.onError(e);
        }, function () {
          hasValue && id === currentid && o.onNext(value);
          hasValue = false;
          d.dispose();
        }));
      }, function (e) {
        cancelable.dispose();
        o.onError(e);
        hasValue = false;
        id++;
      }, function () {
        cancelable.dispose();
        hasValue && o.onNext(value);
        o.onCompleted();
        hasValue = false;
        id++;
      });
      return new BinaryDisposable(subscription, cancelable);
    }, source);
  }

  observableProto.debounce = function () {
    if (isFunction(arguments[0])) {
      return debounceWithSelector(this, arguments[0]);
    } else if (typeof arguments[0] === 'number') {
      return new DebounceObservable(this, arguments[0], arguments[1]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.
   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).
   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.
   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithTime = observableProto.windowTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
    var source = this,
        timeShift;
    timeShiftOrScheduler == null && (timeShift = timeSpan);
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    if (typeof timeShiftOrScheduler === 'number') {
      timeShift = timeShiftOrScheduler;
    } else if (isScheduler(timeShiftOrScheduler)) {
      timeShift = timeSpan;
      scheduler = timeShiftOrScheduler;
    }
    return new AnonymousObservable(function (observer) {
      var groupDisposable,
          nextShift = timeShift,
          nextSpan = timeSpan,
          q = [],
          refCountDisposable,
          timerD = new SerialDisposable(),
          totalTime = 0;
      groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);

      function createTimer() {
        var m = new SingleAssignmentDisposable(),
            isSpan = false,
            isShift = false;
        timerD.setDisposable(m);
        if (nextSpan === nextShift) {
          isSpan = true;
          isShift = true;
        } else if (nextSpan < nextShift) {
          isSpan = true;
        } else {
          isShift = true;
        }
        var newTotalTime = isSpan ? nextSpan : nextShift,
            ts = newTotalTime - totalTime;
        totalTime = newTotalTime;
        if (isSpan) {
          nextSpan += timeShift;
        }
        if (isShift) {
          nextShift += timeShift;
        }
        m.setDisposable(scheduler.scheduleFuture(null, ts, function () {
          if (isShift) {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          isSpan && q.shift().onCompleted();
          createTimer();
        }));
      };
      q.push(new Subject());
      observer.onNext(addRef(q[0], refCountDisposable));
      createTimer();
      groupDisposable.add(source.subscribe(function (x) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onNext(x);
        }
      }, function (e) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onError(e);
        }
        observer.onError(e);
      }, function () {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onCompleted();
        }
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  /**
   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.
   * @param {Number} timeSpan Maximum time length of a window.
   * @param {Number} count Maximum element count of a window.
   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithTimeOrCount = observableProto.windowTimeOrCount = function (timeSpan, count, scheduler) {
    var source = this;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new AnonymousObservable(function (observer) {
      var timerD = new SerialDisposable(),
          groupDisposable = new CompositeDisposable(timerD),
          refCountDisposable = new RefCountDisposable(groupDisposable),
          n = 0,
          windowId = 0,
          s = new Subject();

      function createTimer(id) {
        var m = new SingleAssignmentDisposable();
        timerD.setDisposable(m);
        m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {
          if (id !== windowId) {
            return;
          }
          n = 0;
          var newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
          createTimer(newId);
        }));
      }

      observer.onNext(addRef(s, refCountDisposable));
      createTimer(0);

      groupDisposable.add(source.subscribe(function (x) {
        var newId = 0,
            newWindow = false;
        s.onNext(x);
        if (++n === count) {
          newWindow = true;
          n = 0;
          newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
        }
        newWindow && createTimer(newId);
      }, function (e) {
        s.onError(e);
        observer.onError(e);
      }, function () {
        s.onCompleted();
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
   * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).
   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.
   * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithTime = observableProto.bufferTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
    return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.
   * @param {Number} timeSpan Maximum time length of a buffer.
   * @param {Number} count Maximum element count of a buffer.
   * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithTimeOrCount = observableProto.bufferTimeOrCount = function (timeSpan, count, scheduler) {
    return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
  };

  var TimeIntervalObservable = function (__super__) {
    inherits(TimeIntervalObservable, __super__);
    function TimeIntervalObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    TimeIntervalObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TimeIntervalObserver(o, this._s));
    };

    return TimeIntervalObservable;
  }(ObservableBase);

  var TimeIntervalObserver = function (__super__) {
    inherits(TimeIntervalObserver, __super__);

    function TimeIntervalObserver(o, s) {
      this._o = o;
      this._s = s;
      this._l = s.now();
      __super__.call(this);
    }

    TimeIntervalObserver.prototype.next = function (x) {
      var now = this._s.now(),
          span = now - this._l;
      this._l = now;
      this._o.onNext({ value: x, interval: span });
    };
    TimeIntervalObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TimeIntervalObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TimeIntervalObserver;
  }(AbstractObserver);

  /**
   *  Records the time interval between consecutive values in an observable sequence.
   *
   * @example
   *  1 - res = source.timeInterval();
   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);
   *
   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence with time interval information on values.
   */
  observableProto.timeInterval = function (scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TimeIntervalObservable(this, scheduler);
  };

  var TimestampObservable = function (__super__) {
    inherits(TimestampObservable, __super__);
    function TimestampObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    TimestampObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TimestampObserver(o, this._s));
    };

    return TimestampObservable;
  }(ObservableBase);

  var TimestampObserver = function (__super__) {
    inherits(TimestampObserver, __super__);
    function TimestampObserver(o, s) {
      this._o = o;
      this._s = s;
      __super__.call(this);
    }

    TimestampObserver.prototype.next = function (x) {
      this._o.onNext({ value: x, timestamp: this._s.now() });
    };

    TimestampObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TimestampObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TimestampObserver;
  }(AbstractObserver);

  /**
   *  Records the timestamp for each value in an observable sequence.
   *
   * @example
   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }
   *  2 - res = source.timestamp(Rx.Scheduler.default);
   *
   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the default scheduler is used.
   * @returns {Observable} An observable sequence with timestamp information on values.
   */
  observableProto.timestamp = function (scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TimestampObservable(this, scheduler);
  };

  var SampleObservable = function (__super__) {
    inherits(SampleObservable, __super__);
    function SampleObservable(source, sampler) {
      this.source = source;
      this._sampler = sampler;
      __super__.call(this);
    }

    SampleObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        atEnd: false,
        value: null,
        hasValue: false,
        sourceSubscription: new SingleAssignmentDisposable()
      };

      state.sourceSubscription.setDisposable(this.source.subscribe(new SampleSourceObserver(state)));
      return new BinaryDisposable(state.sourceSubscription, this._sampler.subscribe(new SamplerObserver(state)));
    };

    return SampleObservable;
  }(ObservableBase);

  var SamplerObserver = function (__super__) {
    inherits(SamplerObserver, __super__);
    function SamplerObserver(s) {
      this._s = s;
      __super__.call(this);
    }

    SamplerObserver.prototype._handleMessage = function () {
      if (this._s.hasValue) {
        this._s.hasValue = false;
        this._s.o.onNext(this._s.value);
      }
      this._s.atEnd && this._s.o.onCompleted();
    };

    SamplerObserver.prototype.next = function () {
      this._handleMessage();
    };
    SamplerObserver.prototype.error = function (e) {
      this._s.onError(e);
    };
    SamplerObserver.prototype.completed = function () {
      this._handleMessage();
    };

    return SamplerObserver;
  }(AbstractObserver);

  var SampleSourceObserver = function (__super__) {
    inherits(SampleSourceObserver, __super__);
    function SampleSourceObserver(s) {
      this._s = s;
      __super__.call(this);
    }

    SampleSourceObserver.prototype.next = function (x) {
      this._s.hasValue = true;
      this._s.value = x;
    };
    SampleSourceObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    SampleSourceObserver.prototype.completed = function () {
      this._s.atEnd = true;
      this._s.sourceSubscription.dispose();
    };

    return SampleSourceObserver;
  }(AbstractObserver);

  /**
   *  Samples the observable sequence at each interval.
   *
   * @example
   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence
   *  2 - res = source.sample(5000); // 5 seconds
   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds
   *
   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.
   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Sampled observable sequence.
   */
  observableProto.sample = function (intervalOrSampler, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return typeof intervalOrSampler === 'number' ? new SampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : new SampleObservable(this, intervalOrSampler);
  };

  var TimeoutError = Rx.TimeoutError = function (message) {
    this.message = message || 'Timeout has occurred';
    this.name = 'TimeoutError';
    Error.call(this);
  };
  TimeoutError.prototype = Object.create(Error.prototype);

  function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {
    if (isFunction(firstTimeout)) {
      other = timeoutDurationSelector;
      timeoutDurationSelector = firstTimeout;
      firstTimeout = observableNever();
    }
    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));
    return new AnonymousObservable(function (o) {
      var subscription = new SerialDisposable(),
          timer = new SerialDisposable(),
          original = new SingleAssignmentDisposable();

      subscription.setDisposable(original);

      var id = 0,
          switched = false;

      function setTimer(timeout) {
        var myId = id,
            d = new SingleAssignmentDisposable();

        function timerWins() {
          switched = myId === id;
          return switched;
        }

        timer.setDisposable(d);
        d.setDisposable(timeout.subscribe(function () {
          timerWins() && subscription.setDisposable(other.subscribe(o));
          d.dispose();
        }, function (e) {
          timerWins() && o.onError(e);
        }, function () {
          timerWins() && subscription.setDisposable(other.subscribe(o));
        }));
      };

      setTimer(firstTimeout);

      function oWins() {
        var res = !switched;
        if (res) {
          id++;
        }
        return res;
      }

      original.setDisposable(source.subscribe(function (x) {
        if (oWins()) {
          o.onNext(x);
          var timeout = tryCatch(timeoutDurationSelector)(x);
          if (timeout === errorObj) {
            return o.onError(timeout.e);
          }
          setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
        }
      }, function (e) {
        oWins() && o.onError(e);
      }, function () {
        oWins() && o.onCompleted();
      }));
      return new BinaryDisposable(subscription, timer);
    }, source);
  }

  function timeout(source, dueTime, other, scheduler) {
    if (isScheduler(other)) {
      scheduler = other;
      other = observableThrow(new TimeoutError());
    }
    if (other instanceof Error) {
      other = observableThrow(other);
    }
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));
    return new AnonymousObservable(function (o) {
      var id = 0,
          original = new SingleAssignmentDisposable(),
          subscription = new SerialDisposable(),
          switched = false,
          timer = new SerialDisposable();

      subscription.setDisposable(original);

      function createTimer() {
        var myId = id;
        timer.setDisposable(scheduler.scheduleFuture(null, dueTime, function () {
          switched = id === myId;
          if (switched) {
            isPromise(other) && (other = observableFromPromise(other));
            subscription.setDisposable(other.subscribe(o));
          }
        }));
      }

      createTimer();

      original.setDisposable(source.subscribe(function (x) {
        if (!switched) {
          id++;
          o.onNext(x);
          createTimer();
        }
      }, function (e) {
        if (!switched) {
          id++;
          o.onError(e);
        }
      }, function () {
        if (!switched) {
          id++;
          o.onCompleted();
        }
      }));
      return new BinaryDisposable(subscription, timer);
    }, source);
  }

  observableProto.timeout = function () {
    var firstArg = arguments[0];
    if (firstArg instanceof Date || typeof firstArg === 'number') {
      return timeout(this, firstArg, arguments[1], arguments[2]);
    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
      return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  var GenerateAbsoluteObservable = function (__super__) {
    inherits(GenerateAbsoluteObservable, __super__);
    function GenerateAbsoluteObservable(state, cndFn, itrFn, resFn, timeFn, s) {
      this._state = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._timeFn = timeFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      state.hasResult && state.o.onNext(state.result);

      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }
      state.hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (state.hasResult === errorObj) {
        return state.o.onError(state.hasResult.e);
      }
      if (state.hasResult) {
        state.result = tryCatch(state.self._resFn)(state.newState);
        if (state.result === errorObj) {
          return state.o.onError(state.result.e);
        }
        var time = tryCatch(state.self._timeFn)(state.newState);
        if (time === errorObj) {
          return state.o.onError(time.e);
        }
        recurse(state, time);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateAbsoluteObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        newState: this._state,
        first: true,
        hasResult: false
      };
      return this._s.scheduleRecursiveFuture(state, new Date(this._s.now()), scheduleRecursive);
    };

    return GenerateAbsoluteObservable;
  }(ObservableBase);

  /**
   *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithAbsoluteTime(0,
   *      function (x) { return return true; },
   *      function (x) { return x + 1; },
   *      function (x) { return x; },
   *      function (x) { return new Date(); }
   *  });
   *
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.
   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns {Observable} The generated sequence.
   */
  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
  };

  var GenerateRelativeObservable = function (__super__) {
    inherits(GenerateRelativeObservable, __super__);
    function GenerateRelativeObservable(state, cndFn, itrFn, resFn, timeFn, s) {
      this._state = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._timeFn = timeFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      state.hasResult && state.o.onNext(state.result);

      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }

      state.hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (state.hasResult === errorObj) {
        return state.o.onError(state.hasResult.e);
      }
      if (state.hasResult) {
        state.result = tryCatch(state.self._resFn)(state.newState);
        if (state.result === errorObj) {
          return state.o.onError(state.result.e);
        }
        var time = tryCatch(state.self._timeFn)(state.newState);
        if (time === errorObj) {
          return state.o.onError(time.e);
        }
        recurse(state, time);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateRelativeObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        newState: this._state,
        first: true,
        hasResult: false
      };
      return this._s.scheduleRecursiveFuture(state, 0, scheduleRecursive);
    };

    return GenerateRelativeObservable;
  }(ObservableBase);

  /**
   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithRelativeTime(0,
   *      function (x) { return return true; },
   *      function (x) { return x + 1; },
   *      function (x) { return x; },
   *      function (x) { return 500; }
   *  );
   *
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.
   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns {Observable} The generated sequence.
   */
  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
  };

  var DelaySubscription = function (__super__) {
    inherits(DelaySubscription, __super__);
    function DelaySubscription(source, dt, s) {
      this.source = source;
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    DelaySubscription.prototype.subscribeCore = function (o) {
      var d = new SerialDisposable();

      d.setDisposable(this._s.scheduleFuture([this.source, o, d], this._dt, scheduleMethod));

      return d;
    };

    function scheduleMethod(s, state) {
      var source = state[0],
          o = state[1],
          d = state[2];
      d.setDisposable(source.subscribe(o));
    }

    return DelaySubscription;
  }(ObservableBase);

  /**
   *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
   *
   * @example
   *  1 - res = source.delaySubscription(5000); // 5s
   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds
   *
   * @param {Number} dueTime Relative or absolute time shift of the subscription.
   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Time-shifted sequence.
   */
  observableProto.delaySubscription = function (dueTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new DelaySubscription(this, dueTime, scheduler);
  };

  var SkipLastWithTimeObservable = function (__super__) {
    inherits(SkipLastWithTimeObservable, __super__);
    function SkipLastWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    SkipLastWithTimeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipLastWithTimeObserver(o, this));
    };

    return SkipLastWithTimeObservable;
  }(ObservableBase);

  var SkipLastWithTimeObserver = function (__super__) {
    inherits(SkipLastWithTimeObserver, __super__);

    function SkipLastWithTimeObserver(o, p) {
      this._o = o;
      this._s = p._s;
      this._d = p._d;
      this._q = [];
      __super__.call(this);
    }

    SkipLastWithTimeObserver.prototype.next = function (x) {
      var now = this._s.now();
      this._q.push({ interval: now, value: x });
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._o.onNext(this._q.shift().value);
      }
    };
    SkipLastWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipLastWithTimeObserver.prototype.completed = function () {
      var now = this._s.now();
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._o.onNext(this._q.shift().value);
      }
      this._o.onCompleted();
    };

    return SkipLastWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for skipping elements from the end of the sequence.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout
   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
   */
  observableProto.skipLastWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipLastWithTimeObservable(this, duration, scheduler);
  };

  var TakeLastWithTimeObservable = function (__super__) {
    inherits(TakeLastWithTimeObservable, __super__);
    function TakeLastWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    TakeLastWithTimeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeLastWithTimeObserver(o, this._d, this._s));
    };

    return TakeLastWithTimeObservable;
  }(ObservableBase);

  var TakeLastWithTimeObserver = function (__super__) {
    inherits(TakeLastWithTimeObserver, __super__);

    function TakeLastWithTimeObserver(o, d, s) {
      this._o = o;
      this._d = d;
      this._s = s;
      this._q = [];
      __super__.call(this);
    }

    TakeLastWithTimeObserver.prototype.next = function (x) {
      var now = this._s.now();
      this._q.push({ interval: now, value: x });
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._q.shift();
      }
    };
    TakeLastWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeLastWithTimeObserver.prototype.completed = function () {
      var now = this._s.now();
      while (this._q.length > 0) {
        var next = this._q.shift();
        if (now - next.interval <= this._d) {
          this._o.onNext(next.value);
        }
      }
      this._o.onCompleted();
    };

    return TakeLastWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the end of the sequence.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.
   */
  observableProto.takeLastWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TakeLastWithTimeObservable(this, duration, scheduler);
  };

  /**
   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the end of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.
   */
  observableProto.takeLastBufferWithTime = function (duration, scheduler) {
    var source = this;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new AnonymousObservable(function (o) {
      var q = [];
      return source.subscribe(function (x) {
        var now = scheduler.now();
        q.push({ interval: now, value: x });
        while (q.length > 0 && now - q[0].interval >= duration) {
          q.shift();
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        var now = scheduler.now(),
            res = [];
        while (q.length > 0) {
          var next = q.shift();
          now - next.interval <= duration && res.push(next.value);
        }
        o.onNext(res);
        o.onCompleted();
      });
    }, source);
  };

  var TakeWithTimeObservable = function (__super__) {
    inherits(TakeWithTimeObservable, __super__);
    function TakeWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    function scheduleMethod(s, o) {
      o.onCompleted();
    }

    TakeWithTimeObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._s.scheduleFuture(o, this._d, scheduleMethod), this.source.subscribe(o));
    };

    return TakeWithTimeObservable;
  }(ObservableBase);

  /**
   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   *
   * @example
   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the start of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.
   */
  observableProto.takeWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TakeWithTimeObservable(this, duration, scheduler);
  };

  var SkipWithTimeObservable = function (__super__) {
    inherits(SkipWithTimeObservable, __super__);
    function SkipWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      this._open = false;
      __super__.call(this);
    }

    function scheduleMethod(s, self) {
      self._open = true;
    }

    SkipWithTimeObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._s.scheduleFuture(this, this._d, scheduleMethod), this.source.subscribe(new SkipWithTimeObserver(o, this)));
    };

    return SkipWithTimeObservable;
  }(ObservableBase);

  var SkipWithTimeObserver = function (__super__) {
    inherits(SkipWithTimeObserver, __super__);

    function SkipWithTimeObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipWithTimeObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };
    SkipWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipWithTimeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.
   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded
   *  may not execute immediately, despite the zero due time.
   *
   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.
   * @param {Number} duration Duration for skipping elements from the start of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
   */
  observableProto.skipWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipWithTimeObservable(this, duration, scheduler);
  };

  var SkipUntilWithTimeObservable = function (__super__) {
    inherits(SkipUntilWithTimeObservable, __super__);
    function SkipUntilWithTimeObservable(source, startTime, scheduler) {
      this.source = source;
      this._st = startTime;
      this._s = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(s, state) {
      state._open = true;
    }

    SkipUntilWithTimeObservable.prototype.subscribeCore = function (o) {
      this._open = false;
      return new BinaryDisposable(this._s.scheduleFuture(this, this._st, scheduleMethod), this.source.subscribe(new SkipUntilWithTimeObserver(o, this)));
    };

    return SkipUntilWithTimeObservable;
  }(ObservableBase);

  var SkipUntilWithTimeObserver = function (__super__) {
    inherits(SkipUntilWithTimeObserver, __super__);

    function SkipUntilWithTimeObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipUntilWithTimeObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };
    SkipUntilWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipUntilWithTimeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipUntilWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.
   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.
   *
   * @examples
   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);
   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);
   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.
   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.
   */
  observableProto.skipUntilWithTime = function (startTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipUntilWithTimeObservable(this, startTime, scheduler);
  };

  /**
   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.
   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.
   * @param {Scheduler} [scheduler] Scheduler to run the timer on.
   * @returns {Observable} An observable sequence with the elements taken until the specified end time.
   */
  observableProto.takeUntilWithTime = function (endTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    var source = this;
    return new AnonymousObservable(function (o) {
      return new BinaryDisposable(scheduler.scheduleFuture(o, endTime, function (_, o) {
        o.onCompleted();
      }), source.subscribe(o));
    }, source);
  };

  /**
   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.
   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item
   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.
   * @returns {Observable} An Observable that performs the throttle operation.
   */
  observableProto.throttle = function (windowDuration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    var duration = +windowDuration || 0;
    if (duration <= 0) {
      throw new RangeError('windowDuration cannot be less or equal zero.');
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      var lastOnNext = 0;
      return source.subscribe(function (x) {
        var now = scheduler.now();
        if (lastOnNext === 0 || now - lastOnNext >= duration) {
          lastOnNext = now;
          o.onNext(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        o.onCompleted();
      });
    }, source);
  };

  var TransduceObserver = function (__super__) {
    inherits(TransduceObserver, __super__);
    function TransduceObserver(o, xform) {
      this._o = o;
      this._xform = xform;
      __super__.call(this);
    }

    TransduceObserver.prototype.next = function (x) {
      var res = tryCatch(this._xform['@@transducer/step']).call(this._xform, this._o, x);
      if (res === errorObj) {
        this._o.onError(res.e);
      }
    };

    TransduceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TransduceObserver.prototype.completed = function () {
      this._xform['@@transducer/result'](this._o);
    };

    return TransduceObserver;
  }(AbstractObserver);

  function transformForObserver(o) {
    return {
      '@@transducer/init': function transducerInit() {
        return o;
      },
      '@@transducer/step': function transducerStep(obs, input) {
        return obs.onNext(input);
      },
      '@@transducer/result': function transducerResult(obs) {
        return obs.onCompleted();
      }
    };
  }

  /**
   * Executes a transducer to transform the observable sequence
   * @param {Transducer} transducer A transducer to execute
   * @returns {Observable} An Observable sequence containing the results from the transducer.
   */
  observableProto.transduce = function (transducer) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var xform = transducer(transformForObserver(o));
      return source.subscribe(new TransduceObserver(o, xform));
    }, source);
  };

  var SwitchFirstObservable = function (__super__) {
    inherits(SwitchFirstObservable, __super__);
    function SwitchFirstObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    SwitchFirstObservable.prototype.subscribeCore = function (o) {
      var m = new SingleAssignmentDisposable(),
          g = new CompositeDisposable(),
          state = {
        hasCurrent: false,
        isStopped: false,
        o: o,
        g: g
      };

      g.add(m);
      m.setDisposable(this.source.subscribe(new SwitchFirstObserver(state)));
      return g;
    };

    return SwitchFirstObservable;
  }(ObservableBase);

  var SwitchFirstObserver = function (__super__) {
    inherits(SwitchFirstObserver, __super__);
    function SwitchFirstObserver(state) {
      this._s = state;
      __super__.call(this);
    }

    SwitchFirstObserver.prototype.next = function (x) {
      if (!this._s.hasCurrent) {
        this._s.hasCurrent = true;
        isPromise(x) && (x = observableFromPromise(x));
        var inner = new SingleAssignmentDisposable();
        this._s.g.add(inner);
        inner.setDisposable(x.subscribe(new InnerObserver(this._s, inner)));
      }
    };

    SwitchFirstObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    SwitchFirstObserver.prototype.completed = function () {
      this._s.isStopped = true;
      !this._s.hasCurrent && this._s.g.length === 1 && this._s.o.onCompleted();
    };

    inherits(InnerObserver, __super__);
    function InnerObserver(state, inner) {
      this._s = state;
      this._i = inner;
      __super__.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this._s.g.remove(this._i);
      this._s.hasCurrent = false;
      this._s.isStopped && this._s.g.length === 1 && this._s.o.onCompleted();
    };

    return SwitchFirstObserver;
  }(AbstractObserver);

  /**
   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.
   */
  observableProto.switchFirst = function () {
    return new SwitchFirstObservable(this);
  };

  observableProto.flatMapFirst = observableProto.exhaustMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
  };

  observableProto.flatMapWithMaxConcurrent = observableProto.flatMapMaxConcurrent = function (limit, selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
  };

  /** Provides a set of extension methods for virtual time scheduling. */
  var VirtualTimeScheduler = Rx.VirtualTimeScheduler = function (__super__) {
    inherits(VirtualTimeScheduler, __super__);

    /**
     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.
     *
     * @constructor
     * @param {Number} initialClock Initial value for the clock.
     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
     */
    function VirtualTimeScheduler(initialClock, comparer) {
      this.clock = initialClock;
      this.comparer = comparer;
      this.isEnabled = false;
      this.queue = new PriorityQueue(1024);
      __super__.call(this);
    }

    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

    VirtualTimeSchedulerPrototype.now = function () {
      return this.toAbsoluteTime(this.clock);
    };

    VirtualTimeSchedulerPrototype.schedule = function (state, action) {
      return this.scheduleAbsolute(state, this.clock, action);
    };

    VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
      var dt = dueTime instanceof Date ? this.toRelativeTime(dueTime - this.now()) : this.toRelativeTime(dueTime);

      return this.scheduleRelative(state, dt, action);
    };

    /**
     * Adds a relative time value to an absolute time value.
     * @param {Number} absolute Absolute virtual time value.
     * @param {Number} relative Relative virtual time value to add.
     * @return {Number} Resulting absolute virtual time sum value.
     */
    VirtualTimeSchedulerPrototype.add = notImplemented;

    /**
     * Converts an absolute time to a number
     * @param {Any} The absolute time.
     * @returns {Number} The absolute time in ms
     */
    VirtualTimeSchedulerPrototype.toAbsoluteTime = notImplemented;

    /**
     * Converts the TimeSpan value to a relative virtual time value.
     * @param {Number} timeSpan TimeSpan value to convert.
     * @return {Number} Corresponding relative virtual time value.
     */
    VirtualTimeSchedulerPrototype.toRelativeTime = notImplemented;

    /**
     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.
     * @param {Mixed} state Initial state passed to the action upon the first iteration.
     * @param {Number} period Period for running the work periodically.
     * @param {Function} action Action to be executed, potentially updating the state.
     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
     */
    VirtualTimeSchedulerPrototype.schedulePeriodic = function (state, period, action) {
      var s = new SchedulePeriodicRecursive(this, state, period, action);
      return s.start();
    };

    /**
     * Schedules an action to be executed after dueTime.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Number} dueTime Relative time after which to execute the action.
     * @param {Function} action Action to be executed.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    VirtualTimeSchedulerPrototype.scheduleRelative = function (state, dueTime, action) {
      var runAt = this.add(this.clock, dueTime);
      return this.scheduleAbsolute(state, runAt, action);
    };

    /**
     * Starts the virtual time scheduler.
     */
    VirtualTimeSchedulerPrototype.start = function () {
      if (!this.isEnabled) {
        this.isEnabled = true;
        do {
          var next = this.getNext();
          if (next !== null) {
            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
            next.invoke();
          } else {
            this.isEnabled = false;
          }
        } while (this.isEnabled);
      }
    };

    /**
     * Stops the virtual time scheduler.
     */
    VirtualTimeSchedulerPrototype.stop = function () {
      this.isEnabled = false;
    };

    /**
     * Advances the scheduler's clock to the specified time, running all work till that point.
     * @param {Number} time Absolute time to advance the scheduler's clock to.
     */
    VirtualTimeSchedulerPrototype.advanceTo = function (time) {
      var dueToClock = this.comparer(this.clock, time);
      if (this.comparer(this.clock, time) > 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (dueToClock === 0) {
        return;
      }
      if (!this.isEnabled) {
        this.isEnabled = true;
        do {
          var next = this.getNext();
          if (next !== null && this.comparer(next.dueTime, time) <= 0) {
            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
            next.invoke();
          } else {
            this.isEnabled = false;
          }
        } while (this.isEnabled);
        this.clock = time;
      }
    };

    /**
     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.
     * @param {Number} time Relative time to advance the scheduler's clock by.
     */
    VirtualTimeSchedulerPrototype.advanceBy = function (time) {
      var dt = this.add(this.clock, time),
          dueToClock = this.comparer(this.clock, dt);
      if (dueToClock > 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (dueToClock === 0) {
        return;
      }

      this.advanceTo(dt);
    };

    /**
     * Advances the scheduler's clock by the specified relative time.
     * @param {Number} time Relative time to advance the scheduler's clock by.
     */
    VirtualTimeSchedulerPrototype.sleep = function (time) {
      var dt = this.add(this.clock, time);
      if (this.comparer(this.clock, dt) >= 0) {
        throw new ArgumentOutOfRangeError();
      }

      this.clock = dt;
    };

    /**
     * Gets the next scheduled item to be executed.
     * @returns {ScheduledItem} The next scheduled item.
     */
    VirtualTimeSchedulerPrototype.getNext = function () {
      while (this.queue.length > 0) {
        var next = this.queue.peek();
        if (next.isCancelled()) {
          this.queue.dequeue();
        } else {
          return next;
        }
      }
      return null;
    };

    /**
     * Schedules an action to be executed at dueTime.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Number} dueTime Absolute time at which to execute the action.
     * @param {Function} action Action to be executed.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (state, dueTime, action) {
      var self = this;

      function run(scheduler, state1) {
        self.queue.remove(si);
        return action(scheduler, state1);
      }

      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
      this.queue.enqueue(si);

      return si.disposable;
    };

    return VirtualTimeScheduler;
  }(Scheduler);

  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */
  Rx.HistoricalScheduler = function (__super__) {
    inherits(HistoricalScheduler, __super__);

    /**
     * Creates a new historical scheduler with the specified initial clock value.
     * @constructor
     * @param {Number} initialClock Initial value for the clock.
     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
     */
    function HistoricalScheduler(initialClock, comparer) {
      var clock = initialClock == null ? 0 : initialClock;
      var cmp = comparer || defaultSubComparer;
      __super__.call(this, clock, cmp);
    }

    var HistoricalSchedulerProto = HistoricalScheduler.prototype;

    /**
     * Adds a relative time value to an absolute time value.
     * @param {Number} absolute Absolute virtual time value.
     * @param {Number} relative Relative virtual time value to add.
     * @return {Number} Resulting absolute virtual time sum value.
     */
    HistoricalSchedulerProto.add = function (absolute, relative) {
      return absolute + relative;
    };

    HistoricalSchedulerProto.toAbsoluteTime = function (absolute) {
      return new Date(absolute).getTime();
    };

    /**
     * Converts the TimeSpan value to a relative virtual time value.
     * @memberOf HistoricalScheduler
     * @param {Number} timeSpan TimeSpan value to convert.
     * @return {Number} Corresponding relative virtual time value.
     */
    HistoricalSchedulerProto.toRelativeTime = function (timeSpan) {
      return timeSpan;
    };

    return HistoricalScheduler;
  }(Rx.VirtualTimeScheduler);

  function OnNextPredicate(predicate) {
    this.predicate = predicate;
  }

  OnNextPredicate.prototype.equals = function (other) {
    if (other === this) {
      return true;
    }
    if (other == null) {
      return false;
    }
    if (other.kind !== 'N') {
      return false;
    }
    return this.predicate(other.value);
  };

  function OnErrorPredicate(predicate) {
    this.predicate = predicate;
  }

  OnErrorPredicate.prototype.equals = function (other) {
    if (other === this) {
      return true;
    }
    if (other == null) {
      return false;
    }
    if (other.kind !== 'E') {
      return false;
    }
    return this.predicate(other.error);
  };

  var ReactiveTest = Rx.ReactiveTest = {
    /** Default virtual time used for creation of observable sequences in unit tests. */
    created: 100,
    /** Default virtual time used to subscribe to observable sequences in unit tests. */
    subscribed: 200,
    /** Default virtual time used to dispose subscriptions in unit tests. */
    disposed: 1000,

    /**
     * Factory method for an OnNext notification record at a given time with a given value or a predicate function.
     *
     * 1 - ReactiveTest.onNext(200, 42);
     * 2 - ReactiveTest.onNext(200, function (x) { return x.length == 2; });
     *
     * @param ticks Recorded virtual time the OnNext notification occurs.
     * @param value Recorded value stored in the OnNext notification or a predicate.
     * @return Recorded OnNext notification.
     */
    onNext: function onNext(ticks, value) {
      return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
    },
    /**
     * Factory method for an OnError notification record at a given time with a given error.
     *
     * 1 - ReactiveTest.onNext(200, new Error('error'));
     * 2 - ReactiveTest.onNext(200, function (e) { return e.message === 'error'; });
     *
     * @param ticks Recorded virtual time the OnError notification occurs.
     * @param exception Recorded exception stored in the OnError notification.
     * @return Recorded OnError notification.
     */
    onError: function onError(ticks, error) {
      return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
    },
    /**
     * Factory method for an OnCompleted notification record at a given time.
     *
     * @param ticks Recorded virtual time the OnCompleted notification occurs.
     * @return Recorded OnCompleted notification.
     */
    onCompleted: function onCompleted(ticks) {
      return new Recorded(ticks, Notification.createOnCompleted());
    },
    /**
     * Factory method for a subscription record based on a given subscription and disposal time.
     *
     * @param start Virtual time indicating when the subscription was created.
     * @param end Virtual time indicating when the subscription was disposed.
     * @return Subscription object.
     */
    subscribe: function subscribe(start, end) {
      return new Subscription(start, end);
    }
  };

  /**
   * Creates a new object recording the production of the specified value at the given virtual time.
   *
   * @constructor
   * @param {Number} time Virtual time the value was produced on.
   * @param {Mixed} value Value that was produced.
   * @param {Function} comparer An optional comparer.
   */
  var Recorded = Rx.Recorded = function (time, value, comparer) {
    this.time = time;
    this.value = value;
    this.comparer = comparer || defaultComparer;
  };

  /**
   * Checks whether the given recorded object is equal to the current instance.
   *
   * @param {Recorded} other Recorded object to check for equality.
   * @returns {Boolean} true if both objects are equal; false otherwise.
   */
  Recorded.prototype.equals = function (other) {
    return this.time === other.time && this.comparer(this.value, other.value);
  };

  /**
   * Returns a string representation of the current Recorded value.
   *
   * @returns {String} String representation of the current Recorded value.
   */
  Recorded.prototype.toString = function () {
    return this.value.toString() + '@' + this.time;
  };

  /**
   * Creates a new subscription object with the given virtual subscription and unsubscription time.
   *
   * @constructor
   * @param {Number} subscribe Virtual time at which the subscription occurred.
   * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.
   */
  var Subscription = Rx.Subscription = function (start, end) {
    this.subscribe = start;
    this.unsubscribe = end || Number.MAX_VALUE;
  };

  /**
   * Checks whether the given subscription is equal to the current instance.
   * @param other Subscription object to check for equality.
   * @returns {Boolean} true if both objects are equal; false otherwise.
   */
  Subscription.prototype.equals = function (other) {
    return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
  };

  /**
   * Returns a string representation of the current Subscription value.
   * @returns {String} String representation of the current Subscription value.
   */
  Subscription.prototype.toString = function () {
    return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
  };

  var MockDisposable = Rx.MockDisposable = function (scheduler) {
    this.scheduler = scheduler;
    this.disposes = [];
    this.disposes.push(this.scheduler.clock);
  };

  MockDisposable.prototype.dispose = function () {
    this.disposes.push(this.scheduler.clock);
  };

  var MockObserver = function (__super__) {
    inherits(MockObserver, __super__);

    function MockObserver(scheduler) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = [];
    }

    var MockObserverPrototype = MockObserver.prototype;

    MockObserverPrototype.onNext = function (value) {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
    };

    MockObserverPrototype.onError = function (e) {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(e)));
    };

    MockObserverPrototype.onCompleted = function () {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
    };

    return MockObserver;
  }(Observer);

  function MockPromise(scheduler, messages) {
    var self = this;
    this.scheduler = scheduler;
    this.messages = messages;
    this.subscriptions = [];
    this.observers = [];
    for (var i = 0, len = this.messages.length; i < len; i++) {
      var message = this.messages[i],
          notification = message.value;
      (function (innerNotification) {
        scheduler.scheduleAbsolute(null, message.time, function () {
          var obs = self.observers.slice(0);

          for (var j = 0, jLen = obs.length; j < jLen; j++) {
            innerNotification.accept(obs[j]);
          }
          return disposableEmpty;
        });
      })(notification);
    }
  }

  MockPromise.prototype.then = function (onResolved, onRejected) {
    var self = this;

    this.subscriptions.push(new Subscription(this.scheduler.clock));
    var index = this.subscriptions.length - 1;

    var newPromise;

    var observer = Rx.Observer.create(function (x) {
      var retValue = onResolved(x);
      if (retValue && typeof retValue.then === 'function') {
        newPromise = retValue;
      } else {
        var ticks = self.scheduler.clock;
        newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
      }
      var idx = self.observers.indexOf(observer);
      self.observers.splice(idx, 1);
      self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
    }, function (err) {
      onRejected(err);
      var idx = self.observers.indexOf(observer);
      self.observers.splice(idx, 1);
      self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
    });
    this.observers.push(observer);

    return newPromise || new MockPromise(this.scheduler, this.messages);
  };

  var HotObservable = function (__super__) {
    inherits(HotObservable, __super__);

    function HotObservable(scheduler, messages) {
      __super__.call(this);
      var message,
          notification,
          observable = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0, len = this.messages.length; i < len; i++) {
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) {
          scheduler.scheduleAbsolute(null, message.time, function () {
            var obs = observable.observers.slice(0);

            for (var j = 0, jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }

    HotObservable.prototype._subscribe = function (o) {
      var observable = this;
      this.observers.push(o);
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      return disposableCreate(function () {
        var idx = observable.observers.indexOf(o);
        observable.observers.splice(idx, 1);
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
      });
    };

    return HotObservable;
  }(Observable);

  var ColdObservable = function (__super__) {
    inherits(ColdObservable, __super__);

    function ColdObservable(scheduler, messages) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
    }

    ColdObservable.prototype._subscribe = function (o) {
      var message,
          notification,
          observable = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var d = new CompositeDisposable();
      for (var i = 0, len = this.messages.length; i < len; i++) {
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) {
          d.add(observable.scheduler.scheduleRelative(null, message.time, function () {
            innerNotification.accept(o);
            return disposableEmpty;
          }));
        })(notification);
      }
      return disposableCreate(function () {
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        d.dispose();
      });
    };

    return ColdObservable;
  }(Observable);

  /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */
  Rx.TestScheduler = function (__super__) {
    inherits(TestScheduler, __super__);

    function baseComparer(x, y) {
      return x > y ? 1 : x < y ? -1 : 0;
    }

    function TestScheduler() {
      __super__.call(this, 0, baseComparer);
    }

    /**
     * Schedules an action to be executed at the specified virtual time.
     *
     * @param state State passed to the action to be executed.
     * @param dueTime Absolute virtual time at which to execute the action.
     * @param action Action to be executed.
     * @return Disposable object used to cancel the scheduled action (best effort).
     */
    TestScheduler.prototype.scheduleAbsolute = function (state, dueTime, action) {
      dueTime <= this.clock && (dueTime = this.clock + 1);
      return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);
    };
    /**
     * Adds a relative virtual time to an absolute virtual time value.
     *
     * @param absolute Absolute virtual time value.
     * @param relative Relative virtual time value to add.
     * @return Resulting absolute virtual time sum value.
     */
    TestScheduler.prototype.add = function (absolute, relative) {
      return absolute + relative;
    };
    /**
     * Converts the absolute virtual time value to a DateTimeOffset value.
     *
     * @param absolute Absolute virtual time value to convert.
     * @return Corresponding DateTimeOffset value.
     */
    TestScheduler.prototype.toAbsoluteTime = function (absolute) {
      return new Date(absolute).getTime();
    };
    /**
     * Converts the TimeSpan value to a relative virtual time value.
     *
     * @param timeSpan TimeSpan value to convert.
     * @return Corresponding relative virtual time value.
     */
    TestScheduler.prototype.toRelativeTime = function (timeSpan) {
      return timeSpan;
    };
    /**
     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
     *
     * @param create Factory method to create an observable sequence.
     * @param created Virtual time at which to invoke the factory to create an observable sequence.
     * @param subscribed Virtual time at which to subscribe to the created observable sequence.
     * @param disposed Virtual time at which to dispose the subscription.
     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.
     */
    TestScheduler.prototype.startScheduler = function (createFn, settings) {
      settings || (settings = {});
      settings.created == null && (settings.created = ReactiveTest.created);
      settings.subscribed == null && (settings.subscribed = ReactiveTest.subscribed);
      settings.disposed == null && (settings.disposed = ReactiveTest.disposed);

      var observer = this.createObserver(),
          source,
          subscription;

      this.scheduleAbsolute(null, settings.created, function () {
        source = createFn();
        return disposableEmpty;
      });

      this.scheduleAbsolute(null, settings.subscribed, function () {
        subscription = source.subscribe(observer);
        return disposableEmpty;
      });

      this.scheduleAbsolute(null, settings.disposed, function () {
        subscription.dispose();
        return disposableEmpty;
      });

      this.start();

      return observer;
    };

    /**
     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.
     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createHotObservable = function () {
      var len = arguments.length,
          args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return new HotObservable(this, args);
    };

    /**
     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.
     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createColdObservable = function () {
      var len = arguments.length,
          args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return new ColdObservable(this, args);
    };

    /**
     * Creates a resolved promise with the given value and ticks
     * @param {Number} ticks The absolute time of the resolution.
     * @param {Any} value The value to yield at the given tick.
     * @returns {MockPromise} A mock Promise which fulfills with the given value.
     */
    TestScheduler.prototype.createResolvedPromise = function (ticks, value) {
      return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
    };

    /**
     * Creates a rejected promise with the given reason and ticks
     * @param {Number} ticks The absolute time of the resolution.
     * @param {Any} reason The reason for rejection to yield at the given tick.
     * @returns {MockPromise} A mock Promise which rejects with the given reason.
     */
    TestScheduler.prototype.createRejectedPromise = function (ticks, reason) {
      return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
    };

    /**
     * Creates an observer that records received notification messages and timestamps those.
     * @return Observer that can be used to assert the timing of received notifications.
     */
    TestScheduler.prototype.createObserver = function () {
      return new MockObserver(this);
    };

    return TestScheduler;
  }(VirtualTimeScheduler);

  var AnonymousObservable = Rx.AnonymousObservable = function (__super__) {
    inherits(AnonymousObservable, __super__);

    // Fix subscriber to check for undefined or function returned to decorate as Disposable
    function fixSubscriber(subscriber) {
      return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
    }

    function setDisposable(s, state) {
      var ado = state[0],
          self = state[1];
      var sub = tryCatch(self.__subscribe).call(self, ado);
      if (sub === errorObj && !ado.fail(errorObj.e)) {
        thrower(errorObj.e);
      }
      ado.setDisposable(fixSubscriber(sub));
    }

    function AnonymousObservable(subscribe, parent) {
      this.source = parent;
      this.__subscribe = subscribe;
      __super__.call(this);
    }

    AnonymousObservable.prototype._subscribe = function (o) {
      var ado = new AutoDetachObserver(o),
          state = [ado, this];

      if (currentThreadScheduler.scheduleRequired()) {
        currentThreadScheduler.schedule(state, setDisposable);
      } else {
        setDisposable(null, state);
      }
      return ado;
    };

    return AnonymousObservable;
  }(Observable);

  var AutoDetachObserver = function (__super__) {
    inherits(AutoDetachObserver, __super__);

    function AutoDetachObserver(observer) {
      __super__.call(this);
      this.observer = observer;
      this.m = new SingleAssignmentDisposable();
    }

    var AutoDetachObserverPrototype = AutoDetachObserver.prototype;

    AutoDetachObserverPrototype.next = function (value) {
      var result = tryCatch(this.observer.onNext).call(this.observer, value);
      if (result === errorObj) {
        this.dispose();
        thrower(result.e);
      }
    };

    AutoDetachObserverPrototype.error = function (err) {
      var result = tryCatch(this.observer.onError).call(this.observer, err);
      this.dispose();
      result === errorObj && thrower(result.e);
    };

    AutoDetachObserverPrototype.completed = function () {
      var result = tryCatch(this.observer.onCompleted).call(this.observer);
      this.dispose();
      result === errorObj && thrower(result.e);
    };

    AutoDetachObserverPrototype.setDisposable = function (value) {
      this.m.setDisposable(value);
    };
    AutoDetachObserverPrototype.getDisposable = function () {
      return this.m.getDisposable();
    };

    AutoDetachObserverPrototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this.m.dispose();
    };

    return AutoDetachObserver;
  }(AbstractObserver);

  var UnderlyingObservable = function (__super__) {
    inherits(UnderlyingObservable, __super__);
    function UnderlyingObservable(m, u) {
      this._m = m;
      this._u = u;
      __super__.call(this);
    }

    UnderlyingObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._m.getDisposable(), this._u.subscribe(o));
    };

    return UnderlyingObservable;
  }(ObservableBase);

  var GroupedObservable = function (__super__) {
    inherits(GroupedObservable, __super__);
    function GroupedObservable(key, underlyingObservable, mergedDisposable) {
      __super__.call(this);
      this.key = key;
      this.underlyingObservable = !mergedDisposable ? underlyingObservable : new UnderlyingObservable(mergedDisposable, underlyingObservable);
    }

    GroupedObservable.prototype._subscribe = function (o) {
      return this.underlyingObservable.subscribe(o);
    };

    return GroupedObservable;
  }(Observable);

  /**
   *  Represents an object that is both an observable sequence as well as an observer.
   *  Each notification is broadcasted to all subscribed observers.
   */
  var Subject = Rx.Subject = function (__super__) {
    inherits(Subject, __super__);
    function Subject() {
      __super__.call(this);
      this.isDisposed = false;
      this.isStopped = false;
      this.observers = [];
      this.hasError = false;
    }

    addProperties(Subject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(o);
          return new InnerSubscription(this, o);
        }
        if (this.hasError) {
          o.onError(this.error);
          return disposableEmpty;
        }
        o.onCompleted();
        return disposableEmpty;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onCompleted();
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onError(error);
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (!this.isStopped) {
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        }
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
      }
    });

    /**
     * Creates a subject from the specified observer and observable.
     * @param {Observer} observer The observer used to send messages to the subject.
     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.
     * @returns {Subject} Subject implemented using the given observer and observable.
     */
    Subject.create = function (observer, observable) {
      return new AnonymousSubject(observer, observable);
    };

    return Subject;
  }(Observable);

  /**
   *  Represents the result of an asynchronous operation.
   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
   */
  var AsyncSubject = Rx.AsyncSubject = function (__super__) {
    inherits(AsyncSubject, __super__);

    /**
     * Creates a subject that can only receive one value and that value is cached for all future observations.
     * @constructor
     */
    function AsyncSubject() {
      __super__.call(this);
      this.isDisposed = false;
      this.isStopped = false;
      this.hasValue = false;
      this.observers = [];
      this.hasError = false;
    }

    addProperties(AsyncSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);

        if (!this.isStopped) {
          this.observers.push(o);
          return new InnerSubscription(this, o);
        }

        if (this.hasError) {
          o.onError(this.error);
        } else if (this.hasValue) {
          o.onNext(this.value);
          o.onCompleted();
        } else {
          o.onCompleted();
        }

        return disposableEmpty;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
       */
      onCompleted: function onCompleted() {
        var i, len;
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          var os = cloneArray(this.observers),
              len = os.length;

          if (this.hasValue) {
            for (i = 0; i < len; i++) {
              var o = os[i];
              o.onNext(this.value);
              o.onCompleted();
            }
          } else {
            for (i = 0; i < len; i++) {
              os[i].onCompleted();
            }
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the error.
       * @param {Mixed} error The Error to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasError = true;
          this.error = error;

          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onError(error);
          }

          this.observers.length = 0;
        }
      },
      /**
       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
       * @param {Mixed} value The value to store in the subject.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.value = value;
        this.hasValue = true;
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
        this.error = null;
        this.value = null;
      }
    });

    return AsyncSubject;
  }(Observable);

  /**
   *  Represents a value that changes over time.
   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
   */
  var BehaviorSubject = Rx.BehaviorSubject = function (__super__) {
    inherits(BehaviorSubject, __super__);
    function BehaviorSubject(value) {
      __super__.call(this);
      this.value = value;
      this.observers = [];
      this.isDisposed = false;
      this.isStopped = false;
      this.hasError = false;
    }

    addProperties(BehaviorSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(o);
          o.onNext(this.value);
          return new InnerSubscription(this, o);
        }
        if (this.hasError) {
          o.onError(this.error);
        } else {
          o.onCompleted();
        }
        return disposableEmpty;
      },
      /**
       * Gets the current value or throws an exception.
       * Value is frozen after onCompleted is called.
       * After onError is called always throws the specified exception.
       * An exception is always thrown after dispose is called.
       * @returns {Mixed} The initial value passed to the constructor until onNext is called; after which, the last value passed to onNext.
       */
      getValue: function getValue() {
        checkDisposed(this);
        if (this.hasError) {
          thrower(this.error);
        }
        return this.value;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onCompleted();
        }

        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.hasError = true;
        this.error = error;

        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onError(error);
        }

        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.value = value;
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onNext(value);
        }
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
        this.value = null;
        this.error = null;
      }
    });

    return BehaviorSubject;
  }(Observable);

  /**
   * Represents an object that is both an observable sequence as well as an observer.
   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
   */
  var ReplaySubject = Rx.ReplaySubject = function (__super__) {

    var maxSafeInteger = Math.pow(2, 53) - 1;

    function createRemovableDisposable(subject, observer) {
      return disposableCreate(function () {
        observer.dispose();
        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
      });
    }

    inherits(ReplaySubject, __super__);

    /**
     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.
     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.
     *  @param {Number} [windowSize] Maximum time length of the replay buffer.
     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.
     */
    function ReplaySubject(bufferSize, windowSize, scheduler) {
      this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
      this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
      this.scheduler = scheduler || currentThreadScheduler;
      this.q = [];
      this.observers = [];
      this.isStopped = false;
      this.isDisposed = false;
      this.hasError = false;
      this.error = null;
      __super__.call(this);
    }

    addProperties(ReplaySubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        var so = new ScheduledObserver(this.scheduler, o),
            subscription = createRemovableDisposable(this, so);

        this._trim(this.scheduler.now());
        this.observers.push(so);

        for (var i = 0, len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }

        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }

        so.ensureActive();
        return subscription;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      _trim: function _trim(now) {
        while (this.q.length > this.bufferSize) {
          this.q.shift();
        }
        while (this.q.length > 0 && now - this.q[0].interval > this.windowSize) {
          this.q.shift();
        }
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        var now = this.scheduler.now();
        this.q.push({ interval: now, value: value });
        this._trim(now);

        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onNext(value);
          observer.ensureActive();
        }
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.error = error;
        this.hasError = true;
        var now = this.scheduler.now();
        this._trim(now);
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onError(error);
          observer.ensureActive();
        }
        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        var now = this.scheduler.now();
        this._trim(now);
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onCompleted();
          observer.ensureActive();
        }
        this.observers.length = 0;
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
      }
    });

    return ReplaySubject;
  }(Observable);

  var AnonymousSubject = Rx.AnonymousSubject = function (__super__) {
    inherits(AnonymousSubject, __super__);
    function AnonymousSubject(observer, observable) {
      this.observer = observer;
      this.observable = observable;
      __super__.call(this);
    }

    addProperties(AnonymousSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        return this.observable.subscribe(o);
      },
      onCompleted: function onCompleted() {
        this.observer.onCompleted();
      },
      onError: function onError(error) {
        this.observer.onError(error);
      },
      onNext: function onNext(value) {
        this.observer.onNext(value);
      }
    });

    return AnonymousSubject;
  }(Observable);

  /**
  * Used to pause and resume streams.
  */
  Rx.Pauser = function (__super__) {
    inherits(Pauser, __super__);
    function Pauser() {
      __super__.call(this);
    }

    /**
     * Pauses the underlying sequence.
     */
    Pauser.prototype.pause = function () {
      this.onNext(false);
    };

    /**
    * Resumes the underlying sequence.
    */
    Pauser.prototype.resume = function () {
      this.onNext(true);
    };

    return Pauser;
  }(Subject);

  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
    root.Rx = Rx;

    define(function () {
      return Rx;
    });
  } else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = Rx).Rx = Rx;
    } else {
      freeExports.Rx = Rx;
    }
  } else {
    // in a browser or Rhino
    root.Rx = Rx;
  }

  // All code before this point will be filtered from stack traces.
  var rEndingLine = captureLine();
}).call(undefined);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":108}],124:[function(require,module,exports){
'use strict';

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

},{"buffer":3}],125:[function(require,module,exports){
'use strict';

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":30,"readable-stream/duplex.js":110,"readable-stream/passthrough.js":119,"readable-stream/readable.js":120,"readable-stream/transform.js":121,"readable-stream/writable.js":122}],126:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":124}],127:[function(require,module,exports){
"use strict";

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function () /*varargs*/{
    this._defaults.push({ fn: fn, arguments: arguments });
    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, def.arguments);
  });
};

module.exports = Agent;

},{}],128:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = undefined;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop() {};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function (method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  } else {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP.6.0');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP.3.0');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return (/[\/+]json($|[^-\w])/.test(mime)
  );
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function (user, pass, options) {
  if (1 === arguments.length) pass = '';
  if ((typeof pass === 'undefined' ? 'undefined' : _typeof(pass)) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function (val) {
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function () {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function () {
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch (e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function () {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function (url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":127,"./is-object":129,"./request-base":130,"./response-base":131,"component-emitter":4}],129:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(obj) {
  return null !== obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj));
}

module.exports = isObject;

},{}],130:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options) {
  if (!options || 'object' !== (typeof options === 'undefined' ? 'undefined' : _typeof(options))) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function () {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function (n) {
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data ? this._data + '&' + data : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function () {
  console.trace("Unsupported");
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":129}],131:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util

  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct);

  // params
  var params = utils.params(ct);
  for (var key in params) {
    this[key] = params[key];
  }this.links = {};

  // links
  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {
    // ignore
  }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.redirect = 3 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = 4 == type || 5 == type ? this.toError() : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.forbidden = 403 == status;
  this.notFound = 404 == status;
};

},{"./utils":132}],132:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],133:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],134:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:54 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("regions", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.regions = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.regions = t());
}(window, function () {
  return function (r) {
    var n = {};function i(e) {
      if (n[e]) return n[e].exports;var t = n[e] = { i: e, l: !1, exports: {} };return r[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
    }return i.m = r, i.c = n, i.d = function (e, t, r) {
      i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r });
    }, i.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, i.t = function (t, e) {
      if (1 & e && (t = i(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var r = Object.create(null);if (i.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var n in t) {
        i.d(r, n, function (e) {
          return t[e];
        }.bind(null, n));
      }return r;
    }, i.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return i.d(t, "a", t), t;
    }, i.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, i.p = "localhost:8080/dist/plugin/", i(i.s = 2);
  }({ 2: function _(e, t, r) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function n(e, t) {
        for (var r = 0; r < t.length; r++) {
          var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
      }function s(e, t, r) {
        return t && n(e.prototype, t), r && n(e, r), e;
      }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var a = function () {
        function n(e, t) {
          var r = this;i(this, n), this.wavesurfer = t, this.wrapper = t.drawer.wrapper, this.util = t.util, this.style = this.util.style, this.id = null == e.id ? t.util.getId() : e.id, this.start = Number(e.start) || 0, this.end = null == e.end ? this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(e.end), this.resize = void 0 === e.resize || Boolean(e.resize), this.drag = void 0 === e.drag || Boolean(e.drag), this.loop = Boolean(e.loop), this.color = e.color || "rgba(0, 0, 0, 0.1)", this.data = e.data || {}, this.attributes = e.attributes || {}, this.maxLength = e.maxLength, this.minLength = e.minLength, this._onRedraw = function () {
            return r.updateRender();
          }, this.scroll = !1 !== e.scroll && t.params.scrollParent, this.scrollSpeed = e.scrollSpeed || 1, this.scrollThreshold = e.scrollThreshold || 10, this.bindInOut(), this.render(), this.wavesurfer.on("zoom", this._onRedraw), this.wavesurfer.on("redraw", this._onRedraw), this.wavesurfer.fireEvent("region-created", this);
        }return s(n, [{ key: "update", value: function value(e) {
            null != e.start && (this.start = Number(e.start)), null != e.end && (this.end = Number(e.end)), null != e.loop && (this.loop = Boolean(e.loop)), null != e.color && (this.color = e.color), null != e.data && (this.data = e.data), null != e.resize && (this.resize = Boolean(e.resize)), null != e.drag && (this.drag = Boolean(e.drag)), null != e.maxLength && (this.maxLength = Number(e.maxLength)), null != e.minLength && (this.minLength = Number(e.minLength)), null != e.attributes && (this.attributes = e.attributes), this.updateRender(), this.fireEvent("update"), this.wavesurfer.fireEvent("region-updated", this);
          } }, { key: "remove", value: function value() {
            this.element && (this.wrapper.removeChild(this.element), this.element = null, this.fireEvent("remove"), this.wavesurfer.un("zoom", this._onRedraw), this.wavesurfer.un("redraw", this._onRedraw), this.wavesurfer.fireEvent("region-removed", this));
          } }, { key: "play", value: function value() {
            this.wavesurfer.play(this.start, this.end), this.fireEvent("play"), this.wavesurfer.fireEvent("region-play", this);
          } }, { key: "playLoop", value: function value() {
            var e = this;this.play(), this.once("out", function () {
              return e.playLoop();
            });
          } }, { key: "render", value: function value() {
            var e = document.createElement("region");for (var t in e.className = "wavesurfer-region", e.title = this.formatTime(this.start, this.end), e.setAttribute("data-id", this.id), this.attributes) {
              e.setAttribute("data-region-" + t, this.attributes[t]);
            }this.wrapper.scrollWidth;if (this.style(e, { position: "absolute", zIndex: 2, height: "100%", top: "0px" }), this.resize) {
              var r = e.appendChild(document.createElement("handle")),
                  n = e.appendChild(document.createElement("handle"));r.className = "wavesurfer-handle wavesurfer-handle-start", n.className = "wavesurfer-handle wavesurfer-handle-end";var i = { cursor: "col-resize", position: "absolute", left: "0px", top: "0px", width: "1%", maxWidth: "4px", height: "100%" };this.style(r, i), this.style(n, i), this.style(n, { left: "100%" });
            }this.element = this.wrapper.appendChild(e), this.updateRender(), this.bindEvents(e);
          } }, { key: "formatTime", value: function value(e, t) {
            return (e == t ? [e] : [e, t]).map(function (e) {
              return [Math.floor(e % 3600 / 60), ("00" + Math.floor(e % 60)).slice(-2)].join(":");
            }).join("-");
          } }, { key: "getWidth", value: function value() {
            return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
          } }, { key: "updateRender", value: function value() {
            var e = this.wavesurfer.getDuration(),
                t = this.getWidth();if (this.start < 0 && (this.start = 0, this.end = this.end - this.start), this.end > e && (this.end = e, this.start = e - (this.end - this.start)), null != this.minLength && (this.end = Math.max(this.start + this.minLength, this.end)), null != this.maxLength && (this.end = Math.min(this.start + this.maxLength, this.end)), null != this.element) {
              var r = Math.round(this.start / e * t),
                  n = Math.round(this.end / e * t) - r;for (var i in this.style(this.element, { left: r + "px", width: n + "px", backgroundColor: this.color, cursor: this.drag ? "move" : "default" }), this.attributes) {
                this.element.setAttribute("data-region-" + i, this.attributes[i]);
              }this.element.title = this.formatTime(this.start, this.end);
            }
          } }, { key: "bindInOut", value: function value() {
            var t = this;this.firedIn = !1, this.firedOut = !1;var e = function e(_e) {
              !t.firedOut && t.firedIn && (t.start >= Math.round(100 * _e) / 100 || t.end <= Math.round(100 * _e) / 100) && (t.firedOut = !0, t.firedIn = !1, t.fireEvent("out"), t.wavesurfer.fireEvent("region-out", t)), !t.firedIn && t.start <= _e && t.end > _e && (t.firedIn = !0, t.firedOut = !1, t.fireEvent("in"), t.wavesurfer.fireEvent("region-in", t));
            };this.wavesurfer.backend.on("audioprocess", e), this.on("remove", function () {
              t.wavesurfer.backend.un("audioprocess", e);
            }), this.on("out", function () {
              t.loop && t.wavesurfer.play(t.start);
            });
          } }, { key: "bindEvents", value: function value() {
            var o,
                u,
                l,
                d,
                h,
                c,
                f,
                v,
                p,
                m,
                g,
                w,
                e,
                t,
                r,
                y = this;this.element.addEventListener("mouseenter", function (e) {
              y.fireEvent("mouseenter", e), y.wavesurfer.fireEvent("region-mouseenter", y, e);
            }), this.element.addEventListener("mouseleave", function (e) {
              y.fireEvent("mouseleave", e), y.wavesurfer.fireEvent("region-mouseleave", y, e);
            }), this.element.addEventListener("click", function (e) {
              e.preventDefault(), y.fireEvent("click", e), y.wavesurfer.fireEvent("region-click", y, e);
            }), this.element.addEventListener("dblclick", function (e) {
              e.stopPropagation(), e.preventDefault(), y.fireEvent("dblclick", e), y.wavesurfer.fireEvent("region-dblclick", y, e);
            }), (this.drag || this.resize) && (v = y.wavesurfer.drawer.container, p = y.wavesurfer.getDuration(), m = y.scrollSpeed, g = y.scrollThreshold, w = !1, e = function e(_e2) {
              _e2.touches && 1 < _e2.touches.length || (u = _e2.targetTouches ? _e2.targetTouches[0].identifier : null, _e2.stopPropagation(), o = y.wavesurfer.drawer.handleEvent(_e2, !0) * p, d = y.wrapper.scrollWidth - y.wrapper.clientWidth, f = y.wrapper.getBoundingClientRect(), h = "handle" == _e2.target.tagName.toLowerCase() ? _e2.target.classList.contains("wavesurfer-handle-start") ? "start" : "end" : !(l = !0));
            }, t = function t(e) {
              e.touches && 1 < e.touches.length || ((l || h) && (c = null, h = l = !1), w && (w = !1, y.util.preventClick(), y.fireEvent("update-end", e), y.wavesurfer.fireEvent("region-update-end", y, e)));
            }, r = function r(e) {
              if (!(e.touches && 1 < e.touches.length) && (!e.targetTouches || e.targetTouches[0].identifier == u) && (l || h)) {
                var t = o,
                    r = y.wavesurfer.drawer.handleEvent(e) * p,
                    n = r - o;if (o = r, y.drag && l && (w = w || !!n, y.onDrag(n)), y.resize && h && (w = w || !!n, y.onResize(n, h)), y.scroll && v.clientWidth < y.wrapper.scrollWidth) {
                  if (l) {
                    var i = y.element.getBoundingClientRect(),
                        s = i.left - f.left;r < t && 0 <= s ? c = -1 : t < r && s + i.width <= f.right && (c = 1), (-1 === c && g < s || 1 === c && s + i.width < f.right - g) && (c = null);
                  } else {
                    var a = e.clientX - f.left;c = a <= g ? -1 : a >= f.right - g ? 1 : null;
                  }c && function e(t) {
                    if (c && (l || h)) {
                      var r = y.wrapper.scrollLeft + m * c;y.wrapper.scrollLeft = r = Math.min(d, Math.max(0, r));var n = y.wavesurfer.drawer.handleEvent(t) * p,
                          i = n - o;o = n, l ? y.onDrag(i) : y.onResize(i, h), window.requestAnimationFrame(function () {
                        e(t);
                      });
                    }
                  }(e);
                }
              }
            }, y.element.addEventListener("mousedown", e), y.element.addEventListener("touchstart", e), y.wrapper.addEventListener("mousemove", r), y.wrapper.addEventListener("touchmove", r), document.body.addEventListener("mouseup", t), document.body.addEventListener("touchend", t), y.on("remove", function () {
              document.body.removeEventListener("mouseup", t), document.body.removeEventListener("touchend", t), y.wrapper.removeEventListener("mousemove", r), y.wrapper.removeEventListener("touchmove", r);
            }), y.wavesurfer.on("destroy", function () {
              document.body.removeEventListener("mouseup", t), document.body.removeEventListener("touchend", t);
            }));
          } }, { key: "onDrag", value: function value(e) {
            var t = this.wavesurfer.getDuration();this.end + e > t || this.start + e < 0 || this.update({ start: this.start + e, end: this.end + e });
          } }, { key: "onResize", value: function value(e, t) {
            "start" == t ? this.update({ start: Math.min(this.start + e, this.end), end: Math.max(this.start + e, this.end) }) : this.update({ start: Math.min(this.end + e, this.start), end: Math.max(this.end + e, this.start) });
          } }]), n;
      }(),
          o = function () {
        function n(e, t) {
          var r = this;i(this, n), this.params = e, this.wavesurfer = t, this.util = t.util, Object.getOwnPropertyNames(this.util.Observer.prototype).forEach(function (e) {
            a.prototype[e] = r.util.Observer.prototype[e];
          }), this.wavesurfer.Region = a, this.list = {}, this._onReady = function () {
            r.wrapper = r.wavesurfer.drawer.wrapper, r.params.regions && r.params.regions.forEach(function (e) {
              r.add(e);
            }), r.params.dragSelection && r.enableDragSelection(r.params);
          };
        }return s(n, null, [{ key: "create", value: function value(e) {
            return { name: "regions", deferInit: !(!e || !e.deferInit) && e.deferInit, params: e, staticProps: { initRegions: function initRegions() {
                  console.warn('Deprecated initRegions! Use wavesurfer.initPlugins("regions") instead!'), this.initPlugin("regions");
                }, addRegion: function addRegion(e) {
                  return this.initialisedPluginList.regions || this.initPlugin("regions"), this.regions.add(e);
                }, clearRegions: function clearRegions() {
                  this.regions && this.regions.clear();
                }, enableDragSelection: function enableDragSelection(e) {
                  this.initialisedPluginList.regions || this.initPlugin("regions"), this.regions.enableDragSelection(e);
                }, disableDragSelection: function disableDragSelection() {
                  this.regions.disableDragSelection();
                } }, instance: n };
          } }]), s(n, [{ key: "init", value: function value() {
            this.wavesurfer.isReady && this._onReady(), this.wavesurfer.on("ready", this._onReady);
          } }, { key: "destroy", value: function value() {
            this.wavesurfer.un("ready", this._onReady), this.disableDragSelection(), this.clear();
          } }, { key: "add", value: function value(e) {
            var t = this,
                r = new this.wavesurfer.Region(e, this.wavesurfer);return (this.list[r.id] = r).on("remove", function () {
              delete t.list[r.id];
            }), r;
          } }, { key: "clear", value: function value() {
            var t = this;Object.keys(this.list).forEach(function (e) {
              t.list[e].remove();
            });
          } }, { key: "enableDragSelection", value: function value(n) {
            var i,
                s,
                a,
                o,
                u,
                l,
                d,
                h = this,
                c = n.slop || 2,
                f = this.wavesurfer.drawer.container,
                v = !1 !== n.scroll && this.wavesurfer.params.scrollParent,
                p = n.scrollSpeed || 1,
                m = n.scrollThreshold || 10,
                g = this.wavesurfer.getDuration(),
                w = 0,
                e = function e(_e3) {
              _e3.touches && 1 < _e3.touches.length || (g = h.wavesurfer.getDuration(), u = _e3.targetTouches ? _e3.targetTouches[0].identifier : null, s = h.wrapper.scrollWidth - h.wrapper.clientWidth, d = h.wrapper.getBoundingClientRect(), i = !0, a = h.wavesurfer.drawer.handleEvent(_e3, !0), l = o = null);
            };this.wrapper.addEventListener("mousedown", e), this.wrapper.addEventListener("touchstart", e), this.on("disable-drag-selection", function () {
              h.wrapper.removeEventListener("touchstart", e), h.wrapper.removeEventListener("mousedown", e);
            });var t = function t(e) {
              e.touches && 1 < e.touches.length || (i = !1, w = 0, l = null, o && (h.util.preventClick(), o.fireEvent("update-end", e), h.wavesurfer.fireEvent("region-update-end", o, e)), o = null);
            };this.wrapper.addEventListener("mouseup", t), this.wrapper.addEventListener("touchend", t), document.body.addEventListener("mouseup", t), document.body.addEventListener("touchend", t), this.on("disable-drag-selection", function () {
              document.body.removeEventListener("mouseup", t), document.body.removeEventListener("touchend", t), h.wrapper.removeEventListener("touchend", t), h.wrapper.removeEventListener("mouseup", t);
            });var r = function r(e) {
              if (i && !(++w <= c || e.touches && 1 < e.touches.length || e.targetTouches && e.targetTouches[0].identifier != u)) {
                o || (o = h.add(n || {}));var t = h.wavesurfer.drawer.handleEvent(e);if (o.update({ start: Math.min(t * g, a * g), end: Math.max(t * g, a * g) }), v && f.clientWidth < h.wrapper.scrollWidth) {
                  var r = e.clientX - d.left;(l = r <= m ? -1 : r >= d.right - m ? 1 : null) && function e(t) {
                    if (o && l) {
                      var r = h.wrapper.scrollLeft + p * l;h.wrapper.scrollLeft = r = Math.min(s, Math.max(0, r));var n = h.wavesurfer.drawer.handleEvent(t);o.update({ start: Math.min(n * g, a * g), end: Math.max(n * g, a * g) }), r < s && 0 < r && window.requestAnimationFrame(function () {
                        e(t);
                      });
                    }
                  }(e);
                }
              }
            };this.wrapper.addEventListener("mousemove", r), this.wrapper.addEventListener("touchmove", r), this.on("disable-drag-selection", function () {
              h.wrapper.removeEventListener("touchmove", r), h.wrapper.removeEventListener("mousemove", r);
            });
          } }, { key: "disableDragSelection", value: function value() {
            this.fireEvent("disable-drag-selection");
          } }, { key: "getCurrentRegion", value: function value() {
            var r = this,
                n = this.wavesurfer.getCurrentTime(),
                i = null;return Object.keys(this.list).forEach(function (e) {
              var t = r.list[e];t.start <= n && t.end >= n && (!i || t.end - t.start < i.end - i.start) && (i = t);
            }), i;
          } }]), n;
      }();t.default = o, e.exports = t.default;
    } });
});


},{}],135:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:54 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("timeline", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.timeline = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.timeline = t());
}(window, function () {
  return function (a) {
    var r = {};function n(e) {
      if (r[e]) return r[e].exports;var t = r[e] = { i: e, l: !1, exports: {} };return a[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports;
    }return n.m = a, n.c = r, n.d = function (e, t, a) {
      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: a });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, n.t = function (t, e) {
      if (1 & e && (t = n(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var a = Object.create(null);if (n.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) {
        n.d(a, r, function (e) {
          return t[e];
        }.bind(null, r));
      }return a;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "localhost:8080/dist/plugin/", n(n.s = 0);
  }([function (e, t, a) {
    "use strict";
    function r(e, t) {
      for (var a = 0; a < t.length; a++) {
        var r = t[a];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
      }
    }function n(e, t, a) {
      return t && r(e.prototype, t), a && r(e, a), e;
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var i = function () {
      function r(e, t) {
        var a = this;if (function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, r), o.call(this), this.container = "string" == typeof e.container ? document.querySelector(e.container) : e.container, !this.container) throw new Error("No container for wavesurfer timeline");this.wavesurfer = t, this.util = t.util, this.params = this.util.extend({}, { height: 20, notchPercentHeight: 90, labelPadding: 5, unlabeledNotchColor: "#c0c0c0", primaryColor: "#000", secondaryColor: "#c0c0c0", primaryFontColor: "#000", secondaryFontColor: "#000", fontFamily: "Arial", fontSize: 10, zoomDebounce: !1, formatTimeCallback: this.defaultFormatTimeCallback, timeInterval: this.defaultTimeInterval, primaryLabelInterval: this.defaultPrimaryLabelInterval, secondaryLabelInterval: this.defaultSecondaryLabelInterval }, e), this.canvases = [], this.wrapper = null, this.drawer = null, this.pixelRatio = null, this.maxCanvasWidth = null, this.maxCanvasElementWidth = null, this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {
          return a.render();
        }, this.params.zoomDebounce) : function () {
          return a.render();
        };
      }return n(r, null, [{ key: "create", value: function value(e) {
          return { name: "timeline", deferInit: !(!e || !e.deferInit) && e.deferInit, params: e, instance: r };
        } }]), n(r, [{ key: "init", value: function value() {
          this.wavesurfer.on("ready", this._onReady), this.wavesurfer.isReady && this._onReady();
        } }, { key: "destroy", value: function value() {
          this.unAll(), this.wavesurfer.un("redraw", this._onRedraw), this.wavesurfer.un("zoom", this._onZoom), this.wavesurfer.un("ready", this._onReady), this.wavesurfer.drawer.wrapper.removeEventListener("scroll", this._onScroll), this.wrapper && this.wrapper.parentNode && (this.wrapper.removeEventListener("click", this._onWrapperClick), this.wrapper.parentNode.removeChild(this.wrapper), this.wrapper = null);
        } }, { key: "createWrapper", value: function value() {
          var e = this.wavesurfer.params;this.container.innerHTML = "", this.wrapper = this.container.appendChild(document.createElement("timeline")), this.util.style(this.wrapper, { display: "block", position: "relative", userSelect: "none", webkitUserSelect: "none", height: "".concat(this.params.height, "px") }), (e.fillParent || e.scrollParent) && this.util.style(this.wrapper, { width: "100%", overflowX: "hidden", overflowY: "hidden" }), this.wrapper.addEventListener("click", this._onWrapperClick);
        } }, { key: "render", value: function value() {
          this.wrapper || this.createWrapper(), this.updateCanvases(), this.updateCanvasesPositioning(), this.renderCanvases();
        } }, { key: "updateCanvases", value: function value() {
          for (var e, t, a = this, r = Math.round(this.drawer.wrapper.scrollWidth), n = Math.ceil(r / this.maxCanvasElementWidth); this.canvases.length < n;) {
            void 0, e = a.wrapper.appendChild(document.createElement("canvas")), a.canvases.push(e), a.util.style(e, { position: "absolute", zIndex: 4 });
          }for (; this.canvases.length > n;) {
            t = void 0, (t = a.canvases.pop()).parentElement.removeChild(t);
          }
        } }, { key: "updateCanvasesPositioning", value: function value() {
          var r = this,
              n = this.canvases.length;this.canvases.forEach(function (e, t) {
            var a = t === n - 1 ? r.drawer.wrapper.scrollWidth - r.maxCanvasElementWidth * (n - 1) : r.maxCanvasElementWidth;e.width = a * r.pixelRatio, e.height = (r.params.height + 1) * r.pixelRatio, r.util.style(e, { width: "".concat(a, "px"), height: "".concat(r.params.height, "px"), left: "".concat(t * r.maxCanvasElementWidth, "px") });
          });
        } }, { key: "renderCanvases", value: function value() {
          var r = this,
              e = this.wavesurfer.backend.getDuration();if (!(e <= 0)) {
            var t,
                a = this.wavesurfer.params,
                n = this.params.fontSize * a.pixelRatio,
                i = parseInt(e, 10) + 1,
                o = a.fillParent && !a.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * a.pixelRatio,
                s = this.params.height * this.pixelRatio,
                l = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio,
                c = o / e,
                u = this.params.formatTimeCallback,
                h = function h(e) {
              return "function" == typeof e ? e(c) : e;
            },
                p = h(this.params.timeInterval),
                f = h(this.params.primaryLabelInterval),
                d = h(this.params.secondaryLabelInterval),
                v = 0,
                m = 0,
                y = [];for (t = 0; t < i / p; t++) {
              y.push([t, m, v]), m += p, v += c * p;
            }var w = function w(t) {
              y.forEach(function (e) {
                t(e[0], e[1], e[2]);
              });
            };this.setFillStyles(this.params.primaryColor), this.setFonts("".concat(n, "px ").concat(this.params.fontFamily)), this.setFillStyles(this.params.primaryFontColor), w(function (e, t, a) {
              e % f == 0 && (r.fillRect(a, 0, 1, s), r.fillText(u(t, c), a + r.params.labelPadding * r.pixelRatio, s));
            }), this.setFillStyles(this.params.secondaryColor), this.setFonts("".concat(n, "px ").concat(this.params.fontFamily)), this.setFillStyles(this.params.secondaryFontColor), w(function (e, t, a) {
              e % d == 0 && (r.fillRect(a, 0, 1, s), r.fillText(u(t, c), a + r.params.labelPadding * r.pixelRatio, s));
            }), this.setFillStyles(this.params.unlabeledNotchColor), w(function (e, t, a) {
              e % d != 0 && e % f != 0 && r.fillRect(a, 0, 1, l);
            });
          }
        } }, { key: "setFillStyles", value: function value(t) {
          this.canvases.forEach(function (e) {
            e.getContext("2d").fillStyle = t;
          });
        } }, { key: "setFonts", value: function value(t) {
          this.canvases.forEach(function (e) {
            e.getContext("2d").font = t;
          });
        } }, { key: "fillRect", value: function value(n, i, o, s) {
          var l = this;this.canvases.forEach(function (e, t) {
            var a = t * l.maxCanvasWidth,
                r = { x1: Math.max(n, t * l.maxCanvasWidth), y1: i, x2: Math.min(n + o, t * l.maxCanvasWidth + e.width), y2: i + s };r.x1 < r.x2 && e.getContext("2d").fillRect(r.x1 - a, r.y1, r.x2 - r.x1, r.y2 - r.y1);
          });
        } }, { key: "fillText", value: function value(r, n, i) {
          var o,
              s = 0;this.canvases.forEach(function (e) {
            var t = e.getContext("2d"),
                a = t.canvas.width;n + o < s || (n < s + a && (o = t.measureText(r).width, t.fillText(r, n - s, i)), s += a);
          });
        } }, { key: "defaultFormatTimeCallback", value: function value(e, t) {
          if (1 < e / 60) {
            var a = parseInt(e / 60, 10);return e = (e = parseInt(e % 60, 10)) < 10 ? "0" + e : e, "".concat(a, ":").concat(e);
          }return Math.round(1e3 * e) / 1e3;
        } }, { key: "defaultTimeInterval", value: function value(e) {
          return 25 <= e ? 1 : 25 <= 5 * e ? 5 : 25 <= 15 * e ? 15 : 60 * Math.ceil(.5 / e);
        } }, { key: "defaultPrimaryLabelInterval", value: function value(e) {
          return 25 <= e ? 10 : 25 <= 5 * e ? 6 : 4;
        } }, { key: "defaultSecondaryLabelInterval", value: function value(e) {
          return 25 <= e ? 5 : 2;
        } }]), r;
    }();t.default = i;var o = function o() {
      var a = this;this._onScroll = function () {
        a.wrapper && a.drawer.wrapper && (a.wrapper.scrollLeft = a.drawer.wrapper.scrollLeft);
      }, this._onRedraw = function () {
        return a.render();
      }, this._onReady = function () {
        var e = a.wavesurfer;a.drawer = e.drawer, a.pixelRatio = e.drawer.params.pixelRatio, a.maxCanvasWidth = e.drawer.maxCanvasWidth || e.drawer.width, a.maxCanvasElementWidth = e.drawer.maxCanvasElementWidth || Math.round(a.maxCanvasWidth / a.pixelRatio), e.drawer.wrapper.addEventListener("scroll", a._onScroll), e.on("redraw", a._onRedraw), e.on("zoom", a._onZoom), a.render();
      }, this._onWrapperClick = function (e) {
        e.preventDefault();var t = "offsetX" in e ? e.offsetX : e.layerX;a.fireEvent("click", t / a.wrapper.scrollWidth || 0);
      };
    };e.exports = t.default;
  }]);
});


},{}],136:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:49 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("WaveSurfer", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.WaveSurfer = t() : e.WaveSurfer = t();
}(window, function () {
  return function (r) {
    var n = {};function i(e) {
      if (n[e]) return n[e].exports;var t = n[e] = { i: e, l: !1, exports: {} };return r[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
    }return i.m = r, i.c = n, i.d = function (e, t, r) {
      i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r });
    }, i.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, i.t = function (t, e) {
      if (1 & e && (t = i(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var r = Object.create(null);if (i.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var n in t) {
        i.d(r, n, function (e) {
          return t[e];
        }.bind(null, n));
      }return r;
    }, i.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return i.d(t, "a", t), t;
    }, i.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, i.p = "", i(i.s = 4);
  }([function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "ajax", { enumerable: !0, get: function get() {
        return n.default;
      } }), Object.defineProperty(t, "getId", { enumerable: !0, get: function get() {
        return i.default;
      } }), Object.defineProperty(t, "max", { enumerable: !0, get: function get() {
        return a.default;
      } }), Object.defineProperty(t, "min", { enumerable: !0, get: function get() {
        return s.default;
      } }), Object.defineProperty(t, "Observer", { enumerable: !0, get: function get() {
        return o.default;
      } }), Object.defineProperty(t, "extend", { enumerable: !0, get: function get() {
        return u.default;
      } }), Object.defineProperty(t, "style", { enumerable: !0, get: function get() {
        return l.default;
      } }), Object.defineProperty(t, "requestAnimationFrame", { enumerable: !0, get: function get() {
        return c.default;
      } }), Object.defineProperty(t, "frame", { enumerable: !0, get: function get() {
        return h.default;
      } }), Object.defineProperty(t, "debounce", { enumerable: !0, get: function get() {
        return f.default;
      } }), Object.defineProperty(t, "preventClick", { enumerable: !0, get: function get() {
        return d.default;
      } });var n = p(r(5)),
        i = p(r(6)),
        a = p(r(7)),
        s = p(r(8)),
        o = p(r(1)),
        u = p(r(9)),
        l = p(r(10)),
        c = p(r(2)),
        h = p(r(11)),
        f = p(r(12)),
        d = p(r(13));function p(e) {
      return e && e.__esModule ? e : { default: e };
    }
  }, function (e, t, r) {
    "use strict";
    function i(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function () {
      function e() {
        !function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, e), this.handlers = null;
      }var t, r, n;return t = e, (r = [{ key: "on", value: function value(e, t) {
          var r = this;this.handlers || (this.handlers = {});var n = this.handlers[e];return n || (n = this.handlers[e] = []), n.push(t), { name: e, callback: t, un: function un(e, t) {
              return r.un(e, t);
            } };
        } }, { key: "un", value: function value(e, t) {
          if (this.handlers) {
            var r,
                n = this.handlers[e];if (n) if (t) for (r = n.length - 1; 0 <= r; r--) {
              n[r] == t && n.splice(r, 1);
            } else n.length = 0;
          }
        } }, { key: "unAll", value: function value() {
          this.handlers = null;
        } }, { key: "once", value: function value(i, a) {
          var s = this;return this.on(i, function e() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) {
              r[n] = arguments[n];
            }a.apply(s, r), setTimeout(function () {
              s.un(i, e);
            }, 0);
          });
        } }, { key: "fireEvent", value: function value(e) {
          for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), n = 1; n < t; n++) {
            r[n - 1] = arguments[n];
          }if (this.handlers) {
            var i = this.handlers[e];i && i.forEach(function (e) {
              e.apply(void 0, r);
            });
          }
        } }]) && i(t.prototype, r), n && i(t, n), e;
    }();t.default = n, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e, t) {
      return setTimeout(e, 1e3 / 60);
    }).bind(window);t.default = n, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function a(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
    }function s(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function o(e) {
      return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function u(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function l(e, t, r) {
      return t && u(e.prototype, t), r && u(e, r), e;
    }function c(e, t) {
      return (c = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var h = "playing",
        f = "paused",
        d = "finished",
        p = function (e) {
      function i(e) {
        var t, r, n;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, i), (n = s(this, o(i).call(this))).audioContext = null, n.offlineAudioContext = null, n.stateBehaviors = (a(t = {}, h, { init: function init() {
            this.addOnAudioProcess();
          }, getPlayedPercents: function getPlayedPercents() {
            var e = this.getDuration();return this.getCurrentTime() / e || 0;
          }, getCurrentTime: function getCurrentTime() {
            return this.startPosition + this.getPlayedTime();
          } }), a(t, f, { init: function init() {
            this.removeOnAudioProcess();
          }, getPlayedPercents: function getPlayedPercents() {
            var e = this.getDuration();return this.getCurrentTime() / e || 0;
          }, getCurrentTime: function getCurrentTime() {
            return this.startPosition;
          } }), a(t, d, { init: function init() {
            this.removeOnAudioProcess(), this.fireEvent("finish");
          }, getPlayedPercents: function getPlayedPercents() {
            return 1;
          }, getCurrentTime: function getCurrentTime() {
            return this.getDuration();
          } }), t), n.params = e, n.ac = e.audioContext || n.getAudioContext(), n.lastPlay = n.ac.currentTime, n.startPosition = 0, n.scheduledPause = null, n.states = (a(r = {}, h, Object.create(n.stateBehaviors[h])), a(r, f, Object.create(n.stateBehaviors[f])), a(r, d, Object.create(n.stateBehaviors[d])), r), n.analyser = null, n.buffer = null, n.filters = [], n.gainNode = null, n.mergedPeaks = null, n.offlineAc = null, n.peaks = null, n.playbackRate = 1, n.analyser = null, n.scriptNode = null, n.source = null, n.splitPeaks = [], n.state = null, n.explicitDuration = null, n;
      }return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && c(e, t);
      }(i, n.Observer), l(i, [{ key: "supportsWebAudio", value: function value() {
          return !(!window.AudioContext && !window.webkitAudioContext);
        } }, { key: "getAudioContext", value: function value() {
          return window.WaveSurferAudioContext || (window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)()), window.WaveSurferAudioContext;
        } }, { key: "getOfflineAudioContext", value: function value(e) {
          return window.WaveSurferOfflineAudioContext || (window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, e)), window.WaveSurferOfflineAudioContext;
        } }]), l(i, [{ key: "init", value: function value() {
          this.createVolumeNode(), this.createScriptNode(), this.createAnalyserNode(), this.setState(f), this.setPlaybackRate(this.params.audioRate), this.setLength(0);
        } }, { key: "disconnectFilters", value: function value() {
          this.filters && (this.filters.forEach(function (e) {
            e && e.disconnect();
          }), this.filters = null, this.analyser.connect(this.gainNode));
        } }, { key: "setState", value: function value(e) {
          this.state !== this.states[e] && (this.state = this.states[e], this.state.init.call(this));
        } }, { key: "setFilter", value: function value() {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
            t[r] = arguments[r];
          }this.setFilters(t);
        } }, { key: "setFilters", value: function value(e) {
          this.disconnectFilters(), e && e.length && (this.filters = e, this.analyser.disconnect(), e.reduce(function (e, t) {
            return e.connect(t), t;
          }, this.analyser).connect(this.gainNode));
        } }, { key: "createScriptNode", value: function value() {
          this.params.audioScriptProcessor ? this.scriptNode = this.params.audioScriptProcessor : this.ac.createScriptProcessor ? this.scriptNode = this.ac.createScriptProcessor(i.scriptBufferSize) : this.scriptNode = this.ac.createJavaScriptNode(i.scriptBufferSize), this.scriptNode.connect(this.ac.destination);
        } }, { key: "addOnAudioProcess", value: function value() {
          var t = this;this.scriptNode.onaudioprocess = function () {
            var e = t.getCurrentTime();e >= t.getDuration() ? (t.setState(d), t.fireEvent("pause")) : e >= t.scheduledPause ? t.pause() : t.state === t.states[h] && t.fireEvent("audioprocess", e);
          };
        } }, { key: "removeOnAudioProcess", value: function value() {
          this.scriptNode.onaudioprocess = null;
        } }, { key: "createAnalyserNode", value: function value() {
          this.analyser = this.ac.createAnalyser(), this.analyser.connect(this.gainNode);
        } }, { key: "createVolumeNode", value: function value() {
          this.ac.createGain ? this.gainNode = this.ac.createGain() : this.gainNode = this.ac.createGainNode(), this.gainNode.connect(this.ac.destination);
        } }, { key: "setSinkId", value: function value(e) {
          if (e) {
            var t = new window.Audio();if (!t.setSinkId) return Promise.reject(new Error("setSinkId is not supported in your browser"));t.autoplay = !0;var r = this.ac.createMediaStreamDestination();return this.gainNode.disconnect(), this.gainNode.connect(r), t.srcObject = r.stream, t.setSinkId(e);
          }return Promise.reject(new Error("Invalid deviceId: " + e));
        } }, { key: "setVolume", value: function value(e) {
          this.gainNode.gain.setValueAtTime(e, this.ac.currentTime);
        } }, { key: "getVolume", value: function value() {
          return this.gainNode.gain.value;
        } }, { key: "decodeArrayBuffer", value: function value(e, t, r) {
          this.offlineAc || (this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100)), this.offlineAc.decodeAudioData(e, function (e) {
            return t(e);
          }, r);
        } }, { key: "setPeaks", value: function value(e, t) {
          this.explicitDuration = t, this.peaks = e;
        } }, { key: "setLength", value: function value(e) {
          if (!this.mergedPeaks || e != 2 * this.mergedPeaks.length - 1 + 2) {
            this.splitPeaks = [], this.mergedPeaks = [];var t,
                r = this.buffer ? this.buffer.numberOfChannels : 1;for (t = 0; t < r; t++) {
              this.splitPeaks[t] = [], this.splitPeaks[t][2 * (e - 1)] = 0, this.splitPeaks[t][2 * (e - 1) + 1] = 0;
            }this.mergedPeaks[2 * (e - 1)] = 0, this.mergedPeaks[2 * (e - 1) + 1] = 0;
          }
        } }, { key: "getPeaks", value: function value(e, t, r) {
          if (this.peaks) return this.peaks;if (t = t || 0, r = r || e - 1, this.setLength(e), !this.buffer.length) {
            var n = this.createBuffer(1, 4096, this.sampleRate);this.buffer = n.buffer;
          }var i,
              a = this.buffer.length / e,
              s = ~~(a / 10) || 1,
              o = this.buffer.numberOfChannels;for (i = 0; i < o; i++) {
            var u = this.splitPeaks[i],
                l = this.buffer.getChannelData(i),
                c = void 0;for (c = t; c <= r; c++) {
              var h = ~~(c * a),
                  f = ~~(h + a),
                  d = 0,
                  p = 0,
                  v = void 0;for (v = h; v < f; v += s) {
                var y = l[v];p < y && (p = y), y < d && (d = y);
              }u[2 * c] = p, u[2 * c + 1] = d, (0 == i || p > this.mergedPeaks[2 * c]) && (this.mergedPeaks[2 * c] = p), (0 == i || d < this.mergedPeaks[2 * c + 1]) && (this.mergedPeaks[2 * c + 1] = d);
            }
          }return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
        } }, { key: "getPlayedPercents", value: function value() {
          return this.state.getPlayedPercents.call(this);
        } }, { key: "disconnectSource", value: function value() {
          this.source && this.source.disconnect();
        } }, { key: "destroy", value: function value() {
          this.isPaused() || this.pause(), this.unAll(), this.buffer = null, this.disconnectFilters(), this.disconnectSource(), this.gainNode.disconnect(), this.scriptNode.disconnect(), this.analyser.disconnect(), this.params.closeAudioContext && ("function" == typeof this.ac.close && "closed" != this.ac.state && this.ac.close(), this.ac = null, this.params.audioContext ? this.params.audioContext = null : window.WaveSurferAudioContext = null, window.WaveSurferOfflineAudioContext = null);
        } }, { key: "load", value: function value(e) {
          this.startPosition = 0, this.lastPlay = this.ac.currentTime, this.buffer = e, this.createSource();
        } }, { key: "createSource", value: function value() {
          this.disconnectSource(), this.source = this.ac.createBufferSource(), this.source.start = this.source.start || this.source.noteGrainOn, this.source.stop = this.source.stop || this.source.noteOff, this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime), this.source.buffer = this.buffer, this.source.connect(this.analyser);
        } }, { key: "isPaused", value: function value() {
          return this.state !== this.states[h];
        } }, { key: "getDuration", value: function value() {
          return this.buffer ? this.buffer.duration : this.explicitDuration ? this.explicitDuration : 0;
        } }, { key: "seekTo", value: function value(e, t) {
          if (this.buffer) return (this.scheduledPause = null) == e && (e = this.getCurrentTime()) >= this.getDuration() && (e = 0), null == t && (t = this.getDuration()), this.startPosition = e, this.lastPlay = this.ac.currentTime, this.state === this.states[d] && this.setState(f), { start: e, end: t };
        } }, { key: "getPlayedTime", value: function value() {
          return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
        } }, { key: "play", value: function value(e, t) {
          if (this.buffer) {
            this.createSource();var r = this.seekTo(e, t);e = r.start, t = r.end, this.scheduledPause = t, this.source.start(0, e, t - e), "suspended" == this.ac.state && this.ac.resume && this.ac.resume(), this.setState(h), this.fireEvent("play");
          }
        } }, { key: "pause", value: function value() {
          this.scheduledPause = null, this.startPosition += this.getPlayedTime(), this.source && this.source.stop(0), this.setState(f), this.fireEvent("pause");
        } }, { key: "getCurrentTime", value: function value() {
          return this.state.getCurrentTime.call(this);
        } }, { key: "getPlaybackRate", value: function value() {
          return this.playbackRate;
        } }, { key: "setPlaybackRate", value: function value(e) {
          e = e || 1, this.isPaused() ? this.playbackRate = e : (this.pause(), this.playbackRate = e, this.play());
        } }]), i;
    }();(t.default = p).scriptBufferSize = 256, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var i = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0)),
        a = n(r(14)),
        s = n(r(3)),
        o = n(r(16)),
        u = n(r(17));function n(e) {
      return e && e.__esModule ? e : { default: e };
    }function l(e) {
      return (l = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function c(e, t) {
      return !t || "object" !== l(t) && "function" != typeof t ? d(e) : t;
    }function h(e) {
      return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function f(e, t) {
      return (f = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }function d(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e;
    }function p(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function v(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function y(e, t, r) {
      return t && v(e.prototype, t), r && v(e, r), e;
    }var m = function (e) {
      function n(e) {
        var t;if (p(this, n), (t = c(this, h(n).call(this))).defaultParams = { audioContext: null, audioRate: 1, autoCenter: !0, backend: "WebAudio", barHeight: 1, barGap: null, container: null, cursorColor: "#333", cursorWidth: 1, dragSelection: !0, fillParent: !0, forceDecode: !1, height: 128, hideScrollbar: !1, interact: !0, loopSelection: !0, maxCanvasWidth: 4e3, mediaContainer: null, mediaControls: !1, mediaType: "audio", minPxPerSec: 20, normalize: !1, partialRender: !1, pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI, plugins: [], progressColor: "#555", removeMediaElementOnDestroy: !0, renderer: a.default, responsive: !1, scrollParent: !1, skipLength: 2, splitChannels: !1, waveColor: "#999", xhr: {} }, t.backends = { MediaElement: o.default, WebAudio: s.default }, t.util = i, t.params = i.extend({}, t.defaultParams, e), t.container = "string" == typeof e.container ? document.querySelector(t.params.container) : t.params.container, !t.container) throw new Error("Container element not found");if (null == t.params.mediaContainer ? t.mediaContainer = t.container : "string" == typeof t.params.mediaContainer ? t.mediaContainer = document.querySelector(t.params.mediaContainer) : t.mediaContainer = t.params.mediaContainer, !t.mediaContainer) throw new Error("Media Container element not found");if (t.params.maxCanvasWidth <= 1) throw new Error("maxCanvasWidth must be greater than 1");if (t.params.maxCanvasWidth % 2 == 1) throw new Error("maxCanvasWidth must be an even number");if (t.savedVolume = 0, t.isMuted = !1, t.tmpEvents = [], t.currentAjax = null, t.arraybuffer = null, t.drawer = null, t.backend = null, t.peakCache = null, "function" != typeof t.params.renderer) throw new Error("Renderer parameter is invalid");t.Drawer = t.params.renderer, t.Backend = t.backends[t.params.backend], t.initialisedPluginList = {}, t.isDestroyed = !1, t.isReady = !1;var r = 0;return t._onResize = i.debounce(function () {
          r == t.drawer.wrapper.clientWidth || t.params.scrollParent || (r = t.drawer.wrapper.clientWidth, t.drawer.fireEvent("redraw"));
        }, "number" == typeof t.params.responsive ? t.params.responsive : 100), c(t, d(d(t)));
      }return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && f(e, t);
      }(n, i.Observer), y(n, null, [{ key: "create", value: function value(e) {
          return new n(e).init();
        } }]), y(n, [{ key: "init", value: function value() {
          return this.registerPlugins(this.params.plugins), this.createDrawer(), this.createBackend(), this.createPeakCache(), this;
        } }, { key: "registerPlugins", value: function value(e) {
          var t = this;return e.forEach(function (e) {
            return t.addPlugin(e);
          }), e.forEach(function (e) {
            e.deferInit || t.initPlugin(e.name);
          }), this.fireEvent("plugins-registered", e), this;
        } }, { key: "addPlugin", value: function value(t) {
          var r = this;if (!t.name) throw new Error("Plugin does not have a name!");if (!t.instance) throw new Error("Plugin ".concat(t.name, " does not have an instance property!"));t.staticProps && Object.keys(t.staticProps).forEach(function (e) {
            r[e] = t.staticProps[e];
          });var n = t.instance;return Object.getOwnPropertyNames(i.Observer.prototype).forEach(function (e) {
            n.prototype[e] = i.Observer.prototype[e];
          }), this[t.name] = new n(t.params || {}, this), this.fireEvent("plugin-added", t.name), this;
        } }, { key: "initPlugin", value: function value(e) {
          if (!this[e]) throw new Error("Plugin ".concat(e, " has not been added yet!"));return this.initialisedPluginList[e] && this.destroyPlugin(e), this[e].init(), this.initialisedPluginList[e] = !0, this.fireEvent("plugin-initialised", e), this;
        } }, { key: "destroyPlugin", value: function value(e) {
          if (!this[e]) throw new Error("Plugin ".concat(e, " has not been added yet and cannot be destroyed!"));if (!this.initialisedPluginList[e]) throw new Error("Plugin ".concat(e, " is not active and cannot be destroyed!"));if ("function" != typeof this[e].destroy) throw new Error("Plugin ".concat(e, " does not have a destroy function!"));return this[e].destroy(), delete this.initialisedPluginList[e], this.fireEvent("plugin-destroyed", e), this;
        } }, { key: "destroyAllPlugins", value: function value() {
          var t = this;Object.keys(this.initialisedPluginList).forEach(function (e) {
            return t.destroyPlugin(e);
          });
        } }, { key: "createDrawer", value: function value() {
          var r = this;this.drawer = new this.Drawer(this.container, this.params), this.drawer.init(), this.fireEvent("drawer-created", this.drawer), !1 !== this.params.responsive && (window.addEventListener("resize", this._onResize, !0), window.addEventListener("orientationchange", this._onResize, !0)), this.drawer.on("redraw", function () {
            r.drawBuffer(), r.drawer.progress(r.backend.getPlayedPercents());
          }), this.drawer.on("click", function (e, t) {
            setTimeout(function () {
              return r.seekTo(t);
            }, 0);
          }), this.drawer.on("scroll", function (e) {
            r.params.partialRender && r.drawBuffer(), r.fireEvent("scroll", e);
          });
        } }, { key: "createBackend", value: function value() {
          var t = this;this.backend && this.backend.destroy(), "AudioElement" == this.params.backend && (this.params.backend = "MediaElement"), "WebAudio" != this.params.backend || this.Backend.prototype.supportsWebAudio.call(null) || (this.params.backend = "MediaElement"), this.backend = new this.Backend(this.params), this.backend.init(), this.fireEvent("backend-created", this.backend), this.backend.on("finish", function () {
            return t.fireEvent("finish");
          }), this.backend.on("play", function () {
            return t.fireEvent("play");
          }), this.backend.on("pause", function () {
            return t.fireEvent("pause");
          }), this.backend.on("audioprocess", function (e) {
            t.drawer.progress(t.backend.getPlayedPercents()), t.fireEvent("audioprocess", e);
          });
        } }, { key: "createPeakCache", value: function value() {
          this.params.partialRender && (this.peakCache = new u.default());
        } }, { key: "getDuration", value: function value() {
          return this.backend.getDuration();
        } }, { key: "getCurrentTime", value: function value() {
          return this.backend.getCurrentTime();
        } }, { key: "setCurrentTime", value: function value(e) {
          e >= this.getDuration() ? this.seekTo(1) : this.seekTo(e / this.getDuration());
        } }, { key: "play", value: function value(e, t) {
          var r = this;return this.fireEvent("interaction", function () {
            return r.play(e, t);
          }), this.backend.play(e, t);
        } }, { key: "pause", value: function value() {
          if (!this.backend.isPaused()) return this.backend.pause();
        } }, { key: "playPause", value: function value() {
          return this.backend.isPaused() ? this.play() : this.pause();
        } }, { key: "isPlaying", value: function value() {
          return !this.backend.isPaused();
        } }, { key: "skipBackward", value: function value(e) {
          this.skip(-e || -this.params.skipLength);
        } }, { key: "skipForward", value: function value(e) {
          this.skip(e || this.params.skipLength);
        } }, { key: "skip", value: function value(e) {
          var t = this.getDuration() || 1,
              r = this.getCurrentTime() || 0;r = Math.max(0, Math.min(t, r + (e || 0))), this.seekAndCenter(r / t);
        } }, { key: "seekAndCenter", value: function value(e) {
          this.seekTo(e), this.drawer.recenter(e);
        } }, { key: "seekTo", value: function value(e) {
          var t = this;if ("number" != typeof e || !isFinite(e) || e < 0 || 1 < e) return console.error("Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!");this.fireEvent("interaction", function () {
            return t.seekTo(e);
          });var r = this.backend.isPaused();r || this.backend.pause();var n = this.params.scrollParent;this.params.scrollParent = !1, this.backend.seekTo(e * this.getDuration()), this.drawer.progress(e), r || this.backend.play(), this.params.scrollParent = n, this.fireEvent("seek", e);
        } }, { key: "stop", value: function value() {
          this.pause(), this.seekTo(0), this.drawer.progress(0);
        } }, { key: "setSinkId", value: function value(e) {
          return this.backend.setSinkId(e);
        } }, { key: "setVolume", value: function value(e) {
          this.backend.setVolume(e), this.fireEvent("volume", e);
        } }, { key: "getVolume", value: function value() {
          return this.backend.getVolume();
        } }, { key: "setPlaybackRate", value: function value(e) {
          this.backend.setPlaybackRate(e);
        } }, { key: "getPlaybackRate", value: function value() {
          return this.backend.getPlaybackRate();
        } }, { key: "toggleMute", value: function value() {
          this.setMute(!this.isMuted);
        } }, { key: "setMute", value: function value(e) {
          e !== this.isMuted && (e ? (this.savedVolume = this.backend.getVolume(), this.backend.setVolume(0), this.isMuted = !0, this.fireEvent("volume", 0)) : (this.backend.setVolume(this.savedVolume), this.isMuted = !1, this.fireEvent("volume", this.savedVolume))), this.fireEvent("mute", this.isMuted);
        } }, { key: "getMute", value: function value() {
          return this.isMuted;
        } }, { key: "isReady", value: function value() {
          return this.isReady;
        } }, { key: "getFilters", value: function value() {
          return this.backend.filters || [];
        } }, { key: "toggleScroll", value: function value() {
          this.params.scrollParent = !this.params.scrollParent, this.drawBuffer();
        } }, { key: "toggleInteraction", value: function value() {
          this.params.interact = !this.params.interact;
        } }, { key: "getWaveColor", value: function value() {
          return this.params.waveColor;
        } }, { key: "setWaveColor", value: function value(e) {
          this.params.waveColor = e, this.drawBuffer();
        } }, { key: "getProgressColor", value: function value() {
          return this.params.progressColor;
        } }, { key: "setProgressColor", value: function value(e) {
          this.params.progressColor = e, this.drawBuffer();
        } }, { key: "getCursorColor", value: function value() {
          return this.params.cursorColor;
        } }, { key: "setCursorColor", value: function value(e) {
          this.params.cursorColor = e, this.drawer.updateCursor();
        } }, { key: "getHeight", value: function value() {
          return this.params.height;
        } }, { key: "setHeight", value: function value(e) {
          this.params.height = e, this.drawer.setHeight(e * this.params.pixelRatio), this.drawBuffer();
        } }, { key: "drawBuffer", value: function value() {
          var e,
              t = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio),
              r = this.drawer.getWidth(),
              n = t,
              i = this.drawer.getScrollX(),
              a = Math.max(i + r, n);if (this.params.fillParent && (!this.params.scrollParent || t < r) && (i = 0, a = n = r), this.params.partialRender) {
            var s,
                o = this.peakCache.addRangeToPeakCache(n, i, a);for (s = 0; s < o.length; s++) {
              e = this.backend.getPeaks(n, o[s][0], o[s][1]), this.drawer.drawPeaks(e, n, o[s][0], o[s][1]);
            }
          } else e = this.backend.getPeaks(n, i, a), this.drawer.drawPeaks(e, n, i, a);this.fireEvent("redraw", e, n);
        } }, { key: "zoom", value: function value(e) {
          this.params.scrollParent = e ? (this.params.minPxPerSec = e, !0) : (this.params.minPxPerSec = this.defaultParams.minPxPerSec, !1), this.drawBuffer(), this.drawer.progress(this.backend.getPlayedPercents()), this.drawer.recenter(this.getCurrentTime() / this.getDuration()), this.fireEvent("zoom", e);
        } }, { key: "loadArrayBuffer", value: function value(e) {
          var t = this;this.decodeArrayBuffer(e, function (e) {
            t.isDestroyed || t.loadDecodedBuffer(e);
          });
        } }, { key: "loadDecodedBuffer", value: function value(e) {
          this.backend.load(e), this.drawBuffer(), this.fireEvent("ready"), this.isReady = !0;
        } }, { key: "loadBlob", value: function value(e) {
          var t = this,
              r = new FileReader();r.addEventListener("progress", function (e) {
            return t.onProgress(e);
          }), r.addEventListener("load", function (e) {
            return t.loadArrayBuffer(e.target.result);
          }), r.addEventListener("error", function () {
            return t.fireEvent("error", "Error reading file");
          }), r.readAsArrayBuffer(e), this.empty();
        } }, { key: "load", value: function value(e, t, r, n) {
          if (this.empty(), r) {
            var i = { "Preload is not 'auto', 'none' or 'metadata'": -1 === ["auto", "metadata", "none"].indexOf(r), "Peaks are not provided": !t, "Backend is not of type MediaElement": "MediaElement" !== this.params.backend, "Url is not of type string": "string" != typeof e },
                a = Object.keys(i).filter(function (e) {
              return i[e];
            });a.length && (console.warn("Preload parameter of wavesurfer.load will be ignored because:\n\t- " + a.join("\n\t- ")), r = null);
          }switch (this.params.backend) {case "WebAudio":
              return this.loadBuffer(e, t, n);case "MediaElement":
              return this.loadMediaElement(e, t, r, n);}
        } }, { key: "loadBuffer", value: function value(t, e, r) {
          var n = this,
              i = function i(e) {
            return e && n.tmpEvents.push(n.once("ready", e)), n.getArrayBuffer(t, function (e) {
              return n.loadArrayBuffer(e);
            });
          };if (!e) return i();this.backend.setPeaks(e, r), this.drawBuffer(), this.tmpEvents.push(this.once("interaction", i));
        } }, { key: "loadMediaElement", value: function value(e, t, r, n) {
          var i = this,
              a = e;if ("string" == typeof e) this.backend.load(a, this.mediaContainer, t, r);else {
            var s = e;this.backend.loadElt(s, t), a = s.src;
          }this.tmpEvents.push(this.backend.once("canplay", function () {
            i.drawBuffer(), i.fireEvent("ready"), i.isReady = !0;
          }), this.backend.once("error", function (e) {
            return i.fireEvent("error", e);
          })), t && this.backend.setPeaks(t, n), t && !this.params.forceDecode || !this.backend.supportsWebAudio() || this.getArrayBuffer(a, function (e) {
            i.decodeArrayBuffer(e, function (e) {
              i.backend.buffer = e, i.backend.setPeaks(null), i.drawBuffer(), i.fireEvent("waveform-ready");
            });
          });
        } }, { key: "decodeArrayBuffer", value: function value(t, r) {
          var n = this;this.arraybuffer = t, this.backend.decodeArrayBuffer(t, function (e) {
            n.isDestroyed || n.arraybuffer != t || (r(e), n.arraybuffer = null);
          }, function () {
            return n.fireEvent("error", "Error decoding audiobuffer");
          });
        } }, { key: "getArrayBuffer", value: function value(e, r) {
          var n = this,
              t = i.ajax({ url: e, responseType: "arraybuffer", xhr: this.params.xhr });return this.currentAjax = t, this.tmpEvents.push(t.on("progress", function (e) {
            n.onProgress(e);
          }), t.on("success", function (e, t) {
            r(e), n.currentAjax = null;
          }), t.on("error", function (e) {
            n.fireEvent("error", "XHR error: " + e.target.statusText), n.currentAjax = null;
          })), t;
        } }, { key: "onProgress", value: function value(e) {
          var t;t = e.lengthComputable ? e.loaded / e.total : e.loaded / (e.loaded + 1e6), this.fireEvent("loading", Math.round(100 * t), e.target);
        } }, { key: "exportPCM", value: function value(e, t, r, n) {
          e = e || 1024, n = n || 0, t = t || 1e4, r = r || !1;var i = this.backend.getPeaks(e, n),
              a = [].map.call(i, function (e) {
            return Math.round(e * t) / t;
          }),
              s = JSON.stringify(a);return r || window.open("data:application/json;charset=utf-8," + encodeURIComponent(s)), s;
        } }, { key: "exportImage", value: function value(e, t) {
          return e || (e = "image/png"), t || (t = 1), this.drawer.getImage(e, t);
        } }, { key: "cancelAjax", value: function value() {
          this.currentAjax && (this.currentAjax.xhr.abort(), this.currentAjax = null);
        } }, { key: "clearTmpEvents", value: function value() {
          this.tmpEvents.forEach(function (e) {
            return e.un();
          });
        } }, { key: "empty", value: function value() {
          this.backend.isPaused() || (this.stop(), this.backend.disconnectSource()), this.isReady = !1, this.cancelAjax(), this.clearTmpEvents(), this.drawer.progress(0), this.drawer.setWidth(0), this.drawer.drawPeaks({ length: this.drawer.getWidth() }, 0);
        } }, { key: "destroy", value: function value() {
          this.destroyAllPlugins(), this.fireEvent("destroy"), this.cancelAjax(), this.clearTmpEvents(), this.unAll(), !1 !== this.params.responsive && (window.removeEventListener("resize", this._onResize, !0), window.removeEventListener("orientationchange", this._onResize, !0)), this.backend.destroy(), this.drawer.destroy(), this.isDestroyed = !0, this.isReady = !1, this.arraybuffer = null;
        } }]), n;
    }();(t.default = m).VERSION = "2.1.0", m.util = i, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
      var t = new i.default(),
          r = new XMLHttpRequest(),
          n = !1;r.open(e.method || "GET", e.url, !0), r.responseType = e.responseType || "json", e.xhr && (e.xhr.requestHeaders && e.xhr.requestHeaders.forEach(function (e) {
        r.setRequestHeader(e.key, e.value);
      }), e.xhr.withCredentials && (r.withCredentials = !0));return r.addEventListener("progress", function (e) {
        t.fireEvent("progress", e), e.lengthComputable && e.loaded == e.total && (n = !0);
      }), r.addEventListener("load", function (e) {
        n || t.fireEvent("progress", e), t.fireEvent("load", e), 200 == r.status || 206 == r.status ? t.fireEvent("success", r.response, e) : t.fireEvent("error", e);
      }), r.addEventListener("error", function (e) {
        return t.fireEvent("error", e);
      }), r.send(), t.xhr = r, t;
    };var n,
        i = (n = r(1)) && n.__esModule ? n : { default: n };e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function () {
      return "wavesurfer_" + Math.random().toString(32).substring(2);
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t) {
      var r = -1 / 0;return Object.keys(t).forEach(function (e) {
        t[e] > r && (r = t[e]);
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t) {
      var r = Number(1 / 0);return Object.keys(t).forEach(function (e) {
        t[e] < r && (r = t[e]);
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (r) {
      for (var e = arguments.length, t = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++) {
        t[n - 1] = arguments[n];
      }return t.forEach(function (t) {
        Object.keys(t).forEach(function (e) {
          r[e] = t[e];
        });
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t, r) {
      return Object.keys(r).forEach(function (e) {
        t.style[e] !== r[e] && (t.style[e] = r[e]);
      }), t;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (n) {
      return function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
          t[r] = arguments[r];
        }return (0, i.default)(function () {
          return n.apply(void 0, t);
        });
      };
    };var n,
        i = (n = r(2)) && n.__esModule ? n : { default: n };e.exports = t.default;
  }, function (e, t) {
    function r(t, r, n) {
      var i, a, s, o, u;function l() {
        var e = Date.now() - o;e < r && 0 <= e ? i = setTimeout(l, r - e) : (i = null, n || (u = t.apply(s, a), s = a = null));
      }null == r && (r = 100);var e = function e() {
        s = this, a = arguments, o = Date.now();var e = n && !i;return i || (i = setTimeout(l, r)), e && (u = t.apply(s, a), s = a = null), u;
      };return e.clear = function () {
        i && (clearTimeout(i), i = null);
      }, e.flush = function () {
        i && (u = t.apply(s, a), s = a = null, clearTimeout(i), i = null);
      }, e;
    }r.debounce = r, e.exports = r;
  }, function (e, t, r) {
    "use strict";
    function n(e) {
      e.stopPropagation(), document.body.removeEventListener("click", n, !0);
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
      document.body.addEventListener("click", n, !0);
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n,
        a = (n = r(15)) && n.__esModule ? n : { default: n },
        f = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e) {
      return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function l(e, t) {
      return (l = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var c = function (e) {
      function n(e, t) {
        var r;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (r = o(this, u(n).call(this, e, t))).maxCanvasWidth = t.maxCanvasWidth, r.maxCanvasElementWidth = Math.round(t.maxCanvasWidth / t.pixelRatio), r.hasProgressCanvas = t.waveColor != t.progressColor, r.halfPixel = .5 / t.pixelRatio, r.canvases = [], r.progressWave = null, r;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && l(e, t);
      }(n, a.default), t = n, (r = [{ key: "init", value: function value() {
          this.createWrapper(), this.createElements();
        } }, { key: "createElements", value: function value() {
          this.progressWave = this.wrapper.appendChild(this.style(document.createElement("wave"), { position: "absolute", zIndex: 3, left: 0, top: 0, bottom: 0, overflow: "hidden", width: "0", display: "none", boxSizing: "border-box", borderRightStyle: "solid", pointerEvents: "none" })), this.addCanvas(), this.updateCursor();
        } }, { key: "updateCursor", value: function value() {
          this.style(this.progressWave, { borderRightWidth: this.params.cursorWidth + "px", borderRightColor: this.params.cursorColor });
        } }, { key: "updateSize", value: function value() {
          for (var n = this, e = Math.round(this.width / this.params.pixelRatio), t = Math.ceil(e / this.maxCanvasElementWidth); this.canvases.length < t;) {
            this.addCanvas();
          }for (; this.canvases.length > t;) {
            this.removeCanvas();
          }this.canvases.forEach(function (e, t) {
            var r = n.maxCanvasWidth + 2 * Math.ceil(n.params.pixelRatio / 2);t == n.canvases.length - 1 && (r = n.width - n.maxCanvasWidth * (n.canvases.length - 1)), n.updateDimensions(e, r, n.height), n.clearWaveForEntry(e);
          });
        } }, { key: "addCanvas", value: function value() {
          var e = {},
              t = this.maxCanvasElementWidth * this.canvases.length;e.wave = this.wrapper.appendChild(this.style(document.createElement("canvas"), { position: "absolute", zIndex: 2, left: t + "px", top: 0, bottom: 0, height: "100%", pointerEvents: "none" })), e.waveCtx = e.wave.getContext("2d"), this.hasProgressCanvas && (e.progress = this.progressWave.appendChild(this.style(document.createElement("canvas"), { position: "absolute", left: t + "px", top: 0, bottom: 0, height: "100%" })), e.progressCtx = e.progress.getContext("2d")), this.canvases.push(e);
        } }, { key: "removeCanvas", value: function value() {
          var e = this.canvases.pop();e.wave.parentElement.removeChild(e.wave), this.hasProgressCanvas && e.progress.parentElement.removeChild(e.progress);
        } }, { key: "updateDimensions", value: function value(e, t, r) {
          var n = Math.round(t / this.params.pixelRatio),
              i = Math.round(this.width / this.params.pixelRatio);e.start = e.waveCtx.canvas.offsetLeft / i || 0, e.end = e.start + n / i, e.waveCtx.canvas.width = t, e.waveCtx.canvas.height = r, this.style(e.waveCtx.canvas, { width: n + "px" }), this.style(this.progressWave, { display: "block" }), this.hasProgressCanvas && (e.progressCtx.canvas.width = t, e.progressCtx.canvas.height = r, this.style(e.progressCtx.canvas, { width: n + "px" }));
        } }, { key: "clearWave", value: function value() {
          var t = this;this.canvases.forEach(function (e) {
            return t.clearWaveForEntry(e);
          });
        } }, { key: "clearWaveForEntry", value: function value(e) {
          e.waveCtx.clearRect(0, 0, e.waveCtx.canvas.width, e.waveCtx.canvas.height), this.hasProgressCanvas && e.progressCtx.clearRect(0, 0, e.progressCtx.canvas.width, e.progressCtx.canvas.height);
        } }, { key: "drawBars", value: function value(e, t, v, y) {
          var m = this;return this.prepareDraw(e, t, v, y, function (e) {
            var t = e.absmax,
                r = e.hasMinVals,
                n = (e.height, e.offsetY),
                i = e.halfH,
                a = e.peaks;if (void 0 !== v) {
              var s,
                  o = r ? 2 : 1,
                  u = a.length / o,
                  l = m.params.barWidth * m.params.pixelRatio,
                  c = l + (null === m.params.barGap ? Math.max(m.params.pixelRatio, ~~(l / 2)) : Math.max(m.params.pixelRatio, m.params.barGap * m.params.pixelRatio)),
                  h = u / m.width,
                  f = y;for (s = v; s < f; s += c) {
                var d = a[Math.floor(s * h * o)] || 0,
                    p = Math.round(d / t * i);m.fillRect(s + m.halfPixel, i - p + n, l + m.halfPixel, 2 * p);
              }
            }
          });
        } }, { key: "drawWave", value: function value(e, t, l, c) {
          var h = this;return this.prepareDraw(e, t, l, c, function (e) {
            var t = e.absmax,
                r = e.hasMinVals,
                n = (e.height, e.offsetY),
                i = e.halfH,
                a = e.peaks;if (!r) {
              var s,
                  o = [],
                  u = a.length;for (s = 0; s < u; s++) {
                o[2 * s] = a[s], o[2 * s + 1] = -a[s];
              }a = o;
            }void 0 !== l && h.drawLine(a, t, i, n, l, c), h.fillRect(0, i + n - h.halfPixel, h.width, h.halfPixel);
          });
        } }, { key: "drawLine", value: function value(t, r, n, i, a, s) {
          var o = this;this.canvases.forEach(function (e) {
            o.setFillStyles(e), o.drawLineToContext(e, e.waveCtx, t, r, n, i, a, s), o.drawLineToContext(e, e.progressCtx, t, r, n, i, a, s);
          });
        } }, { key: "drawLineToContext", value: function value(e, t, r, n, i, a, s, o) {
          if (t) {
            var u = r.length / 2,
                l = this.params.fillParent && this.width != u ? this.width / u : 1,
                c = Math.round(u * e.start),
                h = Math.round(u * e.end) + 1;if (!(o < c || h < s)) {
              var f,
                  d,
                  p = Math.min(c, s),
                  v = Math.max(h, o);for (t.beginPath(), t.moveTo((p - c) * l + this.halfPixel, i + a), f = p; f < v; f++) {
                var y = r[2 * f] || 0,
                    m = Math.round(y / n * i);t.lineTo((f - c) * l + this.halfPixel, i - m + a);
              }for (d = v - 1; p <= d; d--) {
                var b = r[2 * d + 1] || 0,
                    g = Math.round(b / n * i);t.lineTo((d - c) * l + this.halfPixel, i - g + a);
              }t.closePath(), t.fill();
            }
          }
        } }, { key: "fillRect", value: function value(e, t, r, n) {
          var i,
              a = Math.floor(e / this.maxCanvasWidth),
              s = Math.min(Math.ceil((e + r) / this.maxCanvasWidth) + 1, this.canvases.length);for (i = a; i < s; i++) {
            var o = this.canvases[i],
                u = i * this.maxCanvasWidth,
                l = { x1: Math.max(e, i * this.maxCanvasWidth), y1: t, x2: Math.min(e + r, i * this.maxCanvasWidth + o.waveCtx.canvas.width), y2: t + n };l.x1 < l.x2 && (this.setFillStyles(o), this.fillRectToContext(o.waveCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1), this.fillRectToContext(o.progressCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1));
          }
        } }, { key: "prepareDraw", value: function value(s, o, u, l, c) {
          var h = this;return f.frame(function () {
            if (s[0] instanceof Array) {
              var e = s;if (h.params.splitChannels) return h.setHeight(e.length * h.params.height * h.params.pixelRatio), e.forEach(function (e, t) {
                return h.prepareDraw(e, t, u, l, c);
              });s = e[0];
            }var t = 1 / h.params.barHeight;if (h.params.normalize) {
              var r = f.max(s),
                  n = f.min(s);t = r < -n ? -n : r;
            }var i = [].some.call(s, function (e) {
              return e < 0;
            }),
                a = h.params.height * h.params.pixelRatio;return c({ absmax: t, hasMinVals: i, height: a, offsetY: a * o || 0, halfH: a / 2, peaks: s });
          })();
        } }, { key: "fillRectToContext", value: function value(e, t, r, n, i) {
          e && e.fillRect(t, r, n, i);
        } }, { key: "setFillStyles", value: function value(e) {
          e.waveCtx.fillStyle = this.params.waveColor, this.hasProgressCanvas && (e.progressCtx.fillStyle = this.params.progressColor);
        } }, { key: "getImage", value: function value(t, r) {
          var e = this.canvases.map(function (e) {
            return e.wave.toDataURL(t, r);
          });return 1 < e.length ? e : e[0];
        } }, { key: "updateProgress", value: function value(e) {
          this.style(this.progressWave, { width: e + "px" });
        } }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = c, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var a = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function n(e) {
      return (n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== n(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e) {
      return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function l(e, t) {
      return (l = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var i = function (e) {
      function n(e, t) {
        var r;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (r = o(this, u(n).call(this))).container = e, r.params = t, r.width = 0, r.height = t.height * r.params.pixelRatio, r.lastPos = 0, r.wrapper = null, r;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && l(e, t);
      }(n, a.Observer), t = n, (r = [{ key: "style", value: function value(e, t) {
          return a.style(e, t);
        } }, { key: "createWrapper", value: function value() {
          this.wrapper = this.container.appendChild(document.createElement("wave")), this.style(this.wrapper, { display: "block", position: "relative", userSelect: "none", webkitUserSelect: "none", height: this.params.height + "px" }), (this.params.fillParent || this.params.scrollParent) && this.style(this.wrapper, { width: "100%", overflowX: this.params.hideScrollbar ? "hidden" : "auto", overflowY: "hidden" }), this.setupWrapperEvents();
        } }, { key: "handleEvent", value: function value(e, t) {
          !t && e.preventDefault();var r,
              n = e.targetTouches ? e.targetTouches[0].clientX : e.clientX,
              i = this.wrapper.getBoundingClientRect(),
              a = this.width,
              s = this.getWidth();return !this.params.fillParent && a < s ? 1 < (r = (n - i.left) * (this.params.pixelRatio / a) || 0) && (r = 1) : r = (n - i.left + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0, r;
        } }, { key: "setupWrapperEvents", value: function value() {
          var n = this;this.wrapper.addEventListener("click", function (e) {
            var t = n.wrapper.offsetHeight - n.wrapper.clientHeight;if (0 != t) {
              var r = n.wrapper.getBoundingClientRect();if (e.clientY >= r.bottom - t) return;
            }n.params.interact && n.fireEvent("click", e, n.handleEvent(e));
          }), this.wrapper.addEventListener("scroll", function (e) {
            return n.fireEvent("scroll", e);
          });
        } }, { key: "drawPeaks", value: function value(e, t, r, n) {
          this.setWidth(t) || this.clearWave(), this.params.barWidth ? this.drawBars(e, 0, r, n) : this.drawWave(e, 0, r, n);
        } }, { key: "resetScroll", value: function value() {
          null !== this.wrapper && (this.wrapper.scrollLeft = 0);
        } }, { key: "recenter", value: function value(e) {
          var t = this.wrapper.scrollWidth * e;this.recenterOnPosition(t, !0);
        } }, { key: "recenterOnPosition", value: function value(e, t) {
          var r = this.wrapper.scrollLeft,
              n = ~~(this.wrapper.clientWidth / 2),
              i = this.wrapper.scrollWidth - this.wrapper.clientWidth,
              a = e - n,
              s = a - r;if (0 != i) {
            if (!t && -n <= s && s < n) {
              a = r + (s = Math.max(-5, Math.min(5, s)));
            }(a = Math.max(0, Math.min(i, a))) != r && (this.wrapper.scrollLeft = a);
          }
        } }, { key: "getScrollX", value: function value() {
          var e = this.params.pixelRatio,
              t = Math.round(this.wrapper.scrollLeft * e);if (this.params.scrollParent) {
            var r = ~~(this.wrapper.scrollWidth * e - this.getWidth());t = Math.min(r, Math.max(0, t));
          }return t;
        } }, { key: "getWidth", value: function value() {
          return Math.round(this.container.clientWidth * this.params.pixelRatio);
        } }, { key: "setWidth", value: function value(e) {
          return this.width != e && (this.width = e, this.params.fillParent || this.params.scrollParent ? this.style(this.wrapper, { width: "" }) : this.style(this.wrapper, { width: ~~(this.width / this.params.pixelRatio) + "px" }), this.updateSize(), !0);
        } }, { key: "setHeight", value: function value(e) {
          return e != this.height && (this.height = e, this.style(this.wrapper, { height: ~~(this.height / this.params.pixelRatio) + "px" }), this.updateSize(), !0);
        } }, { key: "progress", value: function value(e) {
          var t = 1 / this.params.pixelRatio,
              r = Math.round(e * this.width) * t;if (r < this.lastPos || r - this.lastPos >= t) {
            if (this.lastPos = r, this.params.scrollParent && this.params.autoCenter) {
              var n = ~~(this.wrapper.scrollWidth * e);this.recenterOnPosition(n);
            }this.updateProgress(r);
          }
        } }, { key: "destroy", value: function value() {
          this.unAll(), this.wrapper && (this.wrapper.parentNode == this.container && this.container.removeChild(this.wrapper), this.wrapper = null);
        } }, { key: "updateCursor", value: function value() {} }, { key: "updateSize", value: function value() {} }, { key: "drawBars", value: function value(e, t, r, n) {} }, { key: "drawWave", value: function value(e, t, r, n) {} }, { key: "clearWave", value: function value() {} }, { key: "updateProgress", value: function value(e) {} }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = i, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n,
        a = (n = r(3)) && n.__esModule ? n : { default: n };!function (e) {
      {
        if (e && e.__esModule) return;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }t.default = e;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e, t, r) {
      return (u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, r) {
        var n = function (e, t) {
          for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = l(e));) {}return e;
        }(e, t);if (n) {
          var i = Object.getOwnPropertyDescriptor(n, t);return i.get ? i.get.call(r) : i.value;
        }
      })(e, t, r || e);
    }function l(e) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function c(e, t) {
      return (c = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var h = function (e) {
      function n(e) {
        var t;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (t = o(this, l(n).call(this, e))).params = e, t.media = { currentTime: 0, duration: 0, paused: !0, playbackRate: 1, play: function play() {}, pause: function pause() {}, volume: 0 }, t.mediaType = e.mediaType.toLowerCase(), t.elementPosition = e.elementPosition, t.peaks = null, t.playbackRate = 1, t.volume = 1, t.buffer = null, t.onPlayEnd = null, t;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && c(e, t);
      }(n, a.default), t = n, (r = [{ key: "init", value: function value() {
          this.setPlaybackRate(this.params.audioRate), this.createTimer();
        } }, { key: "createTimer", value: function value() {
          var t = this;this.on("play", function e() {
            t.isPaused() || (t.fireEvent("audioprocess", t.getCurrentTime()), (window.requestAnimationFrame || window.webkitRequestAnimationFrame)(e));
          }), this.on("pause", function () {
            t.fireEvent("audioprocess", t.getCurrentTime());
          });
        } }, { key: "load", value: function value(e, t, r, n) {
          var i = document.createElement(this.mediaType);i.controls = this.params.mediaControls, i.autoplay = this.params.autoplay || !1, i.preload = null == n ? "auto" : n, i.src = e, i.style.width = "100%";var a = t.querySelector(this.mediaType);a && t.removeChild(a), t.appendChild(i), this._load(i, r);
        } }, { key: "loadElt", value: function value(e, t) {
          e.controls = this.params.mediaControls, e.autoplay = this.params.autoplay || !1, this._load(e, t);
        } }, { key: "_load", value: function value(e, t) {
          var r = this;"function" == typeof e.load && e.load(), e.addEventListener("error", function () {
            r.fireEvent("error", "Error loading media element");
          }), e.addEventListener("canplay", function () {
            r.fireEvent("canplay");
          }), e.addEventListener("ended", function () {
            r.fireEvent("finish");
          }), e.addEventListener("play", function () {
            r.fireEvent("play");
          }), e.addEventListener("pause", function () {
            r.fireEvent("pause");
          }), this.media = e, this.peaks = t, this.onPlayEnd = null, this.buffer = null, this.setPlaybackRate(this.playbackRate), this.setVolume(this.volume);
        } }, { key: "isPaused", value: function value() {
          return !this.media || this.media.paused;
        } }, { key: "getDuration", value: function value() {
          if (this.explicitDuration) return this.explicitDuration;var e = (this.buffer || this.media).duration;return 1 / 0 <= e && (e = this.media.seekable.end(0)), e;
        } }, { key: "getCurrentTime", value: function value() {
          return this.media && this.media.currentTime;
        } }, { key: "getPlayedPercents", value: function value() {
          return this.getCurrentTime() / this.getDuration() || 0;
        } }, { key: "getPlaybackRate", value: function value() {
          return this.playbackRate || this.media.playbackRate;
        } }, { key: "setPlaybackRate", value: function value(e) {
          this.playbackRate = e || 1, this.media.playbackRate = this.playbackRate;
        } }, { key: "seekTo", value: function value(e) {
          null != e && (this.media.currentTime = e), this.clearPlayEnd();
        } }, { key: "play", value: function value(e, t) {
          this.seekTo(e);var r = this.media.play();return t && this.setPlayEnd(t), r;
        } }, { key: "pause", value: function value() {
          var e;return this.media && (e = this.media.pause()), this.clearPlayEnd(), e;
        } }, { key: "setPlayEnd", value: function value(t) {
          var r = this;this._onPlayEnd = function (e) {
            t <= e && (r.pause(), r.seekTo(t));
          }, this.on("audioprocess", this._onPlayEnd);
        } }, { key: "clearPlayEnd", value: function value() {
          this._onPlayEnd && (this.un("audioprocess", this._onPlayEnd), this._onPlayEnd = null);
        } }, { key: "getPeaks", value: function value(e, t, r) {
          return this.buffer ? u(l(n.prototype), "getPeaks", this).call(this, e, t, r) : this.peaks || [];
        } }, { key: "setSinkId", value: function value(e) {
          return e ? this.media.setSinkId ? this.media.setSinkId(e) : Promise.reject(new Error("setSinkId is not supported in your browser")) : Promise.reject(new Error("Invalid deviceId: " + e));
        } }, { key: "getVolume", value: function value() {
          return this.volume || this.media.volume;
        } }, { key: "setVolume", value: function value(e) {
          this.volume = e, this.media.volume = this.volume;
        } }, { key: "destroy", value: function value() {
          this.pause(), this.unAll(), this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode && this.media.parentNode.removeChild(this.media), this.media = null;
        } }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = h, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    function i(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function () {
      function e() {
        !function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, e), this.clearPeakCache();
      }var t, r, n;return t = e, (r = [{ key: "clearPeakCache", value: function value() {
          this.peakCacheRanges = [], this.peakCacheLength = -1;
        } }, { key: "addRangeToPeakCache", value: function value(e, t, r) {
          e != this.peakCacheLength && (this.clearPeakCache(), this.peakCacheLength = e);for (var n = [], i = 0; i < this.peakCacheRanges.length && this.peakCacheRanges[i] < t;) {
            i++;
          }for (i % 2 == 0 && n.push(t); i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= r;) {
            n.push(this.peakCacheRanges[i]), i++;
          }i % 2 == 0 && n.push(r), n = n.filter(function (e, t, r) {
            return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];
          }), this.peakCacheRanges = this.peakCacheRanges.concat(n), this.peakCacheRanges = this.peakCacheRanges.sort(function (e, t) {
            return e - t;
          }).filter(function (e, t, r) {
            return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];
          });var a = [];for (i = 0; i < n.length; i += 2) {
            a.push([n[i], n[i + 1]]);
          }return a;
        } }, { key: "getCacheRanges", value: function value() {
          var e,
              t = [];for (e = 0; e < this.peakCacheRanges.length; e += 2) {
            t.push([this.peakCacheRanges[e], this.peakCacheRanges[e + 1]]);
          }return t;
        } }]) && i(t.prototype, r), n && i(t, n), e;
    }();t.default = n, e.exports = t.default;
  }]);
});


},{}],137:[function(require,module,exports){
'use strict';

// lib

var _require = require('iblokz-data'),
    obj = _require.obj;

// initial state


var initial = {
	number: 0
};

// action
var set = function set(number) {
	return function (state) {
		return obj.patch(state, 'counter', { number: number });
	};
};
var incr = function incr() {
	return function (state) {
		return obj.patch(state, 'counter', { number: state.counter.number + 1 });
	};
};
var decr = function decr() {
	return function (state) {
		return obj.patch(state, 'counter', { number: state.counter.number - 1 });
	};
};

module.exports = {
	initial: initial,
	set: set,
	incr: incr,
	decr: decr
};

},{"iblokz-data":10}],138:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

// namespaces=


var counter = require('./counter');
var midiMap = require('./midi-map');

// initial
var initial = {
	mode: 0,
	stt: false,
	sttMic: false,
	query: '',
	session: {
		sample: 'assets/LatinEthnoElektroGroove.mp3',
		playing: false,
		focused: [0, 0],
		pads: {}
	}
};

// actions
var set = function set(key, value) {
	return function (state) {
		return obj.patch(state, key, value);
	};
};
var toggle = function toggle(key) {
	return function (state) {
		return obj.patch(state, key, !obj.sub(state, key));
	};
};
var arrToggle = function arrToggle(key, value) {
	return function (state) {
		return obj.patch(state, key, arr.toggle(obj.sub(state, key), value));
	};
};

module.exports = {
	initial: initial,
	// namespaces
	midiMap: midiMap,
	// actions
	set: set,
	toggle: toggle,
	arrToggle: arrToggle
};

},{"./counter":137,"./midi-map":139,"iblokz-data":10}],139:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Rx = require('rx');
var $ = Rx.Observable;

// util

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

var arrMod = function arrMod(a, p, v) {
	return [].concat(a.slice(0, p[0]), [p.length === 1 ? v : arrMod(a[p[0]], p.slice(1), v)], a.slice(p[0] + 1));
};

var initial = {
	devices: {
		inputs: [],
		outputs: []
	},
	settings: {
		midiRouteToActive: true
	},
	clock: {
		in: [],
		out: []
	},
	data: {
		in: [],
		out: []
	},
	pitch: 0,
	channels: {},
	map: [['controller', 20, ['instrument', 'vcf', 'cutoff']], ['controller', 21, ['instrument', 'vcf', 'resonance']], ['controller', 22, ['studio', 'bpm'], 60, 200, 0], ['controller', 23, ['studio', 'volume']], ['controller', 24, ['instrument', 'eg', 'attack']], ['controller', 25, ['instrument', 'eg', 'decay']], ['controller', 26, ['instrument', 'eg', 'sustain']], ['controller', 27, ['instrument', 'eg', 'release']]]
};

var connect = function connect(devices) {
	return function (state) {
		return obj.patch(state, 'midiMap', {
			devices: devices,
			data: _extends({}, state.midiMap.data, {
				in: state.midiMap.data.in.indexOf(devices.inputs.findIndex(function (dev) {
					return dev.name.match(/MPKmini2/);
				})) === -1 ? arr.add(state.midiMap.data.in, devices.inputs.findIndex(function (dev) {
					return dev.name.match(/MPKmini2/);
				})) : state.midiMap.data.in
			})
		});
	};
};

var toggleClock = function toggleClock(inOut, index) {
	return function (state) {
		return obj.patch(state, ['midiMap', 'clock', inOut], arr.toggle(obj.sub(state, ['midiMap', 'clock'])[inOut], index));
	};
};

var toggleData = function toggleData(inOut, index) {
	return function (state) {
		return obj.patch(state, ['midiMap', 'data', inOut], arr.toggle(obj.sub(state, ['midiMap', 'data', inOut]), index));
	};
};

var noteOn = function noteOn() {
	var device = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	var channel = arguments[1];
	var note = arguments[2];
	var velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	return function (state) {
		return channel !== undefined ?
		// console.log(state.midiMap.channels, obj.sub(state, ['midiMap', 'channels', channel, note]), channel, note, velocity),
		velocity !== 0 ? obj.patch(state, ['midiMap', 'channels', device, channel, note], velocity) : obj.patch(state, ['midiMap', 'channels', device], _defineProperty({}, channel, obj.filter(obj.sub(state, ['midiMap', 'channels', device, channel]) || {}, function (key, value) {
			return key !== note;
		}))) : state;
	};
};

var panic = function panic() {
	return function (state) {
		return obj.patch(state, ['midiMap', 'channels'], {});
	};
};

var modify = function modify(p, v) {
	return function (state) {
		return obj.patch(state, ['midiMap'], {
			map: arrMod(state.midiMap.map, p, v)
		});
	};
};

module.exports = {
	initial: initial,
	connect: connect,
	toggleClock: toggleClock,
	toggleData: toggleData,
	noteOn: noteOn,
	panic: panic,
	modify: modify
};

},{"iblokz-data":10,"rx":123}],140:[function(require,module,exports){
'use strict';

// lib

var Rx = require('rx');
var $ = Rx.Observable;

// iblokz
var vdom = require('iblokz-snabbdom-helpers');

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

// app


var app = require('./util/app');
var actions = app.adapt(require('./actions'));
var ui = require('./ui');
var actions$ = void 0;
var state$ = new Rx.BehaviorSubject();
// services
// wavesurfer
var wavesurfer = require('./services/wavesurfer.js');
// samples - audiocommons
var samples = require('./services/samples.js');
actions = app.attach(actions, 'samples', samples.actions);
// pads
var pads = require('./services/pads.js');
actions = app.attach(actions, 'pads', pads.actions);
// midi
var midi = require('./services/midi.js');
actions = app.attach(actions, 'midi', midi.actions);
// stt - speach to text
var stt = require('./services/stt.js');
// control
var control = require('./services/control.js');
actions = app.attach(actions, 'control', control.actions);

// hot reloading
if (module.hot) {
	// actions
	actions$ = $.fromEventPattern(function (h) {
		return module.hot.accept("./actions", h);
	}).flatMap(function () {
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		return actions.stream.startWith(function (state) {
			return state;
		});
	}).merge(actions.stream);
	// ui
	module.hot.accept("./ui", function () {
		ui = require('./ui');
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// services
	// wavesurfer
	module.hot.accept("./services/wavesurfer.js", function () {
		wavesurfer.unhook();
		wavesurfer = require('./services/wavesurfer.js');
		wavesurfer.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// samples
	module.hot.accept("./services/samples.js", function () {
		samples.unhook();
		samples = require('./services/samples.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		samples.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// pads
	module.hot.accept("./services/pads.js", function () {
		pads.unhook();
		pads = require('./services/pads.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		pads.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// midi
	module.hot.accept("./services/midi.js", function () {
		midi.unhook();
		midi = require('./services/midi.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		midi.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// stt
	module.hot.accept("./services/stt.js", function () {
		stt.unhook();
		stt = require('./services/stt.js');
		stt.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// control
	module.hot.accept("./services/control.js", function () {
		control.unhook();
		control = require('./services/control.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		control.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
} else {
	actions$ = actions.stream;
}

// actions -> state
actions$.map(function (action) {
	return action.path && console.log(action.path.join('.'), action.payload), console.log(action), action;
}).startWith(function () {
	return actions.initial;
}).scan(function (state, change) {
	return change(state);
}, {}).map(function (state) {
	return console.log(state), state;
}).subscribe(function (state) {
	return state$.onNext(state);
});

// state -> ui
var ui$ = state$.map(function (state) {
	return ui({ state: state, actions: actions });
});
vdom.patchStream(ui$, '#ui');

wavesurfer.hook({ state$: state$, actions: actions });
samples.hook({ state$: state$, actions: actions });
pads.hook({ state$: state$, actions: actions });
midi.hook({ state$: state$, actions: actions });
stt.hook({ state$: state$, actions: actions });
control.hook({ state$: state$, actions: actions });

// livereload impl.
if (module.hot) {
	document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></script>');
}

},{"./actions":138,"./services/control.js":141,"./services/midi.js":142,"./services/pads.js":143,"./services/samples.js":144,"./services/stt.js":145,"./services/wavesurfer.js":146,"./ui":149,"./util/app":151,"iblokz-data":10,"iblokz-snabbdom-helpers":15,"rx":123}],141:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;

var gamepad = require('../util/gamepad');

var actions = {
	initial: {}
};

var play = function play(url) {
	var an = document.createElement('AUDIO');
	an.setAttribute('autoplay', true);
	an.src = url;
};

var keyMap = [['7', '8', '9', '0'], ['u', 'i', 'o', 'p'], ['j', 'k', 'l', ';'], ['m', ',', '.', '/']];

var getIndex = function getIndex(key) {
	return keyMap.reduce(function (p1, cols, row) {
		return p1.row === -1 ? cols.reduce(function (p2, mapKey, col) {
			return key === mapKey ? { row: row, col: col } : p2;
		}, p1) : p1;
	}, { row: -1, col: -1 });
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	gamepad.changes().map(function (pads) {
		return console.log({ pads: pads }), pads;
	}).withLatestFrom(state$, function (pads, state) {
		return { pads: pads, state: state };
	}).subscribe(function (_ref2) {
		var pads = _ref2.pads,
		    state = _ref2.state;

		console.log(pads[0]);
		if (pads[0]) {
			if (pads[0].axes[1] === -1) actions.samples.prev();
			// if (pads[0].axes[0] > 0) actions.move('right');
			if (pads[0].axes[1] === 1) actions.samples.next();
			// if (pads[0].axes[0] < 0) actions.move('left');
			if (pads[0].buttons[8].pressed === true) {
				if (state.samples.list[state.samples.index]) play(state.samples.list[state.samples.index].sound);
			}
			if (pads[0].buttons[3].pressed === true) {
				var sample = state.samples.list[state.samples.index];
				if (sample) actions.pads.load(sample.id, sample.sound);
			}
			if (pads[0].buttons[0].pressed === true) {
				actions.set('sttMic', true);
			}
			if (pads[0].buttons[1].pressed === true) {
				actions.set('mode', 0);
			}
			if (pads[0].buttons[2].pressed === true) {
				actions.set('mode', 1);
			}
		}
	});

	$.fromEvent(document, 'keydown').filter(function (ev) {
		return ['input', 'textarea'].indexOf(ev.target.tagName.toLowerCase()) === -1;
	}).subscribe(function (ev) {
		var pos = getIndex(ev.key);
		console.log(ev.key, ev.target, pos);
		if (pos.row !== -1) {
			actions.midi.trigger(pos.row, pos.col);
		}
	});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/gamepad":160,"rx":123}],142:[function(require,module,exports){
'use strict';
// lib

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj;

var midi = require('../util/midi');
var pocket = require('../util/pocket');
var a = require('../util/audio');
var sampler = require('../util/audio/sources/sampler');

var getIds = function getIds(inputs, indexes) {
	return inputs.map(function (inp) {
		return inp.id;
	}).filter(function (id, i) {
		return indexes.indexOf(i) > -1;
	});
};

var trigger = function trigger(row, col) {
	return function (state) {
		var sampleId = obj.sub(state, ['pads', 'map', row, col]);
		if (sampleId) {
			var inst = sampler.clone(pocket.get(['sampleBank', sampleId]));
			inst = a.connect(inst, a.context.destination);
			a.start(inst);
		}
		return state;
	};
};

var actions = {
	initial: {},
	trigger: trigger
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	var _midi$init = midi.init(),
	    devices$ = _midi$init.devices$,
	    msg$ = _midi$init.msg$;

	// midi device access


	subs.push(devices$.subscribe(function (data) {
		return actions.midiMap.connect(data);
	}));

	var parsedMidiMsg$ = msg$.map(function (raw) {
		return { msg: midi.parseMidiMsg(raw.msg), raw: raw };
	})
	// .map(data => (console.log(data), data))
	.share();

	// midi messages
	subs.push(parsedMidiMsg$.map(function (midiData) {
		return console.log({ midiData: midiData }), midiData;
	})
	// .filter(({msg}) => ['noteOn', 'noteOff'].indexOf(msg.state) > -1)
	.filter(function (_ref2) {
		var msg = _ref2.msg;
		return msg.state === 'controller' || msg.state === 'noteOn';
	}).withLatestFrom(state$, function (midiData, state) {
		return _extends({}, midiData, { state: state });
	})
	// .filter(({raw, state}) => (
	// 	// console.log(raw.input.id, state.midiMap.devices.inputs, state.midiMap.data.in),
	// 	getIds(state.midiMap.devices.inputs, state.midiMap.data.in).indexOf(
	// 		raw.input.id
	// 	) > -1
	// ))
	.subscribe(function (_ref3) {
		var raw = _ref3.raw,
		    msg = _ref3.msg,
		    state = _ref3.state;

		// console.log(state.midiMap.devices.inputs, raw.input);
		// traktor
		if (msg.channel === 13 && msg.state === 'controller' && msg.value === 1) {
			if (msg.controller >= 10 && msg.controller <= 26) {
				var col = (msg.controller - 10) % 4;
				var row = (msg.controller - 10 - col) / 4;
				var sampleId = obj.sub(state, ['pads', 'map', row, col]);
				// let inst;
				switch (state.mode) {
					case 1:
						trigger(row, col)(state);
						break;
					case 0:
						actions.set(['pads', 'focused'], [row, col]);
						break;
					default:
				}
			}
			if (msg.controller >= 37 && msg.controller <= 39) {
				actions.set('mode', msg.controller - 37);
			}
		}
		if (msg.channel === 10 && msg.state === 'noteOn') {
			var _col = (msg.note.number - 60) % 4;
			var _row = (msg.note.number - 60 - _col) / 4 + ((msg.note.number - 60 - _col) / 4 % 2 === 1 ? -1 : 1);
			// console.log((msg.note.number - 60 - col) / 4, (msg.note.number - 60 - col) % 2, row, col);
			switch (state.mode) {
				case 1:
					trigger(_row, _col)(state);
					break;
				case 0:
					actions.set(['pads', 'focused'], [_row, _col]);
					break;
				default:
			}
		}
	}));

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/audio":156,"../util/audio/sources/sampler":157,"../util/midi":161,"../util/pocket":162,"iblokz-data":10,"rx":123}],143:[function(require,module,exports){
'use strict';
// lib

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var pocket = require('../util/pocket');
var file = require('../util/file');

var _require2 = require('../util/audio'),
    context = _require2.context;

var sampler = require('../util/audio/sources/sampler');

var load = function load(id, url) {
	return $.fromPromise(fetch(url.replace('http://', '//')).then(function (res) {
		return res.arrayBuffer();
	})).concatMap(function (buffer) {
		return $.fromCallback(context.decodeAudioData, context)(buffer);
	}).map(function (buffer) {
		return {
			id: id,
			node: sampler.create(url, buffer)
		};
	}).map(function (sample) {
		return pocket.put(['sampleBank', sample.id], sample.node), function (state) {
			return obj.patch(state, ['pads', 'map'].concat(_toConsumableArray(state.pads.focused)), sample.id);
		};
	});
};

var actions = {
	initial: {
		focused: [0, 0],
		map: {}
	},
	load: load
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/audio":156,"../util/audio/sources/sampler":157,"../util/file":158,"../util/pocket":162,"iblokz-data":10,"rx":123}],144:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;

var request = require('superagent');

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = require('../util/pocket');

var url = 'https://m2.audiocommons.org/api/audioclips';

var search = function search(_ref) {
	var pattern = _ref.pattern,
	    _ref$source = _ref.source,
	    source = _ref$source === undefined ? 'freesound' : _ref$source;
	return request.get(url + '/search').query({ pattern: pattern, source: source }).then(function (res) {
		return res.body.results;
	}).then(function (results) {
		return console.log(results), results;
	}).then(function (results) {
		return results[0].members.map(function (m) {
			return {
				id: m.content['@id'],
				name: m.content.title,
				author: m.content.author.replace('freesound-users:', ''),
				sound: m.content.availableAs[0].locator,
				image: m.content.images[0].locator,
				license: m.content.license,
				duration: m.content.duration
			};
		});
	}).then(function (list) {
		return function (state) {
			return obj.patch(state, ['samples'], { list: list });
		};
	});
};

var next = function next() {
	return function (state) {
		return obj.patch(state, ['samples'], {
			index: state.samples.index < state.samples.list.length - 1 ? state.samples.index + 1 : state.samples.index
		});
	};
};

var prev = function prev() {
	return function (state) {
		return obj.patch(state, ['samples'], {
			index: state.samples.index > 0 ? state.samples.index - 1 : state.samples.index
		});
	};
};

var actions = {
	initial: {
		list: [],
		index: 0
	},
	search: search,
	next: next,
	prev: prev
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];
	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/pocket":162,"iblokz-data":10,"rx":123,"superagent":128}],145:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;
var request = require('superagent');

var SpeechSDK = window.SpeechSDK;

var subscriptionKey = 'c63057e1219441489c1b43132685c4b8';
var region = 'westus';
var url = 'https://' + region + '.api.cognitive.microsoft.com/sts/v1.0/issueToken';

var init = function init(token) {
	var speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
	speechConfig.speechRecognitionLanguage = "en-GB";
	var audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
	var recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);
	return recognizer;
};

var recognize = function recognize(recognizer) {
	return $.fromCallback(recognizer.recognizeOnceAsync, recognizer)().map(function (res) {
		return console.log(res), res;
	});
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	request.post(url).set({
		'Content-Type': 'application/json',
		'Ocp-Apim-Subscription-Key': subscriptionKey
	}).then(function (res) {
		return actions.set('stt', res.text);
	});

	state$.distinctUntilChanged(function (state) {
		return state.stt + ' ' + state.sttMic;
	}).filter(function (state) {
		return state.stt && state.sttMic;
	}).map(function (state) {
		return init(state.stt);
	}).flatMap(recognize).subscribe(function (res) {
		var query = res.privText.replace(/\.$/, '');
		actions.set('query', query);
		actions.samples.search({ pattern: query });
		actions.set('sttMic', false);
	});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"rx":123,"superagent":128}],146:[function(require,module,exports){
'use strict';
// lib

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Rx = require('rx');
var $ = Rx.Observable;

var WaveSurfer = require('wavesurfer.js');
// window.WaveSurfer = WaveSurfer;
var TimelinePlugin = require('wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js');
var RegionsPlugin = require('wavesurfer.js/dist/plugin/wavesurfer.regions.min.js');
// require('wavesurfer/plugin/wavesurfer.timeline.js');
// WaveSurfer = window.WaveSurfer;

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = require('../util/pocket');

var init = function init(container) {
	container.innerHTML = '';
	var wavesurfer = WaveSurfer.create({
		container: '#waveform',
		waveColor: '#cde',
		progressColor: '#789',
		plugins: [TimelinePlugin.create({
			container: '#wave-timeline'
			// deferInit: true // stop the plugin from initialising immediately
		}), RegionsPlugin.create({
			// plugin options ...
		})]
	});
	// wavesurfer.load('assets/LatinEthnoElektroGroove.mp3');
	return wavesurfer;
};

var load = function load(_ref) {
	var wavesurfer = _ref.wavesurfer,
	    sample = _ref.sample;

	console.log(wavesurfer, sample, pocket);
	if (sample[0] === 'url') wavesurfer.load(sample[1]);else if (sample[1]) wavesurfer.loadDecodedBuffer(pocket.get(['sampleBank', sample[1]]).output.buffer);
	return wavesurfer;
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];

	var wavesurfer$ = $.interval(100).map(function () {
		return document.querySelector('#waveform');
	}).distinctUntilChanged(function (el) {
		return el;
	}).filter(function (el) {
		return el;
	}).map(init);

	var sampleChange$ = state$.distinctUntilChanged(function (state) {
		return state.pads.focused.toString() + ' ' + obj.sub(state.pads, ['map'].concat(_toConsumableArray(state.pads.focused)));
	}).map(function (state) {
		return ['id', obj.sub(state.pads.map, state.pads.focused)];
	}).startWith(['url', 'assets/LatinEthnoElektroGroove.mp3']);

	wavesurfer$.flatMap(function (wavesurfer) {
		return $.merge(sampleChange$.map(function (sample) {
			return function (wavesurfer) {
				return load({ wavesurfer: wavesurfer, sample: sample });
			};
		}), state$.distinctUntilChanged(function (state) {
			return state.session.playing;
		}).map(function (state) {
			return function (wavesurfer) {
				return wavesurfer.playPause(), wavesurfer;
			};
		})).scan(function (wavesurfer, reducer) {
			return reducer(wavesurfer);
		}, wavesurfer);
	}).subscribe(function (data) {});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/pocket":162,"iblokz-data":10,"rx":123,"wavesurfer.js":136,"wavesurfer.js/dist/plugin/wavesurfer.regions.min.js":134,"wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js":135}],147:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    select = _require.select,
    option = _require.option,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var formUtil = require('../../util/form');

var play = function play(url) {
	var an = document.createElement('AUDIO');
	an.setAttribute('autoplay', true);
	an.src = url;
};

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#board', [].concat(form('#board-search', {
		on: {
			submit: function submit(ev) {
				ev.preventDefault();
				var data = formUtil.toData(ev.target);
				console.log(data);
				actions.samples.search(data);
			}
		}
	}, [input('#board-search-pattern[name="pattern"][placeholder="Query"]', {
		attrs: {
			value: state.query
		}
	}), select('[name="source"]', ['freesound', 'jamendo', 'europeana'].map(function (s) {
		return option('[value="' + s + '"]', s);
	})), button('Search')]), state.samples.list.length > 0 ? table('#board-samples[width="100%"][cellspacing=4][cellpadding=0]', [thead(tr([th('[width="60%"]', 'Sample'), th('Author'), th('Duration'), th('License'), th('Play'), th('Load')])), tbody(state.samples.list.map(function (sample, index) {
		return tr({
			class: {
				selected: index === state.samples.index
			}
		}, [td([img('[src="' + sample.image + '"]'), span(sample.name)]), td(sample.author), td((sample.duration / 1000).toFixed(2) + ' s'), td(a('[target="_blank"][href="' + sample.license + '"]', sample.license.replace('http://creativecommons.org/', ''))), td([button({
			on: {
				click: function click() {
					return play(sample.sound);
				}
			}
		}, i('.fa.fa-play'))]), td([button({
			on: {
				click: function click(ev) {
					return actions.pads.load(sample.id, sample.sound);
				}
			}
		}, i('.fa.fa-plus'))])]);
	}))]) : []));
};

},{"../../util/form":159,"iblokz-snabbdom-helpers":15}],148:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    button = _require.button,
    span = _require.span,
    header = _require.header,
    h1 = _require.h1,
    ul = _require.ul,
    li = _require.li,
    i = _require.i;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return header([ul('.left', [li(button({
		on: {
			click: function click() {
				return actions.set('sttMic', true);
			}
		},
		class: {
			selected: state.sttMic
		}
	}, i('.fa.fa-volume-control-phone')))]), h1('xAmplR'), ul('.right', [li(button({
		on: {
			click: function click() {
				return actions.set('mode', 0);
			}
		},
		class: {
			selected: state.mode === 0
		}
	}, i('.fa.fa-edit'))), li(button({
		on: {
			click: function click() {
				return actions.set('mode', 1);
			}
		},
		class: {
			selected: state.mode === 1
		}
	}, i('.fa.fa-music')))])]);
};

},{"iblokz-snabbdom-helpers":15}],149:[function(require,module,exports){
'use strict';

// dom

var _require = require('iblokz-snabbdom-helpers'),
    h1 = _require.h1,
    a = _require.a,
    div = _require.div,
    i = _require.i,
    section = _require.section,
    button = _require.button,
    span = _require.span;
// components


var header = require('./header');
var board = require('./board');
var pads = require('./pads');
// const counter = require('./counter');

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#ui', [header({ state: state, actions: actions }), section('.waveform', [div('#wave-timeline'), div('#waveform'), button({
		on: {
			click: function click() {
				return actions.toggle(['session', 'playing']);
			}
		}
	}, i('.fa.fa-' + (state.session.playing ? 'pause' : 'play')))]), board({ state: state, actions: actions }), pads({ state: state, actions: actions })]);
};

},{"./board":147,"./header":148,"./pads":150,"iblokz-snabbdom-helpers":15}],150:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#pads', div('.rows', Array(4).fill({}).map(function (a, row) {
		return div('.cols', Array(4).fill({}).map(function (a, col) {
			return button('.pad', {
				class: {
					focused: state.mode === 0 && state.pads.focused[0] === row && state.pads.focused[1] === col
				},
				on: {
					focus: function focus() {
						return actions.set(['pads', 'focused'], [row, col]);
					},
					click: function click() {
						return state.mode === 1 && actions.midi.trigger(row, col) || state.mode === 0 && actions.set(['pads', 'focused'], [row, col]);
					}
				}
			});
		}));
	})));
};

},{"iblokz-snabbdom-helpers":15}],151:[function(require,module,exports){
'use strict';

// lib

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    arr = _require.arr,
    obj = _require.obj;

var observe = function observe(source) {
	return source instanceof Rx.Observable ? source : source.then instanceof Function ? Rx.Observable.fromPromise(source) : Rx.Observable.just(source);
};

var adapt = function adapt(o) {
	var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	return Object.keys(o).filter(function (key) {
		return key !== 'initial';
	}).reduce(function (o2, key) {
		return _extends({}, o2, o[key] instanceof Function && obj.keyValue(key, function () {
			var _arguments = arguments;

			observe(o[key].apply(null, Array.from(arguments))).subscribe(function (resp) {
				return o2.stream.onNext(_extends(resp, {
					path: [].concat(p, key),
					payload: Array.from(_arguments)
				}));
			});
		}) || o[key] instanceof Object && function () {
			var o3 = adapt(o[key], [].concat(p, key));
			o3.stream.subscribe(function (resp) {
				return o2.stream.onNext(resp);
			});
			return _extends({
				initial: _extends({}, o2.initial, obj.keyValue(key, o3.initial))
			}, obj.keyValue(key, o3));
		}() || obj.keyValue(key, o[key]));
	}, { stream: new Rx.Subject(), initial: o.initial || {} });
};

var attach = function attach(tree, path, node) {
	return [adapt(node, path)].map(function (adaptedNode) {
		return adaptedNode.stream.subscribe(function (resp) {
			return tree.stream.onNext(resp);
		}), _extends({}, obj.patch(tree, path, adaptedNode), {
			initial: obj.patch(tree.initial, path, adaptedNode.initial)
		});
	}).pop();
};

module.exports = {
	adapt: adapt,
	attach: attach
};

},{"iblokz-data":10,"rx":123}],152:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData,
    schedule = _require2.schedule;

var create = function create(prefs) {
	return [{
		prefs: _extends({
			volume: 0.41,
			attack: 0.31,
			decay: 0.16,
			sustain: 0.8,
			release: 0.21
		}, prefs),
		through: _create('gain')
	}].map(function (n) {
		return set(n.through.gain, 'value', 0), n;
	}).pop();
};

var update = function update(n, prefs) {
	return set(n, 'prefs', _extends({}, n.prefs, prefs)), n;
};

var noteOn = function noteOn(node, velocity, time) {
	var now = context.currentTime;
	time = (time || now) + 0.0001;

	node.through.gain.cancelScheduledValues(0);

	var changes = [].concat(
	// attack
	node.prefs.attack > 0 ? [[0, time], [velocity * node.prefs.volume, node.prefs.attack]] : [[velocity * node.prefs.volume, time]],
	// decay
	node.prefs.decay > 0 ? [[node.prefs.sustain * velocity * node.prefs.volume, node.prefs.decay]] : []).reduce(function (a, c) {
		return [[].concat(a[0], c[0]), [].concat(a[1], c[1])];
	}, [[], []]);

	schedule(node.through, 'gain', changes[0], changes[1]);
	return node;
};

var noteOff = function noteOff(node, time) {
	var now = context.currentTime;
	time = time || now + 0.0001;

	setTimeout(function () {
		return node.through.gain.cancelScheduledValues(0), node.through.gain.setValueCurveAtTime(new Float32Array([node.through.gain.value, 0]), time, node.prefs.release > 0 && node.prefs.release || 0.00001);
	}, (time - now) * 1000);
	return node;
};

module.exports = {
	create: create,
	update: update,
	noteOn: noteOn,
	noteOff: noteOff
};

},{"../core":153,"iblokz-data":10}],153:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext)();

var set = function set(o, k, v) {
	return o[k] = v;
};
var isSet = function isSet(v) {
	return v !== undefined;
};
var isGet = function isGet(v) {
	return isSet(v) ? v : null;
};

var apply = function apply(o1, o2) {
	return Object.keys(o2).reduce(function (o, k) {
		return set(o, k, o2[k]);
	}, o1);
};

var create = function create(type) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	return (
		// console.log(type),
		obj.switch(type, {
			oscillator: function oscillator() {
				return context.createOscillator.apply(context, args);
			},
			gain: function gain() {
				return context.createGain.apply(context, args);
			},
			biquadFilter: function biquadFilter() {
				return context.createBiquadFilter.apply(context, args);
			},
			convolver: function convolver() {
				return context.createConvolver.apply(context, args);
			},
			buffer: function buffer() {
				return context.createBuffer.apply(context, args);
			},
			bufferSource: function bufferSource() {
				return context.createBufferSource.apply(context, args);
			}
		})()
	);
};

var update = function update(node, prefs) {
	return apply(node, prefs);
};

var connect = function connect(n1, n2) {
	return (
		// console.log(n1, n2),
		n1.connect(n2), n1
	);
};
var disconnect = function disconnect(n1, n2) {
	// since there is no way to determine if they are connected
	try {
		n1.disconnect(n2);
	} catch (err) {
		console.log(err);
	}
	return n1;
};

var chain = function chain() {
	for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		nodes[_key2] = arguments[_key2];
	}

	return nodes.forEach(function (n, i) {
		return isSet(nodes[i + 1]) && connect(n, nodes[i + 1]);
	}), nodes[0];
};

var unchain = function unchain() {
	for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
		nodes[_key3] = arguments[_key3];
	}

	return nodes.slice().reverse().forEach(function (n, i) {
		return isSet(nodes[i - 1]) && disconnect(nodes[i - 1], n);
	}), nodes[0];
};

var duration = function duration(seconds) {
	return context.sampleRate * seconds;
};
var chData = function chData(node) {
	for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		args[_key4 - 1] = arguments[_key4];
	}

	return (
		// console.log(node, args),
		node.getChannelData.apply(node, args)
	);
};

var schedule = function schedule(node, pref, values, times) {
	return values.length === 1 ? node[pref].setValueAtTime(values[0], times[0]) : (node[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [times[0] + times[1]].concat(times.slice(2))));
};

module.exports = {
	context: context,
	set: set,
	isSet: isSet,
	isGet: isGet,
	create: create,
	update: update,
	connect: connect,
	disconnect: disconnect,
	chain: chain,
	unchain: unchain,
	// util
	duration: duration,
	chData: chData,
	schedule: schedule
};

},{"iblokz-data":10}],154:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;

var create = function create(prefs) {
	return [{
		prefs: _extends({
			type: 'sawtooth',
			frequency: 5,
			gain: 15
		}, prefs),
		effect: _create('oscillator'),
		output: _create('gain')
	}].map(function (n) {
		return chain(n.effect, n.output), set(n.effect.frequency, 'value', n.prefs.frequency), set(n.output.gain, 'value', n.prefs.gain), set(n.effect, 'type', n.prefs.type), n;
	}).pop();
};

var update = function update(n, prefs) {
	return set(n, 'prefs', _extends({}, n.prefs, prefs)), set(n.effect.frequency, 'value', n.prefs.frequency), set(n.output.gain, 'value', n.prefs.gain), set(n.effect, 'type', n.prefs.type), n;
};

var start = function start(n) {
	return n.effect.start(), n;
};

// const clone = n => create(null, n.output.buffer);

module.exports = {
	create: create,
	update: update,
	start: start
};

},{"../core":153,"iblokz-data":10}],155:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;
// const {context} = core;

var buildImpulse = function buildImpulse(_ref) {
	var seconds = _ref.seconds,
	    decay = _ref.decay;

	var impulse = _create('buffer', 2, duration(seconds), context.sampleRate);
	var channelData = [chData(impulse, 0), chData(impulse, 1)];
	for (var i = 0; i < duration(seconds); i++) {
		channelData[0][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
		channelData[1][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
	}
	return impulse;
};

var create = function create(prefs) {
	return [{
		prefs: _extends({ seconds: 3, decay: 2, wet: 0, dry: 1 }, prefs),
		input: _create('gain'),
		output: _create('gain'),
		effect: _create('convolver'),
		wet: _create('gain'),
		dry: _create('gain')
	}].map(function (n) {
		return chain(n.input, n.dry, n.output), chain(n.input, n.effect, n.wet, n.output), set(n.dry.gain, 'value', n.prefs.dry), set(n.wet.gain, 'value', n.prefs.wet), set(n.effect, 'buffer', buildImpulse(n.prefs)), n;
	}
	// n

	/*
 n.input.connect(n.effect);
 n.effect.connect(n.wet);
 n.wet.connect(n.output);
 	n.input.connect(n.dry);
 n.dry.connect(n.output);
 */
	/*
 n.dry.gain.value = n.prefs.dry;
 n.wet.gain.value = n.prefs.wet;
 n.effect.buffer = buildImpulse(n.prefs);
 */
	// set(n.wet.gain, 'value', n.prefs.wet),
	// set(n.effect, 'buffer', buildImpulse(n.prefs)),
	// return n;
	).pop();
};

var update = function update(n, prefs) {
	return (
		//	console.log(prefs, n.prefs),
		(n.prefs.seconds !== prefs.seconds || n.prefs.decay !== prefs.decay) && set(n.effect, 'buffer', buildImpulse(n.prefs)), n.prefs.dry !== prefs.dry && set(n.dry.gain, 'value', prefs.dry), n.prefs.wet !== prefs.wet && set(n.wet.gain, 'value', prefs.wet), set(n, 'prefs', _extends({}, n.prefs, prefs)), n
	);
};

module.exports = {
	create: create,
	update: update
};

},{"../core":153,"iblokz-data":10}],156:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('./core'),
    context = _require2.context,
    set = _require2.set,
    isSet = _require2.isSet,
    isGet = _require2.isGet,
    _schedule = _require2.schedule,
    _create = _require2.create,
    _connect = _require2.connect,
    _disconnect = _require2.disconnect;

var _reverb = require('./effects/reverb');
var _lfo = require('./effects/lfo');
var _adsr = require('./controls/adsr');

var create = function create(type) {
	var prefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context;
	return _extends({}, obj.switch(type, {
		vco: function vco() {
			return { output: _create('oscillator') };
		},
		vca: function vca() {
			return { through: _create('gain') };
		},
		vcf: function vcf() {
			return { through: _create('biquadFilter') };
		},
		lfo: function lfo() {
			return _lfo.create(prefs);
		},
		reverb: function reverb() {
			return _reverb.create(prefs);
		},
		adsr: function adsr() {
			return _adsr.create(prefs);
		}
	})(), { type: type, out: [] });
};

var cutoffToFreq = function cutoffToFreq(cutoff) {
	var minValue = 40;
	var maxValue = context.sampleRate / 2;
	// Logarithm (base 2) to compute how many octaves fall in the range.
	var numberOfOctaves = Math.log(maxValue / minValue) / Math.LN2;
	// Compute a multiplier from 0 to 1 based on an exponential scale.
	var multiplier = Math.pow(2, numberOfOctaves * (cutoff - 1.0));
	// Get back to the frequency value between min and max.
	return maxValue * multiplier;
};

var update = function update(node, prefs) {
	return obj.switch(node.type, {
		vco: function vco() {
			return isSet(prefs.type) && set(node.output, 'type', prefs.type), isSet(prefs.freq) && set(node.output.frequency, 'value', prefs.freq), isSet(prefs.detune) && set(node.output.detune, 'value', prefs.detune), _extends(node, { prefs: prefs });
		},
		vca: function vca() {
			return isSet(prefs.gain) && set(node.through.gain, 'value', prefs.gain), _extends(node, { prefs: prefs });
		},
		vcf: function vcf() {
			return isSet(prefs.type) && set(node.through, 'type', prefs.type), isSet(prefs.cutoff) && _schedule(node.through, 'frequency', [cutoffToFreq(prefs.cutoff)], [context.currentTime + 0.0001]),
			// set(node.through.frequency, 'value', cutoffToFreq(prefs.cutoff)),
			isSet(prefs.resonance) && _schedule(node.through, 'Q', [prefs.resonance * 30], [context.currentTime + 0.0001]), _extends(node, { prefs: prefs });
		},
		reverb: function reverb() {
			return _reverb.update(node, prefs);
		},
		adsr: function adsr() {
			return _adsr.update(node, prefs);
		},
		lfo: function lfo() {
			return _lfo.update(node, prefs);
		}
	})();
};

var connect = function connect(node1, node2) {
	return !(node1.out && node1.out.indexOf(node2) > -1) ? (_connect(
	// input
	isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1,
	// output
	node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), _extends({}, node1, {
		out: [].concat(node1.out || [], [node2])
	})) : node1;
};

var disconnect = function disconnect(node1, node2) {
	return (
		// (console.log('dissconnecting', node1, node2)),
		node1.out.indexOf(node2) > -1 ? (_disconnect(
		// input
		isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1,
		// output
		node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), _extends({}, node1, {
			out: [].concat(node1.out.slice(0, node1.out.indexOf(node2)), node1.out.slice(node1.out.indexOf(node2) + 1))
		})) : typeof node2 === 'undefined' ? node1.out.reduce(function (node1, prevNode) {
			return disconnect(node1, prevNode);
		}, node1) : node1
	);
};

var reroute = function reroute(node1, node2) {
	return node1.out && node1.out.indexOf(node2) === -1 ? connect(disconnect(node1), node2) : node1;
};

var chain = function chain() {
	for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
		nodes[_key] = arguments[_key];
	}

	return nodes.forEach(function (n, i) {
		return isSet(n[i + 1]) && connect(n, nodes[i + 1]);
	}), nodes[0];
};

var unchain = function unchain() {
	for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		nodes[_key2] = arguments[_key2];
	}

	return nodes.slice().reverse().forEach(function (n, i) {
		return isSet(n[i - 1]) && disconnect(nodes[i - 1], n);
	}), nodes[0];
};

var start = function start(node) {
	var _node$output;

	for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		args[_key3 - 1] = arguments[_key3];
	}

	return node.type === 'lfo' && _lfo.start.apply(_lfo, [node].concat(args)) || (_node$output = node.output).start.apply(_node$output, args), node;
};

var stop = function stop(node) {
	var _node$output2;

	for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		args[_key4 - 1] = arguments[_key4];
	}

	return (_node$output2 = node.output).stop.apply(_node$output2, args), node;
};

var schedule = function schedule(node, pref, values, times) {
	return values.length === 1 ? node.through[pref].setValueAtTime(values[0], times[0]) : (node.through[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [times[0] + times[1]].concat(times.slice(2))));
};

var noteToFrequency = function noteToFrequency(note) {
	var notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
	var keyNumber;
	var octave;

	if (note.length === 3) {
		octave = note.charAt(2);
	} else {
		octave = note.charAt(1);
	}

	keyNumber = notes.indexOf(note.slice(0, -1));

	if (keyNumber < 3) {
		keyNumber = keyNumber + 12 + (octave - 1) * 12 + 1;
	} else {
		keyNumber = keyNumber + (octave - 1) * 12 + 1;
	}

	return 440 * Math.pow(2, (keyNumber - 49) / 12);
};

module.exports = {
	context: context,
	create: create,
	update: update,
	schedule: schedule,
	connect: connect,
	disconnect: disconnect,
	reroute: reroute,
	chain: chain,
	unchain: unchain,
	noteToFrequency: noteToFrequency,
	start: start,
	stop: stop,
	vco: function vco(prefs) {
		return update(create('vco', {}, context), prefs);
	},
	vcf: function vcf(prefs) {
		return update(create('vcf', {}, context), prefs);
	},
	lfo: function lfo(prefs) {
		return update(create('lfo', {}, context), prefs);
	},
	vca: function vca(prefs) {
		return update(create('vca', {}, context), prefs);
	},
	adsr: function adsr(prefs) {
		return create('adsr', prefs, context);
	},
	noteOn: _adsr.noteOn,
	noteOff: _adsr.noteOff
};

},{"./controls/adsr":152,"./core":153,"./effects/lfo":154,"./effects/reverb":155,"iblokz-data":10}],157:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;

var create = function create(file, buffer) {
	return [{
		output: _create('bufferSource')
	}].map(function (n) {
		return !buffer ? fetch(file).then(function (res) {
			return res.arrayBuffer();
		}).then(function (buffer) {
			return context.decodeAudioData(buffer, function (buffer) {
				return set(n.output, 'buffer', buffer);
			});
		}) : set(n.output, 'buffer', buffer), n;
	}).pop();
};

var update = function update() {};

var clone = function clone(n) {
	return create(null, n.output.buffer);
};

module.exports = {
	create: create,
	update: update,
	clone: clone
};

},{"../core":153,"iblokz-data":10}],158:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;
var fileSaver = require('file-saver');
var jsZip = require("jszip");

var _require = require("iblokz-data"),
    fn = _require.fn,
    obj = _require.obj;

var load = function load(file) {
	var readAs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
	return $.create(function (stream) {
		var fr = new FileReader();
		fr.onload = function (ev) {
			// console.log(readAs, ev.target.result);
			stream.onNext(readAs === 'json' ? JSON.parse(ev.target.result) : ev.target.result);
			stream.onCompleted();
		};
		// console.log(file, readAs);
		(typeof file === 'string' ? $.fromPromise(fetch(file)).flatMap(function (res) {
			return res.blob();
		}) : $.just(file)).subscribe(function (f) {
			return fn.switch(readAs, {
				arrayBuffer: function arrayBuffer(f) {
					return fr.readAsArrayBuffer(f);
				},
				default: function _default(f) {
					return fr.readAsText(f);
				}
			})(f);
		});
	});
};

var loadZip = function loadZip(file) {
	return load(file, 'arrayBuffer').flatMap(function (data) {
		return $.fromPromise(jsZip.loadAsync(data));
	}).flatMap(function (zf) {
		return $.concat(Object.keys(zf.files).filter(function (k) {
			return !zf.files[k].dir;
		})
		// .map(k => (console.log(k), k))
		.map(function (k) {
			return $.fromPromise(zf.files[k].async('arraybuffer')).map(function (v) {
				return { k: k, v: v };
			});
		})).reduce(function (o, _ref) {
			var k = _ref.k,
			    v = _ref.v;
			return obj.patch(o, k, v);
		}, {});
	});
};

var save = function save(fileName, content) {
	return fileSaver.saveAs(new Blob([JSON.stringify(content)], { type: "text/plain;charset=utf-8" }), fileName);
};

module.exports = {
	load: load,
	loadZip: loadZip,
	save: save
};

},{"file-saver":7,"iblokz-data":10,"jszip":42,"rx":123}],159:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj;

var keys = Object.keys;

var arrify = function arrify(o) {
  return o instanceof Object ? !(o instanceof Array) && keys(o).filter(function (k) {
    return k.match(/^-?[0-9.]+$/);
  }).length === keys(o).length ? keys(o).map(function (k) {
    return arrify(o[k]);
  }) : keys(o).reduce(function (o2, k) {
    return obj.patch(o2, k, arrify(o[k]));
  }, {}) : o;
};

var toData = function toData(form) {
  return arrify(Array.from(form.elements)
  // .map(el => (console.log(el.name), el))
  .filter(function (el) {
    return el.name !== undefined && el.name !== '';
  }).reduce(function (o, el) {
    return obj.patch(o, el.name.split('.'), el.type && el.type === 'number' ? Number(el.value) : el.value);
  }, {}));
};

var clear = function clear(form) {
  return Array.from(form.elements).forEach(function (el) {
    return el.value = null;
  });
};

module.exports = {
  toData: toData,
  clear: clear
};

},{"iblokz-data":10}],160:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var time = require('./time');

var parsePad = function parsePad(pad) {
	return pad && {
		axes: pad.axes,
		buttons: pad.buttons.map(function (button) {
			return {
				pressed: button.pressed,
				value: button.value
			};
		}),
		connected: pad.connected,
		id: pad.id,
		index: pad.index,
		mapping: pad.mapping,
		timestamp: pad.timestamp
	} || pad;
};

var list = function list() {
	return Array.from(navigator.getGamepads() || navigator.webkitGetGamepads() || []).map(parsePad);
};

var changes = function changes() {
	return time.frame().map(list).distinctUntilChanged(function (pads) {
		return pads;
	})
	//	pads.reduce((r, pad) => !pad && r || (r + (pad.axes || '') + (pad.buttons || '')), ''))
	.share();
};

module.exports = {
	list: list,
	changes: changes
};

},{"./time":163,"rx":123}],161:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

var numberToNote = function numberToNote(number) {
	return {
		key: keys[number % 12],
		octave: parseInt((number - number % 12) / 12, 10) - 1,
		number: number
	};
};

var noteToNumber = function noteToNumber(note) {
	return keys.indexOf(note.replace(/[0-9]+/, '')) + (parseInt(note.replace(/[A-Z#b]+/, ''), 10) + 1) * 12;
};

var parseMidiMsg = function parseMidiMsg(event) {
	// Mask off the lower nibble (MIDI channel, which we don't care about)

	var status = event.data[0] & 0xf0;
	var binary = event.data[0].toString(2);
	var channel = event.data[0] - status + 1;
	var msg = {};

	switch (binary.slice(0, 4)) {
		// noteoff
		case "1000":
			msg = {
				state: 'noteOff',
				note: numberToNote(event.data[1])
			};
			break;
		// noteon
		case "1001":
			msg = event.data[2] !== 0 ? // if velocity != 0, this is a note-on message
			{
				state: 'noteOn',
				note: numberToNote(event.data[1]),
				velocity: parseFloat((event.data[2] / 127).toFixed(2))
			} : { // if velocity == 0, fall thru: it's a note-off.	MIDI's weird, ya'll.
				state: 'noteOff',
				note: numberToNote(event.data[1])
			};
			break;
		// pitch wheel
		case "1110":
			msg = {
				state: 'pitchBend',
				pitchValue: event.data[2] === 64 ? 0 : parseFloat((event.data[2] / 63.5 - 1).toFixed(2))
			};
			break;
		// controller
		case "1011":
			msg = {
				state: "controller",
				controller: event.data[1],
				value: parseFloat((event.data[2] / 127).toFixed(2))
			};
			break;
		case "1100":
			msg = {
				state: "bankSelect",
				bank: event.data[1]
			};
			break;
		default:
			msg = {
				state: false
			};
			break;
	}

	return _extends({}, msg, {
		binary: binary,
		status: status,
		channel: channel,
		data: event.data
	});
};
//
// const hookUpMIDIInput = midiAccess => {
// 	var haveAtLeastOneDevice = false;
// 	var inputs = midiAccess.inputs.values();
// 	for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
// 		input.value.onmidimessage = MIDIMessageEventHandler;
// 		haveAtLeastOneDevice = true;
// 	}
// };
//
// const onMIDIInit = midi => {
// 	hookUpMIDIInput(midi);
// 	midi.onstatechange = hookUpMIDIInput;
// };
//
// const onMIDIReject = err =>
// 	console.log(err, 'The MIDI system failed to start.');
//
// (navigator.requestMIDIAccess)
// 		&& navigator.requestMIDIAccess().then(onMIDIInit, onMIDIReject);

var parseAccess = function parseAccess(access) {
	var inputs = [];
	var outputs = [];

	// console.log(access);

	access.inputs.forEach(function (input) {
		return inputs.push(input);
	});
	access.outputs.forEach(function (output) {
		return outputs.push(output);
	});
	return { access: access, inputs: inputs, outputs: outputs };
};

var init = function init() {
	var devices$ = new Rx.Subject();
	$.fromPromise(navigator.requestMIDIAccess()).flatMap(function (access) {
		return $.create(function (stream) {
			access.onstatechange = function (connection) {
				return stream.onNext(connection.currentTarget);
			};
		}).startWith(access);
	}).map(parseAccess)
	// .map(data => (console.log('midi access', data), data))
	.subscribe(function (device) {
		return devices$.onNext(device);
	});
	// .share();

	var msg$ = new Rx.Subject();
	devices$.flatMap(function (_ref) {
		var access = _ref.access,
		    inputs = _ref.inputs;
		return inputs.reduce(function (msgStream, input) {
			return msgStream.merge($.fromEventPattern(function (h) {
				input.onmidimessage = h;
			}).map(function (msg) {
				return { access: access, input: input, msg: msg };
			}));
		}, $.empty());
	}).subscribe(function (msg) {
		return msg$.onNext(msg);
	});

	return {
		devices$: devices$,
		msg$: msg$
	};
};

module.exports = {
	init: init,
	numberToNote: numberToNote,
	noteToNumber: noteToNumber,
	parseMidiMsg: parseMidiMsg
};

},{"rx":123}],162:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = void 0;

var reducers$ = new Rx.Subject();
var pocket$ = new Rx.BehaviorSubject({});

reducers$.scan(function (pocket, reduce) {
	return reduce(pocket);
}, {}).subscribe(function (pocket) {
	return pocket$.onNext(pocket);
});

pocket$.subscribe(function (_pocket) {
	// console.log({pocket});
	pocket = _pocket;
});

var put = function put(path, val) {
	return reducers$.onNext(function (pocket) {
		return obj.patch(pocket, path, val);
	});
};
var get = function get(path) {
	return obj.sub(pocket, path);
};

module.exports = {
	put: put,
	get: get,
	reducers$: reducers$,
	stream: pocket$
};

},{"iblokz-data":10,"rx":123}],163:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var raf = require('raf');

var tick = function tick(cb) {
	return raf(function (dt) {
		cb(dt);
		tick(cb);
	});
};

var frame = function frame() {
	return $.create(function (obs) {
		return tick(function (dt) {
			return obs.onNext(dt);
		});
	}).filter(function (dt) {
		return dt !== 0;
	}).share();
};

var loop = function loop(state$, node) {
	return frame(node).withLatestFrom(state$, function (dt, state) {
		return { dt: dt, state: state };
	});
};

module.exports = {
	frame: frame,
	loop: loop
};

},{"raf":109,"rx":123}]},{},[140])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmlsZS1zYXZlci9kaXN0L0ZpbGVTYXZlci5taW4uanMiLCJub2RlX21vZHVsZXMvaHRtbC10YWdzL2h0bWwtdGFncy5qc29uIiwibm9kZV9tb2R1bGVzL2h0bWwtdGFncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9saWIvYXJyLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1kYXRhL2xpYi9mbi5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9saWIvb2JqLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1kYXRhL2xpYi9zdHIuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2guanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2h0bWxkb21hcGkuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2lzLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1zbmFiYmRvbS1oZWxwZXJzL25vZGVfbW9kdWxlcy9zbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvY2xhc3MuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvcHJvcHMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1zbmFiYmRvbS1oZWxwZXJzL25vZGVfbW9kdWxlcy9zbmFiYmRvbS90aHVuay5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otc25hYmJkb20taGVscGVycy9ub2RlX21vZHVsZXMvc25hYmJkb20vdm5vZGUuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvdXRpbC9hdHRycy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRhYmxlLXN0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvQXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1N0cmluZ1JlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0dlbmVyaWNXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2xpZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguYWxsLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9hZ2VudC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcGx1Z2luL3dhdmVzdXJmZXIucmVnaW9ucy5taW4uanMiLCJub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnRpbWVsaW5lLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3Qvd2F2ZXN1cmZlci5taW4uanMiLCJzcmMvanMvYWN0aW9ucy9jb3VudGVyL2luZGV4LmpzIiwic3JjL2pzL2FjdGlvbnMvaW5kZXguanMiLCJzcmMvanMvYWN0aW9ucy9taWRpLW1hcC9pbmRleC5qcyIsInNyYy9qcy9pbmRleC5qcyIsInNyYy9qcy9zZXJ2aWNlcy9jb250cm9sLmpzIiwic3JjL2pzL3NlcnZpY2VzL21pZGkuanMiLCJzcmMvanMvc2VydmljZXMvcGFkcy5qcyIsInNyYy9qcy9zZXJ2aWNlcy9zYW1wbGVzLmpzIiwic3JjL2pzL3NlcnZpY2VzL3N0dC5qcyIsInNyYy9qcy9zZXJ2aWNlcy93YXZlc3VyZmVyLmpzIiwic3JjL2pzL3VpL2JvYXJkL2luZGV4LmpzIiwic3JjL2pzL3VpL2hlYWRlci9pbmRleC5qcyIsInNyYy9qcy91aS9pbmRleC5qcyIsInNyYy9qcy91aS9wYWRzL2luZGV4LmpzIiwic3JjL2pzL3V0aWwvYXBwLmpzIiwic3JjL2pzL3V0aWwvYXVkaW8vY29udHJvbHMvYWRzci5qcyIsInNyYy9qcy91dGlsL2F1ZGlvL2NvcmUuanMiLCJzcmMvanMvdXRpbC9hdWRpby9lZmZlY3RzL2xmby5qcyIsInNyYy9qcy91dGlsL2F1ZGlvL2VmZmVjdHMvcmV2ZXJiLmpzIiwic3JjL2pzL3V0aWwvYXVkaW8vaW5kZXguanMiLCJzcmMvanMvdXRpbC9hdWRpby9zb3VyY2VzL3NhbXBsZXIuanMiLCJzcmMvanMvdXRpbC9maWxlLmpzIiwic3JjL2pzL3V0aWwvZm9ybS5qcyIsInNyYy9qcy91dGlsL2dhbWVwYWQuanMiLCJzcmMvanMvdXRpbC9taWRpLmpzIiwic3JjL2pzL3V0aWwvcG9ja2V0LmpzIiwic3JjL2pzL3V0aWwvdGltZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQUVBLFFBQVEsVUFBUixHQUFxQixVQUFyQjtBQUNBLFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBLFFBQVEsYUFBUixHQUF3QixhQUF4Qjs7QUFFQSxJQUFJLFNBQVMsRUFBYjtBQUNBLElBQUksWUFBWSxFQUFoQjtBQUNBLElBQUksTUFBTSxPQUFP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LGNBQVosQ0FBMkIsTUFBM0IsRUFBbUMsVUFBQyxFQUFELEVBQUssS0FBTDtBQUFBLFNBQWdCLEVBQUMsTUFBRCxFQUFLLFlBQUwsRUFBaEI7QUFBQSxFQUFuQyxDQUFsQjtBQUFBLENBQWI7O0FBRUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2hCLGFBRGdCO0FBRWhCO0FBRmdCLENBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICsgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICsgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYlhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWlJc0ltWnBiR1VpT2lKbGJYQjBlUzVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYlhYMD0iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIoZnVuY3Rpb24oYSxiKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGIpO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGV4cG9ydHMpYigpO2Vsc2V7YigpLGEuRmlsZVNhdmVyPXtleHBvcnRzOnt9fS5leHBvcnRzfX0pKHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGEsYil7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGI/Yj17YXV0b0JvbTohMX06XCJvYmplY3RcIiE9dHlwZW9mIGImJihjb25zb2xlLndhcm4oXCJEZXByaWNhdGVkOiBFeHBlY3RlZCB0aGlyZCBhcmd1bWVudCB0byBiZSBhIG9iamVjdFwiKSxiPXthdXRvQm9tOiFifSksYi5hdXRvQm9tJiYvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChhLnR5cGUpP25ldyBCbG9iKFtcIlxcdUZFRkZcIixhXSx7dHlwZTphLnR5cGV9KTphfWZ1bmN0aW9uIGMoYixjLGQpe3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtlLm9wZW4oXCJHRVRcIixiKSxlLnJlc3BvbnNlVHlwZT1cImJsb2JcIixlLm9ubG9hZD1mdW5jdGlvbigpe2EoZS5yZXNwb25zZSxjLGQpfSxlLm9uZXJyb3I9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiY291bGQgbm90IGRvd25sb2FkIGZpbGVcIil9LGUuc2VuZCgpfWZ1bmN0aW9uIGQoYSl7dmFyIGI9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBiLm9wZW4oXCJIRUFEXCIsYSwhMSksYi5zZW5kKCksMjAwPD1iLnN0YXR1cyYmMjk5Pj1iLnN0YXR1c31mdW5jdGlvbiBlKGEpe3RyeXthLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9Y2F0Y2goYyl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtiLmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwhMCwhMCx3aW5kb3csMCwwLDAsODAsMjAsITEsITEsITEsITEsMCxudWxsKSxhLmRpc3BhdGNoRXZlbnQoYil9fXZhciBmPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl8fCg0MixldmFsKShcInRoaXNcIil9Y2F0Y2goYSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93LndpbmRvdz09PXdpbmRvdz93aW5kb3c6XCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYuc2VsZj09PXNlbGY/c2VsZjpcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsJiZnbG9iYWwuZ2xvYmFsPT09Z2xvYmFsP2dsb2JhbDp0aGlzfX0oKSxhPWYuc2F2ZUFzfHxcIm9iamVjdFwiIT10eXBlb2Ygd2luZG93fHx3aW5kb3chPT1mP2Z1bmN0aW9uKCl7fTpcImRvd25sb2FkXCJpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGU/ZnVuY3Rpb24oYixnLGgpe3ZhciBpPWYuVVJMfHxmLndlYmtpdFVSTCxqPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2c9Z3x8Yi5uYW1lfHxcImRvd25sb2FkXCIsai5kb3dubG9hZD1nLGoucmVsPVwibm9vcGVuZXJcIixcInN0cmluZ1wiPT10eXBlb2YgYj8oai5ocmVmPWIsai5vcmlnaW49PT1sb2NhdGlvbi5vcmlnaW4/ZShqKTpkKGouaHJlZik/YyhiLGcsaCk6ZShqLGoudGFyZ2V0PVwiX2JsYW5rXCIpKTooai5ocmVmPWkuY3JlYXRlT2JqZWN0VVJMKGIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLnJldm9rZU9iamVjdFVSTChqLmhyZWYpfSw0RTQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGopfSwwKSl9OlwibXNTYXZlT3JPcGVuQmxvYlwiaW4gbmF2aWdhdG9yP2Z1bmN0aW9uKGYsZyxoKXtpZihnPWd8fGYubmFtZXx8XCJkb3dubG9hZFwiLFwic3RyaW5nXCIhPXR5cGVvZiBmKW5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGIoZixoKSxnKTtlbHNlIGlmKGQoZikpYyhmLGcsaCk7ZWxzZXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtpLmhyZWY9ZixpLnRhcmdldD1cIl9ibGFua1wiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGkpfSl9fTpmdW5jdGlvbihhLGIsZCxlKXtpZihlPWV8fG9wZW4oXCJcIixcIl9ibGFua1wiKSxlJiYoZS5kb2N1bWVudC50aXRsZT1lLmRvY3VtZW50LmJvZHkuaW5uZXJUZXh0PVwiZG93bmxvYWRpbmcuLi5cIiksXCJzdHJpbmdcIj09dHlwZW9mIGEpcmV0dXJuIGMoYSxiLGQpO3ZhciBnPVwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI9PT1hLnR5cGUsaD0vY29uc3RydWN0b3IvaS50ZXN0KGYuSFRNTEVsZW1lbnQpfHxmLnNhZmFyaSxpPS9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtpZigoaXx8ZyYmaCkmJlwib2JqZWN0XCI9PXR5cGVvZiBGaWxlUmVhZGVyKXt2YXIgaj1uZXcgRmlsZVJlYWRlcjtqLm9ubG9hZGVuZD1mdW5jdGlvbigpe3ZhciBhPWoucmVzdWx0O2E9aT9hOmEucmVwbGFjZSgvXmRhdGE6W147XSo7LyxcImRhdGE6YXR0YWNobWVudC9maWxlO1wiKSxlP2UubG9jYXRpb24uaHJlZj1hOmxvY2F0aW9uPWEsZT1udWxsfSxqLnJlYWRBc0RhdGFVUkwoYSl9ZWxzZXt2YXIgaz1mLlVSTHx8Zi53ZWJraXRVUkwsbD1rLmNyZWF0ZU9iamVjdFVSTChhKTtlP2UubG9jYXRpb249bDpsb2NhdGlvbi5ocmVmPWwsZT1udWxsLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtrLnJldm9rZU9iamVjdFVSTChsKX0sNEU0KX19O2Yuc2F2ZUFzPWEuc2F2ZUFzPWEsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmKG1vZHVsZS5leHBvcnRzPWEpfSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGVTYXZlci5taW4uanMubWFwIiwibW9kdWxlLmV4cG9ydHM9W1xuXHRcImFcIixcblx0XCJhYmJyXCIsXG5cdFwiYWRkcmVzc1wiLFxuXHRcImFyZWFcIixcblx0XCJhcnRpY2xlXCIsXG5cdFwiYXNpZGVcIixcblx0XCJhdWRpb1wiLFxuXHRcImJcIixcblx0XCJiYXNlXCIsXG5cdFwiYmRpXCIsXG5cdFwiYmRvXCIsXG5cdFwiYmxvY2txdW90ZVwiLFxuXHRcImJvZHlcIixcblx0XCJiclwiLFxuXHRcImJ1dHRvblwiLFxuXHRcImNhbnZhc1wiLFxuXHRcImNhcHRpb25cIixcblx0XCJjaXRlXCIsXG5cdFwiY29kZVwiLFxuXHRcImNvbFwiLFxuXHRcImNvbGdyb3VwXCIsXG5cdFwiZGF0YVwiLFxuXHRcImRhdGFsaXN0XCIsXG5cdFwiZGRcIixcblx0XCJkZWxcIixcblx0XCJkZXRhaWxzXCIsXG5cdFwiZGZuXCIsXG5cdFwiZGlhbG9nXCIsXG5cdFwiZGl2XCIsXG5cdFwiZGxcIixcblx0XCJkdFwiLFxuXHRcImVtXCIsXG5cdFwiZW1iZWRcIixcblx0XCJmaWVsZHNldFwiLFxuXHRcImZpZ2NhcHRpb25cIixcblx0XCJmaWd1cmVcIixcblx0XCJmb290ZXJcIixcblx0XCJmb3JtXCIsXG5cdFwiaDFcIixcblx0XCJoMlwiLFxuXHRcImgzXCIsXG5cdFwiaDRcIixcblx0XCJoNVwiLFxuXHRcImg2XCIsXG5cdFwiaGVhZFwiLFxuXHRcImhlYWRlclwiLFxuXHRcImhncm91cFwiLFxuXHRcImhyXCIsXG5cdFwiaHRtbFwiLFxuXHRcImlcIixcblx0XCJpZnJhbWVcIixcblx0XCJpbWdcIixcblx0XCJpbnB1dFwiLFxuXHRcImluc1wiLFxuXHRcImtiZFwiLFxuXHRcImtleWdlblwiLFxuXHRcImxhYmVsXCIsXG5cdFwibGVnZW5kXCIsXG5cdFwibGlcIixcblx0XCJsaW5rXCIsXG5cdFwibWFpblwiLFxuXHRcIm1hcFwiLFxuXHRcIm1hcmtcIixcblx0XCJtYXRoXCIsXG5cdFwibWVudVwiLFxuXHRcIm1lbnVpdGVtXCIsXG5cdFwibWV0YVwiLFxuXHRcIm1ldGVyXCIsXG5cdFwibmF2XCIsXG5cdFwibm9zY3JpcHRcIixcblx0XCJvYmplY3RcIixcblx0XCJvbFwiLFxuXHRcIm9wdGdyb3VwXCIsXG5cdFwib3B0aW9uXCIsXG5cdFwib3V0cHV0XCIsXG5cdFwicFwiLFxuXHRcInBhcmFtXCIsXG5cdFwicGljdHVyZVwiLFxuXHRcInByZVwiLFxuXHRcInByb2dyZXNzXCIsXG5cdFwicVwiLFxuXHRcInJiXCIsXG5cdFwicnBcIixcblx0XCJydFwiLFxuXHRcInJ0Y1wiLFxuXHRcInJ1YnlcIixcblx0XCJzXCIsXG5cdFwic2FtcFwiLFxuXHRcInNjcmlwdFwiLFxuXHRcInNlY3Rpb25cIixcblx0XCJzZWxlY3RcIixcblx0XCJzbG90XCIsXG5cdFwic21hbGxcIixcblx0XCJzb3VyY2VcIixcblx0XCJzcGFuXCIsXG5cdFwic3Ryb25nXCIsXG5cdFwic3R5bGVcIixcblx0XCJzdWJcIixcblx0XCJzdW1tYXJ5XCIsXG5cdFwic3VwXCIsXG5cdFwic3ZnXCIsXG5cdFwidGFibGVcIixcblx0XCJ0Ym9keVwiLFxuXHRcInRkXCIsXG5cdFwidGVtcGxhdGVcIixcblx0XCJ0ZXh0YXJlYVwiLFxuXHRcInRmb290XCIsXG5cdFwidGhcIixcblx0XCJ0aGVhZFwiLFxuXHRcInRpbWVcIixcblx0XCJ0aXRsZVwiLFxuXHRcInRyXCIsXG5cdFwidHJhY2tcIixcblx0XCJ1XCIsXG5cdFwidWxcIixcblx0XCJ2YXJcIixcblx0XCJ2aWRlb1wiLFxuXHRcIndiclwiXG5dXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaHRtbC10YWdzLmpzb24nKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRvYmo6IHJlcXVpcmUoJy4vbGliL29iaicpLFxuXHRhcnI6IHJlcXVpcmUoJy4vbGliL2FycicpLFxuXHRzdHI6IHJlcXVpcmUoJy4vbGliL3N0cicpLFxuXHRmbjogcmVxdWlyZSgnLi9saWIvZm4nKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYWRkID0gKGFyciwgaXRlbSkgPT4gW10uY29uY2F0KGFyciwgW2l0ZW1dKTtcblxuY29uc3QgcmVtb3ZlID0gKGFyciwgaXRlbSkgPT4gYXJyLmluZGV4T2YoaXRlbSkgPiAtMSA/IFtdLmNvbmNhdChcblx0YXJyLnNsaWNlKDAsIGFyci5pbmRleE9mKGl0ZW0pKSxcblx0YXJyLnNsaWNlKGFyci5pbmRleE9mKGl0ZW0pICsgMSlcbikgOiBhcnI7XG5cbmNvbnN0IHRvZ2dsZSA9IChhcnIsIGl0ZW0pID0+IGFyci5pbmRleE9mKGl0ZW0pID4gLTFcblx0PyByZW1vdmUoYXJyLCBpdGVtKVxuXHQ6IGFkZChhcnIsIGl0ZW0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0YWRkLFxuXHRyZW1vdmUsXG5cdHRvZ2dsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb2JqID0gcmVxdWlyZSgnLi9vYmonKTtcblxuLy8gKCgoYSwgYiwg4oCmLCBuKSDihpIgbyksIChvIOKGkiBwKSwg4oCmLCAoeCDihpIgeSksICh5IOKGkiB6KSkg4oaSICgoYSwgYiwg4oCmLCBuKSDihpIgeilcbmNvbnN0IHBpcGUgPSAoYSwgLi4uZm5zKSA9PiAoLi4uYXJncykgPT4gZm5zLnJlZHVjZSgocmVzLCBmbikgPT4gZm4ocmVzKSwgYSguLi5hcmdzKSk7XG5cbi8vICgoeSDihpIgeiksICh4IOKGkiB5KSwg4oCmLCAobyDihpIgcCksICgoYSwgYiwg4oCmLCBuKSDihpIgbykpIOKGkiAoKGEsIGIsIOKApiwgbikg4oaSIHopXG5jb25zdCBjb21wb3NlID0gKC4uLmZucykgPT4gcGlwZShmbnMuc2xpY2UoLTEpLnBvcCgpLCAuLi5mbnMucmV2ZXJzZSgpLnNsaWNlKDEpKTtcblxuLy8gc3dpdGNoIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNvbXBvc2UsXG5cdHBpcGUsXG5cdHN3aXRjaDogb2JqLnN3aXRjaFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qga2V5VmFsdWUgPSAoaywgdikgPT4ge1xuXHRsZXQgbyA9IHt9O1xuXHRvW2tdID0gdjtcblx0cmV0dXJuIG87XG59O1xuXG5jb25zdCBjbG9uZSA9IG8gPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvKSB8fCB7fSksIG8pO1xuXG5jb25zdCBzdWIgPSAobywgcCkgPT4gKHAgaW5zdGFuY2VvZiBBcnJheSlcblx0PyAodHlwZW9mIG9bcFswXV0gIT09ICd1bmRlZmluZWQnICYmIHAubGVuZ3RoID4gMSkgPyBzdWIob1twWzBdXSwgcC5zbGljZSgxKSkgOiBvW3BbMF1dXG5cdDogb1twXTtcblxuY29uc3QgcGF0Y2ggPSAobywgaywgdikgPT4gT2JqZWN0LmFzc2lnbihjbG9uZShvKSxcblx0KGsgaW5zdGFuY2VvZiBBcnJheSlcblx0XHQ/IGtleVZhbHVlKGtbMF0sIChrLmxlbmd0aCA+IDEpXG5cdFx0XHQ/IHBhdGNoKG9ba1swXV0gfHwge30sIGsuc2xpY2UoMSksIHYpXG5cdFx0XHQ6IHR5cGVvZiBvW2tbMF1dID09PSAnb2JqZWN0JyAmJiBvW2tbMF1dLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmFzc2lnbihjbG9uZShvW2tbMF1dKSwgdikgfHwgdilcblx0XHQ6IGtleVZhbHVlKGssIHR5cGVvZiBvW2tdID09PSAnb2JqZWN0JyAmJiBvW2tdLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmFzc2lnbihjbG9uZShvW2tdKSwgdikgfHwgdilcbik7XG5cbmNvbnN0IHJlZHVjZSA9IChvLCByZWR1Y2VGbiwgaW5pdGlhbCkgPT4gT2JqZWN0LmtleXMobylcblx0LnJlZHVjZShcblx0XHQoYWNjdW11bGF0b3IsIGtleSwgaW5kZXgpID0+IHJlZHVjZUZuKGFjY3VtdWxhdG9yLCBrZXksIG9ba2V5XSwgaW5kZXgsIG8pLFxuXHRcdHR5cGVvZiBpbml0aWFsID09PSAndW5kZWZpbmVkJ1xuXHRcdFx0PyBvW09iamVjdC5rZXlzKG8pWzBdXSAvLyB0byBjb25maXJtIHdpdGggdGhlIGFycmF5IHJlZHVjZSBzcGVjIGluIHRoaXMgY2FzZSB0aGUgZmlydHMgcHJvcGVydHkgaXMgdXNlZFxuXHRcdFx0OiBpbml0aWFsXG5cdCk7XG5cbmNvbnN0IG1hcCA9IChvLCBtYXBGbikgPT4gcmVkdWNlKG8sXG5cdChvMiwga2V5LCB2YWx1ZSwgaW5kZXgpID0+IHBhdGNoKG8yLCBrZXksIG1hcEZuKGtleSwgdmFsdWUsIGluZGV4LCBvKSksXG5cdHt9XG4pO1xuXG5jb25zdCBmaWx0ZXIgPSAobywgZmlsdGVyRm4pID0+IHJlZHVjZShvLFxuXHQobzIsIGtleSwgdmFsdWUsIGluZGV4KSA9PiBmaWx0ZXJGbihrZXksIHZhbHVlLCBpbmRleCwgbylcblx0XHQ/IHBhdGNoKG8yLCBrZXksIHZhbHVlKVxuXHRcdDogbzIsXG5cdHt9XG4pO1xuXG5jb25zdCB0cmF2ZXJzZSA9ICh0cmVlLCBmbikgPT4gT2JqZWN0LmtleXModHJlZSkucmVkdWNlKChvLCBrKSA9PlxuXHRwYXRjaChvLCBrLFxuXHRcdCh0eXBlb2YgdHJlZVtrXSA9PT0gJ29iamVjdCcgJiYgdHJlZVtrXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHRcdFx0PyB0cmF2ZXJzZSh0cmVlW2tdLCBmbilcblx0XHRcdDogZm4odHJlZVtrXSwgaylcblx0KSwge31cbik7XG5cbmNvbnN0IGNoYWluQ2FsbCA9IChvLCBjaGFpbikgPT4gY2hhaW4ucmVkdWNlKFxuXHQobywgbGluaykgPT4gKHR5cGVvZiBsaW5rWzFdID09PSAndW5kZWZpbmVkJylcblx0XHQ/IG9bbGlua1swXV0oKVxuXHRcdDogb1tsaW5rWzBdXShsaW5rWzFdKSxcblx0b1xuKTtcblxuY29uc3QgX3N3aXRjaCA9ICh2YWx1ZSwgY2FzZXMpID0+XG5cdHN1YihjYXNlcywgdmFsdWUpICYmIHN1YihjYXNlcywgdmFsdWUpWydkZWZhdWx0J10gfHwgc3ViKGNhc2VzLCB2YWx1ZSlcblx0fHwgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0JiYgdmFsdWUubGVuZ3RoID4gMSAmJiBfc3dpdGNoKHZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCAtIDEpLCBjYXNlcylcblx0fHwgY2FzZXNbJ2RlZmF1bHQnXSB8fCBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGtleVZhbHVlLFxuXHRjbG9uZSxcblx0c3ViLFxuXHRwYXRjaCxcblx0cmVkdWNlLFxuXHRtYXAsXG5cdGZpbHRlcixcblx0dHJhdmVyc2UsXG5cdGNoYWluQ2FsbCxcblx0c3dpdGNoOiBfc3dpdGNoXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjYXBpdGFsaXplID0gY2h1bmsgPT4gY2h1bmsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjaHVuay5zbGljZSgxKTtcblxuY29uc3QgdG9DYW1lbENhc2UgPSAoc3RyLCBnbHVlID0gJ18nKSA9PlxuXHRzdHIuc3BsaXQoZ2x1ZSlcblx0XHQubWFwKChjaHVuaywgaSkgPT4gKGkgPT09IDApXG5cdFx0XHQ/IGNodW5rXG5cdFx0XHQ6IGNhcGl0YWxpemUoY2h1bmspKVxuXHRcdC5qb2luKCcnKTtcblxuY29uc3QgZnJvbUNhbWVsQ2FzZSA9IChzdHIsIGdsdWUgPSAnXycpID0+XG5cdHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICcgJDEnKVxuXHRcdC5zcGxpdCgnICcpXG5cdFx0Lm1hcChjaHVuayA9PiBjaHVuay50b0xvd2VyQ2FzZSgpKVxuXHRcdC5qb2luKGdsdWUpO1xuXG5jb25zdCBzaW5ndWxhclRvUGx1cmFsID0gc3RyID0+XG5cdHN0ci5yZXBsYWNlKC95JC8sICdpZScpLmNvbmNhdCgncycpO1xuXG5jb25zdCBwbHVyYWxUb1Npbmd1bGFyID0gc3RyID0+XG5cdHN0ci5yZXBsYWNlKC9pZXMkLywgJ3knKS5yZXBsYWNlKC9zJC8sICcnKTtcblxuY29uc3QgdG9Eb2N1bWVudElkID0gKHN0ciwgZ2x1ZSA9ICdfJywgc3VmZml4ID0gJ0lkJywgcHJlZml4ID0gJycpID0+XG5cdHByZWZpeC5jb25jYXQocGx1cmFsVG9TaW5ndWxhcih0b0NhbWVsQ2FzZShzdHIsIGdsdWUpKSwgc3VmZml4KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNhcGl0YWxpemUsXG5cdHRvQ2FtZWxDYXNlLFxuXHRmcm9tQ2FtZWxDYXNlLFxuXHRzaW5ndWxhclRvUGx1cmFsLFxuXHRwbHVyYWxUb1Npbmd1bGFyLFxuXHR0b0RvY3VtZW50SWRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNuYWJiZG9tID0gcmVxdWlyZSgnc25hYmJkb20nKTtcbmNvbnN0IGggPSByZXF1aXJlKCdzbmFiYmRvbS9oJykuZGVmYXVsdDtcbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IGh0bWxUYWdzID0gcmVxdWlyZSgnaHRtbC10YWdzJyk7XG5cbmNvbnN0IGF0dHJzID0gcmVxdWlyZSgnLi91dGlsL2F0dHJzJyk7XG5cbmNvbnN0IHBhdGNoID0gc25hYmJkb20uaW5pdChbIC8vIEluaXQgcGF0Y2ggZnVuY3Rpb24gd2l0aCBjaG9vc2VuIG1vZHVsZXNcblx0cmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9jbGFzcycpLmRlZmF1bHQsIC8vIG1ha2VzIGl0IGVhc3kgdG8gdG9nZ2xlIGNsYXNzZXNcblx0cmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9wcm9wcycpLmRlZmF1bHQsIC8vIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gRE9NIGVsZW1lbnRzXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvYXR0cmlidXRlcycpLmRlZmF1bHQsIC8vIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gRE9NIGVsZW1lbnRzXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvc3R5bGUnKS5kZWZhdWx0LCAvLyBoYW5kbGVzIHN0eWxpbmcgb24gZWxlbWVudHMgd2l0aCBzdXBwb3J0IGZvciBhbmltYXRpb25zXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMnKS5kZWZhdWx0IC8vIGF0dGFjaGVzIGV2ZW50IGxpc3RlbmVyc1xuXSk7XG5cbmNvbnN0IHBhdGNoU3RyZWFtID0gKHN0cmVhbSwgZG9tKSA9PiB7XG5cdGRvbSA9ICh0eXBlb2YgZG9tID09PSAnc3RyaW5nJykgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRvbSkgOiBkb207XG5cdHN0cmVhbS5zY2FuKFxuXHRcdCh2bm9kZSwgbmV3Vm5vZGUpID0+IHBhdGNoKHZub2RlLCBuZXdWbm9kZSksXG5cdFx0ZG9tXG5cdCkuc3Vic2NyaWJlKCk7XG59O1xuXG5jb25zdCBoeXBlckhlbHBlcnMgPSBodG1sVGFncy5yZWR1Y2UoXG5cdChvLCB0YWcpID0+IHtcblx0XHRvW3RhZ10gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbQXJyYXkuZnJvbShhcmd1bWVudHMpXVxuXHRcdFx0XHQubWFwKGF0dHJzLnByb2Nlc3MpXG5cdFx0XHRcdC5tYXAoYXJncyA9PiAoXG5cdFx0XHRcdFx0Ly8gaXMgdGhlIGZpcnN0IGFyZ3VtZW50IGEgc2VsZWN0b3Jcblx0XHRcdFx0XHRhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLm1hdGNoKC9eKFxcLnwjKVthLXpBLVpcXC1fMC05XSsvaWcpKVxuXHRcdFx0XHRcdFx0PyBbXS5jb25jYXQodGFnICsgYXJnc1swXSwgYXJncy5zbGljZSgxKSlcblx0XHRcdFx0XHRcdDogW3RhZ10uY29uY2F0KGFyZ3MpKVxuXHRcdFx0XHQubWFwKGFyZ3MgPT4gaC5hcHBseSh0aGlzLCBhcmdzKSlcblx0XHRcdFx0LnBvcCgpO1xuXHRcdH07XG5cdFx0cmV0dXJuIG87XG5cdH0sIHt9XG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG5cdHtcblx0XHRoLFxuXHRcdHBhdGNoLFxuXHRcdHBhdGNoU3RyZWFtXG5cdH0sXG5cdGh5cGVySGVscGVyc1xuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZub2RlXzEgPSByZXF1aXJlKFwiLi92bm9kZVwiKTtcbnZhciBpcyA9IHJlcXVpcmUoXCIuL2lzXCIpO1xuZnVuY3Rpb24gYWRkTlMoZGF0YSwgY2hpbGRyZW4sIHNlbCkge1xuICAgIGRhdGEubnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIGlmIChzZWwgIT09ICdmb3JlaWduT2JqZWN0JyAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZERhdGEgPSBjaGlsZHJlbltpXS5kYXRhO1xuICAgICAgICAgICAgaWYgKGNoaWxkRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWRkTlMoY2hpbGREYXRhLCBjaGlsZHJlbltpXS5jaGlsZHJlbiwgY2hpbGRyZW5baV0uc2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGgoc2VsLCBiLCBjKSB7XG4gICAgdmFyIGRhdGEgPSB7fSwgY2hpbGRyZW4sIHRleHQsIGk7XG4gICAgaWYgKGMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhID0gYjtcbiAgICAgICAgaWYgKGlzLmFycmF5KGMpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGMpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICYmIGMuc2VsKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzLmFycmF5KGIpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGIpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiICYmIGIuc2VsKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtiXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5hcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaXMucHJpbWl0aXZlKGNoaWxkcmVuW2ldKSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IHZub2RlXzEudm5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxbMF0gPT09ICdzJyAmJiBzZWxbMV0gPT09ICd2JyAmJiBzZWxbMl0gPT09ICdnJyAmJlxuICAgICAgICAoc2VsLmxlbmd0aCA9PT0gMyB8fCBzZWxbM10gPT09ICcuJyB8fCBzZWxbM10gPT09ICcjJykpIHtcbiAgICAgICAgYWRkTlMoZGF0YSwgY2hpbGRyZW4sIHNlbCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZV8xLnZub2RlKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIHVuZGVmaW5lZCk7XG59XG5leHBvcnRzLmggPSBoO1xuO1xuZXhwb3J0cy5kZWZhdWx0ID0gaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xufVxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuZnVuY3Rpb24gdGFnTmFtZShlbG0pIHtcbiAgICByZXR1cm4gZWxtLnRhZ05hbWU7XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KSB7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQ7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMztcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDg7XG59XG5leHBvcnRzLmh0bWxEb21BcGkgPSB7XG4gICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gICAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICAgIGdldFRleHRDb250ZW50OiBnZXRUZXh0Q29udGVudCxcbiAgICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcbiAgICBpc1RleHQ6IGlzVGV4dCxcbiAgICBpc0NvbW1lbnQ6IGlzQ29tbWVudCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmh0bWxEb21BcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sZG9tYXBpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBwcmltaXRpdmUocykge1xuICAgIHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHMgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBib29sZWFuQXR0cnMgPSBbXCJhbGxvd2Z1bGxzY3JlZW5cIiwgXCJhc3luY1wiLCBcImF1dG9mb2N1c1wiLCBcImF1dG9wbGF5XCIsIFwiY2hlY2tlZFwiLCBcImNvbXBhY3RcIiwgXCJjb250cm9sc1wiLCBcImRlY2xhcmVcIixcbiAgICBcImRlZmF1bHRcIiwgXCJkZWZhdWx0Y2hlY2tlZFwiLCBcImRlZmF1bHRtdXRlZFwiLCBcImRlZmF1bHRzZWxlY3RlZFwiLCBcImRlZmVyXCIsIFwiZGlzYWJsZWRcIiwgXCJkcmFnZ2FibGVcIixcbiAgICBcImVuYWJsZWRcIiwgXCJmb3Jtbm92YWxpZGF0ZVwiLCBcImhpZGRlblwiLCBcImluZGV0ZXJtaW5hdGVcIiwgXCJpbmVydFwiLCBcImlzbWFwXCIsIFwiaXRlbXNjb3BlXCIsIFwibG9vcFwiLCBcIm11bHRpcGxlXCIsXG4gICAgXCJtdXRlZFwiLCBcIm5vaHJlZlwiLCBcIm5vcmVzaXplXCIsIFwibm9zaGFkZVwiLCBcIm5vdmFsaWRhdGVcIiwgXCJub3dyYXBcIiwgXCJvcGVuXCIsIFwicGF1c2VvbmV4aXRcIiwgXCJyZWFkb25seVwiLFxuICAgIFwicmVxdWlyZWRcIiwgXCJyZXZlcnNlZFwiLCBcInNjb3BlZFwiLCBcInNlYW1sZXNzXCIsIFwic2VsZWN0ZWRcIiwgXCJzb3J0YWJsZVwiLCBcInNwZWxsY2hlY2tcIiwgXCJ0cmFuc2xhdGVcIixcbiAgICBcInRydWVzcGVlZFwiLCBcInR5cGVtdXN0bWF0Y2hcIiwgXCJ2aXNpYmxlXCJdO1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG52YXIgeG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbnZhciBjb2xvbkNoYXIgPSA1ODtcbnZhciB4Q2hhciA9IDEyMDtcbnZhciBib29sZWFuQXR0cnNEaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBib29sZWFuQXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBib29sZWFuQXR0cnNEaWN0W2Jvb2xlYW5BdHRyc1tpXV0gPSB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQXR0cnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGtleSwgZWxtID0gdm5vZGUuZWxtLCBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMsIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycztcbiAgICBpZiAoIW9sZEF0dHJzICYmICFhdHRycylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChvbGRBdHRycyA9PT0gYXR0cnMpXG4gICAgICAgIHJldHVybjtcbiAgICBvbGRBdHRycyA9IG9sZEF0dHJzIHx8IHt9O1xuICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgLy8gdXBkYXRlIG1vZGlmaWVkIGF0dHJpYnV0ZXMsIGFkZCBuZXcgYXR0cmlidXRlc1xuICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgIHZhciBjdXIgPSBhdHRyc1trZXldO1xuICAgICAgICB2YXIgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICAgICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICAgICAgICBpZiAoYm9vbGVhbkF0dHJzRGljdFtrZXldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKGtleSwgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5jaGFyQ29kZUF0KDApICE9PSB4Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKGtleSwgY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmNoYXJDb2RlQXQoMykgPT09IGNvbG9uQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgeG1sIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoeG1sTlMsIGtleSwgY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmNoYXJDb2RlQXQoNSkgPT09IGNvbG9uQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgeGxpbmsgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKGtleSwgY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlbW92ZWQgYXR0cmlidXRlc1xuICAgIC8vIHVzZSBgaW5gIG9wZXJhdG9yIHNpbmNlIHRoZSBwcmV2aW91cyBgZm9yYCBpdGVyYXRpb24gdXNlcyBpdCAoLmkuZS4gYWRkIGV2ZW4gYXR0cmlidXRlcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZSlcbiAgICAvLyB0aGUgb3RoZXIgb3B0aW9uIGlzIHRvIHJlbW92ZSBhbGwgYXR0cmlidXRlcyB3aXRoIHZhbHVlID09IHVuZGVmaW5lZFxuICAgIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBhdHRycykpIHtcbiAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYXR0cmlidXRlc01vZHVsZSA9IHsgY3JlYXRlOiB1cGRhdGVBdHRycywgdXBkYXRlOiB1cGRhdGVBdHRycyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5hdHRyaWJ1dGVzTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgb2xkQ2xhc3MgPSBvbGRWbm9kZS5kYXRhLmNsYXNzLCBrbGFzcyA9IHZub2RlLmRhdGEuY2xhc3M7XG4gICAgaWYgKCFvbGRDbGFzcyAmJiAha2xhc3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkQ2xhc3MgPT09IGtsYXNzKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkQ2xhc3MgPSBvbGRDbGFzcyB8fCB7fTtcbiAgICBrbGFzcyA9IGtsYXNzIHx8IHt9O1xuICAgIGZvciAobmFtZSBpbiBvbGRDbGFzcykge1xuICAgICAgICBpZiAoIWtsYXNzW25hbWVdKSB7XG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4ga2xhc3MpIHtcbiAgICAgICAgY3VyID0ga2xhc3NbbmFtZV07XG4gICAgICAgIGlmIChjdXIgIT09IG9sZENsYXNzW25hbWVdKSB7XG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0W2N1ciA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jbGFzc01vZHVsZSA9IHsgY3JlYXRlOiB1cGRhdGVDbGFzcywgdXBkYXRlOiB1cGRhdGVDbGFzcyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5jbGFzc01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYXNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaW52b2tlSGFuZGxlcihoYW5kbGVyLCB2bm9kZSwgZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBjYWxsIGZ1bmN0aW9uIGhhbmRsZXJcbiAgICAgICAgaGFuZGxlci5jYWxsKHZub2RlLCBldmVudCwgdm5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBjYWxsIGhhbmRsZXIgd2l0aCBhcmd1bWVudHNcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGFyZ3VtZW50IGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgaWYgKGhhbmRsZXIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclswXS5jYWxsKHZub2RlLCBoYW5kbGVyWzFdLCBldmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBoYW5kbGVyLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyWzBdLmFwcGx5KHZub2RlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGwgbXVsdGlwbGUgaGFuZGxlcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGludm9rZUhhbmRsZXIoaGFuZGxlcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCwgdm5vZGUpIHtcbiAgICB2YXIgbmFtZSA9IGV2ZW50LnR5cGUsIG9uID0gdm5vZGUuZGF0YS5vbjtcbiAgICAvLyBjYWxsIGV2ZW50IGhhbmRsZXIocykgaWYgZXhpc3RzXG4gICAgaWYgKG9uICYmIG9uW25hbWVdKSB7XG4gICAgICAgIGludm9rZUhhbmRsZXIob25bbmFtZV0sIHZub2RlLCBldmVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgaGFuZGxlRXZlbnQoZXZlbnQsIGhhbmRsZXIudm5vZGUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB1cGRhdGVFdmVudExpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uLCBvbGRMaXN0ZW5lciA9IG9sZFZub2RlLmxpc3RlbmVyLCBvbGRFbG0gPSBvbGRWbm9kZS5lbG0sIG9uID0gdm5vZGUgJiYgdm5vZGUuZGF0YS5vbiwgZWxtID0gKHZub2RlICYmIHZub2RlLmVsbSksIG5hbWU7XG4gICAgLy8gb3B0aW1pemF0aW9uIGZvciByZXVzZWQgaW1tdXRhYmxlIGhhbmRsZXJzXG4gICAgaWYgKG9sZE9uID09PSBvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBleGlzdGluZyBsaXN0ZW5lcnMgd2hpY2ggbm8gbG9uZ2VyIHVzZWRcbiAgICBpZiAob2xkT24gJiYgb2xkTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gaWYgZWxlbWVudCBjaGFuZ2VkIG9yIGRlbGV0ZWQgd2UgcmVtb3ZlIGFsbCBleGlzdGluZyBsaXN0ZW5lcnMgdW5jb25kaXRpb25hbGx5XG4gICAgICAgIGlmICghb24pIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciBpZiBlbGVtZW50IHdhcyBjaGFuZ2VkIG9yIGV4aXN0aW5nIGxpc3RlbmVycyByZW1vdmVkXG4gICAgICAgICAgICAgICAgb2xkRWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgb2xkTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciBpZiBleGlzdGluZyBsaXN0ZW5lciByZW1vdmVkXG4gICAgICAgICAgICAgICAgaWYgKCFvbltuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRFbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBvbGRMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgbmV3IGxpc3RlbmVycyB3aGljaCBoYXMgbm90IGFscmVhZHkgYXR0YWNoZWRcbiAgICBpZiAob24pIHtcbiAgICAgICAgLy8gcmV1c2UgZXhpc3RpbmcgbGlzdGVuZXIgb3IgY3JlYXRlIG5ld1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB2bm9kZS5saXN0ZW5lciA9IG9sZFZub2RlLmxpc3RlbmVyIHx8IGNyZWF0ZUxpc3RlbmVyKCk7XG4gICAgICAgIC8vIHVwZGF0ZSB2bm9kZSBmb3IgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIudm5vZGUgPSB2bm9kZTtcbiAgICAgICAgLy8gaWYgZWxlbWVudCBjaGFuZ2VkIG9yIGFkZGVkIHdlIGFkZCBhbGwgbmVlZGVkIGxpc3RlbmVycyB1bmNvbmRpdGlvbmFsbHlcbiAgICAgICAgaWYgKCFvbGRPbikge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGxpc3RlbmVyIGlmIGVsZW1lbnQgd2FzIGNoYW5nZWQgb3IgbmV3IGxpc3RlbmVycyBhZGRlZFxuICAgICAgICAgICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgbGlzdGVuZXIgaWYgbmV3IGxpc3RlbmVyIGFkZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRPbltuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXZlbnRMaXN0ZW5lcnNNb2R1bGUgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVFdmVudExpc3RlbmVycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGRlc3Ryb3k6IHVwZGF0ZUV2ZW50TGlzdGVuZXJzXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5ldmVudExpc3RlbmVyc01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50bGlzdGVuZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gdXBkYXRlUHJvcHMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGtleSwgY3VyLCBvbGQsIGVsbSA9IHZub2RlLmVsbSwgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLnByb3BzLCBwcm9wcyA9IHZub2RlLmRhdGEucHJvcHM7XG4gICAgaWYgKCFvbGRQcm9wcyAmJiAhcHJvcHMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkUHJvcHMgPT09IHByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkUHJvcHMgPSBvbGRQcm9wcyB8fCB7fTtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghcHJvcHNba2V5XSkge1xuICAgICAgICAgICAgZGVsZXRlIGVsbVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgICAgIG9sZCA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChvbGQgIT09IGN1ciAmJiAoa2V5ICE9PSAndmFsdWUnIHx8IGVsbVtrZXldICE9PSBjdXIpKSB7XG4gICAgICAgICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucHJvcHNNb2R1bGUgPSB7IGNyZWF0ZTogdXBkYXRlUHJvcHMsIHVwZGF0ZTogdXBkYXRlUHJvcHMgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMucHJvcHNNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByYWYgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgc2V0VGltZW91dDtcbnZhciBuZXh0RnJhbWUgPSBmdW5jdGlvbiAoZm4pIHsgcmFmKGZ1bmN0aW9uICgpIHsgcmFmKGZuKTsgfSk7IH07XG5mdW5jdGlvbiBzZXROZXh0RnJhbWUob2JqLCBwcm9wLCB2YWwpIHtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkgeyBvYmpbcHJvcF0gPSB2YWw7IH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlU3R5bGUob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGN1ciwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBvbGRTdHlsZSA9IG9sZFZub2RlLmRhdGEuc3R5bGUsIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgICBpZiAoIW9sZFN0eWxlICYmICFzdHlsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChvbGRTdHlsZSA9PT0gc3R5bGUpXG4gICAgICAgIHJldHVybjtcbiAgICBvbGRTdHlsZSA9IG9sZFN0eWxlIHx8IHt9O1xuICAgIHN0eWxlID0gc3R5bGUgfHwge307XG4gICAgdmFyIG9sZEhhc0RlbCA9ICdkZWxheWVkJyBpbiBvbGRTdHlsZTtcbiAgICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICAgICAgaWYgKCFzdHlsZVtuYW1lXSkge1xuICAgICAgICAgICAgaWYgKG5hbWVbMF0gPT09ICctJyAmJiBuYW1lWzFdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBlbG0uc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbG0uc3R5bGVbbmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgY3VyID0gc3R5bGVbbmFtZV07XG4gICAgICAgIGlmIChuYW1lID09PSAnZGVsYXllZCcgJiYgc3R5bGUuZGVsYXllZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZTIgaW4gc3R5bGUuZGVsYXllZCkge1xuICAgICAgICAgICAgICAgIGN1ciA9IHN0eWxlLmRlbGF5ZWRbbmFtZTJdO1xuICAgICAgICAgICAgICAgIGlmICghb2xkSGFzRGVsIHx8IGN1ciAhPT0gb2xkU3R5bGUuZGVsYXllZFtuYW1lMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TmV4dEZyYW1lKGVsbS5zdHlsZSwgbmFtZTIsIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdyZW1vdmUnICYmIGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChuYW1lWzBdID09PSAnLScgJiYgbmFtZVsxXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbG0uc3R5bGVbbmFtZV0gPSBjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURlc3Ryb3lTdHlsZSh2bm9kZSkge1xuICAgIHZhciBzdHlsZSwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBzID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgICBpZiAoIXMgfHwgIShzdHlsZSA9IHMuZGVzdHJveSkpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlSZW1vdmVTdHlsZSh2bm9kZSwgcm0pIHtcbiAgICB2YXIgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gICAgaWYgKCFzIHx8ICFzLnJlbW92ZSkge1xuICAgICAgICBybSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIGkgPSAwLCBjb21wU3R5bGUsIHN0eWxlID0gcy5yZW1vdmUsIGFtb3VudCA9IDAsIGFwcGxpZWQgPSBbXTtcbiAgICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgYXBwbGllZC5wdXNoKG5hbWUpO1xuICAgICAgICBlbG0uc3R5bGVbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICB9XG4gICAgY29tcFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbG0pO1xuICAgIHZhciBwcm9wcyA9IGNvbXBTdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnNwbGl0KCcsICcpO1xuICAgIGZvciAoOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFwcGxpZWQuaW5kZXhPZihwcm9wc1tpXSkgIT09IC0xKVxuICAgICAgICAgICAgYW1vdW50Kys7XG4gICAgfVxuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldi50YXJnZXQgPT09IGVsbSlcbiAgICAgICAgICAgIC0tYW1vdW50O1xuICAgICAgICBpZiAoYW1vdW50ID09PSAwKVxuICAgICAgICAgICAgcm0oKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc3R5bGVNb2R1bGUgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgICB1cGRhdGU6IHVwZGF0ZVN0eWxlLFxuICAgIGRlc3Ryb3k6IGFwcGx5RGVzdHJveVN0eWxlLFxuICAgIHJlbW92ZTogYXBwbHlSZW1vdmVTdHlsZVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuc3R5bGVNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2bm9kZV8xID0gcmVxdWlyZShcIi4vdm5vZGVcIik7XG52YXIgaXMgPSByZXF1aXJlKFwiLi9pc1wiKTtcbnZhciBodG1sZG9tYXBpXzEgPSByZXF1aXJlKFwiLi9odG1sZG9tYXBpXCIpO1xuZnVuY3Rpb24gaXNVbmRlZihzKSB7IHJldHVybiBzID09PSB1bmRlZmluZWQ7IH1cbmZ1bmN0aW9uIGlzRGVmKHMpIHsgcmV0dXJuIHMgIT09IHVuZGVmaW5lZDsgfVxudmFyIGVtcHR5Tm9kZSA9IHZub2RlXzEuZGVmYXVsdCgnJywge30sIFtdLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5mdW5jdGlvbiBzYW1lVm5vZGUodm5vZGUxLCB2bm9kZTIpIHtcbiAgICByZXR1cm4gdm5vZGUxLmtleSA9PT0gdm5vZGUyLmtleSAmJiB2bm9kZTEuc2VsID09PSB2bm9kZTIuc2VsO1xufVxuZnVuY3Rpb24gaXNWbm9kZSh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5zZWwgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4KGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gICAgdmFyIGksIG1hcCA9IHt9LCBrZXksIGNoO1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICAgIGNoID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBrZXkgPSBjaC5rZXk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knLCAncHJlJywgJ3Bvc3QnXTtcbnZhciBoXzEgPSByZXF1aXJlKFwiLi9oXCIpO1xuZXhwb3J0cy5oID0gaF8xLmg7XG52YXIgdGh1bmtfMSA9IHJlcXVpcmUoXCIuL3RodW5rXCIpO1xuZXhwb3J0cy50aHVuayA9IHRodW5rXzEudGh1bms7XG5mdW5jdGlvbiBpbml0KG1vZHVsZXMsIGRvbUFwaSkge1xuICAgIHZhciBpLCBqLCBjYnMgPSB7fTtcbiAgICB2YXIgYXBpID0gZG9tQXBpICE9PSB1bmRlZmluZWQgPyBkb21BcGkgOiBodG1sZG9tYXBpXzEuZGVmYXVsdDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGhvb2sgPSBtb2R1bGVzW2pdW2hvb2tzW2ldXTtcbiAgICAgICAgICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2goaG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW1wdHlOb2RlQXQoZWxtKSB7XG4gICAgICAgIHZhciBpZCA9IGVsbS5pZCA/ICcjJyArIGVsbS5pZCA6ICcnO1xuICAgICAgICB2YXIgYyA9IGVsbS5jbGFzc05hbWUgPyAnLicgKyBlbG0uY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignLicpIDogJyc7XG4gICAgICAgIHJldHVybiB2bm9kZV8xLmRlZmF1bHQoYXBpLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpICsgaWQgKyBjLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYihjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBybUNiKCkge1xuICAgICAgICAgICAgaWYgKC0tbGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gYXBpLnBhcmVudE5vZGUoY2hpbGRFbG0pO1xuICAgICAgICAgICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnRfMSwgY2hpbGRFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICB2YXIgaSwgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICAgICAgICAgIGkodm5vZGUpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLCBzZWwgPSB2bm9kZS5zZWw7XG4gICAgICAgIGlmIChzZWwgPT09ICchJykge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS50ZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZS5lbG0gPSBhcGkuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUGFyc2Ugc2VsZWN0b3JcbiAgICAgICAgICAgIHZhciBoYXNoSWR4ID0gc2VsLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIHZhciBkb3RJZHggPSBzZWwuaW5kZXhPZignLicsIGhhc2hJZHgpO1xuICAgICAgICAgICAgdmFyIGhhc2ggPSBoYXNoSWR4ID4gMCA/IGhhc2hJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGRvdCA9IGRvdElkeCA+IDAgPyBkb3RJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRhZyA9IGhhc2hJZHggIT09IC0xIHx8IGRvdElkeCAhPT0gLTEgPyBzZWwuc2xpY2UoMCwgTWF0aC5taW4oaGFzaCwgZG90KSkgOiBzZWw7XG4gICAgICAgICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEubnMpID8gYXBpLmNyZWF0ZUVsZW1lbnROUyhpLCB0YWcpXG4gICAgICAgICAgICAgICAgOiBhcGkuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgaWYgKGhhc2ggPCBkb3QpXG4gICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnaWQnLCBzZWwuc2xpY2UoaGFzaCArIDEsIGRvdCkpO1xuICAgICAgICAgICAgaWYgKGRvdElkeCA+IDApXG4gICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBzZWwuc2xpY2UoZG90ICsgMSkucmVwbGFjZSgvXFwuL2csICcgJykpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIGlmIChpcy5hcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBjcmVhdGVFbG0oY2gsIGluc2VydGVkVm5vZGVRdWV1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgYXBpLmFwcGVuZENoaWxkKGVsbSwgYXBpLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgICAgICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5jcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChpLmluc2VydClcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm5vZGUuZWxtID0gYXBpLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bm9kZS5lbG07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgICAgICAgIGlmIChjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbShjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgYmVmb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayh2bm9kZSkge1xuICAgICAgICB2YXIgaSwgaiwgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSlcbiAgICAgICAgICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpID0gdm5vZGUuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IG51bGwgJiYgdHlwZW9mIGkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgICAgICB2YXIgaV8xID0gdm9pZCAwLCBsaXN0ZW5lcnMgPSB2b2lkIDAsIHJtID0gdm9pZCAwLCBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihjaC5zZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICBybSA9IGNyZWF0ZVJtQ2IoY2guZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGlfMSA9IDA7IGlfMSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2lfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNicy5yZW1vdmVbaV8xXShjaCwgcm0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWYoaV8xID0gY2guZGF0YSkgJiYgaXNEZWYoaV8xID0gaV8xLmhvb2spICYmIGlzRGVmKGlfMSA9IGlfMS5yZW1vdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpXzEoY2gsIHJtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnRFbG0sIGNoLmVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMCwgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICAgIHZhciBvbGRLZXlUb0lkeDtcbiAgICAgICAgdmFyIGlkeEluT2xkO1xuICAgICAgICB2YXIgZWxtVG9Nb3ZlO1xuICAgICAgICB2YXIgYmVmb3JlO1xuICAgICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgaWYgKG9sZFN0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgbWlnaHQgaGF2ZSBiZWVuIG1vdmVkIGxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZEVuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkS2V5VG9JZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4SW5PbGQgPSBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbG1Ub01vdmUuc2VsICE9PSBuZXdTdGFydFZub2RlLnNlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBlbG1Ub01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9IG5ld0NoW25ld0VuZElkeCArIDFdID09IG51bGwgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgYmVmb3JlLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgdmFyIGksIGhvb2s7XG4gICAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YSkgJiYgaXNEZWYoaG9vayA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucHJlcGF0Y2gpKSB7XG4gICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodm5vZGUuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgICAgICBpID0gdm5vZGUuZGF0YS5ob29rO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKVxuICAgICAgICAgICAgICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucG9zdHBhdGNoKSkge1xuICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgICAgdmFyIGksIGVsbSwgcGFyZW50O1xuICAgICAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucHJlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY2JzLnByZVtpXSgpO1xuICAgICAgICBpZiAoIWlzVm5vZGUob2xkVm5vZGUpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgICAgcGFyZW50ID0gYXBpLnBhcmVudE5vZGUoZWxtKTtcbiAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudCwgdm5vZGUuZWxtLCBhcGkubmV4dFNpYmxpbmcoZWxtKSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudCwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluc2VydGVkVm5vZGVRdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQoaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnBvc3QubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjYnMucG9zdFtpXSgpO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfTtcbn1cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbmFiYmRvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoXzEgPSByZXF1aXJlKFwiLi9oXCIpO1xuZnVuY3Rpb24gY29weVRvVGh1bmsodm5vZGUsIHRodW5rKSB7XG4gICAgdGh1bmsuZWxtID0gdm5vZGUuZWxtO1xuICAgIHZub2RlLmRhdGEuZm4gPSB0aHVuay5kYXRhLmZuO1xuICAgIHZub2RlLmRhdGEuYXJncyA9IHRodW5rLmRhdGEuYXJncztcbiAgICB0aHVuay5kYXRhID0gdm5vZGUuZGF0YTtcbiAgICB0aHVuay5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHRodW5rLnRleHQgPSB2bm9kZS50ZXh0O1xuICAgIHRodW5rLmVsbSA9IHZub2RlLmVsbTtcbn1cbmZ1bmN0aW9uIGluaXQodGh1bmspIHtcbiAgICB2YXIgY3VyID0gdGh1bmsuZGF0YTtcbiAgICB2YXIgdm5vZGUgPSBjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBjdXIuYXJncyk7XG4gICAgY29weVRvVGh1bmsodm5vZGUsIHRodW5rKTtcbn1cbmZ1bmN0aW9uIHByZXBhdGNoKG9sZFZub2RlLCB0aHVuaykge1xuICAgIHZhciBpLCBvbGQgPSBvbGRWbm9kZS5kYXRhLCBjdXIgPSB0aHVuay5kYXRhO1xuICAgIHZhciBvbGRBcmdzID0gb2xkLmFyZ3MsIGFyZ3MgPSBjdXIuYXJncztcbiAgICBpZiAob2xkLmZuICE9PSBjdXIuZm4gfHwgb2xkQXJncy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVuayk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG9sZEFyZ3NbaV0gIT09IGFyZ3NbaV0pIHtcbiAgICAgICAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVuayk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weVRvVGh1bmsob2xkVm5vZGUsIHRodW5rKTtcbn1cbmV4cG9ydHMudGh1bmsgPSBmdW5jdGlvbiB0aHVuayhzZWwsIGtleSwgZm4sIGFyZ3MpIHtcbiAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MgPSBmbjtcbiAgICAgICAgZm4gPSBrZXk7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGhfMS5oKHNlbCwge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgaG9vazogeyBpbml0OiBpbml0LCBwcmVwYXRjaDogcHJlcGF0Y2ggfSxcbiAgICAgICAgZm46IGZuLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy50aHVuaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRodW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gdm5vZGUoc2VsLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgZWxtKSB7XG4gICAgdmFyIGtleSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGRhdGEua2V5O1xuICAgIHJldHVybiB7IHNlbDogc2VsLCBkYXRhOiBkYXRhLCBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIHRleHQ6IHRleHQsIGVsbTogZWxtLCBrZXk6IGtleSB9O1xufVxuZXhwb3J0cy52bm9kZSA9IHZub2RlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12bm9kZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3Qgc3RyUGFyc2UgPSBzID0+XG5cdHMubWF0Y2goL15bMC05XSskLykgPyBwYXJzZUludChzLCAxMClcblx0OiBzLm1hdGNoKC9eWzAtOS5dKyQvKSA/IHBhcnNlRmxvYXQocylcblx0OiBzID09PSAndHJ1ZScgPyB0cnVlXG5cdDogcyA9PT0gJ2ZhbHNlJyA/IGZhbHNlXG5cdDogcztcblxuY29uc3QgcHJvY2VzcyA9IGFyZ3MgPT4ge1xuXHRsZXQgbmV3QXJncyA9IGFyZ3Muc2xpY2UoKTtcblxuXHRsZXQgc2VsZWN0b3IgPSBuZXdBcmdzWzBdICYmIHR5cGVvZiBuZXdBcmdzWzBdID09PSAnc3RyaW5nJyAmJiBuZXdBcmdzWzBdIHx8ICcnO1xuXHRpZiAoc2VsZWN0b3IgIT09ICcnKSBuZXdBcmdzID0gbmV3QXJncy5zbGljZSgxKTtcblxuXHRjb25zdCBhdHRyUmVnRXhwID0gL1xcW1thLXpcXC0wLTldKz0oXCJbXlwiXStcInwnW14nXSsnfFswLTkuXSt8dHJ1ZXxmYWxzZXxbXlxcXV49XlwiXiddKylcXF0vaWc7XG5cblx0bGV0IGF0dHJzID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IubWF0Y2goYXR0clJlZ0V4cCk7XG5cdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShhdHRyUmVnRXhwLCAnJyk7XG5cblx0YXR0cnMgPSBhdHRycyAmJiBhdHRycy5tYXAgJiYgYXR0cnNcblx0XHQubWFwKGMgPT4gYy5yZXBsYWNlKC9bW1xcXShcInwnKV0vZywgJycpLnNwbGl0KCc9JykpXG5cdFx0LnJlZHVjZSgobywgYXR0cikgPT4gb2JqLnBhdGNoKG8sIGF0dHJbMF0sIHN0clBhcnNlKGF0dHJbMV0pKSwge30pIHx8IHt9O1xuXG5cdGlmIChhdHRycyAmJiBPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoID4gMCkge1xuXHRcdGlmICghbmV3QXJnc1swXSB8fCBuZXdBcmdzWzBdXG5cdFx0XHQmJiB0eXBlb2YgbmV3QXJnc1swXSA9PT0gJ29iamVjdCcgJiYgIShuZXdBcmdzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRhdHRycyA9IE9iamVjdC5hc3NpZ24oe30sIG5ld0FyZ3NbMF0gJiYgbmV3QXJnc1swXS5hdHRycyB8fCB7fSwgYXR0cnMpO1xuXHRcdFx0bmV3QXJnc1swXSA9IE9iamVjdC5hc3NpZ24oe30sIG5ld0FyZ3NbMF0gfHwge30sIHthdHRyc30pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdBcmdzID0gW3thdHRyc31dLmNvbmNhdChuZXdBcmdzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoc2VsZWN0b3IgIT09ICcnKSBuZXdBcmdzID0gW3NlbGVjdG9yXS5jb25jYXQobmV3QXJncyk7XG5cblx0Ly8gY29uc29sZS5sb2coYXJncywgbmV3QXJncyk7XG5cdHJldHVybiBuZXdBcmdzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHN0clBhcnNlLFxuXHRwcm9jZXNzXG59O1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE11dGF0aW9uID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbnZhciBzY2hlZHVsZURyYWluO1xuXG57XG4gIGlmIChNdXRhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbihuZXh0VGljayk7XG4gICAgdmFyIGVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LmRhdGEgPSAoY2FsbGVkID0gKytjYWxsZWQgJSAyKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFnbG9iYWwuc2V0SW1tZWRpYXRlICYmIHR5cGVvZiBnbG9iYWwuTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBuZXh0VGljaztcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgIHZhciBzY3JpcHRFbCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soKTtcblxuICAgICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBzY3JpcHRFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgc2NyaXB0RWwgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2ssIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGRyYWluaW5nO1xudmFyIHF1ZXVlID0gW107XG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBpLCBvbGRRdWV1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGxlbikge1xuICAgIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgb2xkUXVldWVbaV0oKTtcbiAgICB9XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1tZWRpYXRlO1xuZnVuY3Rpb24gaW1tZWRpYXRlKHRhc2spIHtcbiAgaWYgKHF1ZXVlLnB1c2godGFzaykgPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgc2NoZWR1bGVEcmFpbigpO1xuICB9XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YVdvcmtlcicpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLnN0cmVhbUluZm9bJ2RhdGFfbGVuZ3RoJ10gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzaW9uLlxuICogQHBhcmFtIHtHZW5lcmljV29ya2VyfSB1bmNvbXByZXNzZWRXb3JrZXIgdGhlIHdvcmtlciB0byBwaXBlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb25PcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGNvbXByZXNzaW5nLlxuICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIG5ldyB3b3JrZXIgY29tcHJlc3NpbmcgdGhlIGNvbnRlbnQuXG4gKi9cbkNvbXByZXNzZWRPYmplY3QuY3JlYXRlV29ya2VyRnJvbSA9IGZ1bmN0aW9uICh1bmNvbXByZXNzZWRXb3JrZXIsIGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdW5jb21wcmVzc2VkV29ya2VyXG4gICAgLnBpcGUobmV3IENyYzMyUHJvYmUoKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwidW5jb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAucGlwZShjb21wcmVzc2lvbi5jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbk9wdGlvbnMpKVxuICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJjb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCBjb21wcmVzc2lvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzZWRPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbmV4cG9ydHMuU1RPUkUgPSB7XG4gICAgbWFnaWM6IFwiXFx4MDBcXHgwMFwiLFxuICAgIGNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBjb21wcmVzc2lvblwiKTtcbiAgICB9LFxuICAgIHVuY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGRlY29tcHJlc3Npb25cIik7XG4gICAgfVxufTtcbmV4cG9ydHMuREVGTEFURSA9IHJlcXVpcmUoJy4vZmxhdGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3psaWIvY3JjMzIuanNcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVbbl0gPSBjO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY3JjMzIgb2YgYSBzdHJpbmcuXG4gKiBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyB0aGUgZnVuY3Rpb24gY3JjMzIsIGJ1dCBmb3Igc3RyaW5ncy4gVXNpbmcgdGhlXG4gKiBzYW1lIGZ1bmN0aW9uIGZvciB0aGUgdHdvIHVzZSBjYXNlcyBsZWFkcyB0byBob3JyaWJsZSBwZXJmb3JtYW5jZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY3JjIHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgY3JjLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW4gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSBjcmMzMiBjb21wdXRhdGlvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbXB1dGVkIGNyYzMyLlxuICovXG5mdW5jdGlvbiBjcmMzMnN0cihjcmMsIHN0ciwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyYzMyd3JhcHBlcihpbnB1dCwgY3JjKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcblxuICAgIGlmKGlzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JjMzJzdHIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLmJhc2U2NCA9IGZhbHNlO1xuZXhwb3J0cy5iaW5hcnkgPSBmYWxzZTtcbmV4cG9ydHMuZGlyID0gZmFsc2U7XG5leHBvcnRzLmNyZWF0ZUZvbGRlcnMgPSB0cnVlO1xuZXhwb3J0cy5kYXRlID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb24gPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbk9wdGlvbnMgPSBudWxsO1xuZXhwb3J0cy5jb21tZW50ID0gbnVsbDtcbmV4cG9ydHMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbmV4cG9ydHMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuIiwiLyogZ2xvYmFsIFByb21pc2UgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gbG9hZCB0aGUgZ2xvYmFsIG9iamVjdCBmaXJzdDpcbi8vIC0gaXQgc2hvdWxkIGJlIGJldHRlciBpbnRlZ3JhdGVkIGluIHRoZSBzeXN0ZW0gKHVuaGFuZGxlZFJlamVjdGlvbiBpbiBub2RlKVxuLy8gLSB0aGUgZW52aXJvbm1lbnQgbWF5IGhhdmUgYSBjdXN0b20gUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiAoc2VlIHpvbmUuanMpXG52YXIgRVM2UHJvbWlzZSA9IG51bGw7XG5pZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBFUzZQcm9taXNlID0gUHJvbWlzZTtcbn0gZWxzZSB7XG4gICAgRVM2UHJvbWlzZSA9IHJlcXVpcmUoXCJsaWVcIik7XG59XG5cbi8qKlxuICogTGV0IHRoZSB1c2VyIHVzZS9jaGFuZ2Ugc29tZSBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFByb21pc2U6IEVTNlByb21pc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVVNFX1RZUEVEQVJSQVkgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG52YXIgcGFrbyA9IHJlcXVpcmUoXCJwYWtvXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG52YXIgQVJSQVlfVFlQRSA9IFVTRV9UWVBFREFSUkFZID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG5cbmV4cG9ydHMubWFnaWMgPSBcIlxceDA4XFx4MDBcIjtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdGhhdCB1c2VzIHBha28gdG8gaW5mbGF0ZS9kZWZsYXRlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIHRoZSBuYW1lIG9mIHRoZSBwYWtvIGZ1bmN0aW9uIHRvIGNhbGwgOiBlaXRoZXIgXCJEZWZsYXRlXCIgb3IgXCJJbmZsYXRlXCIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiAoZGUpY29tcHJlc3NpbmcuXG4gKi9cbmZ1bmN0aW9uIEZsYXRlV29ya2VyKGFjdGlvbiwgb3B0aW9ucykge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkZsYXRlV29ya2VyL1wiICsgYWN0aW9uKTtcblxuICAgIHRoaXMuX3Bha28gPSBudWxsO1xuICAgIHRoaXMuX3Bha29BY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy5fcGFrb09wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHRoZSBgbWV0YWAgb2JqZWN0IGZyb20gdGhlIGxhc3QgY2h1bmsgcmVjZWl2ZWRcbiAgICAvLyB0aGlzIGFsbG93IHRoaXMgd29ya2VyIHRvIHBhc3MgYXJvdW5kIG1ldGFkYXRhXG4gICAgdGhpcy5tZXRhID0ge307XG59XG5cbnV0aWxzLmluaGVyaXRzKEZsYXRlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLm1ldGEgPSBjaHVuay5tZXRhO1xuICAgIGlmICh0aGlzLl9wYWtvID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBha28oKTtcbiAgICB9XG4gICAgdGhpcy5fcGFrby5wdXNoKHV0aWxzLnRyYW5zZm9ybVRvKEFSUkFZX1RZUEUsIGNodW5rLmRhdGEpLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaChbXSwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcGFrbyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgX3Bha28gb2JqZWN0LlxuICogVE9ETzogbGF6eS1sb2FkaW5nIHRoaXMgb2JqZWN0IGlzbid0IHRoZSBiZXN0IHNvbHV0aW9uIGJ1dCBpdCdzIHRoZVxuICogcXVpY2tlc3QuIFRoZSBiZXN0IHNvbHV0aW9uIGlzIHRvIGxhenktbG9hZCB0aGUgd29ya2VyIGxpc3QuIFNlZSBhbHNvIHRoZVxuICogaXNzdWUgIzQ0Ni5cbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLl9jcmVhdGVQYWtvID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Bha28gPSBuZXcgcGFrb1t0aGlzLl9wYWtvQWN0aW9uXSh7XG4gICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgbGV2ZWw6IHRoaXMuX3Bha29PcHRpb25zLmxldmVsIHx8IC0xIC8vIGRlZmF1bHQgY29tcHJlc3Npb25cbiAgICB9KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcGFrby5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiBzZWxmLm1ldGFcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbmV4cG9ydHMuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkRlZmxhdGVcIiwgY29tcHJlc3Npb25PcHRpb25zKTtcbn07XG5leHBvcnRzLnVuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkluZmxhdGVcIiwge30pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi4vdXRmOCcpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciBzaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWMgdGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG52YXIgZGVjVG9IZXggPSBmdW5jdGlvbihkZWMsIGJ5dGVzKSB7XG4gICAgdmFyIGhleCA9IFwiXCIsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjICYgMHhmZik7XG4gICAgICAgIGRlYyA9IGRlYyA+Pj4gODtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIFVOSVggcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IHVuaXhQZXJtaXNzaW9ucyB0aGUgdW5peCBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTQ3MDUvdGhlLXppcC1mb3JtYXRzLWV4dGVybmFsLWZpbGUtYXR0cmlidXRlIDpcbiAqXG4gKiBUVFRUc3N0cnd4cnd4cnd4MDAwMDAwMDAwMEFEVlNIUlxuICogXl5eXl9fX19fX19fX19fX19fX19fX19fX19fX19fX18gZmlsZSB0eXBlLCBzZWUgemlwaW5mby5jIChVTlhfKilcbiAqICAgICBeXl5fX19fX19fX19fX19fX19fX19fX19fX19fIHNldHVpZCwgc2V0Z2lkLCBzdGlja3lcbiAqICAgICAgICBeXl5eXl5eXl5fX19fX19fX19fX19fX19fIHBlcm1pc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl9fX19fXyBub3QgdXNlZCA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXiBET1MgYXR0cmlidXRlIGJpdHMgOiBBcmNoaXZlLCBEaXJlY3RvcnksIFZvbHVtZSBsYWJlbCwgU3lzdGVtIGZpbGUsIEhpZGRlbiwgUmVhZCBvbmx5XG4gKi9cbnZhciBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKHVuaXhQZXJtaXNzaW9ucywgaXNEaXIpIHtcblxuICAgIHZhciByZXN1bHQgPSB1bml4UGVybWlzc2lvbnM7XG4gICAgaWYgKCF1bml4UGVybWlzc2lvbnMpIHtcbiAgICAgICAgLy8gSSBjYW4ndCB1c2Ugb2N0YWwgdmFsdWVzIGluIHN0cmljdCBtb2RlLCBoZW5jZSB0aGUgaGV4YS5cbiAgICAgICAgLy8gIDA0MDc3NSA9PiAweDQxZmRcbiAgICAgICAgLy8gMDEwMDY2NCA9PiAweDgxYjRcbiAgICAgICAgcmVzdWx0ID0gaXNEaXIgPyAweDQxZmQgOiAweDgxYjQ7XG4gICAgfVxuICAgIHJldHVybiAocmVzdWx0ICYgMHhGRkZGKSA8PCAxNjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIERPUyBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9zUGVybWlzc2lvbnMgdGhlIGRvcyBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIEJpdCAwICAgICBSZWFkLU9ubHlcbiAqIEJpdCAxICAgICBIaWRkZW5cbiAqIEJpdCAyICAgICBTeXN0ZW1cbiAqIEJpdCAzICAgICBWb2x1bWUgTGFiZWxcbiAqIEJpdCA0ICAgICBEaXJlY3RvcnlcbiAqIEJpdCA1ICAgICBBcmNoaXZlXG4gKi9cbnZhciBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAoZG9zUGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICAvLyB0aGUgZGlyIGZsYWcgaXMgYWxyZWFkeSBzZXQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gKGRvc1Blcm1pc3Npb25zIHx8IDApICAmIDB4M0Y7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB2YXJpb3VzIHBhcnRzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmluYWwgemlwIGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCB3aXRoIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvbnNcbiAqIG9uIHRoZSBmaWxlIGVudHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGF0YSBkZXNjcmlwdG9ycy5cbiAqL1xudmFyIGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IFwiXCI7XG4gICAgZGVzY3JpcHRvciA9IHNpZ25hdHVyZS5EQVRBX0RFU0NSSVBUT1IgK1xuICAgICAgICAvLyBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY3JjMzInXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY29tcHJlc3NlZFNpemUnXSwgNCkgK1xuICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddLCA0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuXG4vKipcbiAqIEEgd29ya2VyIHRvIGNvbmNhdGVuYXRlIG90aGVyIHdvcmtlcnMgdG8gY3JlYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbUZpbGVzIGB0cnVlYCB0byBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzLFxuICogYGZhbHNlYCB0byBhY2N1bXVsYXRlIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIHRoZSBwbGF0Zm9ybSB0byB1c2UsIFwiVU5JWFwiIG9yIFwiRE9TXCIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICovXG5mdW5jdGlvbiBaaXBGaWxlV29ya2VyKHN0cmVhbUZpbGVzLCBjb21tZW50LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBzbyBmYXIuIFRoaXMgZG9lc24ndCBjb3VudCBhY2N1bXVsYXRlZCBjaHVua3MuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIC8vIFRoZSBjb21tZW50IG9mIHRoZSB6aXAgZmlsZVxuICAgIHRoaXMuemlwQ29tbWVudCA9IGNvbW1lbnQ7XG4gICAgLy8gVGhlIHBsYXRmb3JtIFwiZ2VuZXJhdGluZ1wiIHRoZSB6aXAgZmlsZS5cbiAgICB0aGlzLnppcFBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgLy8gdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAgICB0aGlzLmVuY29kZUZpbGVOYW1lID0gZW5jb2RlRmlsZU5hbWU7XG4gICAgLy8gU2hvdWxkIHdlIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMgP1xuICAgIHRoaXMuc3RyZWFtRmlsZXMgPSBzdHJlYW1GaWxlcztcbiAgICAvLyBJZiBgc3RyZWFtRmlsZXNgIGlzIGZhbHNlLCB3ZSB3aWxsIG5lZWQgdG8gYWNjdW11bGF0ZSB0aGUgY29udGVudCBvZiB0aGVcbiAgICAvLyBmaWxlcyB0byBjYWxjdWxhdGUgc2l6ZXMgLyBjcmMzMiAoYW5kIHdyaXRlIHRoZW0gKmJlZm9yZSogdGhlIGNvbnRlbnQpLlxuICAgIC8vIFRoaXMgYm9vbGVhbiBpbmRpY2F0ZXMgaWYgd2UgYXJlIGFjY3VtdWxhdGluZyBjaHVua3MgKGl0IHdpbGwgY2hhbmdlIGEgbG90XG4gICAgLy8gZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHdvcmtlcikuXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgLy8gVGhlIGJ1ZmZlciByZWNlaXZpbmcgY2h1bmtzIHdoZW4gYWNjdW11bGF0aW5nIGNvbnRlbnQuXG4gICAgdGhpcy5jb250ZW50QnVmZmVyID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIHRoaXMuZGlyUmVjb3JkcyA9IFtdO1xuICAgIC8vIFRoZSBvZmZzZXQgKGluIGJ5dGVzKSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHppcCBmaWxlIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyB6aXAgZmlsZS5cbiAgICB0aGlzLmVudHJpZXNDb3VudCA9IDA7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIGFkZGVkLCBudWxsIHdoZW4gaGFuZGxpbmcgdGhlIGVuZCBvZiB0aGUgemlwIGZpbGUuXG4gICAgLy8gVXNlZCBmb3IgdGhlIGVtaXRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4uL2NvbXByZXNzaW9ucycpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKCcuL1ppcEZpbGVXb3JrZXInKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXPCoHVzZWQgd2l0aG91dMKgYG5ld2AsIGl0wqBhZGRzIGBuZXdgIGJlZm9yZcKgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoJy4vbG9hZCcpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy4xLjVcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoJy4vemlwRW50cmllcycpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHppcC5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6aXA7XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIHJ1bm5pbmcgaW4gTm9kZWpzLCB3aWxsIGJlIHVuZGVmaW5lZCBpbiBhIGJyb3dzZXIuXG4gICAgICogSW4gYSBicm93c2VyLCBicm93c2VyaWZ5IHdvbid0IGluY2x1ZGUgdGhpcyBmaWxlIGFuZCB0aGUgd2hvbGUgbW9kdWxlXG4gICAgICogd2lsbCBiZSByZXNvbHZlZCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICovXG4gICAgaXNOb2RlIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciBmcm9tIGFuIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgbmV3QnVmZmVyRnJvbTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgLy8gWFhYIFdlIGNhbid0IHVzZSBgQnVmZmVyLmZyb21gIHdoaWNoIGNvbWVzIGZyb20gYFVpbnQ4QXJyYXkuZnJvbWBcbiAgICAgICAgLy8gaW4gbm9kZWpzIHY0ICg8IHYuNC41KS4gSXQncyBub3QgdGhlIGV4cGVjdGVkIGltcGxlbWVudGF0aW9uIChhbmRcbiAgICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IHNpZ25hdHVyZSkuXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzgwNTNcbiAgICAgICAgLy8gQSBjb25kaXRpb24gb24gbm9kZWpzJyB2ZXJzaW9uIHdvbid0IHNvbHZlIHRoZSBpc3N1ZSBhcyB3ZSBkb24ndFxuICAgICAgICAvLyBjb250cm9sIHRoZSBCdWZmZXIgcG9seWZpbGxzIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgdXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzaXplIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgYWxsb2NCdWZmZXI6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChCdWZmZXIuYWxsb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBCdWZmZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0J1ZmZlciA6IGZ1bmN0aW9uKGIpe1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGIpO1xuICAgIH0sXG5cbiAgICBpc1N0cmVhbSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5vbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnBhdXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucmVzdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9TdHJlYW1IZWxwZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZSgnLi96aXBPYmplY3QnKTtcbnZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyID0gcmVxdWlyZShcIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlclwiKTtcblxuXG4vKipcbiAqIEFkZCBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsT3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgLy8gYmUgc3VyZSBzdWIgZm9sZGVycyBleGlzdFxuICAgIHZhciBkYXRhVHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKSxcbiAgICAgICAgcGFyZW50O1xuXG5cbiAgICAvKlxuICAgICAqIENvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIHZhciBvID0gdXRpbHMuZXh0ZW5kKG9yaWdpbmFsT3B0aW9ucyB8fCB7fSwgZGVmYXVsdHMpO1xuICAgIG8uZGF0ZSA9IG8uZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIGlmIChvLmNvbXByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG8uY3JlYXRlRm9sZGVycyAmJiAocGFyZW50ID0gcGFyZW50Rm9sZGVyKG5hbWUpKSkge1xuICAgICAgICBmb2xkZXJBZGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSBkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBvLmJpbmFyeSA9PT0gZmFsc2UgJiYgby5iYXNlNjQgPT09IGZhbHNlO1xuICAgIGlmICghb3JpZ2luYWxPcHRpb25zIHx8IHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuYmluYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gIWlzVW5pY29kZVN0cmluZztcbiAgICB9XG5cblxuICAgIHZhciBpc0NvbXByZXNzZWRFbXB0eSA9IChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkgJiYgZGF0YS51bmNvbXByZXNzZWRTaXplID09PSAwO1xuXG4gICAgaWYgKGlzQ29tcHJlc3NlZEVtcHR5IHx8IG8uZGlyIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8uYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBcIlNUT1JFXCI7XG4gICAgICAgIGRhdGFUeXBlID0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29udGVudCB0byBmaXQuXG4gICAgICovXG5cbiAgICB2YXIgemlwT2JqZWN0Q29udGVudCA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0IHx8IGRhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBuZXcgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKG5hbWUsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSB1dGlscy5wcmVwYXJlQ29udGVudChuYW1lLCBkYXRhLCBvLmJpbmFyeSwgby5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG8uYmFzZTY0KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0gbmV3IFppcE9iamVjdChuYW1lLCB6aXBPYmplY3RDb250ZW50LCBvKTtcbiAgICB0aGlzLmZpbGVzW25hbWVdID0gb2JqZWN0O1xuICAgIC8qXG4gICAgVE9ETzogd2UgY2FuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBhc3luYyBwcm9taXNlc1xuICAgICh3ZSBjYW4gaGF2ZSBhIHByb21pc2Ugb2YgYSBEYXRlKCkgZm9yIGV4YW1wbGUpIGJ1dCByZXR1cm5pbmcgYVxuICAgIHByb21pc2UgaXMgdXNlbGVzcyBiZWNhdXNlIGZpbGUobmFtZSwgZGF0YSkgcmV0dXJucyB0aGUgSlNaaXBcbiAgICBvYmplY3QgZm9yIGNoYWluaW5nLiBTaG91bGQgd2UgYnJlYWsgdGhhdCB0byBhbGxvdyB0aGUgdXNlclxuICAgIHRvIGNhdGNoIHRoZSBlcnJvciA/XG5cbiAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcE9iamVjdENvbnRlbnQpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICAgICovXG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIHBhdGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBwYXJlbnQgZm9sZGVyLCBvciBcIlwiXG4gKi9cbnZhciBwYXJlbnRGb2xkZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09ICd1bmRlZmluZWQnKSA/IGNyZWF0ZUZvbGRlcnMgOiBkZWZhdWx0cy5jcmVhdGVGb2xkZXJzO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4qIENyb3NzLXdpbmRvdywgY3Jvc3MtTm9kZS1jb250ZXh0IHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXRlY3Rpb25cbiogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IEFueXRoaW5nXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sXG4qIGZhbHNlIG90aGVyd2lzZVxuKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gcmV0dXJuIHRoZSBhY3R1YWwgcHJvdG90eXBlIG9mIEpTWmlwXG52YXIgb3V0ID0ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgbG9hZEFzeW5jXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBhdCB0aGlzIGZvbGRlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUsIHJlbGF0aXZlUGF0aCwgZmlsZTtcbiAgICAgICAgZm9yIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tmaWxlbmFtZV07XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBmaWxlbmFtZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLCBmaWxlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aCAmJiBmaWxlbmFtZS5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoKSA9PT0gdGhpcy5yb290KSB7IC8vIHRoZSBmaWxlIGlzIGluIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgICAgICAgICBjYihyZWxhdGl2ZVBhdGgsIGZpbGUpOyAvLyBUT0RPIHJldmVyc2UgdGhlIHBhcmFtZXRlcnMgPyBuZWVkIHRvIGJlIGNsZWFuIEFORCBjb25zaXN0ZW50IHdpdGggdGhlIGZpbHRlciBzZWFyY2ggZm4uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbmVzdGVkIGZpbGVzL2ZvbGRlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaCB0aGUgcHJlZGljYXRlIHRvIHVzZSA6XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gocmVsYXRpdmVQYXRoLCBlbnRyeSkpIHsgLy8gdGhlIGZpbGUgbWF0Y2hlcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2ggYSBmaWxlLlxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd8UmVnRXhwfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGFkZCAoaWYgZGF0YSBpcyBkZWZpbmVkKSxcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmaW5kIChpZiBubyBkYXRhKSBvciBhIHJlZ2V4IHRvIG1hdGNoIGZpbGVzLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgIFRoZSBmaWxlIGRhdGEsIGVpdGhlciByYXcgb3IgYmFzZTY0IGVuY29kZWRcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSBvICAgICBGaWxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuICB7SlNaaXB8T2JqZWN0fEFycmF5fSB0aGlzIEpTWmlwIG9iamVjdCAod2hlbiBhZGRpbmcgYSBmaWxlKSxcbiAgICAgKiBhIGZpbGUgKHdoZW4gc2VhcmNoaW5nIGJ5IHN0cmluZykgb3IgYW4gYXJyYXkgb2YgZmlsZXMgKHdoZW4gc2VhcmNoaW5nIGJ5IHJlZ2V4KS5cbiAgICAgKi9cbiAgICBmaWxlOiBmdW5jdGlvbihuYW1lLCBkYXRhLCBvKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVnZXhwLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZmlsZXNbdGhpcy5yb290ICsgbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiAhb2JqLmRpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9yZSB0aGFuIG9uZSBhcmd1bWVudCA6IHdlIGhhdmUgZGF0YSAhXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBkYXRhLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGlyZWN0b3J5IHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8UmVnRXhwfSBhcmcgVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSB0byBhZGQsIG9yIGEgcmVnZXggdG8gc2VhcmNoIGZvbGRlcnMuXG4gICAgICogQHJldHVybiAge0pTWmlwfSBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IGRpcmVjdG9yeSBhcyB0aGUgcm9vdCwgb3IgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGluZyBmb2xkZXJzLlxuICAgICAqL1xuICAgIGZvbGRlcjogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGlyICYmIGFyZy50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UsIG5hbWUgaXMgYSBuZXcgZm9sZGVyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5yb290ICsgYXJnO1xuICAgICAgICB2YXIgbmV3Rm9sZGVyID0gZm9sZGVyQWRkLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcgYnkgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoaXMgZm9sZGVyIGFzIHRoZSByb290XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldC5yb290ID0gbmV3Rm9sZGVyLm5hbWU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUsIG9yIGEgZGlyZWN0b3J5IGFuZCBhbGwgc3ViLWZpbGVzLCBmcm9tIHRoZSB6aXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhpcyBKU1ppcCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSB6aXAgZmlsZVxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXMgYW4gaW50ZXJuYWwgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgc3RyZWFtZWQgemlwIGZpbGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHdvcmtlciwgb3B0cyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgc3RyZWFtRmlsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgY29tbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBvcHRzLmNvbXByZXNzaW9uID0gb3B0cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gXCJiaW5hcnlzdHJpbmdcIiBpcyBwcmVmZXJlZCBidXQgdGhlIGludGVybmFscyB1c2UgXCJzdHJpbmdcIi5cbiAgICAgICAgICBpZihvcHRzLnR5cGUgPT09IFwiYmluYXJ5c3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdHMudHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFvcHRzLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG91dHB1dCB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KG9wdHMudHlwZSk7XG5cbiAgICAgICAgICAvLyBhY2NlcHQgbm9kZWpzIGBwcm9jZXNzLnBsYXRmb3JtYFxuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnZGFyd2luJyB8fFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnZnJlZWJzZCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnc3Vub3MnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIlVOSVhcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiRE9TXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbW1lbnQgPSBvcHRzLmNvbW1lbnQgfHwgdGhpcy5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgICAgd29ya2VyID0gZ2VuZXJhdGUuZ2VuZXJhdGVXb3JrZXIodGhpcywgb3B0cywgY29tbWVudCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdvcmtlciA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgIHdvcmtlci5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHdvcmtlciwgb3B0cy50eXBlIHx8IFwic3RyaW5nXCIsIG9wdHMubWltZVR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlQXN5bmM6IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVOb2RlU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IFwibm9kZWJ1ZmZlclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IG91dDtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdXNlZCBieSBtb2R1bGUgYnVuZGxlcnMgKGJyb3dzZXJpZnkvd2VicGFjay9ldGMpIHdoZW5cbiAqIGluY2x1ZGluZyBhIHN0cmVhbSBpbXBsZW1lbnRhdGlvbi4gV2UgdXNlIFwicmVhZGFibGUtc3RyZWFtXCIgdG8gZ2V0IGFcbiAqIGNvbnNpc3RlbnQgYmVoYXZpb3IgYmV0d2VlbiBub2RlanMgdmVyc2lvbnMgYnV0IGJ1bmRsZXJzIG9mdGVuIGhhdmUgYSBzaGltXG4gKiBmb3IgXCJzdHJlYW1cIi4gVXNpbmcgdGhpcyBzaGltIGdyZWF0bHkgaW1wcm92ZSB0aGUgY29tcGF0aWJpbGl0eSBhbmQgZ3JlYXRseVxuICogcmVkdWNlIHRoZSBmaW5hbCBzaXplIG9mIHRoZSBidW5kbGUgKG9ubHkgb25lIHN0cmVhbSBpbXBsZW1lbnRhdGlvbiwgbm90XG4gKiB0d28pLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgRGF0YVJlYWRlciA9IHJlcXVpcmUoJy4vRGF0YVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gQXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdGRhdGFbaV0gPSBkYXRhW2ldICYgMHhGRjtcblx0fVxufVxudXRpbHMuaW5oZXJpdHMoQXJyYXlSZWFkZXIsIERhdGFSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnplcm8gKyBpXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDQ7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT09IHNpZzAgJiYgdGhpcy5kYXRhW2kgKyAxXSA9PT0gc2lnMSAmJiB0aGlzLmRhdGFbaSArIDJdID09PSBzaWcyICYmIHRoaXMuZGF0YVtpICsgM10gPT09IHNpZzMpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBzaWcwID0gc2lnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNpZzEgPSBzaWcuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgc2lnMiA9IHNpZy5jaGFyQ29kZUF0KDIpLFxuICAgICAgICBzaWczID0gc2lnLmNoYXJDb2RlQXQoMyksXG4gICAgICAgIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcwID09PSBkYXRhWzBdICYmIHNpZzEgPT09IGRhdGFbMV0gJiYgc2lnMiA9PT0gZGF0YVsyXSAmJiBzaWczID09PSBkYXRhWzNdO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gRGF0YVJlYWRlcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTsgLy8gdHlwZSA6IHNlZSBpbXBsZW1lbnRhdGlvblxuICAgIHRoaXMubGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy56ZXJvID0gMDtcbn1cbkRhdGFSZWFkZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIG9mZnNldCB3aWxsIG5vdCBnbyB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXQgdGhlIGFkZGl0aW9uYWwgb2Zmc2V0IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgb2Zmc2V0IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgodGhpcy5pbmRleCArIG9mZnNldCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggd2lsbCBub3QgYmUgdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3SW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja0luZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLnplcm8gKyBuZXdJbmRleCB8fCBuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuZCBvZiBkYXRhIHJlYWNoZWQgKGRhdGEgbGVuZ3RoID0gXCIgKyB0aGlzLmxlbmd0aCArIFwiLCBhc2tlZCBpbmRleCA9IFwiICsgKG5ld0luZGV4KSArIFwiKS4gQ29ycnVwdGVkIHppcCA/XCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCBUaGUgbmV3IGluZGV4LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBzZXRJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KG5ld0luZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG5ld0luZGV4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2tpcCB0aGUgbmV4dCBuIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2tpcDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuaW5kZXggKyBuKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIHRoZSBpbmRleCB0byB1c2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBhIGJ5dGUuXG4gICAgICovXG4gICAgYnl0ZUF0OiBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBudW1iZXIgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIuXG4gICAgICovXG4gICAgcmVhZEludDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuaW5kZXggKyBzaXplIC0gMTsgaSA+PSB0aGlzLmluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgKyB0aGlzLmJ5dGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgc3RyaW5nIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGNvcnJlc3BvbmRpbmcgc3RyaW5nLlxuICAgICAqL1xuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMucmVhZERhdGEoc2l6ZSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIHdpdGhvdXQgY29udmVyc2lvbiwgPHNpemU+IGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSByYXcgZGF0YSwgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXG4gICAgICovXG4gICAgcmVhZERhdGE6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbGFzdCBvY2N1cmVuY2Ugb2YgYSB6aXAgc2lnbmF0dXJlICg0IGJ5dGVzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBzaWduYXR1cmUgdG8gZmluZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9TdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9Ob2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICdkYXRhJzpbXSxcbiAgICAgICAgJ2VuZCc6W10sXG4gICAgICAgICdlcnJvcic6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dHJhU3RyZWFtSW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZSgnLi9Db252ZXJ0V29ya2VyJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKCcuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcicpO1xuICAgIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubmV3QmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIGNvbnRlbnQpLCBtaW1lVHlwZSk7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFBcnJheS5qb2luKFwiXCIpO1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICByZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGRhdGFBcnJheVtpXSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICArIHR5cGUgKyBcIidcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gKiBjb21wbGV0ZSBibG9jay5cbiAqIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYWxsYmFjayBhIGNhbGxiYWNrIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZS4gQ2FsbGVkXG4gKiB3aXRoIG9uZSBhcmcgOlxuICogLSB0aGUgbWV0YWRhdGEgbGlua2VkIHRvIHRoZSB1cGRhdGUgcmVjZWl2ZWQuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaGVscGVyLCB1cGRhdGVDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUeXBlID0gaGVscGVyLl9pbnRlcm5hbFR5cGUsXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gaGVscGVyLl9vdXRwdXRUeXBlLFxuICAgICAgICAgICAgbWltZVR5cGUgPSBoZWxwZXIuX21pbWVUeXBlO1xuICAgICAgICBoZWxwZXJcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWxsYmFjayhtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVppcE91dHB1dChyZXN1bHRUeXBlLCBjb25jYXQoY2h1bmtUeXBlLCBkYXRhQXJyYXkpLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsVHlwZSA9IGludGVybmFsVHlwZTtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCB0byBvdXRwdXQgcmVzdWx0c1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcbiAgICAgICAgLy8gdGhlIG1pbWUgdHlwZVxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyLnBpcGUobmV3IENvbnZlcnRXb3JrZXIoaW50ZXJuYWxUeXBlKSk7XG4gICAgICAgIC8vIHRoZSBsYXN0IHdvcmtlcnMgY2FuIGJlIHJld2lyZWQgd2l0aG91dCBpc3N1ZXMgYnV0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBhbnkgdXBkYXRlcyBvbiBwcmV2aW91cyB3b3JrZXJzLlxuICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB0aGlzLl93b3JrZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuXG5TdHJlYW1IZWxwZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gICAgICogY29tcGxldGUgYmxvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gICAgICovXG4gICAgYWNjdW11bGF0ZSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZSh0aGlzLCB1cGRhdGVDYik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBvbiBhbiBldmVudCB0cmlnZ2VyZWQgb24gYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCB0aGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChldnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZihldnQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHNlbGYsIGNodW5rLmRhdGEsIGNodW5rLm1ldGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZGVsYXkoZm4sIGFyZ3VtZW50cywgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLCBbXSwgdGhpcy5fd29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5vZGVqcyBzdHJlYW0gZm9yIHRoaXMgaGVscGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Tm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcn0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gICAgICovXG4gICAgdG9Ob2RlanNTdHJlYW0gOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KFwibm9kZXN0cmVhbVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgc3RyZWFtIGNvbnRhaW5pbmcgYmxvYi9hcnJheWJ1ZmZlci91aW50OGFycmF5L3N0cmluZ1xuICAgICAgICAgICAgLy8gaXMgc3RyYW5nZSBhbmQgSSBkb24ndCBrbm93IGlmIGl0IHdvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgICAgIC8vIEkgeW91IGZpbmQgdGhpcyBjb21tZW50IGFuZCBoYXZlIGEgZ29vZCB1c2VjYXNlLCBwbGVhc2Ugb3BlbiBhXG4gICAgICAgICAgICAvLyBidWcgcmVwb3J0ICFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcih0aGlzLCB7XG4gICAgICAgICAgICBvYmplY3RNb2RlIDogdGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCJcbiAgICAgICAgfSwgdXBkYXRlQ2IpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ2FwcGxpY2F0aW9uL3ppcCcpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdjb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZScpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRoYXQgcGFzcyBhcyBhIFwiYmluYXJ5IHN0cmluZ1wiOiBpdCBzaG91bGQgcmVwcmVzZW50IGEgYnl0ZVxuICogYXJyYXkgYnV0IG1heSBoYXZlID4gMjU1IGNoYXIgY29kZXMuIEJlIHN1cmUgdG8gdGFrZSBvbmx5IHRoZSBmaXJzdCBieXRlXG4gKiBhbmQgcmV0dXJucyB0aGUgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fSB0aGUgc3RyaW5nIGluIGEgYmluYXJ5IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nMmJpbmFyeShzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCByZXN1bHQpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBibG9iIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQgYW5kIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ9IHBhcnQgdGhlIGNvbnRlbnQgdG8gcHV0IGluIHRoZSBibG9iLiBETyBOT1QgdXNlXG4gKiBhbiBVaW50OEFycmF5IGJlY2F1c2UgdGhlIHN0b2NrIGJyb3dzZXIgb2YgYW5kcm9pZCA0IHdvbid0IGFjY2VwdCBpdCAoaXRcbiAqIHdpbGwgYmUgc2lsZW50bHkgY29udmVydGVkIHRvIGEgc3RyaW5nLCBcIltvYmplY3QgVWludDhBcnJheV1cIikuXG4gKlxuICogVXNlIG9ubHkgT05FIHBhcnQgdG8gYnVpbGQgdGhlIGJsb2IgdG8gYXZvaWQgYSBtZW1vcnkgbGVhayBpbiBJRTExIC8gRWRnZTpcbiAqIHdoZW4gYSBsYXJnZSBhbW91bnQgb2YgQXJyYXkgaXMgdXNlZCB0byBjcmVhdGUgdGhlIEJsb2IsIHRoZSBhbW91bnQgb2ZcbiAqIG1lbW9yeSBjb25zdW1lZCBpcyBuZWFybHkgMTAwIHRpbWVzIHRoZSBvcmlnaW5hbCBkYXRhIGFtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBibG9iLlxuICogQHJldHVybiB7QmxvYn0gdGhlIGNyZWF0ZWQgYmxvYi5cbiAqL1xuZXhwb3J0cy5uZXdCbG9iID0gZnVuY3Rpb24ocGFydCwgdHlwZSkge1xuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KFwiYmxvYlwiKTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIEJsb2IgY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtwYXJ0XSwge1xuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCwgYnJvd3NlciBvbmx5LCBvbGQgd2F5XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvLyB3ZWxsLCBmdWNrID8hXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiBjYW4ndCBjb25zdHJ1Y3QgdGhlIEJsb2IuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzYW1lIGlucHV0LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBGaWxsIGluIGFuIGFycmF5IHdpdGggYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdXNlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIGZpbGwgaW4gKHdpbGwgYmUgbXV0YXRlZCkuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJheVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciBmb3IgdGhlIGZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICogVGhpcyBjb250YWlucyBzdGF0aWMgaW5mb3JtYXRpb25zIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGluIGEgZm9ybWF0IHZhbGlkIGZvciBKU1ppcC51dGlscy50cmFuc2Zvcm1UbyA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dCB0byBpZGVudGlmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIChsb3dlcmNhc2UpIHR5cGUgb2YgdGhlIGlucHV0LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyICYmIG5vZGVqc1V0aWxzLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJub2RlYnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcInVpbnQ4YXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQuYXJyYXlidWZmZXIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0byBjaGVjay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICovXG5leHBvcnRzLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1O1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gLTE7IC8vIHdlbGwsIFwiXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlwiIGlzIHBhcnNlZCBhcyAtMVxuXG4vKipcbiAqIFByZXR0aWZ5IGEgc3RyaW5nIHJlYWQgYXMgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHByZXR0aWZ5LlxuICogQHJldHVybiB7c3RyaW5nfSBhIHByZXR0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlcyA9ICcnLFxuICAgICAgICBjb2RlLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoc3RyIHx8IFwiXCIpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmVzICs9ICdcXFxceCcgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGF0dHIpICYmIHR5cGVvZiByZXN1bHRbYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0cl0gPSBhcmd1bWVudHNbaV1bYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFyYml0cmFyeSBjb250ZW50IGludG8gYSBQcm9taXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIGZvciB0aGUgY29udGVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhIHRoZSBjb250ZW50IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFuIHVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IG9ubHkgaGFzIG9uZSBieXRlIHBlciBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFzZTY0IHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IGlzIGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IEpTWmlwLlxuICovXG5leHBvcnRzLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24obmFtZSwgaW5wdXREYXRhLCBpc0JpbmFyeSwgaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIGlzQmFzZTY0KSB7XG5cbiAgICAvLyBpZiBpbnB1dERhdGEgaXMgYWxyZWFkeSBhIHByb21pc2UsIHRoaXMgZmxhdHRlbiBpdC5cbiAgICB2YXIgcHJvbWlzZSA9IGV4dGVybmFsLlByb21pc2UucmVzb2x2ZShpbnB1dERhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBpc0Jsb2IgPSBzdXBwb3J0LmJsb2IgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IFsnW29iamVjdCBGaWxlXScsICdbb2JqZWN0IEJsb2JdJ10uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKGlzQmxvYiAmJiB0eXBlb2YgRmlsZVJlYWRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicuIElzIGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gZXhwb3J0cy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmluZywgbm90IGluIGEgYmFzZTY0IGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzdHJpbmcyYmluYXJ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc2lnID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBaaXBFbnRyeSA9IHJlcXVpcmUoJy4vemlwRW50cnknKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMobG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cmllcy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgcmVhZGVyIGlzIG9uIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBhbiBvdGhlciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGV4cGVjdGVkU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuaW5kZXggLT0gNDtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2tpcCg0KTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YVtleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IuXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlza3NDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBmaWxlcywgYmFzZWQgb24gdGhlIG9mZnNldCByZWFkIGluIHRoZSBjZW50cmFsIHBhcnQuXG4gICAgICovXG4gICAgcmVhZExvY2FsRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZmlsZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZmlsZS5sb2NhbEhlYWRlck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG4gICAgICAgICAgICBmaWxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGVVVEY4KCk7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbGU7XG5cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9ob3d0by9yZWFkX3ppcC5odG1sXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgIHZhciBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCk7XG5cblxuICAgICAgICAvKiBleHRyYWN0IGZyb20gdGhlIHppcCBzcGVjIDpcbiAgICAgICAgICAgIDQpICBJZiBvbmUgb2YgdGhlIGZpZWxkcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmVjb3JkIGlzIHRvbyBzbWFsbCB0byBob2xkIHJlcXVpcmVkIGRhdGEsIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgIHNob3VsZCBiZSBzZXQgdG8gLTEgKDB4RkZGRiBvciAweEZGRkZGRkZGKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWklQNjQgZm9ybWF0IHJlY29yZCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIDUpICBUaGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IgcmVjb3JkIG11c3RcbiAgICAgICAgICAgICAgICByZXNpZGUgb24gdGhlIHNhbWUgZGlzayB3aGVuIHNwbGl0dGluZyBvciBzcGFubmluZ1xuICAgICAgICAgICAgICAgIGFuIGFyY2hpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy56aXA2NCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBXYXJuaW5nIDogdGhlIHppcDY0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQsIGJ1dCBPTkxZIGlmIHRoZSA2NGJpdHMgaW50ZWdlciByZWFkIGZyb21cbiAgICAgICAgICAgIHRoZSB6aXAgZmlsZSBjYW4gZml0IGludG8gYSAzMmJpdHMgaW50ZWdlci4gVGhpcyBjYW5ub3QgYmUgc29sdmVkIDogSmF2YVNjcmlwdCByZXByZXNlbnRzXG4gICAgICAgICAgICBhbGwgbnVtYmVycyBhcyA2NC1iaXQgZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICAgICAgICAgICAgU28sIHdlIGhhdmUgNTNiaXRzIGZvciBpbnRlZ2VycyBhbmQgYml0d2lzZSBvcGVyYXRpb25zIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgMzJiaXRzLlxuICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzXG4gICAgICAgICAgICBhbmQgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VDTUEtMjYyLnBkZiBzZWN0aW9uIDguNVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gc2hvdWxkIGxvb2sgZm9yIGEgemlwNjQgRU9DRCBsb2NhdG9yXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyRm9yKGRhdGEpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHppcCBmaWxlIGFuZCBjcmVhdGUgWmlwRW50cmllcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgYSB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlYWRlcihkYXRhKTtcbiAgICAgICAgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIHRoaXMucmVhZENlbnRyYWxEaXIoKTtcbiAgICAgICAgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgIH1cbn07XG4vLyB9fX0gZW5kIG9mIFppcEVudHJpZXNcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cmllcztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKCcuL3JlYWRlci9yZWFkZXJGb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wcmVzc2lvbnMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG5cbnZhciBNQURFX0JZX0RPUyA9IDB4MDA7XG52YXIgTUFERV9CWV9VTklYID0gMHgwMztcblxuLyoqXG4gKiBGaW5kIGEgY29tcHJlc3Npb24gcmVnaXN0ZXJlZCBpbiBKU1ppcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbk1ldGhvZCB0aGUgbWV0aG9kIG1hZ2ljIHRvIGZpbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIEpTWmlwIGNvbXByZXNzaW9uIG9iamVjdCwgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG52YXIgZmluZENvbXByZXNzaW9uID0gZnVuY3Rpb24oY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gY29tcHJlc3Npb25zKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb25zLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc2lvbnNbbWV0aG9kXS5tYWdpYyA9PT0gY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2lvbnNbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICAvLyB0aGUgZmlsZU5hbWUgaXMgc3RvcmVkIGFzIGJpbmFyeSBkYXRhLCB0aGUgaGFuZGxlVVRGOCBtZXRob2Qgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGVuY29kaW5nLlxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdGhpcy51bmNvbXByZXNzZWRTaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbnMgZnJvbSB0aGUgY2VudHJhbCBkaXJlY3RvcnkgXCIgKyBcIihjb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHJlc3Npb24gPSBmaW5kQ29tcHJlc3Npb24odGhpcy5jb21wcmVzc2lvbk1ldGhvZCk7XG4gICAgICAgIGlmIChjb21wcmVzc2lvbiA9PT0gbnVsbCkgeyAvLyBubyBjb21wcmVzc2lvbiBmb3VuZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNvbXByZXNzaW9uIFwiICsgdXRpbHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiICsgdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5maWxlTmFtZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQgPSBuZXcgQ29tcHJlc3NlZE9iamVjdCh0aGlzLmNvbXByZXNzZWRTaXplLCB0aGlzLnVuY29tcHJlc3NlZFNpemUsIHRoaXMuY3JjMzIsIGNvbXByZXNzaW9uLCByZWFkZXIucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICByZWFkZXIuc2tpcCgyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuYml0RmxhZyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTWV0aG9kID0gcmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHJlYWRlci5yZWFkRGF0ZSgpO1xuICAgICAgICB0aGlzLmNyYzMyID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHZhciBmaWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gcmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGVkIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpbGwgYmUgcmVhZCBpbiB0aGUgbG9jYWwgcGFydCwgc2VlIHRoZSBjb21tZW50cyB0aGVyZVxuICAgICAgICByZWFkZXIuc2tpcChmaWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVhZEV4dHJhRmllbGRzKHJlYWRlcik7XG4gICAgICAgIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQocmVhZGVyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudCA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyBhbmQgZ2V0IHRoZSB1bml4L2RvcyBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB2YXIgbWFkZUJ5ID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgRE9TIGRpcmVjdG9yeSBmbGFnIHNldC5cbiAgICAgICAgLy8gV2UgbG9vayBmb3IgaXQgaW4gdGhlIERPUyBhbmQgVU5JWCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBidXQgc29tZSB1bmtub3duIHBsYXRmb3JtIGNvdWxkIHNldCBpdCBhcyBhIGNvbXBhdGliaWxpdHkgZmxhZy5cbiAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDAwMTAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX0RPUykge1xuICAgICAgICAgICAgLy8gZmlyc3QgNiBiaXRzICgwIHRvIDUpXG4gICAgICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgzRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9VTklYKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9ICh0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgICAgICAgICAgLy8gdGhlIG9jdGFsIHBlcm1pc3Npb25zIGFyZSBpbiAodGhpcy51bml4UGVybWlzc2lvbnMgJiAweDAxRkYpLnRvU3RyaW5nKDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFpbCBzYWZlIDogaWYgdGhlIG5hbWUgZW5kcyB3aXRoIGEgLyBpdCBwcm9iYWJseSBtZWFucyBhIGZvbGRlclxuICAgICAgICBpZiAoIXRoaXMuZGlyICYmIHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgWklQNjQgZXh0cmEgZmllbGQgYW5kIG1lcmdlIHRoZSBpbmZvIGluIHRoZSBjdXJyZW50IFppcEVudHJ5LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbihyZWFkZXIpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZywgcHJlcGFyaW5nIHRoZSBleHRyYSByZWFkZXJcbiAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXS52YWx1ZSk7XG5cbiAgICAgICAgLy8gSSByZWFsbHkgaG9wZSB0aGF0IHRoZXNlIDY0Yml0cyBpbnRlZ2VyIGNhbiBmaXQgaW4gMzIgYml0cyBpbnRlZ2VyLCBiZWNhdXNlIGpzXG4gICAgICAgIC8vIHdvbid0IGxldCB1cyBoYXZlIG1vcmUuXG4gICAgICAgIGlmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gZXh0cmFSZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkRXh0cmFGaWVsZHM6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVhZGVyLmluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkc1tleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFuIFVURjggdHJhbnNmb3JtYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGhhbmRsZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIGlmICh0aGlzLnVzZVVURjgoKSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBhdGggPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh1cGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1cGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50Qnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoY29tbWVudEJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBwYXRoIGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgcGF0aCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGF0aEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDcwNzVdO1xuICAgICAgICBpZiAodXBhdGhGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVwYXRoRmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBmaWxlbmFtZSBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlTmFtZSkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1cGF0aEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBjb21tZW50IGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgY29tbWVudCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1Y29tbWVudEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDYzNzVdO1xuICAgICAgICBpZiAodWNvbW1lbnRGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVjb21tZW50RmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBjb21tZW50IGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVDb21tZW50KSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVjb21tZW50RmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2RhdGFCaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICAvLyBrZWVwIG9ubHkgdGhlIGNvbXByZXNzaW9uXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzc2lvbiA6IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zXG4gICAgfTtcbn07XG5cblppcE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHN0cmVhbSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbUhlbHBlciB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGludGVybmFsU3RyZWFtOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlID09PSBcImJpbmFyeXN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSAhdGhpcy5fZGF0YUJpbmFyeTtcblxuICAgICAgICAgICAgaWYgKGlzVW5pY29kZVN0cmluZyAmJiAhYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVW5pY29kZVN0cmluZyAmJiBhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuc2V0SW1tZWRpYXRlOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi4zLjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHRhc2sgICA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKFpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcbiAgdmFyIGRpY3Q7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QgPSBkaWN0aW9uYXJ5O1xuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGltbWVkaWF0ZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZScpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWUsIG1vZHVsZUxvYWRUaW1lLCBub2RlTG9hZFRpbWUsIHVwVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBub2RlTG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIG1vZHVsZUxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgICB1cFRpbWUgPSBwcm9jZXNzLnVwdGltZSgpICogMWU5O1xuICAgIG5vZGVMb2FkVGltZSA9IG1vZHVsZUxvYWRUaW1lIC0gdXBUaW1lO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmb3JtYW5jZS1ub3cuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgb2JqZWN0ID0gcm9vdDtcbiAgfVxuICBvYmplY3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIG9iamVjdC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhZlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59O1xuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQsIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG47KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpID8gZXhwb3J0cyA6IG51bGw7XG4gIHZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKSA/IG1vZHVsZSA6IG51bGw7XG4gIHZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuICB2YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG4gIHZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSAoZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSA/IGZyZWVFeHBvcnRzIDogbnVsbDtcbiAgdmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIHZhciBSeCA9IHtcbiAgICBpbnRlcm5hbHM6IHt9LFxuICAgIGNvbmZpZzoge1xuICAgICAgUHJvbWlzZTogcm9vdC5Qcm9taXNlXG4gICAgfSxcbiAgICBoZWxwZXJzOiB7IH1cbiAgfTtcblxuICAvLyBEZWZhdWx0c1xuICB2YXIgbm9vcCA9IFJ4LmhlbHBlcnMubm9vcCA9IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBpZGVudGl0eSA9IFJ4LmhlbHBlcnMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICBkZWZhdWx0Tm93ID0gUnguaGVscGVycy5kZWZhdWx0Tm93ID0gRGF0ZS5ub3csXG4gICAgZGVmYXVsdENvbXBhcmVyID0gUnguaGVscGVycy5kZWZhdWx0Q29tcGFyZXIgPSBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gaXNFcXVhbCh4LCB5KTsgfSxcbiAgICBkZWZhdWx0U3ViQ29tcGFyZXIgPSBSeC5oZWxwZXJzLmRlZmF1bHRTdWJDb21wYXJlciA9IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ID4geSA/IDEgOiAoeCA8IHkgPyAtMSA6IDApOyB9LFxuICAgIGRlZmF1bHRLZXlTZXJpYWxpemVyID0gUnguaGVscGVycy5kZWZhdWx0S2V5U2VyaWFsaXplciA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH0sXG4gICAgZGVmYXVsdEVycm9yID0gUnguaGVscGVycy5kZWZhdWx0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBpc1Byb21pc2UgPSBSeC5oZWxwZXJzLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiAhIXAgJiYgdHlwZW9mIHAuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwLnRoZW4gPT09ICdmdW5jdGlvbic7IH0sXG4gICAgaXNGdW5jdGlvbiA9IFJ4LmhlbHBlcnMuaXNGdW5jdGlvbiA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHZhciBpc0ZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgaWYgKGlzRm4oL3gvKSkge1xuICAgICAgICBpc0ZuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzRm47XG4gICAgfSgpKTtcblxuICBmdW5jdGlvbiBjbG9uZUFycmF5KGFycikgeyBmb3IodmFyIGEgPSBbXSwgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhLnB1c2goYXJyW2ldKTsgfSByZXR1cm4gYTt9XG5cbiAgdmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbiAgXG4gIGZ1bmN0aW9uIHRyeUNhdGNoZXJHZW4odHJ5Q2F0Y2hUYXJnZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgdHJ5Q2F0Y2ggPSBSeC5pbnRlcm5hbHMudHJ5Q2F0Y2ggPSBmdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignZm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7IH1cbiAgICByZXR1cm4gdHJ5Q2F0Y2hlckdlbihmbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIFJ4LmNvbmZpZy5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG4gIHZhciBoYXNTdGFja3MgPSBmYWxzZSwgc3RhY2tzID0gdHJ5Q2F0Y2goZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfSkoKTtcbiAgaGFzU3RhY2tzID0gISFzdGFja3MuZSAmJiAhIXN0YWNrcy5lLnN0YWNrO1xuXG4gIC8vIEFsbCBjb2RlIGFmdGVyIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcyByZXBvcnRlZCBieSBSeEpTXG4gIHZhciByU3RhcnRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKSwgckZpbGVOYW1lO1xuXG4gIHZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9ICdGcm9tIHByZXZpb3VzIGV2ZW50Oic7XG5cbiAgZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBvYnNlcnZhYmxlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUnhKU1xuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYG9ic2VydmFibGVgLlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgb2JzZXJ2YWJsZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrICYmXG4gICAgICAgIGVycm9yLnN0YWNrLmluZGV4T2YoU1RBQ0tfSlVNUF9TRVBBUkFUT1IpID09PSAtMVxuICAgICkge1xuICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgZm9yICh2YXIgbyA9IG9ic2VydmFibGU7ICEhbzsgbyA9IG8uc291cmNlKSB7XG4gICAgICAgIGlmIChvLnN0YWNrKSB7XG4gICAgICAgICAgc3RhY2tzLnVuc2hpZnQoby5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgdmFyIGNvbmNhdGVkU3RhY2tzID0gc3RhY2tzLmpvaW4oJ1xcbicgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArICdcXG4nKTtcbiAgICAgIGVycm9yLnN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoJ1xcbicpLCBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgIGlmICghaXNJbnRlcm5hbEZyYW1lKGxpbmUpICYmICFpc05vZGVGcmFtZShsaW5lKSAmJiBsaW5lKSB7XG4gICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaXJlZExpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF0sIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHJGaWxlTmFtZSAmJlxuICAgICAgbGluZU51bWJlciA+PSByU3RhcnRpbmdMaW5lICYmXG4gICAgICBsaW5lTnVtYmVyIDw9IHJFbmRpbmdMaW5lO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKCcobW9kdWxlLmpzOicpICE9PSAtMSB8fFxuICAgICAgc3RhY2tMaW5lLmluZGV4T2YoJyhub2RlLmpzOicpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhcHR1cmVMaW5lKCkge1xuICAgIGlmICghaGFzU3RhY2tzKSB7IHJldHVybjsgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoJ0AnKSA+IDAgPyBsaW5lc1sxXSA6IGxpbmVzWzJdO1xuICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHJGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgIHJldHVybiBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogJ2F0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpJ1xuICAgIHZhciBhdHRlbXB0MSA9IC9hdCAuKyBcXCgoLispOihcXGQrKTooPzpcXGQrKVxcKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDEpIHsgcmV0dXJuIFthdHRlbXB0MVsxXSwgTnVtYmVyKGF0dGVtcHQxWzJdKV07IH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6ICdhdCBmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlcidcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7IHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldOyB9XG5cbiAgICAvLyBGaXJlZm94IHN0eWxlOiAnZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlcidcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7IHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldOyB9XG4gIH1cblxuICB2YXIgRW1wdHlFcnJvciA9IFJ4LkVtcHR5RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnU2VxdWVuY2UgY29udGFpbnMgbm8gZWxlbWVudHMuJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBFbXB0eUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgRW1wdHlFcnJvci5wcm90b3R5cGUubmFtZSA9ICdFbXB0eUVycm9yJztcblxuICB2YXIgT2JqZWN0RGlzcG9zZWRFcnJvciA9IFJ4Lk9iamVjdERpc3Bvc2VkRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnT2JqZWN0IGhhcyBiZWVuIGRpc3Bvc2VkJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBPYmplY3REaXNwb3NlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgT2JqZWN0RGlzcG9zZWRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdPYmplY3REaXNwb3NlZEVycm9yJztcblxuICB2YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBSeC5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnQXJndW1lbnQgb3V0IG9mIHJhbmdlJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcblxuICB2YXIgTm90U3VwcG9ydGVkRXJyb3IgPSBSeC5Ob3RTdXBwb3J0ZWRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgTm90U3VwcG9ydGVkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBOb3RTdXBwb3J0ZWRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcic7XG5cbiAgdmFyIE5vdEltcGxlbWVudGVkRXJyb3IgPSBSeC5Ob3RJbXBsZW1lbnRlZEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGlzIG9wZXJhdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIE5vdEltcGxlbWVudGVkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBOb3RJbXBsZW1lbnRlZEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ05vdEltcGxlbWVudGVkRXJyb3InO1xuXG4gIHZhciBub3RJbXBsZW1lbnRlZCA9IFJ4LmhlbHBlcnMubm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfTtcblxuICB2YXIgbm90U3VwcG9ydGVkID0gUnguaGVscGVycy5ub3RTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCk7XG4gIH07XG5cbiAgLy8gU2hpbSBpbiBpdGVyYXRvciBzdXBwb3J0XG4gIHZhciAkaXRlcmF0b3IkID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yKSB8fFxuICAgICdfZXM2c2hpbV9pdGVyYXRvcl8nO1xuICAvLyBCdWcgZm9yIG1vemlsbGEgdmVyc2lvblxuICBpZiAocm9vdC5TZXQgJiYgdHlwZW9mIG5ldyByb290LlNldCgpWydAQGl0ZXJhdG9yJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAkaXRlcmF0b3IkID0gJ0BAaXRlcmF0b3InO1xuICB9XG5cbiAgdmFyIGRvbmVFbnVtZXJhdG9yID0gUnguZG9uZUVudW1lcmF0b3IgPSB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcblxuICB2YXIgaXNJdGVyYWJsZSA9IFJ4LmhlbHBlcnMuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgb1skaXRlcmF0b3IkXSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciBpc0FycmF5TGlrZSA9IFJ4LmhlbHBlcnMuaXNBcnJheUxpa2UgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIG8ubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgUnguaGVscGVycy5pdGVyYXRvciA9ICRpdGVyYXRvciQ7XG5cbiAgdmFyIGJpbmRDYWxsYmFjayA9IFJ4LmludGVybmFscy5iaW5kQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICBpZiAodHlwZW9mIHRoaXNBcmcgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmdW5jOyB9XG4gICAgc3dpdGNoKGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpXG4gICAgICAgIH07XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZyk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIE9iamVjdCAqL1xuICB2YXIgZG9udEVudW1zID0gWyd0b1N0cmluZycsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAndmFsdWVPZicsXG4gICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAnY29uc3RydWN0b3InXSxcbiAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID1cbnR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cbnR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID1cbnR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cyB8fCAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgaGFzRG9udEVudW1CdWcgPSAhKHsgdG9TdHJpbmc6IG51bGwgfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyksXG4gICAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICBdLFxuICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmICh0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nIHx8IG9iaiA9PT0gbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBwcm9wLCBpO1xuXG4gICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRvbnRFbnVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBkb250RW51bXNbaV0pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkb250RW51bXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9KCkpO1xuXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT09IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGgsIGtleTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNMb29zZSA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZhciBza2lwQ3RvciA9IGlzTG9vc2U7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV0sXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIDogcmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmICghc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKG9iakN0b3IgIT09IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiArb2JqZWN0ID09PSArb3RoZXI7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICByZXR1cm4gKG9iamVjdCAhPT0gK29iamVjdCkgP1xuICAgICAgICBvdGhlciAhPT0gK290aGVyIDpcbiAgICAgICAgb2JqZWN0ID09PSArb3RoZXI7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBvYmplY3QgPT09IChvdGhlciArICcnKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBpc09iamVjdCA9IFJ4LmludGVybmFscy5pc09iamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxudmFyIGlzSG9zdE9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QoeyAndG9TdHJpbmcnOiAwIH0gKyAnJyk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mICh2YWx1ZSArICcnKSA9PT0gJ3N0cmluZyc7XG4gIH07XG59KCkpO1xuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGFycmF5VGFnO1xufTtcblxuZnVuY3Rpb24gYXJyYXlTb21lIChhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9PSBvdGhMZW5ndGggJiYgIShpc0xvb3NlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF0sXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoaXNMb29zZSkge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgIGlmIChvYmpUYWcgPT09IGFyZ3NUYWcpIHtcbiAgICAgIG9ialRhZyA9IG9iamVjdFRhZztcbiAgICB9IGVsc2UgaWYgKG9ialRhZyAhPT0gb2JqZWN0VGFnKSB7XG4gICAgICBvYmpJc0FyciA9IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgIH1cbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvdGhlcik7XG4gICAgaWYgKG90aFRhZyA9PT0gYXJnc1RhZykge1xuICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgIH1cbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG9iamVjdCksXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiAhKG9iaklzQXJyIHx8IG9iaklzT2JqKSkge1xuICAgIHJldHVybiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZyk7XG4gIH1cbiAgaWYgKCFpc0xvb3NlKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGV0ZWN0aW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgc2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jSk8uXG4gIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09PSBvYmplY3QpIHtcbiAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PT0gb3RoZXI7XG4gICAgfVxuICB9XG4gIC8vIEFkZCBgb2JqZWN0YCBhbmQgYG90aGVyYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gIHN0YWNrQi5wdXNoKG90aGVyKTtcblxuICB2YXIgcmVzdWx0ID0gKG9iaklzQXJyID8gZXF1YWxBcnJheXMgOiBlcXVhbE9iamVjdHMpKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXG4gIHN0YWNrQS5wb3AoKTtcbiAgc3RhY2tCLnBvcCgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG59XG5cbnZhciBpc0VxdWFsID0gUnguaW50ZXJuYWxzLmlzRXF1YWwgPSBmdW5jdGlvbiAodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufTtcblxuICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgdmFyIGluaGVyaXRzID0gUnguaW50ZXJuYWxzLmluaGVyaXRzID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgX18ucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbiAgfTtcblxuICB2YXIgYWRkUHJvcGVydGllcyA9IFJ4LmludGVybmFscy5hZGRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvcih2YXIgc291cmNlcyA9IFtdLCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXMucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbG4gPSBzb3VyY2VzLmxlbmd0aDsgaWR4IDwgbG47IGlkeCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpZHhdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSeCBVdGlsc1xuICB2YXIgYWRkUmVmID0gUnguaW50ZXJuYWxzLmFkZFJlZiA9IGZ1bmN0aW9uICh4cywgcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShyLmdldERpc3Bvc2FibGUoKSwgeHMuc3Vic2NyaWJlKG9ic2VydmVyKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXJyYXlJbml0aWFsaXplKGNvdW50LCBmYWN0b3J5KSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYVtpXSA9IGZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBJbmRleGVkSXRlbShpZCwgdmFsdWUpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgSW5kZXhlZEl0ZW0ucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciBjID0gdGhpcy52YWx1ZS5jb21wYXJlVG8ob3RoZXIudmFsdWUpO1xuICAgIGMgPT09IDAgJiYgKGMgPSB0aGlzLmlkIC0gb3RoZXIuaWQpO1xuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIHZhciBQcmlvcml0eVF1ZXVlID0gUnguaW50ZXJuYWxzLlByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB0aGlzLml0ZW1zID0gbmV3IEFycmF5KGNhcGFjaXR5KTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgdmFyIHByaW9yaXR5UHJvdG8gPSBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZTtcbiAgcHJpb3JpdHlQcm90by5pc0hpZ2hlclByaW9yaXR5ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbbGVmdF0uY29tcGFyZVRvKHRoaXMuaXRlbXNbcmlnaHRdKSA8IDA7XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5wZXJjb2xhdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGggfHwgaW5kZXggPCAwKSB7IHJldHVybjsgfVxuICAgIHZhciBwYXJlbnQgPSBpbmRleCAtIDEgPj4gMTtcbiAgICBpZiAocGFyZW50IDwgMCB8fCBwYXJlbnQgPT09IGluZGV4KSB7IHJldHVybjsgfVxuICAgIGlmICh0aGlzLmlzSGlnaGVyUHJpb3JpdHkoaW5kZXgsIHBhcmVudCkpIHtcbiAgICAgIHZhciB0ZW1wID0gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHRoaXMuaXRlbXNbcGFyZW50XTtcbiAgICAgIHRoaXMuaXRlbXNbcGFyZW50XSA9IHRlbXA7XG4gICAgICB0aGlzLnBlcmNvbGF0ZShwYXJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBwcmlvcml0eVByb3RvLmhlYXBpZnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAraW5kZXggfHwgKGluZGV4ID0gMCk7XG4gICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoIHx8IGluZGV4IDwgMCkgeyByZXR1cm47IH1cbiAgICB2YXIgbGVmdCA9IDIgKiBpbmRleCArIDEsXG4gICAgICAgIHJpZ2h0ID0gMiAqIGluZGV4ICsgMixcbiAgICAgICAgZmlyc3QgPSBpbmRleDtcbiAgICBpZiAobGVmdCA8IHRoaXMubGVuZ3RoICYmIHRoaXMuaXNIaWdoZXJQcmlvcml0eShsZWZ0LCBmaXJzdCkpIHtcbiAgICAgIGZpcnN0ID0gbGVmdDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0IDwgdGhpcy5sZW5ndGggJiYgdGhpcy5pc0hpZ2hlclByaW9yaXR5KHJpZ2h0LCBmaXJzdCkpIHtcbiAgICAgIGZpcnN0ID0gcmlnaHQ7XG4gICAgfVxuICAgIGlmIChmaXJzdCAhPT0gaW5kZXgpIHtcbiAgICAgIHZhciB0ZW1wID0gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHRoaXMuaXRlbXNbZmlyc3RdO1xuICAgICAgdGhpcy5pdGVtc1tmaXJzdF0gPSB0ZW1wO1xuICAgICAgdGhpcy5oZWFwaWZ5KGZpcnN0KTtcbiAgICB9XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5wZWVrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVtc1swXS52YWx1ZTsgfTtcblxuICBwcmlvcml0eVByb3RvLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdGhpcy5pdGVtc1tpbmRleF0gPSB0aGlzLml0ZW1zWy0tdGhpcy5sZW5ndGhdO1xuICAgIHRoaXMuaXRlbXNbdGhpcy5sZW5ndGhdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVhcGlmeSgpO1xuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8uZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XG4gICAgdGhpcy5yZW1vdmVBdCgwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8uZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IG5ldyBJbmRleGVkSXRlbShQcmlvcml0eVF1ZXVlLmNvdW50KyssIGl0ZW0pO1xuICAgIHRoaXMucGVyY29sYXRlKGluZGV4KTtcbiAgfTtcblxuICBwcmlvcml0eVByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pdGVtc1tpXS52YWx1ZSA9PT0gaXRlbSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KGkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBQcmlvcml0eVF1ZXVlLmNvdW50ID0gMDtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIGdyb3VwIG9mIGRpc3Bvc2FibGUgcmVzb3VyY2VzIHRoYXQgYXJlIGRpc3Bvc2VkIHRvZ2V0aGVyLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBDb21wb3NpdGVEaXNwb3NhYmxlID0gUnguQ29tcG9zaXRlRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBpLCBsZW47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgdGhpcy5kaXNwb3NhYmxlcyA9IGFyZ3M7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5sZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgQ29tcG9zaXRlRGlzcG9zYWJsZVByb3RvdHlwZSA9IENvbXBvc2l0ZURpc3Bvc2FibGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgZGlzcG9zYWJsZSB0byB0aGUgQ29tcG9zaXRlRGlzcG9zYWJsZSBvciBkaXNwb3NlcyB0aGUgZGlzcG9zYWJsZSBpZiB0aGUgQ29tcG9zaXRlRGlzcG9zYWJsZSBpcyBkaXNwb3NlZC5cbiAgICogQHBhcmFtIHtNaXhlZH0gaXRlbSBEaXNwb3NhYmxlIHRvIGFkZC5cbiAgICovXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKGl0ZW0pO1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW5kIGRpc3Bvc2VzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgZGlzcG9zYWJsZSBmcm9tIHRoZSBDb21wb3NpdGVEaXNwb3NhYmxlLlxuICAgKiBAcGFyYW0ge01peGVkfSBpdGVtIERpc3Bvc2FibGUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBmb3VuZDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgQ29tcG9zaXRlRGlzcG9zYWJsZVByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBzaG91bGREaXNwb3NlID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmRpc3Bvc2FibGVzLmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBzaG91bGREaXNwb3NlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgaXRlbS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGREaXNwb3NlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgRGlzcG9zZXMgYWxsIGRpc3Bvc2FibGVzIGluIHRoZSBncm91cCBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIGdyb3VwLlxuICAgKi9cbiAgQ29tcG9zaXRlRGlzcG9zYWJsZVByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGlzcG9zYWJsZXMubGVuZ3RoLCBjdXJyZW50RGlzcG9zYWJsZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBjdXJyZW50RGlzcG9zYWJsZXNbaV0gPSB0aGlzLmRpc3Bvc2FibGVzW2ldOyB9XG4gICAgICB0aGlzLmRpc3Bvc2FibGVzID0gW107XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjdXJyZW50RGlzcG9zYWJsZXNbaV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBzZXQgb2Ygc3RhdGljIG1ldGhvZHMgZm9yIGNyZWF0aW5nIERpc3Bvc2FibGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwb3NlIEFjdGlvbiB0byBydW4gZHVyaW5nIHRoZSBmaXJzdCBjYWxsIHRvIGRpc3Bvc2UuIFRoZSBhY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBiZSBydW4gYXQgbW9zdCBvbmNlLlxuICAgKi9cbiAgdmFyIERpc3Bvc2FibGUgPSBSeC5EaXNwb3NhYmxlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uIHx8IG5vb3A7XG4gIH07XG5cbiAgLyoqIFBlcmZvcm1zIHRoZSB0YXNrIG9mIGNsZWFuaW5nIHVwIHJlc291cmNlcy4gKi9cbiAgRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5hY3Rpb24oKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGlzcG9zYWJsZSBvYmplY3QgdGhhdCBpbnZva2VzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIHdoZW4gZGlzcG9zZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3Bvc2UgQWN0aW9uIHRvIHJ1biBkdXJpbmcgdGhlIGZpcnN0IGNhbGwgdG8gZGlzcG9zZS4gVGhlIGFjdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIHJ1biBhdCBtb3N0IG9uY2UuXG4gICAqIEByZXR1cm4ge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB0aGF0IHJ1bnMgdGhlIGdpdmVuIGFjdGlvbiB1cG9uIGRpc3Bvc2FsLlxuICAgKi9cbiAgdmFyIGRpc3Bvc2FibGVDcmVhdGUgPSBEaXNwb3NhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIG5ldyBEaXNwb3NhYmxlKGFjdGlvbik7IH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRpc3Bvc2FibGUgdGhhdCBkb2VzIG5vdGhpbmcgd2hlbiBkaXNwb3NlZC5cbiAgICovXG4gIHZhciBkaXNwb3NhYmxlRW1wdHkgPSBEaXNwb3NhYmxlLmVtcHR5ID0geyBkaXNwb3NlOiBub29wIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBkaXNwb3NhYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gdGVzdCB3aGV0aGVyIGl0IGhhcyBhIGRpc3Bvc2UgbWV0aG9kXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGEgZGlzcG9zYWJsZSBvYmplY3QsIGVsc2UgZmFsc2UuXG4gICAqL1xuICB2YXIgaXNEaXNwb3NhYmxlID0gRGlzcG9zYWJsZS5pc0Rpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkICYmIGlzRnVuY3Rpb24oZC5kaXNwb3NlKTtcbiAgfTtcblxuICB2YXIgY2hlY2tEaXNwb3NlZCA9IERpc3Bvc2FibGUuY2hlY2tEaXNwb3NlZCA9IGZ1bmN0aW9uIChkaXNwb3NhYmxlKSB7XG4gICAgaWYgKGRpc3Bvc2FibGUuaXNEaXNwb3NlZCkgeyB0aHJvdyBuZXcgT2JqZWN0RGlzcG9zZWRFcnJvcigpOyB9XG4gIH07XG5cbiAgdmFyIGRpc3Bvc2FibGVGaXh1cCA9IERpc3Bvc2FibGUuX2ZpeHVwID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBpc0Rpc3Bvc2FibGUocmVzdWx0KSA/IHJlc3VsdCA6IGRpc3Bvc2FibGVFbXB0eTtcbiAgfTtcblxuICAvLyBTaW5nbGUgYXNzaWdubWVudFxuICB2YXIgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUgPSBSeC5TaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB9O1xuICBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZS5wcm90b3R5cGUuZ2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuICBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZS5wcm90b3R5cGUuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQpIHsgdGhyb3cgbmV3IEVycm9yKCdEaXNwb3NhYmxlIGhhcyBhbHJlYWR5IGJlZW4gYXNzaWduZWQnKTsgfVxuICAgIHZhciBzaG91bGREaXNwb3NlID0gdGhpcy5pc0Rpc3Bvc2VkO1xuICAgICFzaG91bGREaXNwb3NlICYmICh0aGlzLmN1cnJlbnQgPSB2YWx1ZSk7XG4gICAgc2hvdWxkRGlzcG9zZSAmJiB2YWx1ZSAmJiB2YWx1ZS5kaXNwb3NlKCk7XG4gIH07XG4gIFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgdmFyIG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICBvbGQgJiYgb2xkLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTXVsdGlwbGUgYXNzaWdubWVudCBkaXNwb3NhYmxlXG4gIHZhciBTZXJpYWxEaXNwb3NhYmxlID0gUnguU2VyaWFsRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB9O1xuICBTZXJpYWxEaXNwb3NhYmxlLnByb3RvdHlwZS5nZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gIH07XG4gIFNlcmlhbERpc3Bvc2FibGUucHJvdG90eXBlLnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgc2hvdWxkRGlzcG9zZSA9IHRoaXMuaXNEaXNwb3NlZDtcbiAgICBpZiAoIXNob3VsZERpc3Bvc2UpIHtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgb2xkICYmIG9sZC5kaXNwb3NlKCk7XG4gICAgc2hvdWxkRGlzcG9zZSAmJiB2YWx1ZSAmJiB2YWx1ZS5kaXNwb3NlKCk7XG4gIH07XG4gIFNlcmlhbERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB2YXIgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgb2xkICYmIG9sZC5kaXNwb3NlKCk7XG4gIH07XG5cbiAgdmFyIEJpbmFyeURpc3Bvc2FibGUgPSBSeC5CaW5hcnlEaXNwb3NhYmxlID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICB0aGlzLl9maXJzdCA9IGZpcnN0O1xuICAgIHRoaXMuX3NlY29uZCA9IHNlY29uZDtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgfTtcblxuICBCaW5hcnlEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgdmFyIG9sZDEgPSB0aGlzLl9maXJzdDtcbiAgICAgIHRoaXMuX2ZpcnN0ID0gbnVsbDtcbiAgICAgIG9sZDEgJiYgb2xkMS5kaXNwb3NlKCk7XG4gICAgICB2YXIgb2xkMiA9IHRoaXMuX3NlY29uZDtcbiAgICAgIHRoaXMuX3NlY29uZCA9IG51bGw7XG4gICAgICBvbGQyICYmIG9sZDIuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgTkFyeURpc3Bvc2FibGUgPSBSeC5OQXJ5RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkaXNwb3NhYmxlcykge1xuICAgIHRoaXMuX2Rpc3Bvc2FibGVzID0gZGlzcG9zYWJsZXM7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH07XG5cbiAgTkFyeURpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fZGlzcG9zYWJsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXNbaV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzcG9zYWJsZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlIHRoYXQgb25seSBkaXNwb3NlcyBpdHMgdW5kZXJseWluZyBkaXNwb3NhYmxlIHJlc291cmNlIHdoZW4gYWxsIGRlcGVuZGVudCBkaXNwb3NhYmxlIG9iamVjdHMgaGF2ZSBiZWVuIGRpc3Bvc2VkLlxuICAgKi9cbiAgdmFyIFJlZkNvdW50RGlzcG9zYWJsZSA9IFJ4LlJlZkNvdW50RGlzcG9zYWJsZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBJbm5lckRpc3Bvc2FibGUoZGlzcG9zYWJsZSkge1xuICAgICAgdGhpcy5kaXNwb3NhYmxlID0gZGlzcG9zYWJsZTtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZS5jb3VudCsrO1xuICAgICAgdGhpcy5pc0lubmVyRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBJbm5lckRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkICYmICF0aGlzLmlzSW5uZXJEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzSW5uZXJEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZS5jb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NhYmxlLmNvdW50ID09PSAwICYmIHRoaXMuZGlzcG9zYWJsZS5pc1ByaW1hcnlEaXNwb3NlZCkge1xuICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGUudW5kZXJseWluZ0Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSZWZDb3VudERpc3Bvc2FibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGRpc3Bvc2FibGUuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtEaXNwb3NhYmxlfSBkaXNwb3NhYmxlIFVuZGVybHlpbmcgZGlzcG9zYWJsZS5cbiAgICAgICovXG4gICAgZnVuY3Rpb24gUmVmQ291bnREaXNwb3NhYmxlKGRpc3Bvc2FibGUpIHtcbiAgICAgIHRoaXMudW5kZXJseWluZ0Rpc3Bvc2FibGUgPSBkaXNwb3NhYmxlO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzUHJpbWFyeURpc3Bvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlIG9ubHkgd2hlbiBhbGwgZGVwZW5kZW50IGRpc3Bvc2FibGVzIGhhdmUgYmVlbiBkaXNwb3NlZFxuICAgICAqL1xuICAgIFJlZkNvdW50RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkICYmICF0aGlzLmlzUHJpbWFyeURpc3Bvc2VkKSB7XG4gICAgICAgIHRoaXMuaXNQcmltYXJ5RGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy51bmRlcmx5aW5nRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlcGVuZGVudCBkaXNwb3NhYmxlIHRoYXQgd2hlbiBkaXNwb3NlZCBkZWNyZWFzZXMgdGhlIHJlZmNvdW50IG9uIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IEEgZGVwZW5kZW50IGRpc3Bvc2FibGUgY29udHJpYnV0aW5nIHRvIHRoZSByZWZlcmVuY2UgY291bnQgdGhhdCBtYW5hZ2VzIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUncyBsaWZldGltZS5cbiAgICAgKi9cbiAgICBSZWZDb3VudERpc3Bvc2FibGUucHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Rpc3Bvc2VkID8gZGlzcG9zYWJsZUVtcHR5IDogbmV3IElubmVyRGlzcG9zYWJsZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlZkNvdW50RGlzcG9zYWJsZTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBTY2hlZHVsZWREaXNwb3NhYmxlKHNjaGVkdWxlciwgZGlzcG9zYWJsZSkge1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGU7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUl0ZW0ocywgc2VsZikge1xuICAgIGlmICghc2VsZi5pc0Rpc3Bvc2VkKSB7XG4gICAgICBzZWxmLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgc2VsZi5kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBTY2hlZHVsZWREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIHNjaGVkdWxlSXRlbSk7XG4gIH07XG5cbiAgdmFyIFNjaGVkdWxlZEl0ZW0gPSBSeC5pbnRlcm5hbHMuU2NoZWR1bGVkSXRlbSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIHN0YXRlLCBhY3Rpb24sIGR1ZVRpbWUsIGNvbXBhcmVyKSB7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyIHx8IGRlZmF1bHRTdWJDb21wYXJlcjtcbiAgICB0aGlzLmRpc3Bvc2FibGUgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNwb3NhYmxlLnNldERpc3Bvc2FibGUodGhpcy5pbnZva2VDb3JlKCkpO1xuICB9O1xuXG4gIFNjaGVkdWxlZEl0ZW0ucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVyKHRoaXMuZHVlVGltZSwgb3RoZXIuZHVlVGltZSk7XG4gIH07XG5cbiAgU2NoZWR1bGVkSXRlbS5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkO1xuICB9O1xuXG4gIFNjaGVkdWxlZEl0ZW0ucHJvdG90eXBlLmludm9rZUNvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3Bvc2FibGVGaXh1cCh0aGlzLmFjdGlvbih0aGlzLnNjaGVkdWxlciwgdGhpcy5zdGF0ZSkpO1xuICB9O1xuXG4gIC8qKiBQcm92aWRlcyBhIHNldCBvZiBzdGF0aWMgcHJvcGVydGllcyB0byBhY2Nlc3MgY29tbW9ubHkgdXNlZCBzY2hlZHVsZXJzLiAqL1xuICB2YXIgU2NoZWR1bGVyID0gUnguU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIFNjaGVkdWxlcigpIHsgfVxuXG4gICAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgc2NoZWR1bGVyICovXG4gICAgU2NoZWR1bGVyLmlzU2NoZWR1bGVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzIGluc3RhbmNlb2YgU2NoZWR1bGVyO1xuICAgIH07XG5cbiAgICB2YXIgc2NoZWR1bGVyUHJvdG8gPSBTY2hlZHVsZXIucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZHVlVGltZS5cbiAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBSZWxhdGl2ZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cbiAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgZHQgPSBkdWVUaW1lO1xuICAgICAgZHQgaW5zdGFuY2VvZiBEYXRlICYmIChkdCA9IGR0IC0gdGhpcy5ub3coKSk7XG4gICAgICBkdCA9IFNjaGVkdWxlci5ub3JtYWxpemUoZHQpO1xuXG4gICAgICBpZiAoZHQgPT09IDApIHsgcmV0dXJuIHRoaXMuc2NoZWR1bGUoc3RhdGUsIGFjdGlvbik7IH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlRnV0dXJlKHN0YXRlLCBkdCwgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgc2NoZWR1bGVyUHJvdG8uX3NjaGVkdWxlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcblxuICAgIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbCBtYWNoaW5lJ3Mgc3lzdGVtIGNsb2NrLiAqL1xuICAgIFNjaGVkdWxlci5ub3cgPSBkZWZhdWx0Tm93O1xuXG4gICAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdGltZSBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsIG1hY2hpbmUncyBzeXN0ZW0gY2xvY2suICovXG4gICAgU2NoZWR1bGVyLnByb3RvdHlwZS5ub3cgPSBkZWZhdWx0Tm93O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgc3BlY2lmaWVkIFRpbWVTcGFuIHZhbHVlIHRvIGEgcG9zaXRpdmUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRoZSB0aW1lIHNwYW4gdmFsdWUgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBzcGVjaWZpZWQgVGltZVNwYW4gdmFsdWUgaWYgaXQgaXMgemVybyBvciBwb3NpdGl2ZTsgb3RoZXJ3aXNlLCAwXG4gICAgICovXG4gICAgU2NoZWR1bGVyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xuICAgICAgdGltZVNwYW4gPCAwICYmICh0aW1lU3BhbiA9IDApO1xuICAgICAgcmV0dXJuIHRpbWVTcGFuO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZWR1bGVyO1xuICB9KCkpO1xuXG4gIHZhciBub3JtYWxpemVUaW1lID0gU2NoZWR1bGVyLm5vcm1hbGl6ZSwgaXNTY2hlZHVsZXIgPSBTY2hlZHVsZXIuaXNTY2hlZHVsZXI7XG5cbiAgKGZ1bmN0aW9uIChzY2hlZHVsZXJQcm90bykge1xuXG4gICAgZnVuY3Rpb24gaW52b2tlUmVjSW1tZWRpYXRlKHNjaGVkdWxlciwgcGFpcikge1xuICAgICAgdmFyIHN0YXRlID0gcGFpclswXSwgYWN0aW9uID0gcGFpclsxXSwgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgYWN0aW9uKHN0YXRlLCBpbm5lckFjdGlvbik7XG4gICAgICByZXR1cm4gZ3JvdXA7XG5cbiAgICAgIGZ1bmN0aW9uIGlubmVyQWN0aW9uKHN0YXRlMikge1xuICAgICAgICB2YXIgaXNBZGRlZCA9IGZhbHNlLCBpc0RvbmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZCA9IHNjaGVkdWxlci5zY2hlZHVsZShzdGF0ZTIsIHNjaGVkdWxlV29yayk7XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgZ3JvdXAuYWRkKGQpO1xuICAgICAgICAgIGlzQWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrKF8sIHN0YXRlMykge1xuICAgICAgICAgIGlmIChpc0FkZGVkKSB7XG4gICAgICAgICAgICBncm91cC5yZW1vdmUoZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGlvbihzdGF0ZTMsIGlubmVyQWN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlUmVjRGF0ZShzY2hlZHVsZXIsIHBhaXIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHBhaXJbMF0sIGFjdGlvbiA9IHBhaXJbMV0sIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGFjdGlvbihzdGF0ZSwgaW5uZXJBY3Rpb24pO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuXG4gICAgICBmdW5jdGlvbiBpbm5lckFjdGlvbihzdGF0ZTIsIGR1ZVRpbWUxKSB7XG4gICAgICAgIHZhciBpc0FkZGVkID0gZmFsc2UsIGlzRG9uZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBkID0gc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKHN0YXRlMiwgZHVlVGltZTEsIHNjaGVkdWxlV29yayk7XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgZ3JvdXAuYWRkKGQpO1xuICAgICAgICAgIGlzQWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrKF8sIHN0YXRlMykge1xuICAgICAgICAgIGlmIChpc0FkZGVkKSB7XG4gICAgICAgICAgICBncm91cC5yZW1vdmUoZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGlvbihzdGF0ZTMsIGlubmVyQWN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCByZWN1cnNpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGV4ZWN1dGUgcmVjdXJzaXZlbHkuIFRoZSBsYXN0IHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGFjdGlvbiBpcyB1c2VkIHRvIHRyaWdnZXIgcmVjdXJzaXZlIHNjaGVkdWxpbmcgb2YgdGhlIGFjdGlvbiwgcGFzc2luZyBpbiByZWN1cnNpdmUgaW52b2NhdGlvbiBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVSZWN1cnNpdmUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUoW3N0YXRlLCBhY3Rpb25dLCBpbnZva2VSZWNJbW1lZGlhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIHJlY3Vyc2l2ZWx5IGFmdGVyIGEgc3BlY2lmaWVkIHJlbGF0aXZlIG9yIGFic29sdXRlIGR1ZSB0aW1lLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gZXhlY3V0ZSByZWN1cnNpdmVseS4gVGhlIGxhc3QgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgYWN0aW9uIGlzIHVzZWQgdG8gdHJpZ2dlciByZWN1cnNpdmUgc2NoZWR1bGluZyBvZiB0aGUgYWN0aW9uLCBwYXNzaW5nIGluIHRoZSByZWN1cnNpdmUgZHVlIHRpbWUgYW5kIGludm9jYXRpb24gc3RhdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXIgfCBEYXRlfSBkdWVUaW1lIFJlbGF0aXZlIG9yIGFic29sdXRlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVGdXR1cmUoW3N0YXRlLCBhY3Rpb25dLCBkdWVUaW1lLCBpbnZva2VSZWNEYXRlKTtcbiAgICB9O1xuXG4gIH0oU2NoZWR1bGVyLnByb3RvdHlwZSkpO1xuXG4gIChmdW5jdGlvbiAoc2NoZWR1bGVyUHJvdG8pIHtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHBlcmlvZGljIHBpZWNlIG9mIHdvcmsgYnkgZHluYW1pY2FsbHkgZGlzY292ZXJpbmcgdGhlIHNjaGVkdWxlcidzIGNhcGFiaWxpdGllcy4gVGhlIHBlcmlvZGljIHRhc2sgd2lsbCBiZSBzY2hlZHVsZWQgdXNpbmcgd2luZG93LnNldEludGVydmFsIGZvciB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBJbml0aWFsIHN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHVwb24gdGhlIGZpcnN0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kIFBlcmlvZCBmb3IgcnVubmluZyB0aGUgd29yayBwZXJpb2RpY2FsbHkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZCwgcG90ZW50aWFsbHkgdXBkYXRpbmcgdGhlIHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCByZWN1cnJpbmcgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVQZXJpb2RpYyA9IGZ1bmN0aW9uKHN0YXRlLCBwZXJpb2QsIGFjdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiByb290LnNldEludGVydmFsID09PSAndW5kZWZpbmVkJykgeyB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKTsgfVxuICAgICAgcGVyaW9kID0gbm9ybWFsaXplVGltZShwZXJpb2QpO1xuICAgICAgdmFyIHMgPSBzdGF0ZSwgaWQgPSByb290LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgcyA9IGFjdGlvbihzKTsgfSwgcGVyaW9kKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHsgcm9vdC5jbGVhckludGVydmFsKGlkKTsgfSk7XG4gICAgfTtcblxuICB9KFNjaGVkdWxlci5wcm90b3R5cGUpKTtcblxuICAoZnVuY3Rpb24gKHNjaGVkdWxlclByb3RvKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNjaGVkdWxlciB0aGF0IHdyYXBzIHRoZSBvcmlnaW5hbCBzY2hlZHVsZXIsIGFkZGluZyBleGNlcHRpb24gaGFuZGxpbmcgZm9yIHNjaGVkdWxlZCBhY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgSGFuZGxlciB0aGF0J3MgcnVuIGlmIGFuIGV4Y2VwdGlvbiBpcyBjYXVnaHQuIFRoZSBleGNlcHRpb24gd2lsbCBiZSByZXRocm93biBpZiB0aGUgaGFuZGxlciByZXR1cm5zIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIHtTY2hlZHVsZXJ9IFdyYXBwZXIgYXJvdW5kIHRoZSBvcmlnaW5hbCBzY2hlZHVsZXIsIGVuZm9yY2luZyBleGNlcHRpb24gaGFuZGxpbmcuXG4gICAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uY2F0Y2hFcnJvciA9IHNjaGVkdWxlclByb3RvWydjYXRjaCddID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ2F0Y2hTY2hlZHVsZXIodGhpcywgaGFuZGxlcik7XG4gICAgfTtcbiAgfShTY2hlZHVsZXIucHJvdG90eXBlKSk7XG5cbiAgdmFyIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUgPSBSeC5pbnRlcm5hbHMuU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlVGljayhzZWxmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdGljayhjb21tYW5kLCByZWN1cnNlKSB7XG4gICAgICAgIHJlY3Vyc2UoMCwgc2VsZi5fcGVyaW9kKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdHJ5Q2F0Y2goc2VsZi5fYWN0aW9uKShzZWxmLl9zdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICBzZWxmLl9jYW5jZWwuZGlzcG9zZSgpO1xuICAgICAgICAgIHRocm93ZXIoc3RhdGUuZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZShzY2hlZHVsZXIsIHN0YXRlLCBwZXJpb2QsIGFjdGlvbikge1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX3BlcmlvZCA9IHBlcmlvZDtcbiAgICAgIHRoaXMuX2FjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG5cbiAgICBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9jYW5jZWwgPSBkO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZSgwLCB0aGlzLl9wZXJpb2QsIGNyZWF0ZVRpY2sodGhpcykpKTtcblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlO1xuICB9KCkpO1xuXG4gIC8qKiBHZXRzIGEgc2NoZWR1bGVyIHRoYXQgc2NoZWR1bGVzIHdvcmsgaW1tZWRpYXRlbHkgb24gdGhlIGN1cnJlbnQgdGhyZWFkLiAqL1xuICAgdmFyIEltbWVkaWF0ZVNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW1tZWRpYXRlU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEltbWVkaWF0ZVNjaGVkdWxlcigpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEltbWVkaWF0ZVNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVGaXh1cChhY3Rpb24odGhpcywgc3RhdGUpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEltbWVkaWF0ZVNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICB2YXIgaW1tZWRpYXRlU2NoZWR1bGVyID0gU2NoZWR1bGVyLmltbWVkaWF0ZSA9IG5ldyBJbW1lZGlhdGVTY2hlZHVsZXIoKTtcblxuICAvKipcbiAgICogR2V0cyBhIHNjaGVkdWxlciB0aGF0IHNjaGVkdWxlcyB3b3JrIGFzIHNvb24gYXMgcG9zc2libGUgb24gdGhlIGN1cnJlbnQgdGhyZWFkLlxuICAgKi9cbiAgdmFyIEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIHZhciBxdWV1ZTtcblxuICAgIGZ1bmN0aW9uIHJ1blRyYW1wb2xpbmUgKCkge1xuICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICFpdGVtLmlzQ2FuY2VsbGVkKCkgJiYgaXRlbS5pbnZva2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmhlcml0cyhDdXJyZW50VGhyZWFkU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDdXJyZW50VGhyZWFkU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgc2kgPSBuZXcgU2NoZWR1bGVkSXRlbSh0aGlzLCBzdGF0ZSwgYWN0aW9uLCB0aGlzLm5vdygpKTtcblxuICAgICAgaWYgKCFxdWV1ZSkge1xuICAgICAgICBxdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKDQpO1xuICAgICAgICBxdWV1ZS5lbnF1ZXVlKHNpKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2gocnVuVHJhbXBvbGluZSkoKTtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyB0aHJvd2VyKHJlc3VsdC5lKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUuZW5xdWV1ZShzaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2kuZGlzcG9zYWJsZTtcbiAgICB9O1xuXG4gICAgQ3VycmVudFRocmVhZFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVSZXF1aXJlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICFxdWV1ZTsgfTtcblxuICAgIHJldHVybiBDdXJyZW50VGhyZWFkU2NoZWR1bGVyO1xuICB9KFNjaGVkdWxlcikpO1xuXG4gIHZhciBjdXJyZW50VGhyZWFkU2NoZWR1bGVyID0gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQgPSBuZXcgQ3VycmVudFRocmVhZFNjaGVkdWxlcigpO1xuXG4gIHZhciBzY2hlZHVsZU1ldGhvZCwgY2xlYXJNZXRob2Q7XG5cbiAgdmFyIGxvY2FsVGltZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsb2NhbFNldFRpbWVvdXQsIGxvY2FsQ2xlYXJUaW1lb3V0ID0gbm9vcDtcbiAgICBpZiAoISFyb290LnNldFRpbWVvdXQpIHtcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IHJvb3Quc2V0VGltZW91dDtcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID0gcm9vdC5jbGVhclRpbWVvdXQ7XG4gICAgfSBlbHNlIGlmICghIXJvb3QuV1NjcmlwdCkge1xuICAgICAgbG9jYWxTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGZuLCB0aW1lKSB7XG4gICAgICAgIHJvb3QuV1NjcmlwdC5TbGVlcCh0aW1lKTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZXRUaW1lb3V0OiBsb2NhbFNldFRpbWVvdXQsXG4gICAgICBjbGVhclRpbWVvdXQ6IGxvY2FsQ2xlYXJUaW1lb3V0XG4gICAgfTtcbiAgfSgpKTtcbiAgdmFyIGxvY2FsU2V0VGltZW91dCA9IGxvY2FsVGltZXIuc2V0VGltZW91dCxcbiAgICBsb2NhbENsZWFyVGltZW91dCA9IGxvY2FsVGltZXIuY2xlYXJUaW1lb3V0O1xuXG4gIChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDEsIHRhc2tzQnlIYW5kbGUgPSB7fSwgY3VycmVudGx5UnVubmluZyA9IGZhbHNlO1xuXG4gICAgY2xlYXJNZXRob2QgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5UYXNrKGhhbmRsZSkge1xuICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmcpIHtcbiAgICAgICAgbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcnVuVGFzayhoYW5kbGUpOyB9LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0YXNrKSgpO1xuICAgICAgICAgIGNsZWFyTWV0aG9kKGhhbmRsZSk7XG4gICAgICAgICAgY3VycmVudGx5UnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHRocm93ZXIocmVzdWx0LmUpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVOYXRpdmUgPSBuZXcgUmVnRXhwKCdeJyArXG4gICAgICBTdHJpbmcodG9TdHJpbmcpXG4gICAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3wgZm9yIFteXFxdXSsvZywgJy4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIHZhciBzZXRJbW1lZGlhdGUgPSB0eXBlb2YgKHNldEltbWVkaWF0ZSA9IGZyZWVHbG9iYWwgJiYgbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnNldEltbWVkaWF0ZSkgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgIXJlTmF0aXZlLnRlc3Qoc2V0SW1tZWRpYXRlKSAmJiBzZXRJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBwb3N0TWVzc2FnZVN1cHBvcnRlZCAoKSB7XG4gICAgICAvLyBFbnN1cmUgbm90IGluIGEgd29ya2VyXG4gICAgICBpZiAoIXJvb3QucG9zdE1lc3NhZ2UgfHwgcm9vdC5pbXBvcnRTY3JpcHRzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZSwgb2xkSGFuZGxlciA9IHJvb3Qub25tZXNzYWdlO1xuICAgICAgLy8gVGVzdCBmb3IgYXN5bmNcbiAgICAgIHJvb3Qub25tZXNzYWdlID0gZnVuY3Rpb24gKCkgeyBpc0FzeW5jID0gdHJ1ZTsgfTtcbiAgICAgIHJvb3QucG9zdE1lc3NhZ2UoJycsICcqJyk7XG4gICAgICByb290Lm9ubWVzc2FnZSA9IG9sZEhhbmRsZXI7XG5cbiAgICAgIHJldHVybiBpc0FzeW5jO1xuICAgIH1cblxuICAgIC8vIFVzZSBpbiBvcmRlciwgc2V0SW1tZWRpYXRlLCBuZXh0VGljaywgcG9zdE1lc3NhZ2UsIE1lc3NhZ2VDaGFubmVsLCBzY3JpcHQgcmVhZHlzdGF0ZWNoYW5nZWQsIHNldFRpbWVvdXRcbiAgICBpZiAoaXNGdW5jdGlvbihzZXRJbW1lZGlhdGUpKSB7XG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHsgcnVuVGFzayhpZCk7IH0pO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1blRhc2soaWQpOyB9KTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zdE1lc3NhZ2VTdXBwb3J0ZWQoKSkge1xuICAgICAgdmFyIE1TR19QUkVGSVggPSAnbXMucnguc2NoZWR1bGUnICsgTWF0aC5yYW5kb20oKTtcblxuICAgICAgdmFyIG9uR2xvYmFsUG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gT25seSBpZiB3ZSdyZSBhIG1hdGNoIHRvIGF2b2lkIGFueSBvdGhlciBnbG9iYWwgZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycgJiYgZXZlbnQuZGF0YS5zdWJzdHJpbmcoMCwgTVNHX1BSRUZJWC5sZW5ndGgpID09PSBNU0dfUFJFRklYKSB7XG4gICAgICAgICAgcnVuVGFzayhldmVudC5kYXRhLnN1YnN0cmluZyhNU0dfUFJFRklYLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbkdsb2JhbFBvc3RNZXNzYWdlLCBmYWxzZSk7XG5cbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuICAgICAgICByb290LnBvc3RNZXNzYWdlKE1TR19QUkVGSVggKyBpZCwgJyonKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhcm9vdC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgcm9vdC5NZXNzYWdlQ2hhbm5lbCgpO1xuXG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7IHJ1blRhc2soZS5kYXRhKTsgfTtcblxuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaWQpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiByb290ICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIHJvb3QuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblxuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBzY3JpcHRFbGVtZW50ID0gcm9vdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcblxuICAgICAgICBzY3JpcHRFbGVtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBydW5UYXNrKGlkKTtcbiAgICAgICAgICBzY3JpcHRFbGVtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgc2NyaXB0RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsZW1lbnQpO1xuICAgICAgICAgIHNjcmlwdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcbiAgICAgICAgbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBydW5UYXNrKGlkKTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzY2hlZHVsZXIgdGhhdCBzY2hlZHVsZXMgd29yayB2aWEgYSB0aW1lZCBjYWxsYmFjayBiYXNlZCB1cG9uIHBsYXRmb3JtLlxuICAgKi9cbiAgIHZhciBEZWZhdWx0U2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICAgaW5oZXJpdHMoRGVmYXVsdFNjaGVkdWxlciwgX19zdXBlcl9fKTtcbiAgICAgZnVuY3Rpb24gRGVmYXVsdFNjaGVkdWxlcigpIHtcbiAgICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgfVxuXG4gICAgIGZ1bmN0aW9uIHNjaGVkdWxlQWN0aW9uKGRpc3Bvc2FibGUsIGFjdGlvbiwgc2NoZWR1bGVyLCBzdGF0ZSkge1xuICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgICAgICAgIGRpc3Bvc2FibGUuc2V0RGlzcG9zYWJsZShEaXNwb3NhYmxlLl9maXh1cChhY3Rpb24oc2NoZWR1bGVyLCBzdGF0ZSkpKTtcbiAgICAgICB9O1xuICAgICB9XG5cbiAgICAgZnVuY3Rpb24gQ2xlYXJEaXNwb3NhYmxlKGlkKSB7XG4gICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgfVxuXG4gICAgIENsZWFyRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgIGNsZWFyTWV0aG9kKHRoaXMuX2lkKTtcbiAgICAgICB9XG4gICAgIH07XG5cbiAgICAgZnVuY3Rpb24gTG9jYWxDbGVhckRpc3Bvc2FibGUoaWQpIHtcbiAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICB9XG5cbiAgICAgTG9jYWxDbGVhckRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICBsb2NhbENsZWFyVGltZW91dCh0aGlzLl9pZCk7XG4gICAgICAgfVxuICAgICB9O1xuXG4gICAgRGVmYXVsdFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgdmFyIGRpc3Bvc2FibGUgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgICBpZCA9IHNjaGVkdWxlTWV0aG9kKHNjaGVkdWxlQWN0aW9uKGRpc3Bvc2FibGUsIGFjdGlvbiwgdGhpcywgc3RhdGUpKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShkaXNwb3NhYmxlLCBuZXcgQ2xlYXJEaXNwb3NhYmxlKGlkKSk7XG4gICAgfTtcblxuICAgIERlZmF1bHRTY2hlZHVsZXIucHJvdG90eXBlLl9zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoZHVlVGltZSA9PT0gMCkgeyByZXR1cm4gdGhpcy5zY2hlZHVsZShzdGF0ZSwgYWN0aW9uKTsgfVxuICAgICAgdmFyIGRpc3Bvc2FibGUgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgICBpZCA9IGxvY2FsU2V0VGltZW91dChzY2hlZHVsZUFjdGlvbihkaXNwb3NhYmxlLCBhY3Rpb24sIHRoaXMsIHN0YXRlKSwgZHVlVGltZSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoZGlzcG9zYWJsZSwgbmV3IExvY2FsQ2xlYXJEaXNwb3NhYmxlKGlkKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTG9uZ1J1bm5pbmcoc3RhdGUsIGFjdGlvbiwgZGlzcG9zYWJsZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgYWN0aW9uKHN0YXRlLCBkaXNwb3NhYmxlKTsgfTtcbiAgICB9XG5cbiAgICBEZWZhdWx0U2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZUxvbmdSdW5uaW5nID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gZGlzcG9zYWJsZUNyZWF0ZShub29wKTtcbiAgICAgIHNjaGVkdWxlTWV0aG9kKHNjaGVkdWxlTG9uZ1J1bm5pbmcoc3RhdGUsIGFjdGlvbiwgZGlzcG9zYWJsZSkpO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGU7XG4gICAgfTtcblxuICAgIHJldHVybiBEZWZhdWx0U2NoZWR1bGVyO1xuICB9KFNjaGVkdWxlcikpO1xuXG4gIHZhciBkZWZhdWx0U2NoZWR1bGVyID0gU2NoZWR1bGVyWydkZWZhdWx0J10gPSBTY2hlZHVsZXIuYXN5bmMgPSBuZXcgRGVmYXVsdFNjaGVkdWxlcigpO1xuXG4gIHZhciBDYXRjaFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ2F0Y2hTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBDYXRjaFNjaGVkdWxlcihzY2hlZHVsZXIsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgdGhpcy5fcmVjdXJzaXZlT3JpZ2luYWwgPSBudWxsO1xuICAgICAgdGhpcy5fcmVjdXJzaXZlV3JhcHBlciA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgdGhpcy5fd3JhcChhY3Rpb24pKTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl9zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBkdWVUaW1lLCB0aGlzLl93cmFwKGFjdGlvbikpO1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2NoZWR1bGVyLm5vdygpOyB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXRjaFNjaGVkdWxlcihzY2hlZHVsZXIsIHRoaXMuX2hhbmRsZXIpO1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuX3dyYXAgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZiwgc3RhdGUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKGFjdGlvbikocGFyZW50Ll9nZXRSZWN1cnNpdmVXcmFwcGVyKHNlbGYpLCBzdGF0ZSk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgaWYgKCFwYXJlbnQuX2hhbmRsZXIocmVzLmUpKSB7IHRocm93ZXIocmVzLmUpOyB9XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUZpeHVwKHJlcyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuX2dldFJlY3Vyc2l2ZVdyYXBwZXIgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICBpZiAodGhpcy5fcmVjdXJzaXZlT3JpZ2luYWwgIT09IHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVPcmlnaW5hbCA9IHNjaGVkdWxlcjtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLl9jbG9uZShzY2hlZHVsZXIpO1xuICAgICAgICB3cmFwcGVyLl9yZWN1cnNpdmVPcmlnaW5hbCA9IHNjaGVkdWxlcjtcbiAgICAgICAgd3JhcHBlci5fcmVjdXJzaXZlV3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVdyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vyc2l2ZVdyYXBwZXI7XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZVBlcmlvZGljID0gZnVuY3Rpb24gKHN0YXRlLCBwZXJpb2QsIGFjdGlvbikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLCBmYWlsZWQgPSBmYWxzZSwgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuXG4gICAgICBkLnNldERpc3Bvc2FibGUodGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlUGVyaW9kaWMoc3RhdGUsIHBlcmlvZCwgZnVuY3Rpb24gKHN0YXRlMSkge1xuICAgICAgICBpZiAoZmFpbGVkKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaChhY3Rpb24pKHN0YXRlMSk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZXIocmVzLmUpKSB7IHRocm93ZXIocmVzLmUpOyB9XG4gICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaFNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICAvKipcbiAgICogIFJlcHJlc2VudHMgYSBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXG4gICAqL1xuICB2YXIgTm90aWZpY2F0aW9uID0gUnguTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb24oKSB7XG5cbiAgICB9XG5cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHQgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0T2JzZXJ2ZXIgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgZGVsZWdhdGUgY29ycmVzcG9uZGluZyB0byB0aGUgbm90aWZpY2F0aW9uIG9yIHRoZSBvYnNlcnZlcidzIG1ldGhvZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBub3RpZmljYXRpb24gYW5kIHJldHVybnMgdGhlIHByb2R1Y2VkIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JzZXJ2ZXJ9IG9ic2VydmVyT3JPbk5leHQgRnVuY3Rpb24gdG8gaW52b2tlIGZvciBhbiBPbk5leHQgbm90aWZpY2F0aW9uIG9yIE9ic2VydmVyIHRvIGludm9rZSB0aGUgbm90aWZpY2F0aW9uIG9uLi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgYW4gT25FcnJvciBub3RpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgRnVuY3Rpb24gdG8gaW52b2tlIGZvciBhbiBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybnMge0FueX0gUmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBvYnNlcnZhdGlvbi5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuIG9ic2VydmVyT3JPbk5leHQgJiYgdHlwZW9mIG9ic2VydmVyT3JPbk5leHQgPT09ICdvYmplY3QnID9cbiAgICAgICAgdGhpcy5fYWNjZXB0T2JzZXJ2ZXIob2JzZXJ2ZXJPck9uTmV4dCkgOlxuICAgICAgICB0aGlzLl9hY2NlcHQob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgTm90aWZpY2F0aW9uc1xuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIG5vdGlmaWNhdGlvbiBjYWxscyBvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzdXJmYWNlcyB0aGUgYmVoYXZpb3Igb2YgdGhlIG5vdGlmaWNhdGlvbiB1cG9uIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcik7XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShzZWxmLCBmdW5jdGlvbiAoXywgbm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLl9hY2NlcHRPYnNlcnZlcihvKTtcbiAgICAgICAgICBub3RpZmljYXRpb24ua2luZCA9PT0gJ04nICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbiAgfSkoKTtcblxuICB2YXIgT25OZXh0Tm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPbk5leHROb3RpZmljYXRpb24sIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gT25OZXh0Tm90aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLmtpbmQgPSAnTic7XG4gICAgfVxuXG4gICAgT25OZXh0Tm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9uTmV4dCkge1xuICAgICAgcmV0dXJuIG9uTmV4dCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgT25OZXh0Tm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0T2JzZXJ2ZXIgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBPbk5leHROb3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdPbk5leHQoJyArIHRoaXMudmFsdWUgKyAnKSc7XG4gICAgfTtcblxuICAgIHJldHVybiBPbk5leHROb3RpZmljYXRpb247XG4gIH0oTm90aWZpY2F0aW9uKSk7XG5cbiAgdmFyIE9uRXJyb3JOb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9uRXJyb3JOb3RpZmljYXRpb24sIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gT25FcnJvck5vdGlmaWNhdGlvbihlcnJvcikge1xuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5raW5kID0gJ0UnO1xuICAgIH1cblxuICAgIE9uRXJyb3JOb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHQgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yKSB7XG4gICAgICByZXR1cm4gb25FcnJvcih0aGlzLmVycm9yKTtcbiAgICB9O1xuXG4gICAgT25FcnJvck5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdE9ic2VydmVyID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgfTtcblxuICAgIE9uRXJyb3JOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdPbkVycm9yKCcgKyB0aGlzLmVycm9yICsgJyknO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25FcnJvck5vdGlmaWNhdGlvbjtcbiAgfShOb3RpZmljYXRpb24pKTtcblxuICB2YXIgT25Db21wbGV0ZWROb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9uQ29tcGxldGVkTm90aWZpY2F0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uKCkge1xuICAgICAgdGhpcy5raW5kID0gJ0MnO1xuICAgIH1cblxuICAgIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHJldHVybiBvbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdE9ic2VydmVyID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnT25Db21wbGV0ZWQoKSc7XG4gICAgfTtcblxuICAgIHJldHVybiBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbjtcbiAgfShOb3RpZmljYXRpb24pKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIE9uTmV4dCBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgY29udGFpbmVkIGluIHRoZSBub3RpZmljYXRpb24uXG4gICAqIEByZXR1cm5zIHtOb3RpZmljYXRpb259IFRoZSBPbk5leHQgbm90aWZpY2F0aW9uIGNvbnRhaW5pbmcgdGhlIHZhbHVlLlxuICAgKi9cbiAgdmFyIG5vdGlmaWNhdGlvbkNyZWF0ZU9uTmV4dCA9IE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9uTmV4dE5vdGlmaWNhdGlvbih2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBPbkVycm9yIG5vdGlmaWNhdGlvbiB0byBhbiBvYnNlcnZlci5cbiAgICogQHBhcmFtIHtBbnl9IGVycm9yIFRoZSBleGNlcHRpb24gY29udGFpbmVkIGluIHRoZSBub3RpZmljYXRpb24uXG4gICAqIEByZXR1cm5zIHtOb3RpZmljYXRpb259IFRoZSBPbkVycm9yIG5vdGlmaWNhdGlvbiBjb250YWluaW5nIHRoZSBleGNlcHRpb24uXG4gICAqL1xuICB2YXIgbm90aWZpY2F0aW9uQ3JlYXRlT25FcnJvciA9IE5vdGlmaWNhdGlvbi5jcmVhdGVPbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIG5ldyBPbkVycm9yTm90aWZpY2F0aW9uKGVycm9yKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiB0byBhbiBvYnNlcnZlci5cbiAgICogQHJldHVybnMge05vdGlmaWNhdGlvbn0gVGhlIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIHZhciBub3RpZmljYXRpb25DcmVhdGVPbkNvbXBsZXRlZCA9IE5vdGlmaWNhdGlvbi5jcmVhdGVPbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE9uQ29tcGxldGVkTm90aWZpY2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1cHBvcnRzIHB1c2gtc3R5bGUgaXRlcmF0aW9uIG92ZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICovXG4gIHZhciBPYnNlcnZlciA9IFJ4Lk9ic2VydmVyID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhIG5vdGlmaWNhdGlvbiBjYWxsYmFjayBmcm9tIGFuIG9ic2VydmVyLlxuICAgKiBAcmV0dXJucyBUaGUgYWN0aW9uIHRoYXQgZm9yd2FyZHMgaXRzIGlucHV0IG5vdGlmaWNhdGlvbiB0byB0aGUgdW5kZXJseWluZyBvYnNlcnZlci5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS50b05vdGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYnNlcnZlciA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLmFjY2VwdChvYnNlcnZlcik7IH07XG4gIH07XG5cbiAgLyoqXG4gICAqICBIaWRlcyB0aGUgaWRlbnRpdHkgb2YgYW4gb2JzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIEFuIG9ic2VydmVyIHRoYXQgaGlkZXMgdGhlIGlkZW50aXR5IG9mIHRoZSBzcGVjaWZpZWQgb2JzZXJ2ZXIuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUuYXNPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZlcihcbiAgICAgIGZ1bmN0aW9uICh4KSB7IHNlbGYub25OZXh0KHgpOyB9LFxuICAgICAgZnVuY3Rpb24gKGVycikgeyBzZWxmLm9uRXJyb3IoZXJyKTsgfSxcbiAgICAgIGZ1bmN0aW9uICgpIHsgc2VsZi5vbkNvbXBsZXRlZCgpOyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogIENoZWNrcyBhY2Nlc3MgdG8gdGhlIG9ic2VydmVyIGZvciBncmFtbWFyIHZpb2xhdGlvbnMuIFRoaXMgaW5jbHVkZXMgY2hlY2tpbmcgZm9yIG11bHRpcGxlIE9uRXJyb3Igb3IgT25Db21wbGV0ZWQgY2FsbHMsIGFzIHdlbGwgYXMgcmVlbnRyYW5jeSBpbiBhbnkgb2YgdGhlIG9ic2VydmVyIG1ldGhvZHMuXG4gICAqICBJZiBhIHZpb2xhdGlvbiBpcyBkZXRlY3RlZCwgYW4gRXJyb3IgaXMgdGhyb3duIGZyb20gdGhlIG9mZmVuZGluZyBvYnNlcnZlciBtZXRob2QgY2FsbC5cbiAgICogQHJldHVybnMgQW4gb2JzZXJ2ZXIgdGhhdCBjaGVja3MgY2FsbGJhY2tzIGludm9jYXRpb25zIGFnYWluc3QgdGhlIG9ic2VydmVyIGdyYW1tYXIgYW5kLCBpZiB0aGUgY2hlY2tzIHBhc3MsIGZvcndhcmRzIHRob3NlIHRvIHRoZSBzcGVjaWZpZWQgb2JzZXJ2ZXIuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUuY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBDaGVja2VkT2JzZXJ2ZXIodGhpcyk7IH07XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGFuIG9ic2VydmVyIGZyb20gdGhlIHNwZWNpZmllZCBPbk5leHQsIGFsb25nIHdpdGggb3B0aW9uYWwgT25FcnJvciwgYW5kIE9uQ29tcGxldGVkIGFjdGlvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbk5leHRdIE9ic2VydmVyJ3MgT25OZXh0IGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIE9ic2VydmVyJ3MgT25FcnJvciBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlZF0gT2JzZXJ2ZXIncyBPbkNvbXBsZXRlZCBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZlcn0gVGhlIG9ic2VydmVyIG9iamVjdCBpbXBsZW1lbnRlZCB1c2luZyB0aGUgZ2l2ZW4gYWN0aW9ucy5cbiAgICovXG4gIHZhciBvYnNlcnZlckNyZWF0ZSA9IE9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgb25OZXh0IHx8IChvbk5leHQgPSBub29wKTtcbiAgICBvbkVycm9yIHx8IChvbkVycm9yID0gZGVmYXVsdEVycm9yKTtcbiAgICBvbkNvbXBsZXRlZCB8fCAob25Db21wbGV0ZWQgPSBub29wKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmVyKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhbiBvYnNlcnZlciBmcm9tIGEgbm90aWZpY2F0aW9uIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEFjdGlvbiB0aGF0IGhhbmRsZXMgYSBub3RpZmljYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZlciBvYmplY3QgdGhhdCBpbnZva2VzIHRoZSBzcGVjaWZpZWQgaGFuZGxlciB1c2luZyBhIG5vdGlmaWNhdGlvbiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggbWVzc2FnZSBpdCByZWNlaXZlcy5cbiAgICovXG4gIE9ic2VydmVyLmZyb21Ob3RpZmllciA9IGZ1bmN0aW9uIChoYW5kbGVyLCB0aGlzQXJnKSB7XG4gICAgdmFyIGNiID0gYmluZENhbGxiYWNrKGhhbmRsZXIsIHRoaXNBcmcsIDEpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBjYihub3RpZmljYXRpb25DcmVhdGVPbk5leHQoeCkpO1xuICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gY2Iobm90aWZpY2F0aW9uQ3JlYXRlT25FcnJvcihlKSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNiKG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkKCkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgdGhlIGludm9jYXRpb24gb2Ygb2JzZXJ2ZXIgbWV0aG9kcyBvbiB0aGUgZ2l2ZW4gc2NoZWR1bGVyLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBzY2hlZHVsZSBvYnNlcnZlciBtZXNzYWdlcyBvbi5cbiAgICogQHJldHVybnMge09ic2VydmVyfSBPYnNlcnZlciB3aG9zZSBtZXNzYWdlcyBhcmUgc2NoZWR1bGVkIG9uIHRoZSBnaXZlbiBzY2hlZHVsZXIuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUubm90aWZ5T24gPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZlT25PYnNlcnZlcihzY2hlZHVsZXIsIHRoaXMpO1xuICB9O1xuXG4gIE9ic2VydmVyLnByb3RvdHlwZS5tYWtlU2FmZSA9IGZ1bmN0aW9uKGRpc3Bvc2FibGUpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c1NhZmVPYnNlcnZlcih0aGlzLl9vbk5leHQsIHRoaXMuX29uRXJyb3IsIHRoaXMuX29uQ29tcGxldGVkLCBkaXNwb3NhYmxlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBPYnNlcnZlciBjbGFzcy5cbiAgICogVGhpcyBiYXNlIGNsYXNzIGVuZm9yY2VzIHRoZSBncmFtbWFyIG9mIG9ic2VydmVycyB3aGVyZSBPbkVycm9yIGFuZCBPbkNvbXBsZXRlZCBhcmUgdGVybWluYWwgbWVzc2FnZXMuXG4gICAqL1xuICB2YXIgQWJzdHJhY3RPYnNlcnZlciA9IFJ4LmludGVybmFscy5BYnN0cmFjdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBYnN0cmFjdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYnNlcnZlciBpbiBhIG5vbi1zdG9wcGVkIHN0YXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0T2JzZXJ2ZXIoKSB7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE11c3QgYmUgaW1wbGVtZW50ZWQgYnkgb3RoZXIgb2JzZXJ2ZXJzXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IG5vdEltcGxlbWVudGVkO1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gbm90SW1wbGVtZW50ZWQ7XG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgb2JzZXJ2ZXIgb2YgYSBuZXcgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIE5leHQgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICovXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUub25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAhdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5uZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIG9ic2VydmVyIHRoYXQgYW4gZXhjZXB0aW9uIGhhcyBvY2N1cnJlZC5cbiAgICAgKiBAcGFyYW0ge0FueX0gZXJyb3IgVGhlIGVycm9yIHRoYXQgaGFzIG9jY3VycmVkLlxuICAgICAqL1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIG9ic2VydmVyIG9mIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSBvYnNlcnZlciwgY2F1c2luZyBpdCB0byB0cmFuc2l0aW9uIHRvIHRoZSBzdG9wcGVkIHN0YXRlLlxuICAgICAqL1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTsgfTtcblxuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBBYnN0cmFjdE9ic2VydmVyO1xuICB9KE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENsYXNzIHRvIGNyZWF0ZSBhbiBPYnNlcnZlciBpbnN0YW5jZSBmcm9tIGRlbGVnYXRlLWJhc2VkIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgb24qIG1ldGhvZHMuXG4gICAqL1xuICB2YXIgQW5vbnltb3VzT2JzZXJ2ZXIgPSBSeC5Bbm9ueW1vdXNPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQW5vbnltb3VzT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9ic2VydmVyIGZyb20gdGhlIHNwZWNpZmllZCBPbk5leHQsIE9uRXJyb3IsIGFuZCBPbkNvbXBsZXRlZCBhY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7QW55fSBvbk5leHQgT2JzZXJ2ZXIncyBPbk5leHQgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSBvbkVycm9yIE9ic2VydmVyJ3MgT25FcnJvciBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IG9uQ29tcGxldGVkIE9ic2VydmVyJ3MgT25Db21wbGV0ZWQgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFub255bW91c09ic2VydmVyKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fb25OZXh0ID0gb25OZXh0O1xuICAgICAgdGhpcy5fb25FcnJvciA9IG9uRXJyb3I7XG4gICAgICB0aGlzLl9vbkNvbXBsZXRlZCA9IG9uQ29tcGxldGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBvbk5leHQgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBOZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIEFub255bW91c09ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLl9vbk5leHQodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgb25FcnJvciBhY3Rpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IGVycm9yIFRoZSBlcnJvciB0aGF0IGhhcyBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBBbm9ueW1vdXNPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX29uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgQ2FsbHMgdGhlIG9uQ29tcGxldGVkIGFjdGlvbi5cbiAgICAgKi9cbiAgICBBbm9ueW1vdXNPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fb25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFub255bW91c09ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgQ2hlY2tlZE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDaGVja2VkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBDaGVja2VkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuX3N0YXRlID0gMDsgLy8gMCAtIGlkbGUsIDEgLSBidXN5LCAyIC0gZG9uZVxuICAgIH1cblxuICAgIHZhciBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUgPSBDaGVja2VkT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLm9uTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5jaGVja0FjY2VzcygpO1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29ic2VydmVyLm9uTmV4dCkuY2FsbCh0aGlzLl9vYnNlcnZlciwgdmFsdWUpO1xuICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgICAgcmVzID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlcy5lKTtcbiAgICB9O1xuXG4gICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGlzLmNoZWNrQWNjZXNzKCk7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fb2JzZXJ2ZXIub25FcnJvcikuY2FsbCh0aGlzLl9vYnNlcnZlciwgZXJyKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gMjtcbiAgICAgIHJlcyA9PT0gZXJyb3JPYmogJiYgdGhyb3dlcihyZXMuZSk7XG4gICAgfTtcblxuICAgIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2hlY2tBY2Nlc3MoKTtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYnNlcnZlci5vbkNvbXBsZXRlZCkuY2FsbCh0aGlzLl9vYnNlcnZlcik7XG4gICAgICB0aGlzLl9zdGF0ZSA9IDI7XG4gICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgIH07XG5cbiAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUuY2hlY2tBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDEpIHsgdGhyb3cgbmV3IEVycm9yKCdSZS1lbnRyYW5jeSBkZXRlY3RlZCcpOyB9XG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDIpIHsgdGhyb3cgbmV3IEVycm9yKCdPYnNlcnZlciBjb21wbGV0ZWQnKTsgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAwKSB7IHRoaXMuX3N0YXRlID0gMTsgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ2hlY2tlZE9ic2VydmVyO1xuICB9KE9ic2VydmVyKSk7XG5cbiAgdmFyIFNjaGVkdWxlZE9ic2VydmVyID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlZE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTY2hlZHVsZWRPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNjaGVkdWxlZE9ic2VydmVyKHNjaGVkdWxlciwgb2JzZXJ2ZXIpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLmlzQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGFzRmF1bHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5kaXNwb3NhYmxlID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlTmV4dChvYnNlcnZlciwgeCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyBvYnNlcnZlci5vbk5leHQoeCk7IH07IH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlRXJyb3Iob2JzZXJ2ZXIsIGUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgb2JzZXJ2ZXIub25FcnJvcihlKTsgfTsgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb21wbGV0ZWQob2JzZXJ2ZXIpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTsgfTsgfVxuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKGVucXVldWVOZXh0KHRoaXMub2JzZXJ2ZXIsIHgpKTtcbiAgICB9O1xuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaChlbnF1ZXVlRXJyb3IodGhpcy5vYnNlcnZlciwgZSkpO1xuICAgIH07XG5cbiAgICBTY2hlZHVsZWRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKGVucXVldWVDb21wbGV0ZWQodGhpcy5vYnNlcnZlcikpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB2YXIgd29yaztcbiAgICAgIGlmIChzdGF0ZS5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdvcmsgPSBzdGF0ZS5xdWV1ZS5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuaXNBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2god29yaykoKTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gW107XG4gICAgICAgIHN0YXRlLmhhc0ZhdWx0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhyb3dlcihyZXMuZSk7XG4gICAgICB9XG4gICAgICByZWN1cnNlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBTY2hlZHVsZWRPYnNlcnZlci5wcm90b3R5cGUuZW5zdXJlQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzT3duZXIgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5oYXNGYXVsdGVkICYmIHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBpc093bmVyID0gIXRoaXMuaXNBY3F1aXJlZDtcbiAgICAgICAgdGhpcy5pc0FjcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlzT3duZXIgJiZcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlLnNldERpc3Bvc2FibGUodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUodGhpcywgc2NoZWR1bGVNZXRob2QpKTtcbiAgICB9O1xuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2hlZHVsZWRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIE9ic2VydmVPbk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPYnNlcnZlT25PYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE9ic2VydmVPbk9ic2VydmVyKHNjaGVkdWxlciwgb2JzZXJ2ZXIsIGNhbmNlbCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgc2NoZWR1bGVyLCBvYnNlcnZlcik7XG4gICAgICB0aGlzLl9jYW5jZWwgPSBjYW5jZWw7XG4gICAgfVxuXG4gICAgT2JzZXJ2ZU9uT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuZW5zdXJlQWN0aXZlKCk7XG4gICAgfTtcblxuICAgIE9ic2VydmVPbk9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZSk7XG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xuICAgIH07XG5cbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5jb21wbGV0ZWQuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZW5zdXJlQWN0aXZlKCk7XG4gICAgfTtcblxuICAgIE9ic2VydmVPbk9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9jYW5jZWwgJiYgdGhpcy5fY2FuY2VsLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhbmNlbCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBPYnNlcnZlT25PYnNlcnZlcjtcbiAgfSkoU2NoZWR1bGVkT2JzZXJ2ZXIpO1xuXG4gIHZhciBvYnNlcnZhYmxlUHJvdG87XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBwdXNoLXN0eWxlIGNvbGxlY3Rpb24uXG4gICAqL1xuICB2YXIgT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24gbWFrZVN1YnNjcmliZShzZWxmLCBzdWJzY3JpYmUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgb2xkT25FcnJvciA9IG8ub25FcnJvcjtcbiAgICAgICAgby5vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZSwgc2VsZik7XG4gICAgICAgICAgb2xkT25FcnJvci5jYWxsKG8sIGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmUuY2FsbChzZWxmLCBvKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZSgpIHtcbiAgICAgIGlmIChSeC5jb25maWcubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdmFyIG9sZFN1YnNjcmliZSA9IHRoaXMuX3N1YnNjcmliZTtcbiAgICAgICAgdmFyIGUgPSB0cnlDYXRjaCh0aHJvd2VyKShuZXcgRXJyb3IoKSkuZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZignXFxuJykgKyAxKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gbWFrZVN1YnNjcmliZSh0aGlzLCBvbGRTdWJzY3JpYmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9ic2VydmFibGVQcm90byA9IE9ic2VydmFibGUucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBPYnNlcnZhYmxlXG4gICAgKiBAcGFyYW0ge0FueX0gQW4gb2JqZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIGl0IGlzIGFuIE9ic2VydmFibGVcbiAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGFuIE9ic2VydmFibGUsIGVsc2UgZmFsc2UuXG4gICAgKi9cbiAgICBPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbyAmJiBpc0Z1bmN0aW9uKG8uc3Vic2NyaWJlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIFN1YnNjcmliZXMgYW4gbyB0byB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiAgQHBhcmFtIHtNaXhlZH0gW29Pck9uTmV4dF0gVGhlIG9iamVjdCB0aGF0IGlzIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvciBhbiBhY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBBY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlZF0gQWN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqICBAcmV0dXJucyB7RGlwb3NhYmxlfSBBIGRpc3Bvc2FibGUgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlID0gb2JzZXJ2YWJsZVByb3RvLmZvckVhY2ggPSBmdW5jdGlvbiAob09yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZSh0eXBlb2Ygb09yT25OZXh0ID09PSAnb2JqZWN0JyA/XG4gICAgICAgIG9Pck9uTmV4dCA6XG4gICAgICAgIG9ic2VydmVyQ3JlYXRlKG9Pck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgbmV4dCB2YWx1ZSBpbiB0aGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBcInRoaXNcIiBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IEEgZGlzcG9zYWJsZSBoYW5kbGluZyB0aGUgc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zLlxuICAgICAqL1xuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmVPbk5leHQgPSBmdW5jdGlvbiAob25OZXh0LCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKG9ic2VydmVyQ3JlYXRlKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKHgpIHsgb25OZXh0LmNhbGwodGhpc0FyZywgeCk7IH0gOiBvbk5leHQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBhbiBleGNlcHRpb25hbCBjb25kaXRpb24gaW4gdGhlIHNlcXVlbmNlIHdpdGggYW4gb3B0aW9uYWwgXCJ0aGlzXCIgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IEEgZGlzcG9zYWJsZSBoYW5kbGluZyB0aGUgc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zLlxuICAgICAqL1xuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmVPbkVycm9yID0gZnVuY3Rpb24gKG9uRXJyb3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUob2JzZXJ2ZXJDcmVhdGUobnVsbCwgdHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24oZSkgeyBvbkVycm9yLmNhbGwodGhpc0FyZywgZSk7IH0gOiBvbkVycm9yKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIG5leHQgdmFsdWUgaW4gdGhlIHNlcXVlbmNlIHdpdGggYW4gb3B0aW9uYWwgXCJ0aGlzXCIgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRpc3Bvc2FibGUgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT25Db21wbGV0ZWQgPSBmdW5jdGlvbiAob25Db21wbGV0ZWQsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUob2JzZXJ2ZXJDcmVhdGUobnVsbCwgbnVsbCwgdHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24oKSB7IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7IH0gOiBvbkNvbXBsZXRlZCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbiAgfSkoKTtcblxuICB2YXIgT2JzZXJ2YWJsZUJhc2UgPSBSeC5PYnNlcnZhYmxlQmFzZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT2JzZXJ2YWJsZUJhc2UsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBmaXhTdWJzY3JpYmVyKHN1YnNjcmliZXIpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVyICYmIGlzRnVuY3Rpb24oc3Vic2NyaWJlci5kaXNwb3NlKSA/IHN1YnNjcmliZXIgOlxuICAgICAgICBpc0Z1bmN0aW9uKHN1YnNjcmliZXIpID8gZGlzcG9zYWJsZUNyZWF0ZShzdWJzY3JpYmVyKSA6IGRpc3Bvc2FibGVFbXB0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXREaXNwb3NhYmxlKHMsIHN0YXRlKSB7XG4gICAgICB2YXIgYWRvID0gc3RhdGVbMF0sIHNlbGYgPSBzdGF0ZVsxXTtcbiAgICAgIHZhciBzdWIgPSB0cnlDYXRjaChzZWxmLnN1YnNjcmliZUNvcmUpLmNhbGwoc2VsZiwgYWRvKTtcbiAgICAgIGlmIChzdWIgPT09IGVycm9yT2JqICYmICFhZG8uZmFpbChlcnJvck9iai5lKSkgeyB0aHJvd2VyKGVycm9yT2JqLmUpOyB9XG4gICAgICBhZG8uc2V0RGlzcG9zYWJsZShmaXhTdWJzY3JpYmVyKHN1YikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVCYXNlKCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgT2JzZXJ2YWJsZUJhc2UucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFkbyA9IG5ldyBBdXRvRGV0YWNoT2JzZXJ2ZXIobyksIHN0YXRlID0gW2FkbywgdGhpc107XG5cbiAgICAgIGlmIChjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVxdWlyZWQoKSkge1xuICAgICAgICBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzZXREaXNwb3NhYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldERpc3Bvc2FibGUobnVsbCwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkbztcbiAgICB9O1xuXG4gICAgT2JzZXJ2YWJsZUJhc2UucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBub3RJbXBsZW1lbnRlZDtcblxuICAgIHJldHVybiBPYnNlcnZhYmxlQmFzZTtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbnZhciBGbGF0TWFwT2JzZXJ2YWJsZSA9IFJ4LkZsYXRNYXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuXG4gICAgaW5oZXJpdHMoRmxhdE1hcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBGbGF0TWFwT2JzZXJ2YWJsZShzb3VyY2UsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24ocmVzdWx0U2VsZWN0b3IpID8gcmVzdWx0U2VsZWN0b3IgOiBudWxsO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IGJpbmRDYWxsYmFjayhpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxlY3RvcjsgfSwgdGhpc0FyZywgMyk7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEZsYXRNYXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzLnNlbGVjdG9yLCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIob2JzZXJ2ZXIsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3Rvciwgc291cmNlKSB7XG4gICAgICB0aGlzLmkgPSAwO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm8gPSBvYnNlcnZlcjtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5fd3JhcFJlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdCwgeCwgaSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0U2VsZWN0b3IgP1xuICAgICAgICByZXN1bHQubWFwKGZ1bmN0aW9uKHksIGkyKSB7IHJldHVybiB0aGlzLnJlc3VsdFNlbGVjdG9yKHgsIHksIGksIGkyKTsgfSwgdGhpcykgOlxuICAgICAgICByZXN1bHQ7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuaSsrO1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuc2VsZWN0b3IpKHgsIGksIHRoaXMuc291cmNlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLm8ub25FcnJvcihyZXN1bHQuZSk7IH1cblxuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgIChpc0FycmF5TGlrZShyZXN1bHQpIHx8IGlzSXRlcmFibGUocmVzdWx0KSkgJiYgKHJlc3VsdCA9IE9ic2VydmFibGUuZnJvbShyZXN1bHQpKTtcbiAgICAgIHRoaXMuby5vbk5leHQodGhpcy5fd3JhcFJlc3VsdChyZXN1bHQsIHgsIGkpKTtcbiAgICB9O1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlKSB7IHRoaXMuby5vbkVycm9yKGUpOyB9O1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24oKSB7IHRoaXMuby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIEZsYXRNYXBPYnNlcnZhYmxlO1xuXG59KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEVudW1lcmFibGUgPSBSeC5pbnRlcm5hbHMuRW51bWVyYWJsZSA9IGZ1bmN0aW9uICgpIHsgfTtcblxuICBmdW5jdGlvbiBJc0Rpc3Bvc2VkRGlzcG9zYWJsZShzdGF0ZSkge1xuICAgIHRoaXMuX3MgPSBzdGF0ZTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gIElzRGlzcG9zZWREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlKHNvdXJjZXMpIHtcbiAgICAgIHRoaXMuc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmlzRGlzcG9zZWQpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgY3VycmVudEl0ZW0gPSB0cnlDYXRjaChzdGF0ZS5lLm5leHQpLmNhbGwoc3RhdGUuZSk7XG4gICAgICBpZiAoY3VycmVudEl0ZW0gPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IoY3VycmVudEl0ZW0uZSk7IH1cbiAgICAgIGlmIChjdXJyZW50SXRlbS5kb25lKSB7IHJldHVybiBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7IH1cblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvbWlzZVxuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRJdGVtLnZhbHVlO1xuICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHN0YXRlLnN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIoc3RhdGUsIHJlY3Vyc2UpKSk7XG4gICAgfVxuXG4gICAgQ29uY2F0RW51bWVyYWJsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBvOiBvLFxuICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbixcbiAgICAgICAgZTogdGhpcy5zb3VyY2VzWyRpdGVyYXRvciRdKClcbiAgICAgIH07XG5cbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgc2NoZWR1bGVNZXRob2QpO1xuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlLCBuZXcgSXNEaXNwb3NlZERpc3Bvc2FibGUoc3RhdGUpXSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9yZWN1cnNlID0gcmVjdXJzZTtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9zdGF0ZS5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3N0YXRlLm8ub25FcnJvcihlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlY3Vyc2UodGhpcy5fc3RhdGUpOyB9O1xuXG4gICAgcmV0dXJuIENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgRW51bWVyYWJsZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ29uY2F0RW51bWVyYWJsZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIENhdGNoRXJyb3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGZ1bmN0aW9uIENhdGNoRXJyb3JPYnNlcnZhYmxlKHNvdXJjZXMpIHtcbiAgICAgIHRoaXMuc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhDYXRjaEVycm9yT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgIHZhciBjdXJyZW50SXRlbSA9IHRyeUNhdGNoKHN0YXRlLmUubmV4dCkuY2FsbChzdGF0ZS5lKTtcbiAgICAgIGlmIChjdXJyZW50SXRlbSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihjdXJyZW50SXRlbS5lKTsgfVxuICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHsgcmV0dXJuIHN0YXRlLmxhc3RFcnJvciAhPT0gbnVsbCA/IHN0YXRlLm8ub25FcnJvcihzdGF0ZS5sYXN0RXJyb3IpIDogc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgIGlzUHJvbWlzZShjdXJyZW50VmFsdWUpICYmIChjdXJyZW50VmFsdWUgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoY3VycmVudFZhbHVlKSk7XG5cbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBzdGF0ZS5zdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShjdXJyZW50VmFsdWUuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgIH1cblxuICAgIENhdGNoRXJyb3JPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBpc0Rpc3Bvc2VkOiBmYWxzZSxcbiAgICAgICAgZTogdGhpcy5zb3VyY2VzWyRpdGVyYXRvciRdKCksXG4gICAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLFxuICAgICAgICBsYXN0RXJyb3I6IG51bGwsXG4gICAgICAgIG86IG9cbiAgICAgIH07XG5cbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgc2NoZWR1bGVNZXRob2QpO1xuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlLCBuZXcgSXNEaXNwb3NlZERpc3Bvc2FibGUoc3RhdGUpXSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9yZWN1cnNlID0gcmVjdXJzZTtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9zdGF0ZS5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3N0YXRlLmxhc3RFcnJvciA9IGU7IHRoaXMuX3JlY3Vyc2UodGhpcy5fc3RhdGUpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIENhdGNoRXJyb3JPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgRW51bWVyYWJsZS5wcm90b3R5cGUuY2F0Y2hFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENhdGNoRXJyb3JPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBSZXBlYXRFbnVtZXJhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSZXBlYXRFbnVtZXJhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFJlcGVhdEVudW1lcmFibGUodiwgYykge1xuICAgICAgdGhpcy52ID0gdjtcbiAgICAgIHRoaXMuYyA9IGMgPT0gbnVsbCA/IC0xIDogYztcbiAgICB9XG5cbiAgICBSZXBlYXRFbnVtZXJhYmxlLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVwZWF0RW51bWVyYXRvcih0aGlzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVwZWF0RW51bWVyYXRvcihwKSB7XG4gICAgICB0aGlzLnYgPSBwLnY7XG4gICAgICB0aGlzLmwgPSBwLmM7XG4gICAgfVxuXG4gICAgUmVwZWF0RW51bWVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmwgPT09IDApIHsgcmV0dXJuIGRvbmVFbnVtZXJhdG9yOyB9XG4gICAgICBpZiAodGhpcy5sID4gMCkgeyB0aGlzLmwtLTsgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLnYgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlcGVhdEVudW1lcmFibGU7XG4gIH0oRW51bWVyYWJsZSkpO1xuXG4gIHZhciBlbnVtZXJhYmxlUmVwZWF0ID0gRW51bWVyYWJsZS5yZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGVhdENvdW50KSB7XG4gICAgcmV0dXJuIG5ldyBSZXBlYXRFbnVtZXJhYmxlKHZhbHVlLCByZXBlYXRDb3VudCk7XG4gIH07XG5cbiAgdmFyIE9mRW51bWVyYWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPZkVudW1lcmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gT2ZFbnVtZXJhYmxlKHMsIGZuLCB0aGlzQXJnKSB7XG4gICAgICB0aGlzLnMgPSBzO1xuICAgICAgdGhpcy5mbiA9IGZuID8gYmluZENhbGxiYWNrKGZuLCB0aGlzQXJnLCAzKSA6IG51bGw7XG4gICAgfVxuICAgIE9mRW51bWVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9mRW51bWVyYXRvcih0aGlzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gT2ZFbnVtZXJhdG9yKHApIHtcbiAgICAgIHRoaXMuaSA9IC0xO1xuICAgICAgdGhpcy5zID0gcC5zO1xuICAgICAgdGhpcy5sID0gdGhpcy5zLmxlbmd0aDtcbiAgICAgIHRoaXMuZm4gPSBwLmZuO1xuICAgIH1cblxuICAgIE9mRW51bWVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuICsrdGhpcy5pIDwgdGhpcy5sID9cbiAgICAgICB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogIXRoaXMuZm4gPyB0aGlzLnNbdGhpcy5pXSA6IHRoaXMuZm4odGhpcy5zW3RoaXMuaV0sIHRoaXMuaSwgdGhpcy5zKSB9IDpcbiAgICAgICBkb25lRW51bWVyYXRvcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9mRW51bWVyYWJsZTtcbiAgfShFbnVtZXJhYmxlKSk7XG5cbiAgdmFyIGVudW1lcmFibGVPZiA9IEVudW1lcmFibGUub2YgPSBmdW5jdGlvbiAoc291cmNlLCBzZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgT2ZFbnVtZXJhYmxlKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpO1xuICB9O1xuXG52YXIgT2JzZXJ2ZU9uT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gIGluaGVyaXRzKE9ic2VydmVPbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gIGZ1bmN0aW9uIE9ic2VydmVPbk9ic2VydmFibGUoc291cmNlLCBzKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gIH1cblxuICBPYnNlcnZlT25PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBPYnNlcnZlT25PYnNlcnZlcih0aGlzLl9zLCBvKSk7XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmVPbk9ic2VydmFibGU7XG59KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgIC8qKlxuICAgKiAgV3JhcHMgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpbiBvcmRlciB0byBydW4gaXRzIG9ic2VydmVyIGNhbGxiYWNrcyBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci5cbiAgICpcbiAgICogIFRoaXMgb25seSBpbnZva2VzIG9ic2VydmVyIGNhbGxiYWNrcyBvbiBhIHNjaGVkdWxlci4gSW4gY2FzZSB0aGUgc3Vic2NyaXB0aW9uIGFuZC9vciB1bnN1YnNjcmlwdGlvbiBhY3Rpb25zIGhhdmUgc2lkZS1lZmZlY3RzXG4gICAqICB0aGF0IHJlcXVpcmUgdG8gYmUgcnVuIG9uIGEgc2NoZWR1bGVyLCB1c2Ugc3Vic2NyaWJlT24uXG4gICAqXG4gICAqICBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBub3RpZnkgb2JzZXJ2ZXJzIG9uLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2hvc2Ugb2JzZXJ2YXRpb25zIGhhcHBlbiBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5vYnNlcnZlT24gPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZlT25PYnNlcnZhYmxlKHRoaXMsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFN1YnNjcmliZU9uT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3Vic2NyaWJlT25PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZU9uT2JzZXJ2YWJsZShzb3VyY2UsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzY2hlZHVsZXIsIHN0YXRlKSB7XG4gICAgICB2YXIgc291cmNlID0gc3RhdGVbMF0sIGQgPSBzdGF0ZVsxXSwgbyA9IHN0YXRlWzJdO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKG5ldyBTY2hlZHVsZWREaXNwb3NhYmxlKHNjaGVkdWxlciwgc291cmNlLnN1YnNjcmliZShvKSkpO1xuICAgIH1cblxuICAgIFN1YnNjcmliZU9uT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBkID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShtKTtcbiAgICAgIG0uc2V0RGlzcG9zYWJsZSh0aGlzLl9zLnNjaGVkdWxlKFt0aGlzLnNvdXJjZSwgZCwgb10sIHNjaGVkdWxlTWV0aG9kKSk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YnNjcmliZU9uT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gICAvKipcbiAgICogIFdyYXBzIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaW4gb3JkZXIgdG8gcnVuIGl0cyBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIGxvZ2ljIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLiBUaGlzIG9wZXJhdGlvbiBpcyBub3QgY29tbW9ubHkgdXNlZDtcbiAgICogIHNlZSB0aGUgcmVtYXJrcyBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHN1YnNjcmliZU9uIGFuZCBvYnNlcnZlT24uXG5cbiAgICogIFRoaXMgb25seSBwZXJmb3JtcyB0aGUgc2lkZS1lZmZlY3RzIG9mIHN1YnNjcmlwdGlvbiBhbmQgdW5zdWJzY3JpcHRpb24gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuIEluIG9yZGVyIHRvIGludm9rZSBvYnNlcnZlclxuICAgKiAgY2FsbGJhY2tzIG9uIGEgc2NoZWR1bGVyLCB1c2Ugb2JzZXJ2ZU9uLlxuXG4gICAqICBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBwZXJmb3JtIHN1YnNjcmlwdGlvbiBhbmQgdW5zdWJzY3JpcHRpb24gYWN0aW9ucyBvbi5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdob3NlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT24gPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVPbk9ic2VydmFibGUodGhpcywgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgRnJvbVByb21pc2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZyb21Qcm9taXNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGcm9tUHJvbWlzZU9ic2VydmFibGUocCwgcykge1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTmV4dChzLCBzdGF0ZSkge1xuICAgICAgdmFyIG8gPSBzdGF0ZVswXSwgZGF0YSA9IHN0YXRlWzFdO1xuICAgICAgby5vbk5leHQoZGF0YSk7XG4gICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVFcnJvcihzLCBzdGF0ZSkge1xuICAgICAgdmFyIG8gPSBzdGF0ZVswXSwgZXJyID0gc3RhdGVbMV07XG4gICAgICBvLm9uRXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBGcm9tUHJvbWlzZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksIHNlbGYgPSB0aGlzLCBwID0gdGhpcy5fcDtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ocCkpIHtcbiAgICAgICAgcCA9IHRyeUNhdGNoKHApKCk7XG4gICAgICAgIGlmIChwID09PSBlcnJvck9iaikge1xuICAgICAgICAgIG8ub25FcnJvcihwLmUpO1xuICAgICAgICAgIHJldHVybiBzYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcFxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNlbGYuX3Muc2NoZWR1bGUoW28sIGRhdGFdLCBzY2hlZHVsZU5leHQpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNlbGYuX3Muc2NoZWR1bGUoW28sIGVycl0sIHNjaGVkdWxlRXJyb3IpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzYWQ7XG4gICAgfTtcblxuICAgIHJldHVybiBGcm9tUHJvbWlzZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiBDb252ZXJ0cyBhIFByb21pc2UgdG8gYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZVxuICAqIEBwYXJhbSB7UHJvbWlzZX0gQW4gRVM2IENvbXBsaWFudCBwcm9taXNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHdyYXBzIHRoZSBleGlzdGluZyBwcm9taXNlIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXG4gICovXG4gIHZhciBvYnNlcnZhYmxlRnJvbVByb21pc2UgPSBPYnNlcnZhYmxlLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlciB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBGcm9tUHJvbWlzZU9ic2VydmFibGUocHJvbWlzZSwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKlxuICAgKiBDb252ZXJ0cyBhbiBleGlzdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGFuIEVTNiBDb21wYXRpYmxlIFByb21pc2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHByb21pc2UgPSBSeC5PYnNlcnZhYmxlLnJldHVybig0MikudG9Qcm9taXNlKFJTVlAuUHJvbWlzZSk7XG4gICAqXG4gICAqIC8vIFdpdGggY29uZmlnXG4gICAqIFJ4LmNvbmZpZy5Qcm9taXNlID0gUlNWUC5Qcm9taXNlO1xuICAgKiB2YXIgcHJvbWlzZSA9IFJ4Lk9ic2VydmFibGUucmV0dXJuKDQyKS50b1Byb21pc2UoKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb21pc2VDdG9yXSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHByb21pc2UuIElmIG5vdCBwcm92aWRlZCwgaXQgbG9va3MgZm9yIGl0IGluIFJ4LmNvbmZpZy5Qcm9taXNlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQW4gRVM2IGNvbXBhdGlibGUgcHJvbWlzZSB3aXRoIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2VDdG9yKSB7XG4gICAgcHJvbWlzZUN0b3IgfHwgKHByb21pc2VDdG9yID0gUnguY29uZmlnLlByb21pc2UpO1xuICAgIGlmICghcHJvbWlzZUN0b3IpIHsgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdQcm9taXNlIHR5cGUgbm90IHByb3ZpZGVkIG5vciBpbiBSeC5jb25maWcuUHJvbWlzZScpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvLyBObyBjYW5jZWxsYXRpb24gY2FuIGJlIGRvbmVcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgfSwgcmVqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFRvQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRvQXJyYXlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvQXJyYXlPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb0FycmF5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIobykpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmEgPSBbXTtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuYS5wdXNoKHgpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5vLm9uRXJyb3IoZSk7ICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5vLm9uTmV4dCh0aGlzLmEpOyB0aGlzLm8ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUb0FycmF5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqIENyZWF0ZXMgYW4gYXJyYXkgZnJvbSBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIGEgbGlzdCBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0FycmF5T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGEgc3BlY2lmaWVkIHN1YnNjcmliZSBtZXRob2QgaW1wbGVtZW50YXRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IH0gKTtcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIFJ4LkRpc3Bvc2FibGUuZW1wdHk7IH0gKTtcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgfSApO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmUgSW1wbGVtZW50YXRpb24gb2YgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlJ3Mgc3Vic2NyaWJlIG1ldGhvZCwgcmV0dXJuaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBEaXNwb3NhYmxlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGltcGxlbWVudGF0aW9uIGZvciB0aGUgU3Vic2NyaWJlIG1ldGhvZC5cbiAgICovXG4gIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKHN1YnNjcmliZSwgcGFyZW50KTtcbiAgfTtcblxuICB2YXIgRGVmZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVmZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVmZXIoZmFjdG9yeSkge1xuICAgICAgdGhpcy5fZiA9IGZhY3Rvcnk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEZWZlci5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZikoKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvYnNlcnZhYmxlVGhyb3cocmVzdWx0LmUpLnN1YnNjcmliZShvKTt9XG4gICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJzY3JpYmUobyk7XG4gICAgfTtcblxuICAgIHJldHVybiBEZWZlcjtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaW52b2tlcyB0aGUgc3BlY2lmaWVkIGZhY3RvcnkgZnVuY3Rpb24gd2hlbmV2ZXIgYSBuZXcgb2JzZXJ2ZXIgc3Vic2NyaWJlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmRlZmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUuZnJvbUFycmF5KFsxLDIsM10pOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JzZXJ2YWJsZUZhY3RvcnkgT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBvYnNlcnZlciB0aGF0IHN1YnNjcmliZXMgdG8gdGhlIHJlc3VsdGluZyBzZXF1ZW5jZSBvciBQcm9taXNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBvYnNlcnZlcnMgdHJpZ2dlciBhbiBpbnZvY2F0aW9uIG9mIHRoZSBnaXZlbiBvYnNlcnZhYmxlIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZURlZmVyID0gT2JzZXJ2YWJsZS5kZWZlciA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgIHJldHVybiBuZXcgRGVmZXIob2JzZXJ2YWJsZUZhY3RvcnkpO1xuICB9O1xuXG4gIHZhciBFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRW1wdHlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRW1wdHlPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgc2luayA9IG5ldyBFbXB0eVNpbmsob2JzZXJ2ZXIsIHRoaXMuc2NoZWR1bGVyKTtcbiAgICAgIHJldHVybiBzaW5rLnJ1bigpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFbXB0eVNpbmsob2JzZXJ2ZXIsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJdGVtKHMsIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5vbkNvbXBsZXRlZCgpO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICB9XG5cbiAgICBFbXB0eVNpbmsucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZXIgPT09IGltbWVkaWF0ZVNjaGVkdWxlciA/XG4gICAgICAgIHNjaGVkdWxlSXRlbShudWxsLCBzdGF0ZSkgOlxuICAgICAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgc2NoZWR1bGVJdGVtKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEVtcHR5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFTVBUWV9PQlNFUlZBQkxFID0gbmV3IEVtcHR5T2JzZXJ2YWJsZShpbW1lZGlhdGVTY2hlZHVsZXIpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBlbXB0eSBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCB0aGUgc2luZ2xlIE9uQ29tcGxldGVkIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5lbXB0eSgpO1xuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHNlbmQgdGhlIHRlcm1pbmF0aW9uIGNhbGwgb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggbm8gZWxlbWVudHMuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZUVtcHR5ID0gT2JzZXJ2YWJsZS5lbXB0eSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgIHJldHVybiBzY2hlZHVsZXIgPT09IGltbWVkaWF0ZVNjaGVkdWxlciA/IEVNUFRZX09CU0VSVkFCTEUgOiBuZXcgRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZyb21PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZyb21PYnNlcnZhYmxlKGl0ZXJhYmxlLCBmbiwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNjaGVkdWxlTWV0aG9kKG8sIGl0LCBmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgICB2YXIgbmV4dCA9IHRyeUNhdGNoKGl0Lm5leHQpLmNhbGwoaXQpO1xuICAgICAgICBpZiAobmV4dCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihuZXh0LmUpOyB9XG4gICAgICAgIGlmIChuZXh0LmRvbmUpIHsgcmV0dXJuIG8ub25Db21wbGV0ZWQoKTsgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXh0LnZhbHVlO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKGZuKShyZXN1bHQsIGkpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgIH1cblxuICAgICAgICBvLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICByZWN1cnNlKGkgKyAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgRnJvbU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGxpc3QgPSBPYmplY3QodGhpcy5faXRlcmFibGUpLFxuICAgICAgICAgIGl0ID0gZ2V0SXRlcmFibGUobGlzdCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoMCwgY3JlYXRlU2NoZWR1bGVNZXRob2QobywgaXQsIHRoaXMuX2ZuKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGcm9tT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBtYXhTYWZlSW50ZWdlciA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgZnVuY3Rpb24gU3RyaW5nSXRlcmFibGUocykge1xuICAgIHRoaXMuX3MgPSBzO1xuICB9XG5cbiAgU3RyaW5nSXRlcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3IodGhpcy5fcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gU3RyaW5nSXRlcmF0b3Iocykge1xuICAgIHRoaXMuX3MgPSBzO1xuICAgIHRoaXMuX2wgPSBzLmxlbmd0aDtcbiAgICB0aGlzLl9pID0gMDtcbiAgfVxuXG4gIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faSA8IHRoaXMuX2wgPyB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy5fcy5jaGFyQXQodGhpcy5faSsrKSB9IDogZG9uZUVudW1lcmF0b3I7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXJyYXlJdGVyYWJsZShhKSB7XG4gICAgdGhpcy5fYSA9IGE7XG4gIH1cblxuICBBcnJheUl0ZXJhYmxlLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3IodGhpcy5fYSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcihhKSB7XG4gICAgdGhpcy5fYSA9IGE7XG4gICAgdGhpcy5fbCA9IHRvTGVuZ3RoKGEpO1xuICAgIHRoaXMuX2kgPSAwO1xuICB9XG5cbiAgQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faSA8IHRoaXMuX2wgPyB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy5fYVt0aGlzLl9pKytdIH0gOiBkb25lRW51bWVyYXRvcjtcbiAgfTtcblxuICBmdW5jdGlvbiBudW1iZXJJc0Zpbml0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHJvb3QuaXNGaW5pdGUodmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOYW4obikge1xuICAgIHJldHVybiBuICE9PSBuO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmFibGUobykge1xuICAgIHZhciBpID0gb1skaXRlcmF0b3IkXSwgaXQ7XG4gICAgaWYgKCFpICYmIHR5cGVvZiBvID09PSAnc3RyaW5nJykge1xuICAgICAgaXQgPSBuZXcgU3RyaW5nSXRlcmFibGUobyk7XG4gICAgICByZXR1cm4gaXRbJGl0ZXJhdG9yJF0oKTtcbiAgICB9XG4gICAgaWYgKCFpICYmIG8ubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ID0gbmV3IEFycmF5SXRlcmFibGUobyk7XG4gICAgICByZXR1cm4gaXRbJGl0ZXJhdG9yJF0oKTtcbiAgICB9XG4gICAgaWYgKCFpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBpcyBub3QgaXRlcmFibGUnKTsgfVxuICAgIHJldHVybiBvWyRpdGVyYXRvciRdKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaWduKHZhbHVlKSB7XG4gICAgdmFyIG51bWJlciA9ICt2YWx1ZTtcbiAgICBpZiAobnVtYmVyID09PSAwKSB7IHJldHVybiBudW1iZXI7IH1cbiAgICBpZiAoaXNOYU4obnVtYmVyKSkgeyByZXR1cm4gbnVtYmVyOyB9XG4gICAgcmV0dXJuIG51bWJlciA8IDAgPyAtMSA6IDE7XG4gIH1cblxuICBmdW5jdGlvbiB0b0xlbmd0aChvKSB7XG4gICAgdmFyIGxlbiA9ICtvLmxlbmd0aDtcbiAgICBpZiAoaXNOYU4obGVuKSkgeyByZXR1cm4gMDsgfVxuICAgIGlmIChsZW4gPT09IDAgfHwgIW51bWJlcklzRmluaXRlKGxlbikpIHsgcmV0dXJuIGxlbjsgfVxuICAgIGxlbiA9IHNpZ24obGVuKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobGVuKSk7XG4gICAgaWYgKGxlbiA8PSAwKSB7IHJldHVybiAwOyB9XG4gICAgaWYgKGxlbiA+IG1heFNhZmVJbnRlZ2VyKSB7IHJldHVybiBtYXhTYWZlSW50ZWdlcjsgfVxuICAgIHJldHVybiBsZW47XG4gIH1cblxuICAvKipcbiAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IE9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBhbiBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdC5cbiAgKiBAcGFyYW0ge0FueX0gYXJyYXlMaWtlIEFuIGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWFwRm5dIE1hcCBmdW5jdGlvbiB0byBjYWxsIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gVGhlIGNvbnRleHQgdG8gdXNlIGNhbGxpbmcgdGhlIG1hcEZuIGlmIHByb3ZpZGVkLlxuICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBPcHRpb25hbCBzY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nLiAgSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuY3VycmVudFRocmVhZC5cbiAgKi9cbiAgdmFyIG9ic2VydmFibGVGcm9tID0gT2JzZXJ2YWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBtYXBGbiwgdGhpc0FyZywgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmFibGUgY2Fubm90IGJlIG51bGwuJylcbiAgICB9XG4gICAgaWYgKG1hcEZuICYmICFpc0Z1bmN0aW9uKG1hcEZuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBGbiB3aGVuIHByb3ZpZGVkIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICBpZiAobWFwRm4pIHtcbiAgICAgIHZhciBtYXBwZXIgPSBiaW5kQ2FsbGJhY2sobWFwRm4sIHRoaXNBcmcsIDIpO1xuICAgIH1cbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEZyb21PYnNlcnZhYmxlKGl0ZXJhYmxlLCBtYXBwZXIsIHNjaGVkdWxlcik7XG4gIH1cblxuICB2YXIgRnJvbUFycmF5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGcm9tQXJyYXlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZyb21BcnJheU9ic2VydmFibGUoYXJncywgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9hcmdzID0gYXJncztcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKG8sIGFyZ3MpIHtcbiAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wUmVjdXJzaXZlIChpLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgby5vbk5leHQoYXJnc1tpXSk7XG4gICAgICAgICAgcmVjdXJzZShpICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIEZyb21BcnJheU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZSgwLCBzY2hlZHVsZU1ldGhvZChvLCB0aGlzLl9hcmdzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGcm9tQXJyYXlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogIENvbnZlcnRzIGFuIGFycmF5IHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIHVzaW5nIGFuIG9wdGlvbmFsIHNjaGVkdWxlciB0byBlbnVtZXJhdGUgdGhlIGFycmF5LlxuICAqIEBkZXByZWNhdGVkIHVzZSBPYnNlcnZhYmxlLmZyb20gb3IgT2JzZXJ2YWJsZS5vZlxuICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSBlbnVtZXJhdGlvbiBvZiB0aGUgaW5wdXQgc2VxdWVuY2Ugb24uXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSBwdWxsZWQgZnJvbSB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBzZXF1ZW5jZS5cbiAgKi9cbiAgdmFyIG9ic2VydmFibGVGcm9tQXJyYXkgPSBPYnNlcnZhYmxlLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBGcm9tQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpXG4gIH07XG5cbiAgdmFyIEdlbmVyYXRlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoR2VuZXJhdGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlT2JzZXJ2YWJsZShzdGF0ZSwgY25kRm4sIGl0ckZuLCByZXNGbiwgcykge1xuICAgICAgdGhpcy5faW5pdGlhbFN0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9jbmRGbiA9IGNuZEZuO1xuICAgICAgdGhpcy5faXRyRm4gPSBpdHJGbjtcbiAgICAgIHRoaXMuX3Jlc0ZuID0gcmVzRm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgc3RhdGUuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm5ld1N0YXRlID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5faXRyRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLm5ld1N0YXRlID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLm5ld1N0YXRlLmUpOyB9XG4gICAgICB9XG4gICAgICB2YXIgaGFzUmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fY25kRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgIGlmIChoYXNSZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IoaGFzUmVzdWx0LmUpOyB9XG4gICAgICBpZiAoaGFzUmVzdWx0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9yZXNGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICBzdGF0ZS5vLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICByZWN1cnNlKHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZW5lcmF0ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBvOiBvLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgbmV3U3RhdGU6IHRoaXMuX2luaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9zLnNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHZW5lcmF0ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIEdlbmVyYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHJ1bm5pbmcgYSBzdGF0ZS1kcml2ZW4gbG9vcCBwcm9kdWNpbmcgdGhlIHNlcXVlbmNlJ3MgZWxlbWVudHMsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZ2VuZXJhdGUoMCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPCAxMDsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5nZW5lcmF0ZSgwLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8IDEwOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9LCBSeC5TY2hlZHVsZXIudGltZW91dCk7XG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQ29uZGl0aW9uIHRvIHRlcm1pbmF0ZSBnZW5lcmF0aW9uICh1cG9uIHJldHVybmluZyBmYWxzZSkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGUgSXRlcmF0aW9uIHN0ZXAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciBvbiB3aGljaCB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5jdXJyZW50VGhyZWFkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIGdlbmVyYXRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIE9ic2VydmFibGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEdlbmVyYXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZU9mIChzY2hlZHVsZXIsIGFycmF5KSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBGcm9tQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgLyoqXG4gICogIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSBpbnN0YW5jZSB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgcmVnYXJkbGVzcyBvZiBudW1iZXIgb3IgdHlwZSBvZiB0aGUgYXJndW1lbnRzLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgcHVsbGVkIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgKi9cbiAgT2JzZXJ2YWJsZS5vZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIG5ldyBGcm9tQXJyYXlPYnNlcnZhYmxlKGFyZ3MsIGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IE9ic2VydmFibGUgaW5zdGFuY2Ugd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIHJlZ2FyZGxlc3Mgb2YgbnVtYmVyIG9yIHR5cGUgb2YgdGhlIGFyZ3VtZW50cy5cbiAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIEEgc2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZyB0aGUgYXJndW1lbnRzLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgcHVsbGVkIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgKi9cbiAgT2JzZXJ2YWJsZS5vZldpdGhTY2hlZHVsZXIgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIG5ldyBGcm9tQXJyYXlPYnNlcnZhYmxlKGFyZ3MsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGNoYW5nZXMgdG8gYW4gYXJyYXkgdXNpbmcgQXJyYXkub2JzZXJ2ZS5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQW4gYXJyYXkgdG8gb2JzZXJ2ZSBjaGFuZ2VzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGNoYW5nZXMgdG8gYW4gYXJyYXkgZnJvbSBBcnJheS5vYnNlcnZlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5vZkFycmF5Q2hhbmdlcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5vYnNlcnZlIG9ubHkgYWNjZXB0cyBhcnJheXMuJyk7IH1cbiAgICBpZiAodHlwZW9mIEFycmF5Lm9ic2VydmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEFycmF5LnVub2JzZXJ2ZSAhPT0gJ2Z1bmN0aW9uJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5vYnNlcnZlIGlzIG5vdCBzdXBwb3J0ZWQgb24geW91ciBwbGF0Zm9ybScpIH1cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIGZ1bmN0aW9uIG9ic2VydmVyRm4oY2hhbmdlcykge1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBjaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGNoYW5nZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIEFycmF5Lm9ic2VydmUoYXJyYXksIG9ic2VydmVyRm4pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBBcnJheS51bm9ic2VydmUoYXJyYXksIG9ic2VydmVyRm4pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gY2hhbmdlcyB0byBhbiBvYmplY3QgdXNpbmcgT2JqZWN0Lm9ic2VydmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogQW4gb2JqZWN0IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBjaGFuZ2VzIHRvIGFuIG9iamVjdCBmcm9tIE9iamVjdC5vYnNlcnZlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5vZk9iamVjdENoYW5nZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqZWN0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpOyB9XG4gICAgaWYgKHR5cGVvZiBPYmplY3Qub2JzZXJ2ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LnVub2JzZXJ2ZSAhPT0gJ2Z1bmN0aW9uJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qub2JzZXJ2ZSBpcyBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgcGxhdGZvcm0nKSB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICBmdW5jdGlvbiBvYnNlcnZlckZuKGNoYW5nZXMpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChjaGFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3Qub2JzZXJ2ZShvYmosIG9ic2VydmVyRm4pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3QudW5vYnNlcnZlKG9iaiwgb2JzZXJ2ZXJGbik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBOZXZlck9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTmV2ZXJPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE5ldmVyT2JzZXJ2YWJsZSgpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE5ldmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5ldmVyT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBORVZFUl9PQlNFUlZBQkxFID0gbmV3IE5ldmVyT2JzZXJ2YWJsZSgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9uLXRlcm1pbmF0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlbm90ZSBhbiBpbmZpbml0ZSBkdXJhdGlvbiAoZS5nLiB3aGVuIHVzaW5nIHJlYWN0aXZlIGpvaW5zKS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2Ugb2JzZXJ2ZXJzIHdpbGwgbmV2ZXIgZ2V0IGNhbGxlZC5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlTmV2ZXIgPSBPYnNlcnZhYmxlLm5ldmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBORVZFUl9PQlNFUlZBQkxFO1xuICB9O1xuXG4gIHZhciBQYWlyc09ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUGFpcnNPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhaXJzT2JzZXJ2YWJsZShvLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fa2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qobywgb2JqLCBrZXlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZShpLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBvLm9uTmV4dChba2V5LCBvYmpba2V5XV0pO1xuICAgICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBQYWlyc09ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZSgwLCBzY2hlZHVsZU1ldGhvZChvLCB0aGlzLl9vLCB0aGlzLl9rZXlzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYWlyc09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ29udmVydCBhbiBvYmplY3QgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIFtrZXksIHZhbHVlXSBwYWlycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSBlbnVtZXJhdGlvbiBvZiB0aGUgaW5wdXQgc2VxdWVuY2Ugb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIFtrZXksIHZhbHVlXSBwYWlycyBmcm9tIHRoZSBvYmplY3QuXG4gICAqL1xuICBPYnNlcnZhYmxlLnBhaXJzID0gZnVuY3Rpb24gKG9iaiwgc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFBhaXJzT2JzZXJ2YWJsZShvYmosIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgICB2YXIgUmFuZ2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJhbmdlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSYW5nZU9ic2VydmFibGUoc3RhcnQsIGNvdW50LCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMucmFuZ2VDb3VudCA9IGNvdW50O1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wUmVjdXJzaXZlKHN0YXJ0LCBjb3VudCwgbykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AgKGksIHJlY3Vyc2UpIHtcbiAgICAgICAgaWYgKGkgPCBjb3VudCkge1xuICAgICAgICAgIG8ub25OZXh0KHN0YXJ0ICsgaSk7XG4gICAgICAgICAgcmVjdXJzZShpICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIFJhbmdlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoXG4gICAgICAgIDAsXG4gICAgICAgIGxvb3BSZWN1cnNpdmUodGhpcy5zdGFydCwgdGhpcy5yYW5nZUNvdW50LCBvKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJhbmdlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqICBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBpbnRlZ3JhbCBudW1iZXJzIHdpdGhpbiBhIHNwZWNpZmllZCByYW5nZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgb2JzZXJ2ZXIgbWVzc2FnZXMuXG4gICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW50ZWdlciBpbiB0aGUgc2VxdWVuY2UuXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2Ygc2VxdWVudGlhbCBpbnRlZ2VycyB0byBnZW5lcmF0ZS5cbiAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3Agb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5jdXJyZW50VGhyZWFkLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgYSByYW5nZSBvZiBzZXF1ZW50aWFsIGludGVncmFsIG51bWJlcnMuXG4gICovXG4gIE9ic2VydmFibGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGNvdW50LCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFJhbmdlT2JzZXJ2YWJsZShzdGFydCwgY291bnQsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFJlcGVhdE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVwZWF0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZXBlYXRPYnNlcnZhYmxlKHZhbHVlLCByZXBlYXRDb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnJlcGVhdENvdW50ID0gcmVwZWF0Q291bnQgPT0gbnVsbCA/IC0xIDogcmVwZWF0Q291bnQ7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFJlcGVhdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBzaW5rID0gbmV3IFJlcGVhdFNpbmsob2JzZXJ2ZXIsIHRoaXMpO1xuICAgICAgcmV0dXJuIHNpbmsucnVuKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXBlYXRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgZnVuY3Rpb24gUmVwZWF0U2luayhvYnNlcnZlciwgcGFyZW50KSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG5cbiAgUmVwZWF0U2luay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsIHZhbHVlID0gdGhpcy5wYXJlbnQudmFsdWU7XG4gICAgZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZShpLCByZWN1cnNlKSB7XG4gICAgICBpZiAoaSA9PT0gLTEgfHwgaSA+IDApIHtcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcbiAgICAgICAgaSA+IDAgJiYgaS0tO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IDApIHsgcmV0dXJuIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgIHJlY3Vyc2UoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LnNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZSh0aGlzLnBhcmVudC5yZXBlYXRDb3VudCwgbG9vcFJlY3Vyc2l2ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHJlcGVhdHMgdGhlIGdpdmVuIGVsZW1lbnQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBFbGVtZW50IHRvIHJlcGVhdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdENvdW50IFtPcHRpb25hXSBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkLCByZXBlYXRzIGluZGVmaW5pdGVseS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSBwcm9kdWNlciBsb29wIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuaW1tZWRpYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHJlcGVhdHMgdGhlIGdpdmVuIGVsZW1lbnQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gICAqL1xuICBPYnNlcnZhYmxlLnJlcGVhdCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwZWF0Q291bnQsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgUmVwZWF0T2JzZXJ2YWJsZSh2YWx1ZSwgcmVwZWF0Q291bnQsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIEp1c3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEp1c3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEp1c3RPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBKdXN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RhdGUgPSBbdGhpcy5fdmFsdWUsIG9dO1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlciA9PT0gaW1tZWRpYXRlU2NoZWR1bGVyID9cbiAgICAgICAgc2NoZWR1bGVJdGVtKG51bGwsIHN0YXRlKSA6XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgc2NoZWR1bGVJdGVtKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJdGVtKHMsIHN0YXRlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0ZVswXSwgb2JzZXJ2ZXIgPSBzdGF0ZVsxXTtcbiAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gSnVzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIGEgc2luZ2xlIGVsZW1lbnQsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAgKiAgVGhlcmUgaXMgYW4gYWxpYXMgY2FsbGVkICdqdXN0JyBvciBicm93c2VycyA8SUU5LlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBTaW5nbGUgZWxlbWVudCBpbiB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHNlbmQgdGhlIHNpbmdsZSBlbGVtZW50IG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuaW1tZWRpYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzaW5nbGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZVJldHVybiA9IE9ic2VydmFibGVbJ3JldHVybiddID0gT2JzZXJ2YWJsZS5qdXN0ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgSnVzdE9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFRocm93T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaHJvd09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGhyb3dPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaHJvd09ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0gW3RoaXMuX2Vycm9yLCBvXTtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIgPT09IGltbWVkaWF0ZVNjaGVkdWxlciA/XG4gICAgICAgIHNjaGVkdWxlSXRlbShudWxsLCBzdGF0ZSkgOlxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNjaGVkdWxlSXRlbSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzdGF0ZSkge1xuICAgICAgdmFyIGUgPSBzdGF0ZVswXSwgbyA9IHN0YXRlWzFdO1xuICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gVGhyb3dPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCB0ZXJtaW5hdGVzIHdpdGggYW4gZXhjZXB0aW9uLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCB0aGUgc2luZ2xlIG9uRXJyb3IgbWVzc2FnZS5cbiAgICogIFRoZXJlIGlzIGFuIGFsaWFzIHRvIHRoaXMgbWV0aG9kIGNhbGxlZCAndGhyb3dFcnJvcicgZm9yIGJyb3dzZXJzIDxJRTkuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGVycm9yIEFuIG9iamVjdCB1c2VkIGZvciB0aGUgc2VxdWVuY2UncyB0ZXJtaW5hdGlvbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gc2VuZCB0aGUgZXhjZXB0aW9uYWwgdGVybWluYXRpb24gY2FsbCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgdGVybWluYXRlcyBleGNlcHRpb25hbGx5IHdpdGggdGhlIHNwZWNpZmllZCBleGNlcHRpb24gb2JqZWN0LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVUaHJvdyA9IE9ic2VydmFibGVbJ3Rocm93J10gPSBmdW5jdGlvbiAoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBUaHJvd09ic2VydmFibGUoZXJyb3IsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFVzaW5nT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVXNpbmdPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFVzaW5nT2JzZXJ2YWJsZShyZXNGbiwgb2JzRm4pIHtcbiAgICAgIHRoaXMuX3Jlc0ZuID0gcmVzRm47XG4gICAgICB0aGlzLl9vYnNGbiA9IG9ic0ZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVXNpbmdPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgdmFyIHJlc291cmNlID0gdHJ5Q2F0Y2godGhpcy5fcmVzRm4pKCk7XG4gICAgICBpZiAocmVzb3VyY2UgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShvYnNlcnZhYmxlVGhyb3cocmVzb3VyY2UuZSkuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJlc291cmNlICYmIChkaXNwb3NhYmxlID0gcmVzb3VyY2UpO1xuICAgICAgdmFyIHNvdXJjZSA9IHRyeUNhdGNoKHRoaXMuX29ic0ZuKShyZXNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlID09PSBlcnJvck9iaikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUob2JzZXJ2YWJsZVRocm93KHNvdXJjZS5lKS5zdWJzY3JpYmUobyksIGRpc3Bvc2FibGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobyksIGRpc3Bvc2FibGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVXNpbmdPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGRlcGVuZHMgb24gYSByZXNvdXJjZSBvYmplY3QsIHdob3NlIGxpZmV0aW1lIGlzIHRpZWQgdG8gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlJ3MgbGlmZXRpbWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc291cmNlRmFjdG9yeSBGYWN0b3J5IGZ1bmN0aW9uIHRvIG9idGFpbiBhIHJlc291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JzZXJ2YWJsZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiB0byBvYnRhaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGRlcGVuZHMgb24gdGhlIG9idGFpbmVkIHJlc291cmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBsaWZldGltZSBjb250cm9scyB0aGUgbGlmZXRpbWUgb2YgdGhlIGRlcGVuZGVudCByZXNvdXJjZSBvYmplY3QuXG4gICAqL1xuICBPYnNlcnZhYmxlLnVzaW5nID0gZnVuY3Rpb24gKHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IFVzaW5nT2JzZXJ2YWJsZShyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvcGFnYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgcmVhY3RzIGZpcnN0LlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHJpZ2h0U291cmNlIFNlY29uZCBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHN1cmZhY2VzIGVpdGhlciBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2VzLCB3aGljaGV2ZXIgcmVhY3RlZCBmaXJzdC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5hbWIgPSBmdW5jdGlvbiAocmlnaHRTb3VyY2UpIHtcbiAgICB2YXIgbGVmdFNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGNob2ljZSxcbiAgICAgICAgbGVmdENob2ljZSA9ICdMJywgcmlnaHRDaG9pY2UgPSAnUicsXG4gICAgICAgIGxlZnRTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgcmlnaHRTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgaXNQcm9taXNlKHJpZ2h0U291cmNlKSAmJiAocmlnaHRTb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmlnaHRTb3VyY2UpKTtcblxuICAgICAgZnVuY3Rpb24gY2hvaWNlTCgpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgICAgICBjaG9pY2UgPSBsZWZ0Q2hvaWNlO1xuICAgICAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaG9pY2VSKCkge1xuICAgICAgICBpZiAoIWNob2ljZSkge1xuICAgICAgICAgIGNob2ljZSA9IHJpZ2h0Q2hvaWNlO1xuICAgICAgICAgIGxlZnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0U3Vic2NyaWJlID0gb2JzZXJ2ZXJDcmVhdGUoXG4gICAgICAgIGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgY2hvaWNlTCgpO1xuICAgICAgICAgIGNob2ljZSA9PT0gbGVmdENob2ljZSAmJiBvYnNlcnZlci5vbk5leHQobGVmdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY2hvaWNlTCgpO1xuICAgICAgICAgIGNob2ljZSA9PT0gbGVmdENob2ljZSAmJiBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2hvaWNlTCgpO1xuICAgICAgICAgIGNob2ljZSA9PT0gbGVmdENob2ljZSAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdmFyIHJpZ2h0U3Vic2NyaWJlID0gb2JzZXJ2ZXJDcmVhdGUoXG4gICAgICAgIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgIGNob2ljZVIoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IHJpZ2h0Q2hvaWNlICYmIG9ic2VydmVyLm9uTmV4dChyaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY2hvaWNlUigpO1xuICAgICAgICAgIGNob2ljZSA9PT0gcmlnaHRDaG9pY2UgJiYgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNob2ljZVIoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IHJpZ2h0Q2hvaWNlICYmIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGxlZnRTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShsZWZ0U291cmNlLnN1YnNjcmliZShsZWZ0U3Vic2NyaWJlKSk7XG4gICAgICByaWdodFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHJpZ2h0U291cmNlLnN1YnNjcmliZShyaWdodFN1YnNjcmliZSkpO1xuXG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUobGVmdFN1YnNjcmlwdGlvbiwgcmlnaHRTdWJzY3JpcHRpb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFtYihwLCBjKSB7IHJldHVybiBwLmFtYihjKTsgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGVzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCByZWFjdHMgZmlyc3QuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc3VyZmFjZXMgYW55IG9mIHRoZSBnaXZlbiBzZXF1ZW5jZXMsIHdoaWNoZXZlciByZWFjdGVkIGZpcnN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5hbWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IG9ic2VydmFibGVOZXZlcigpLCBpdGVtcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBpdGVtcyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpdGVtcyA9IG5ldyBBcnJheShpdGVtcyk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgaXRlbXNbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhY2MgPSBhbWIoYWNjLCBpdGVtc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgdmFyIENhdGNoT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ2F0Y2hPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENhdGNoT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDYXRjaE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGQxID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkMSk7XG4gICAgICBkMS5zZXREaXNwb3NhYmxlKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgQ2F0Y2hPYnNlcnZlcihvLCBzdWJzY3JpcHRpb24sIHRoaXMuX2ZuKSkpO1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhdGNoT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBDYXRjaE9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENhdGNoT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ2F0Y2hPYnNlcnZlcihvLCBzLCBmbikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDYXRjaE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fby5vbk5leHQoeCk7IH07XG4gICAgQ2F0Y2hPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuICAgIENhdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9mbikoZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcblxuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX3Muc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShyZXN1bHQuc3Vic2NyaWJlKHRoaXMuX28pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhdGNoT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gaGFuZGxlck9yU2Vjb25kIEV4Y2VwdGlvbiBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGdpdmVuIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkIGluIHRoZSBmaXJzdCBzZXF1ZW5jZSwgb3IgYSBzZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHByb2R1Y2UgcmVzdWx0cyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGluIHRoZSBmaXJzdCBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgZmlyc3Qgc2VxdWVuY2UncyBlbGVtZW50cywgZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnRzIG9mIHRoZSBoYW5kbGVyIHNlcXVlbmNlIGluIGNhc2UgYW4gZXhjZXB0aW9uIG9jY3VycmVkLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvWydjYXRjaCddID0gZnVuY3Rpb24gKGhhbmRsZXJPclNlY29uZCkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGhhbmRsZXJPclNlY29uZCkgPyBuZXcgQ2F0Y2hPYnNlcnZhYmxlKHRoaXMsIGhhbmRsZXJPclNlY29uZCkgOiBvYnNlcnZhYmxlQ2F0Y2goW3RoaXMsIGhhbmRsZXJPclNlY29uZF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtBcnJheSB8IEFyZ3VtZW50c30gYXJncyBBcmd1bWVudHMgb3IgYW4gYXJyYXkgdG8gdXNlIGFzIHRoZSBuZXh0IHNlcXVlbmNlIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBlbGVtZW50cyBmcm9tIGNvbnNlY3V0aXZlIHNvdXJjZSBzZXF1ZW5jZXMgdW50aWwgYSBzb3VyY2Ugc2VxdWVuY2UgdGVybWluYXRlcyBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZUNhdGNoID0gT2JzZXJ2YWJsZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgaXRlbXMgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaXRlbXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBpdGVtc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIH1cbiAgICByZXR1cm4gZW51bWVyYWJsZU9mKGl0ZW1zKS5jYXRjaEVycm9yKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFueSBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgUHJvbWlzZXMgcHJvZHVjZXMgYW4gZWxlbWVudC5cbiAgICogVGhpcyBjYW4gYmUgaW4gdGhlIGZvcm0gb2YgYW4gYXJndW1lbnQgbGlzdCBvZiBvYnNlcnZhYmxlcyBvciBhbiBhcnJheS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogMSAtIG9icyA9IG9ic2VydmFibGUuY29tYmluZUxhdGVzdChvYnMxLCBvYnMyLCBvYnMzLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgICogMiAtIG9icyA9IG9ic2VydmFibGUuY29tYmluZUxhdGVzdChbb2JzMSwgb2JzMiwgb2JzM10sIGZ1bmN0aW9uIChvMSwgbzIsIG8zKSB7IHJldHVybiBvMSArIG8yICsgbzM7IH0pO1xuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbWJpbmVMYXRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzWzBdLnVuc2hpZnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmFsc2VGYWN0b3J5KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgZnVuY3Rpb24gYXJndW1lbnRzVG9BcnJheSgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICB2YXIgQ29tYmluZUxhdGVzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29tYmluZUxhdGVzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdE9ic2VydmFibGUocGFyYW1zLCBjYikge1xuICAgICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgICAgdGhpcy5fY2IgPSBjYjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9wYXJhbXMubGVuZ3RoLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBoYXNWYWx1ZTogYXJyYXlJbml0aWFsaXplKGxlbiwgZmFsc2VGYWN0b3J5KSxcbiAgICAgICAgaGFzVmFsdWVBbGw6IGZhbHNlLFxuICAgICAgICBpc0RvbmU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgIHZhbHVlczogbmV3IEFycmF5KGxlbilcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX3BhcmFtc1tpXSwgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICAgIGlzUHJvbWlzZShzb3VyY2UpICYmIChzb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc291cmNlKSk7XG4gICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobmV3IENvbWJpbmVMYXRlc3RPYnNlcnZlcihvYnNlcnZlciwgaSwgdGhpcy5fY2IsIHN0YXRlKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29tYmluZUxhdGVzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQ29tYmluZUxhdGVzdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdE9ic2VydmVyKG8sIGksIGNiLCBzdGF0ZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9pID0gaTtcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90VGhlU2FtZShpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGopIHtcbiAgICAgICAgcmV0dXJuIGogIT09IGk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIENvbWJpbmVMYXRlc3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zdGF0ZS52YWx1ZXNbdGhpcy5faV0gPSB4O1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuX3N0YXRlLmhhc1ZhbHVlQWxsIHx8ICh0aGlzLl9zdGF0ZS5oYXNWYWx1ZUFsbCA9IHRoaXMuX3N0YXRlLmhhc1ZhbHVlLmV2ZXJ5KGlkZW50aXR5KSkpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX2NiKS5hcHBseShudWxsLCB0aGlzLl9zdGF0ZS52YWx1ZXMpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICB0aGlzLl9vLm9uTmV4dChyZXMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZS5pc0RvbmUuZmlsdGVyKG5vdFRoZVNhbWUodGhpcy5faSkpLmV2ZXJ5KGlkZW50aXR5KSkge1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbWJpbmVMYXRlc3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzRG9uZVt0aGlzLl9pXSA9IHRydWU7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0RvbmUuZXZlcnkoaWRlbnRpdHkpICYmIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogTWVyZ2VzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2hlbmV2ZXIgYW55IG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlcyBvciBQcm9taXNlcyBwcm9kdWNlcyBhbiBlbGVtZW50LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAxIC0gb2JzID0gUnguT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KG9iczEsIG9iczIsIG9iczMsIGZ1bmN0aW9uIChvMSwgbzIsIG8zKSB7IHJldHVybiBvMSArIG8yICsgbzM7IH0pO1xuICAqIDIgLSBvYnMgPSBSeC5PYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAqL1xuICB2YXIgY29tYmluZUxhdGVzdCA9IE9ic2VydmFibGUuY29tYmluZUxhdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihhcmdzW2xlbiAtIDFdKSA/IGFyZ3MucG9wKCkgOiBhcmd1bWVudHNUb0FycmF5O1xuICAgIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgKGFyZ3MgPSBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV3IENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlKGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuICBUaGlzIHRha2VzIGluIGVpdGhlciBhbiBhcnJheSBvciB2YXJpYWJsZSBhcmd1bWVudHMgdG8gY29uY2F0ZW5hdGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggZ2l2ZW4gc2VxdWVuY2UsIGluIHNlcXVlbnRpYWwgb3JkZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvcih2YXIgYXJncyA9IFtdLCBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3MucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBvYnNlcnZhYmxlQ29uY2F0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBDb25jYXRPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb25jYXRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb25jYXRPYnNlcnZlcihzLCBmbikge1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ29uY2F0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9zLm8ub25OZXh0KHgpOyB9O1xuICAgIENvbmNhdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuICAgIENvbmNhdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3MuaSsrOyB0aGlzLl9mbih0aGlzLl9zKTsgfTtcblxuICAgIHJldHVybiBDb25jYXRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIENvbmNhdE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29uY2F0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb25jYXRPYnNlcnZhYmxlKHNvdXJjZXMpIHtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUgKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUuZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxuICAgICAgaWYgKHN0YXRlLmkgPT09IHN0YXRlLnNvdXJjZXMubGVuZ3RoKSB7IHJldHVybiBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7IH1cblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvbWlzZVxuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHN0YXRlLnNvdXJjZXNbc3RhdGUuaV07XG4gICAgICBpc1Byb21pc2UoY3VycmVudFZhbHVlKSAmJiAoY3VycmVudFZhbHVlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShuZXcgQ29uY2F0T2JzZXJ2ZXIoc3RhdGUsIHJlY3Vyc2UpKSk7XG4gICAgfVxuXG4gICAgQ29uY2F0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIGRpc3Bvc2FibGUgPSBkaXNwb3NhYmxlQ3JlYXRlKG5vb3ApO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBvOiBvLFxuICAgICAgICBpOiAwLFxuICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbixcbiAgICAgICAgZGlzcG9zYWJsZTogZGlzcG9zYWJsZSxcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlc1xuICAgICAgfTtcblxuICAgICAgdmFyIGNhbmNlbGFibGUgPSBpbW1lZGlhdGVTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlUmVjdXJzaXZlKTtcbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgZGlzcG9zYWJsZSwgY2FuY2VsYWJsZV0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29uY2F0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlcy5cbiAgICogQHBhcmFtIHtBcnJheSB8IEFyZ3VtZW50c30gYXJncyBBcmd1bWVudHMgb3IgYW4gYXJyYXkgdG8gY29uY2F0IHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdpdmVuIHNlcXVlbmNlLCBpbiBzZXF1ZW50aWFsIG9yZGVyLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVDb25jYXQgPSBPYnNlcnZhYmxlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb25jYXRPYnNlcnZhYmxlKGFyZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgZWFjaCBvYnNlcnZlZCBpbm5lciBzZXF1ZW5jZSwgaW4gc2VxdWVudGlhbCBvcmRlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb25jYXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2UoMSk7XG4gIH07XG5cbiAgdmFyIE1lcmdlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWVyZ2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gTWVyZ2VPYnNlcnZhYmxlKHNvdXJjZSwgbWF4Q29uY3VycmVudCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm1heENvbmN1cnJlbnQgPSBtYXhDb25jdXJyZW50O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTWVyZ2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGcuYWRkKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VPYnNlcnZlcihvYnNlcnZlciwgdGhpcy5tYXhDb25jdXJyZW50LCBnKSkpO1xuICAgICAgcmV0dXJuIGc7XG4gICAgfTtcblxuICAgIHJldHVybiBNZXJnZU9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBNZXJnZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBmdW5jdGlvbiBNZXJnZU9ic2VydmVyKG8sIG1heCwgZykge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgdGhpcy5nID0gZztcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5xID0gW107XG4gICAgICB0aGlzLmFjdGl2ZUNvdW50ID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKE1lcmdlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBNZXJnZU9ic2VydmVyLnByb3RvdHlwZS5oYW5kbGVTdWJzY3JpYmUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgIHZhciBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuZy5hZGQoc2FkKTtcbiAgICAgIGlzUHJvbWlzZSh4cykgJiYgKHhzID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHhzKSk7XG4gICAgICBzYWQuc2V0RGlzcG9zYWJsZSh4cy5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIodGhpcywgc2FkKSkpO1xuICAgIH07XG5cbiAgICBNZXJnZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGlubmVyU291cmNlKSB7XG4gICAgICBpZih0aGlzLmFjdGl2ZUNvdW50IDwgdGhpcy5tYXgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDb3VudCsrO1xuICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmliZShpbm5lclNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnEucHVzaChpbm5lclNvdXJjZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuby5vbkVycm9yKGUpOyB9O1xuICAgIE1lcmdlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kb25lID0gdHJ1ZTsgdGhpcy5hY3RpdmVDb3VudCA9PT0gMCAmJiB0aGlzLm8ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIocGFyZW50LCBzYWQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5zYWQgPSBzYWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMucGFyZW50Lm8ub25OZXh0KHgpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5wYXJlbnQuby5vbkVycm9yKGUpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFyZW50LmcucmVtb3ZlKHRoaXMuc2FkKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaGFuZGxlU3Vic2NyaWJlKHRoaXMucGFyZW50LnEuc2hpZnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudC5hY3RpdmVDb3VudC0tO1xuICAgICAgICB0aGlzLnBhcmVudC5kb25lICYmIHRoaXMucGFyZW50LmFjdGl2ZUNvdW50ID09PSAwICYmIHRoaXMucGFyZW50Lm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIE1lcmdlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgbGltaXRpbmcgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHN1YnNjcmlwdGlvbnMgdG8gaW5uZXIgc2VxdWVuY2VzLlxuICAqIE9yIG1lcmdlcyB0d28gb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhIHNpbmdsZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7TWl4ZWR9IFttYXhDb25jdXJyZW50T3JPdGhlcl0gTWF4aW11bSBudW1iZXIgb2YgaW5uZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkgb3IgdGhlIHNlY29uZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IG1lcmdlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGlubmVyIHNlcXVlbmNlcy5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1lcmdlID0gZnVuY3Rpb24gKG1heENvbmN1cnJlbnRPck90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtYXhDb25jdXJyZW50T3JPdGhlciAhPT0gJ251bWJlcicgP1xuICAgICAgb2JzZXJ2YWJsZU1lcmdlKHRoaXMsIG1heENvbmN1cnJlbnRPck90aGVyKSA6XG4gICAgICBuZXcgTWVyZ2VPYnNlcnZhYmxlKHRoaXMsIG1heENvbmN1cnJlbnRPck90aGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogTWVyZ2VzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhIHNpbmdsZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBUaGUgc2NoZWR1bGVyIGlzIG9wdGlvbmFsIGFuZCBpZiBub3Qgc3BlY2lmaWVkLCB0aGUgaW1tZWRpYXRlIHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBtZXJnZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlcy5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlTWVyZ2UgPSBPYnNlcnZhYmxlLm1lcmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlZHVsZXIsIHNvdXJjZXMgPSBbXSwgaSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyO1xuICAgICAgZm9yKGkgPSAxOyBpIDwgbGVuOyBpKyspIHsgc291cmNlcy5wdXNoKGFyZ3VtZW50c1tpXSk7IH1cbiAgICB9IGVsc2UgaWYgKGlzU2NoZWR1bGVyKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvcihpID0gMTsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXMucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcbiAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXMucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZXNbMF0pKSB7XG4gICAgICBzb3VyY2VzID0gc291cmNlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmFibGVPZihzY2hlZHVsZXIsIHNvdXJjZXMpLm1lcmdlQWxsKCk7XG4gIH07XG5cbiAgdmFyIE1lcmdlQWxsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWVyZ2VBbGxPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNZXJnZUFsbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGcgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLCBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBnLmFkZChtKTtcbiAgICAgIG0uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsT2JzZXJ2ZXIobywgZykpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VBbGxPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE1lcmdlQWxsT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT2JzZXJ2ZXIobywgZykge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuZyA9IGc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKE1lcmdlQWxsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBNZXJnZUFsbE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oaW5uZXJTb3VyY2UpIHtcbiAgICAgIHZhciBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuZy5hZGQoc2FkKTtcbiAgICAgIGlzUHJvbWlzZShpbm5lclNvdXJjZSkgJiYgKGlubmVyU291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGlubmVyU291cmNlKSk7XG4gICAgICBzYWQuc2V0RGlzcG9zYWJsZShpbm5lclNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIodGhpcywgc2FkKSkpO1xuICAgIH07XG5cbiAgICBNZXJnZUFsbE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VBbGxPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuZy5sZW5ndGggPT09IDEgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIocGFyZW50LCBzYWQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5zYWQgPSBzYWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnBhcmVudC5vLm9uTmV4dCh4KTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMucGFyZW50Lm8ub25FcnJvcihlKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFyZW50LmcucmVtb3ZlKHRoaXMuc2FkKTtcbiAgICAgIHRoaXMucGFyZW50LmRvbmUgJiYgdGhpcy5wYXJlbnQuZy5sZW5ndGggPT09IDEgJiYgdGhpcy5wYXJlbnQuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VBbGxPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogTWVyZ2VzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IG1lcmdlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGlubmVyIHNlcXVlbmNlcy5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1lcmdlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTWVyZ2VBbGxPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBDb21wb3NpdGVFcnJvciA9IFJ4LkNvbXBvc2l0ZUVycm9yID0gZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgdGhpcy5pbm5lckVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVGhpcyBjb250YWlucyBtdWx0aXBsZSBlcnJvcnMuIENoZWNrIHRoZSBpbm5lckVycm9ycyc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgQ29tcG9zaXRlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBDb21wb3NpdGVFcnJvci5wcm90b3R5cGUubmFtZSA9ICdDb21wb3NpdGVFcnJvcic7XG5cbiAgdmFyIE1lcmdlRGVsYXlFcnJvck9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgc3RhdGUgPSB7IGlzU3RvcHBlZDogZmFsc2UsIGVycm9yczogW10sIG86IG8gfTtcblxuICAgICAgZ3JvdXAuYWRkKG0pO1xuICAgICAgbS5zZXREaXNwb3NhYmxlKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIoZ3JvdXAsIHN0YXRlKSkpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHJldHVybiBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlRGVsYXlFcnJvck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyKGdyb3VwLCBzdGF0ZSkge1xuICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDb21wbGV0aW9uKG8sIGVycm9ycykge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG8ub25FcnJvcihlcnJvcnNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgby5vbkVycm9yKG5ldyBDb21wb3NpdGVFcnJvcihlcnJvcnMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBNZXJnZURlbGF5RXJyb3JPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgaW5uZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX2dyb3VwLmFkZChpbm5lcik7XG5cbiAgICAgIC8vIENoZWNrIGZvciBwcm9taXNlcyBzdXBwb3J0XG4gICAgICBpc1Byb21pc2UoeCkgJiYgKHggPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoeCkpO1xuICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZSh4LnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihpbm5lciwgdGhpcy5fZ3JvdXAsIHRoaXMuX3N0YXRlKSkpO1xuICAgIH07XG5cbiAgICBNZXJnZURlbGF5RXJyb3JPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fc3RhdGUuZXJyb3JzLnB1c2goZSk7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLl9ncm91cC5sZW5ndGggPT09IDEgJiYgc2V0Q29tcGxldGlvbih0aGlzLl9zdGF0ZS5vLCB0aGlzLl9zdGF0ZS5lcnJvcnMpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIoaW5uZXIsIGdyb3VwLCBzdGF0ZSkge1xuICAgICAgdGhpcy5faW5uZXIgPSBpbm5lcjtcbiAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3N0YXRlLm8ub25OZXh0KHgpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmVycm9ycy5wdXNoKGUpO1xuICAgICAgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMuX2lubmVyKTtcbiAgICAgIHRoaXMuX3N0YXRlLmlzU3RvcHBlZCAmJiB0aGlzLl9ncm91cC5sZW5ndGggPT09IDEgJiYgc2V0Q29tcGxldGlvbih0aGlzLl9zdGF0ZS5vLCB0aGlzLl9zdGF0ZS5lcnJvcnMpO1xuICAgIH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMuX2lubmVyKTtcbiAgICAgIHRoaXMuX3N0YXRlLmlzU3RvcHBlZCAmJiB0aGlzLl9ncm91cC5sZW5ndGggPT09IDEgJiYgc2V0Q29tcGxldGlvbih0aGlzLl9zdGF0ZS5vLCB0aGlzLl9zdGF0ZS5lcnJvcnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIEZsYXR0ZW5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLCBpbiBhIHdheSB0aGF0IGFsbG93cyBhbiBPYnNlcnZlciB0b1xuICAqIHJlY2VpdmUgYWxsIHN1Y2Nlc3NmdWxseSBlbWl0dGVkIGl0ZW1zIGZyb20gYWxsIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZXMgd2l0aG91dCBiZWluZyBpbnRlcnJ1cHRlZCBieVxuICAqIGFuIGVycm9yIG5vdGlmaWNhdGlvbiBmcm9tIG9uZSBvZiB0aGVtLlxuICAqXG4gICogVGhpcyBiZWhhdmVzIGxpa2UgT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VBbGwgZXhjZXB0IHRoYXQgaWYgYW55IG9mIHRoZSBtZXJnZWQgT2JzZXJ2YWJsZXMgbm90aWZ5IG9mIGFuXG4gICogZXJyb3IgdmlhIHRoZSBPYnNlcnZlcidzIG9uRXJyb3IsIG1lcmdlRGVsYXlFcnJvciB3aWxsIHJlZnJhaW4gZnJvbSBwcm9wYWdhdGluZyB0aGF0XG4gICogZXJyb3Igbm90aWZpY2F0aW9uIHVudGlsIGFsbCBvZiB0aGUgbWVyZ2VkIE9ic2VydmFibGVzIGhhdmUgZmluaXNoZWQgZW1pdHRpbmcgaXRlbXMuXG4gICogQHBhcmFtIHtBcnJheSB8IEFyZ3VtZW50c30gYXJncyBBcmd1bWVudHMgb3IgYW4gYXJyYXkgdG8gbWVyZ2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgb2YgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIE9ic2VydmFibGVcbiAgKi9cbiAgT2JzZXJ2YWJsZS5tZXJnZURlbGF5RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBvYnNlcnZhYmxlT2YobnVsbCwgYXJncyk7XG4gICAgcmV0dXJuIG5ldyBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlKHNvdXJjZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnRpbnVlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGVybWluYXRlZCBub3JtYWxseSBvciBieSBhbiBleGNlcHRpb24gd2l0aCB0aGUgbmV4dCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNlY29uZCBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHByb2R1Y2UgcmVzdWx0cyBhZnRlciB0aGUgZmlyc3Qgc2VxdWVuY2UgdGVybWluYXRlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb25jYXRlbmF0ZXMgdGhlIGZpcnN0IGFuZCBzZWNvbmQgc2VxdWVuY2UsIGV2ZW4gaWYgdGhlIGZpcnN0IHNlcXVlbmNlIHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5vbkVycm9yUmVzdW1lTmV4dCA9IGZ1bmN0aW9uIChzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1NlY29uZCBvYnNlcnZhYmxlIGlzIHJlcXVpcmVkJyk7IH1cbiAgICByZXR1cm4gb25FcnJvclJlc3VtZU5leHQoW3RoaXMsIHNlY29uZF0pO1xuICB9O1xuXG4gIHZhciBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIGlmIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHN0YXRlLnNvdXJjZXNbc3RhdGUucG9zKytdO1xuICAgICAgICBpc1Byb21pc2UoY3VycmVudCkgJiYgKGN1cnJlbnQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoY3VycmVudCkpO1xuICAgICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBzdGF0ZS5zdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnQuc3Vic2NyaWJlKG5ldyBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgICBzdGF0ZSA9IHtwb3M6IDAsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBvOiBvLCBzb3VyY2VzOiB0aGlzLnNvdXJjZXMgfSxcbiAgICAgICAgICBjYW5jZWxsYWJsZSA9IGltbWVkaWF0ZVNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgc2NoZWR1bGVNZXRob2QpO1xuXG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBjYW5jZWxsYWJsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9yZWN1cnNlID0gcmVjdXJzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9zdGF0ZS5vLm9uTmV4dCh4KTsgfTtcbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVjdXJzZSh0aGlzLl9zdGF0ZSk7IH07XG4gICAgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZWN1cnNlKHRoaXMuX3N0YXRlKTsgfTtcblxuICAgIHJldHVybiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIG5vcm1hbGx5IG9yIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29uY2F0ZW5hdGVzIHRoZSBzb3VyY2Ugc2VxdWVuY2VzLCBldmVuIGlmIGEgc2VxdWVuY2UgdGVybWluYXRlcyBleGNlcHRpb25hbGx5LlxuICAgKi9cbiAgdmFyIG9uRXJyb3JSZXN1bWVOZXh0ID0gT2JzZXJ2YWJsZS5vbkVycm9yUmVzdW1lTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHNvdXJjZXMgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgc291cmNlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXNbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUoc291cmNlcyk7XG4gIH07XG5cbiAgdmFyIFNraXBVbnRpbE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNraXBVbnRpbE9ic2VydmFibGUoc291cmNlLCBvdGhlcikge1xuICAgICAgdGhpcy5fcyA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX28gPSBpc1Byb21pc2Uob3RoZXIpID8gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKG90aGVyKSA6IG90aGVyO1xuICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcFVudGlsT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBsZWZ0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBsZWZ0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5fcy5zdWJzY3JpYmUobmV3IFNraXBVbnRpbFNvdXJjZU9ic2VydmVyKG8sIHRoaXMpKSk7XG5cbiAgICAgIGlzUHJvbWlzZSh0aGlzLl9vKSAmJiAodGhpcy5fbyA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh0aGlzLl9vKSk7XG5cbiAgICAgIHZhciByaWdodFN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgcmlnaHRTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZSh0aGlzLl9vLnN1YnNjcmliZShuZXcgU2tpcFVudGlsT3RoZXJPYnNlcnZlcihvLCB0aGlzLCByaWdodFN1YnNjcmlwdGlvbikpKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGxlZnRTdWJzY3JpcHRpb24sIHJpZ2h0U3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBVbnRpbE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcFVudGlsU291cmNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsU291cmNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsU291cmNlT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3AuX29wZW4gJiYgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wLl9vcGVuICYmIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgU2tpcFVudGlsT3RoZXJPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwVW50aWxPdGhlck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIobywgcCwgcikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX3IgPSByO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcFVudGlsT3RoZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3AuX29wZW4gPSB0cnVlO1xuICAgICAgdGhpcy5fci5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGVycik7XG4gICAgfTtcblxuICAgIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fci5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxPdGhlck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgYWZ0ZXIgdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlIHwgUHJvbWlzZX0gb3RoZXIgVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHRyaWdnZXJzIHByb3BhZ2F0aW9uIG9mIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgcG9pbnQgdGhlIG90aGVyIHNlcXVlbmNlIHRyaWdnZXJlZCBwcm9wYWdhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5za2lwVW50aWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFNraXBVbnRpbE9ic2VydmFibGUodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIHZhciBTd2l0Y2hPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN3aXRjaE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3dpdGNoT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU3dpdGNoT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgaW5uZXIgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLCBzID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hPYnNlcnZlcihvLCBpbm5lcikpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHMsIGlubmVyKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoU3dpdGNoT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE9ic2VydmVyKG8sIGlubmVyKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxhdGVzdCA9IDA7XG4gICAgICB0aGlzLmhhc0xhdGVzdCA9IGZhbHNlO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGlubmVyU291cmNlKSB7XG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBpZCA9ICsrdGhpcy5sYXRlc3Q7XG4gICAgICB0aGlzLmhhc0xhdGVzdCA9IHRydWU7XG4gICAgICB0aGlzLmlubmVyLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBpc1Byb21pc2UoaW5uZXJTb3VyY2UpICYmIChpbm5lclNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShpbm5lclNvdXJjZSkpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKGlubmVyU291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcih0aGlzLCBpZCkpKTtcbiAgICB9O1xuXG4gICAgU3dpdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBTd2l0Y2hPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICF0aGlzLmhhc0xhdGVzdCAmJiB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihwYXJlbnQsIGlkKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnBhcmVudC5sYXRlc3QgPT09IHRoaXMuaWQgJiYgdGhpcy5wYXJlbnQuby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMucGFyZW50LmxhdGVzdCA9PT0gdGhpcy5pZCAmJiB0aGlzLnBhcmVudC5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5sYXRlc3QgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaGFzTGF0ZXN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50LnN0b3BwZWQgJiYgdGhpcy5wYXJlbnQuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU3dpdGNoT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqIFRyYW5zZm9ybXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjaW5nIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgYXQgYW55IHBvaW50IGluIHRpbWUgcHJvZHVjZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBtb3N0IHJlY2VudCBpbm5lciBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90b1snc3dpdGNoJ10gPSBvYnNlcnZhYmxlUHJvdG8uc3dpdGNoTGF0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3dpdGNoT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVGFrZVVudGlsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlVW50aWxPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT2JzZXJ2YWJsZShzb3VyY2UsIG90aGVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMub3RoZXIgPSBpc1Byb21pc2Uob3RoZXIpID8gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKG90aGVyKSA6IG90aGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZVVudGlsT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG8pLFxuICAgICAgICB0aGlzLm90aGVyLnN1YnNjcmliZShuZXcgVGFrZVVudGlsT2JzZXJ2ZXIobykpXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZVVudGlsT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUYWtlVW50aWxPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlVW50aWxPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VVbnRpbE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBUYWtlVW50aWxPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuXG4gICAgVGFrZVVudGlsT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gbm9vcDtcblxuICAgIHJldHVybiBUYWtlVW50aWxPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1bnRpbCB0aGUgb3RoZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBwcm9kdWNlcyBhIHZhbHVlLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGUgfCBQcm9taXNlfSBvdGhlciBPYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB0ZXJtaW5hdGVzIHByb3BhZ2F0aW9uIG9mIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UgdXAgdG8gdGhlIHBvaW50IHRoZSBvdGhlciBzZXF1ZW5jZSBpbnRlcnJ1cHRlZCBmdXJ0aGVyIHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VVbnRpbCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBuZXcgVGFrZVVudGlsT2JzZXJ2YWJsZSh0aGlzLCBvdGhlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmFsc2VGYWN0b3J5KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgZnVuY3Rpb24gYXJndW1lbnRzVG9BcnJheSgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICB2YXIgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFdpdGhMYXRlc3RGcm9tT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUoc291cmNlLCBzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgdGhpcy5fcyA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3NzID0gc291cmNlcztcbiAgICAgIHRoaXMuX2NiID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGxlbiA9IHRoaXMuX3NzLmxlbmd0aDtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaGFzVmFsdWU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgIGhhc1ZhbHVlQWxsOiBmYWxzZSxcbiAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXkobGVuKVxuICAgICAgfTtcblxuICAgICAgdmFyIG4gPSB0aGlzLl9zcy5sZW5ndGgsIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobiArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG90aGVyID0gdGhpcy5fc3NbaV0sIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBpc1Byb21pc2Uob3RoZXIpICYmIChvdGhlciA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikpO1xuICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShvdGhlci5zdWJzY3JpYmUobmV3IFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlcihvLCBpLCBzdGF0ZSkpKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uc1tpXSA9IHNhZDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dGVyU2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBvdXRlclNhZC5zZXREaXNwb3NhYmxlKHRoaXMuX3Muc3Vic2NyaWJlKG5ldyBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyKG8sIHRoaXMuX2NiLCBzdGF0ZSkpKTtcbiAgICAgIHN1YnNjcmlwdGlvbnNbbl0gPSBvdXRlclNhZDtcblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdpdGhMYXRlc3RGcm9tT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIobywgaSwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3N0YXRlLnZhbHVlc1t0aGlzLl9pXSA9IHg7XG4gICAgICB0aGlzLl9zdGF0ZS5oYXNWYWx1ZVt0aGlzLl9pXSA9IHRydWU7XG4gICAgICB0aGlzLl9zdGF0ZS5oYXNWYWx1ZUFsbCA9IHRoaXMuX3N0YXRlLmhhc1ZhbHVlLmV2ZXJ5KGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gbm9vcDtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXIobywgY2IsIHN0YXRlKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgYWxsVmFsdWVzID0gW3hdLmNvbmNhdCh0aGlzLl9zdGF0ZS52YWx1ZXMpO1xuICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5oYXNWYWx1ZUFsbCkgeyByZXR1cm47IH1cbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9jYikuYXBwbHkobnVsbCwgYWxsVmFsdWVzKTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICB0aGlzLl9vLm9uTmV4dChyZXMpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFdpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiBvbmx5IHdoZW4gdGhlIChmaXJzdCkgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYW4gZWxlbWVudC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aXRoTGF0ZXN0RnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzJyk7IH1cblxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKGFyZ3NbbGVuIC0gMV0pID8gYXJncy5wb3AoKSA6IGFyZ3VtZW50c1RvQXJyYXk7XG4gICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiAoYXJncyA9IGFyZ3NbMF0pO1xuXG4gICAgcmV0dXJuIG5ldyBXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUodGhpcywgYXJncywgcmVzdWx0U2VsZWN0b3IpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGVtcHR5QXJyYXlGYWN0b3J5KCkgeyByZXR1cm4gW107IH1cblxuICB2YXIgWmlwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhaaXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFppcE9ic2VydmFibGUoc291cmNlcywgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2VzO1xuICAgICAgdGhpcy5fY2IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFppcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIG4gPSB0aGlzLl9zLmxlbmd0aCxcbiAgICAgICAgICBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGRvbmUgPSBhcnJheUluaXRpYWxpemUobiwgZmFsc2VGYWN0b3J5KSxcbiAgICAgICAgICBxID0gYXJyYXlJbml0aWFsaXplKG4sIGVtcHR5QXJyYXlGYWN0b3J5KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX3NbaV0sIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zW2ldID0gc2FkO1xuICAgICAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG5ldyBaaXBPYnNlcnZlcihvYnNlcnZlciwgaSwgdGhpcywgcSwgZG9uZSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFppcE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgWmlwT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFppcE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFppcE9ic2VydmVyKG8sIGksIHAsIHEsIGQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX3EgPSBxO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3RFbXB0eSh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH1cbiAgICBmdW5jdGlvbiBzaGlmdEVhY2goeCkgeyByZXR1cm4geC5zaGlmdCgpOyB9XG4gICAgZnVuY3Rpb24gbm90VGhlU2FtZShpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGopIHtcbiAgICAgICAgcmV0dXJuIGogIT09IGk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIFppcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3FbdGhpcy5faV0ucHVzaCh4KTtcbiAgICAgIGlmICh0aGlzLl9xLmV2ZXJ5KG5vdEVtcHR5KSkge1xuICAgICAgICB2YXIgcXVldWVkVmFsdWVzID0gdGhpcy5fcS5tYXAoc2hpZnRFYWNoKTtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3AuX2NiKS5hcHBseShudWxsLCBxdWV1ZWRWYWx1ZXMpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICB0aGlzLl9vLm9uTmV4dChyZXMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9kLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBaaXBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBaaXBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZFt0aGlzLl9pXSA9IHRydWU7XG4gICAgICB0aGlzLl9kLmV2ZXJ5KGlkZW50aXR5KSAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBaaXBPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFsbCBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgYW4gYXJyYXkgaGF2ZSBwcm9kdWNlZCBhbiBlbGVtZW50IGF0IGEgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICogVGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJndW1lbnRzIG11c3QgYmUgYSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggc2VyaWVzIG9mIGVsZW1lbnRzIGF0IGNvcnJlc3BvbmRpbmcgaW5kZXhlcyBpbiB0aGUgYXJncy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgYXJncyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by56aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cycpOyB9XG5cbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihhcmdzW2xlbiAtIDFdKSA/IGFyZ3MucG9wKCkgOiBhcmd1bWVudHNUb0FycmF5O1xuICAgIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgKGFyZ3MgPSBhcmdzWzBdKTtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIGFyZ3MudW5zaGlmdChwYXJlbnQpO1xuXG4gICAgcmV0dXJuIG5ldyBaaXBPYnNlcnZhYmxlKGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICAvKipcbiAgICogTWVyZ2VzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2hlbmV2ZXIgYWxsIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXZlIHByb2R1Y2VkIGFuIGVsZW1lbnQgYXQgYSBjb3JyZXNwb25kaW5nIGluZGV4LlxuICAgKiBAcGFyYW0gYXJndW1lbnRzIE9ic2VydmFibGUgc291cmNlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgRnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHNlcmllcyBvZiBlbGVtZW50cyBhdCBjb3JyZXNwb25kaW5nIGluZGV4ZXMgaW4gdGhlIHNvdXJjZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBPYnNlcnZhYmxlLnppcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGFyZ3MgPSBpc0Z1bmN0aW9uKGFyZ3NbMV0pID8gYXJnc1swXS5jb25jYXQoYXJnc1sxXSkgOiBhcmdzWzBdO1xuICAgIH1cbiAgICB2YXIgZmlyc3QgPSBhcmdzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIGZpcnN0LnppcC5hcHBseShmaXJzdCwgYXJncyk7XG4gIH07XG5cbmZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5mdW5jdGlvbiBlbXB0eUFycmF5RmFjdG9yeSgpIHsgcmV0dXJuIFtdOyB9XG5mdW5jdGlvbiBhcmd1bWVudHNUb0FycmF5KCkge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICByZXR1cm4gYXJncztcbn1cblxudmFyIFppcEl0ZXJhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgaW5oZXJpdHMoWmlwSXRlcmFibGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICBmdW5jdGlvbiBaaXBJdGVyYWJsZU9ic2VydmFibGUoc291cmNlcywgY2IpIHtcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuX2NiID0gY2I7XG4gICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gIH1cblxuICBaaXBJdGVyYWJsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5zb3VyY2VzLCBsZW4gPSBzb3VyY2VzLmxlbmd0aCwgc3Vic2NyaXB0aW9ucyA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcTogYXJyYXlJbml0aWFsaXplKGxlbiwgZW1wdHlBcnJheUZhY3RvcnkpLFxuICAgICAgZG9uZTogYXJyYXlJbml0aWFsaXplKGxlbiwgZmFsc2VGYWN0b3J5KSxcbiAgICAgIGNiOiB0aGlzLl9jYixcbiAgICAgIG86IG9cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgKGlzQXJyYXlMaWtlKHNvdXJjZSkgfHwgaXNJdGVyYWJsZShzb3VyY2UpKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb20oc291cmNlKSk7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uc1tpXSA9IHNhZDtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShuZXcgWmlwSXRlcmFibGVPYnNlcnZlcihzdGF0ZSwgaSkpKTtcbiAgICAgIH0oaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFppcEl0ZXJhYmxlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZUJhc2UpKTtcblxudmFyIFppcEl0ZXJhYmxlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICBpbmhlcml0cyhaaXBJdGVyYWJsZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICBmdW5jdGlvbiBaaXBJdGVyYWJsZU9ic2VydmVyKHMsIGkpIHtcbiAgICB0aGlzLl9zID0gcztcbiAgICB0aGlzLl9pID0gaTtcbiAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdEVtcHR5KHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfVxuICBmdW5jdGlvbiBzaGlmdEVhY2goeCkgeyByZXR1cm4geC5zaGlmdCgpOyB9XG4gIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgaikge1xuICAgICAgcmV0dXJuIGogIT09IGk7XG4gICAgfTtcbiAgfVxuXG4gIFppcEl0ZXJhYmxlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgIHRoaXMuX3MucVt0aGlzLl9pXS5wdXNoKHgpO1xuICAgIGlmICh0aGlzLl9zLnEuZXZlcnkobm90RW1wdHkpKSB7XG4gICAgICB2YXIgcXVldWVkVmFsdWVzID0gdGhpcy5fcy5xLm1hcChzaGlmdEVhY2gpLFxuICAgICAgICAgIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3MuY2IpLmFwcGx5KG51bGwsIHF1ZXVlZFZhbHVlcyk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fcy5vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICB0aGlzLl9zLm8ub25OZXh0KHJlcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zLmRvbmUuZmlsdGVyKG5vdFRoZVNhbWUodGhpcy5faSkpLmV2ZXJ5KGlkZW50aXR5KSkge1xuICAgICAgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIFppcEl0ZXJhYmxlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fcy5vLm9uRXJyb3IoZSk7IH07XG5cbiAgWmlwSXRlcmFibGVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3MuZG9uZVt0aGlzLl9pXSA9IHRydWU7XG4gICAgdGhpcy5fcy5kb25lLmV2ZXJ5KGlkZW50aXR5KSAmJiB0aGlzLl9zLm8ub25Db21wbGV0ZWQoKTtcbiAgfTtcblxuICByZXR1cm4gWmlwSXRlcmFibGVPYnNlcnZlcjtcbn0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFsbCBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgYW4gYXJyYXkgaGF2ZSBwcm9kdWNlZCBhbiBlbGVtZW50IGF0IGEgY29ycmVzcG9uZGluZyBpbmRleC5cbiAqIFRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGFyZ3VtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHNlcmllcyBvZiBlbGVtZW50cyBhdCBjb3JyZXNwb25kaW5nIGluZGV4ZXMgaW4gdGhlIGFyZ3MuXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBhcmdzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICovXG5vYnNlcnZhYmxlUHJvdG8uemlwSXRlcmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudHMnKTsgfVxuXG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcblxuICB2YXIgcGFyZW50ID0gdGhpcztcbiAgYXJncy51bnNoaWZ0KHBhcmVudCk7XG4gIHJldHVybiBuZXcgWmlwSXRlcmFibGVPYnNlcnZhYmxlKGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbn07XG5cbiAgZnVuY3Rpb24gYXNPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdWJzY3JpYmUobykgeyByZXR1cm4gc291cmNlLnN1YnNjcmliZShvKTsgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgSGlkZXMgdGhlIGlkZW50aXR5IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaGlkZXMgdGhlIGlkZW50aXR5IG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShhc09ic2VydmFibGUodGhpcyksIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoeCkgeyByZXR1cm4geC50b0FycmF5KCk7IH1cbiAgZnVuY3Rpb24gbm90RW1wdHkoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSBidWZmZXJzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiBlbGVtZW50IGNvdW50IGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTGVuZ3RoIG9mIGVhY2ggYnVmZmVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NraXBdIE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGJldHdlZW4gY3JlYXRpb24gb2YgY29uc2VjdXRpdmUgYnVmZmVycy4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byB0aGUgY291bnQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGJ1ZmZlcnMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyV2l0aENvdW50ID0gb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlckNvdW50ID0gZnVuY3Rpb24gKGNvdW50LCBza2lwKSB7XG4gICAgdHlwZW9mIHNraXAgIT09ICdudW1iZXInICYmIChza2lwID0gY291bnQpO1xuICAgIHJldHVybiB0aGlzLndpbmRvd1dpdGhDb3VudChjb3VudCwgc2tpcClcbiAgICAgIC5mbGF0TWFwKHRvQXJyYXkpXG4gICAgICAuZmlsdGVyKG5vdEVtcHR5KTtcbiAgfTtcblxuICB2YXIgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIobykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVtYXRlcmlhbGl6ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRGVtYXRlcmlhbGl6ZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZW1hdGVyaWFsaXplT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB4LmFjY2VwdCh0aGlzLl9vKTsgfTtcbiAgICBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIERlbWF0ZXJpYWxpemVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gRGVtYXRlcmlhbGl6ZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogRGVtYXRlcmlhbGl6ZXMgdGhlIGV4cGxpY2l0IG5vdGlmaWNhdGlvbiB2YWx1ZXMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBpbXBsaWNpdCBub3RpZmljYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBleGhpYml0aW5nIHRoZSBiZWhhdmlvciBjb3JyZXNwb25kaW5nIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBub3RpZmljYXRpb24gdmFsdWVzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRlbWF0ZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUoc291cmNlLCBrZXlGbiwgY29tcGFyZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5rZXlGbiA9IGtleUZuO1xuICAgICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIobywgdGhpcy5rZXlGbiwgdGhpcy5jb21wYXJlcikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyKG8sIGtleUZuLCBjb21wYXJlcikge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMua2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICAgIHRoaXMuaGFzQ3VycmVudEtleSA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50S2V5ID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGtleSA9IHgsIGNvbXBhcmVyRXF1YWxzO1xuICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5rZXlGbikpIHtcbiAgICAgICAga2V5ID0gdHJ5Q2F0Y2godGhpcy5rZXlGbikoeCk7XG4gICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLm8ub25FcnJvcihrZXkuZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0N1cnJlbnRLZXkpIHtcbiAgICAgICAgY29tcGFyZXJFcXVhbHMgPSB0cnlDYXRjaCh0aGlzLmNvbXBhcmVyKSh0aGlzLmN1cnJlbnRLZXksIGtleSk7XG4gICAgICAgIGlmIChjb21wYXJlckVxdWFscyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKGNvbXBhcmVyRXF1YWxzLmUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaGFzQ3VycmVudEtleSB8fCAhY29tcGFyZXJFcXVhbHMpIHtcbiAgICAgICAgdGhpcy5oYXNDdXJyZW50S2V5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50S2V5ID0ga2V5O1xuICAgICAgICB0aGlzLm8ub25OZXh0KHgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLm8ub25FcnJvcihlKTtcbiAgICB9O1xuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIG9ubHkgZGlzdGluY3QgY29udGlndW91cyBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGtleUZuIGFuZCB0aGUgY29tcGFyZXIuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW2tleUZuXSBBIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbXBhcmlzb24ga2V5IGZvciBlYWNoIGVsZW1lbnQuIElmIG5vdCBwcm92aWRlZCwgaXQgcHJvamVjdHMgdGhlIHZhbHVlLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gRXF1YWxpdHkgY29tcGFyZXIgZm9yIGNvbXB1dGVkIGtleSB2YWx1ZXMuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gYW4gZXF1YWxpdHkgY29tcGFyZXIgZnVuY3Rpb24uXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb25seSBjb250YWluaW5nIHRoZSBkaXN0aW5jdCBjb250aWd1b3VzIGVsZW1lbnRzLCBiYXNlZCBvbiBhIGNvbXB1dGVkIGtleSB2YWx1ZSwgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZGlzdGluY3RVbnRpbENoYW5nZWQgPSBmdW5jdGlvbiAoa2V5Rm4sIGNvbXBhcmVyKSB7XG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdENvbXBhcmVyKTtcbiAgICByZXR1cm4gbmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZSh0aGlzLCBrZXlGbiwgY29tcGFyZXIpO1xuICB9O1xuXG4gIHZhciBUYXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRhcE9ic2VydmFibGUsX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYXBPYnNlcnZhYmxlKHNvdXJjZSwgb2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fb04gPSBvYnNlcnZlck9yT25OZXh0O1xuICAgICAgdGhpcy5fb0UgPSBvbkVycm9yO1xuICAgICAgdGhpcy5fb0MgPSBvbkNvbXBsZXRlZDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRhcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy50ID0gIXAuX29OIHx8IGlzRnVuY3Rpb24ocC5fb04pID9cbiAgICAgICAgb2JzZXJ2ZXJDcmVhdGUocC5fb04gfHwgbm9vcCwgcC5fb0UgfHwgbm9vcCwgcC5fb0MgfHwgbm9vcCkgOlxuICAgICAgICBwLl9vTjtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy50Lm9uTmV4dCkuY2FsbCh0aGlzLnQsIHgpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgdGhpcy5vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICB0aGlzLm8ub25OZXh0KHgpO1xuICAgIH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLnQub25FcnJvcikuY2FsbCh0aGlzLnQsIGVycik7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICB0aGlzLm8ub25FcnJvcihlcnIpO1xuICAgIH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy50Lm9uQ29tcGxldGVkKS5jYWxsKHRoaXMudCk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRhcE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiAgSW52b2tlcyBhbiBhY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgaW52b2tlcyBhbiBhY3Rpb24gdXBvbiBncmFjZWZ1bCBvciBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZywgbG9nZ2luZywgZXRjLiBvZiBxdWVyeSBiZWhhdmlvciBieSBpbnRlcmNlcHRpbmcgdGhlIG1lc3NhZ2Ugc3RyZWFtIHRvIHJ1biBhcmJpdHJhcnkgYWN0aW9ucyBmb3IgbWVzc2FnZXMgb24gdGhlIHBpcGVsaW5lLlxuICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYnNlcnZlcn0gb2JzZXJ2ZXJPck9uTmV4dCBBY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgYW4gby5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gIEFjdGlvbiB0byBpbnZva2UgdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVXNlZCBpZiBvbmx5IHRoZSBvYnNlcnZlck9yT25OZXh0IHBhcmFtZXRlciBpcyBhbHNvIGEgZnVuY3Rpb24uXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW29uQ29tcGxldGVkXSAgQWN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLiBVc2VkIGlmIG9ubHkgdGhlIG9ic2VydmVyT3JPbk5leHQgcGFyYW1ldGVyIGlzIGFsc28gYSBmdW5jdGlvbi5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoIHRoZSBzaWRlLWVmZmVjdGluZyBiZWhhdmlvciBhcHBsaWVkLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ2RvJ10gPSBvYnNlcnZhYmxlUHJvdG8udGFwID0gb2JzZXJ2YWJsZVByb3RvLmRvQWN0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgcmV0dXJuIG5ldyBUYXBPYnNlcnZhYmxlKHRoaXMsIG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKTtcbiAgfTtcblxuICAvKipcbiAgKiAgSW52b2tlcyBhbiBhY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZywgbG9nZ2luZywgZXRjLiBvZiBxdWVyeSBiZWhhdmlvciBieSBpbnRlcmNlcHRpbmcgdGhlIG1lc3NhZ2Ugc3RyZWFtIHRvIHJ1biBhcmJpdHJhcnkgYWN0aW9ucyBmb3IgbWVzc2FnZXMgb24gdGhlIHBpcGVsaW5lLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uTmV4dCBBY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRvT25OZXh0ID0gb2JzZXJ2YWJsZVByb3RvLnRhcE9uTmV4dCA9IGZ1bmN0aW9uIChvbk5leHQsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy50YXAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKHgpIHsgb25OZXh0LmNhbGwodGhpc0FyZywgeCk7IH0gOiBvbk5leHQpO1xuICB9O1xuXG4gIC8qKlxuICAqICBJbnZva2VzIGFuIGFjdGlvbiB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nLCBsb2dnaW5nLCBldGMuIG9mIHF1ZXJ5IGJlaGF2aW9yIGJ5IGludGVyY2VwdGluZyB0aGUgbWVzc2FnZSBzdHJlYW0gdG8gcnVuIGFyYml0cmFyeSBhY3Rpb25zIGZvciBtZXNzYWdlcyBvbiB0aGUgcGlwZWxpbmUuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBBY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRvT25FcnJvciA9IG9ic2VydmFibGVQcm90by50YXBPbkVycm9yID0gZnVuY3Rpb24gKG9uRXJyb3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy50YXAobm9vcCwgdHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKGUpIHsgb25FcnJvci5jYWxsKHRoaXNBcmcsIGUpOyB9IDogb25FcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBY3Rpb24gdG8gaW52b2tlIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRvT25Db21wbGV0ZWQgPSBvYnNlcnZhYmxlUHJvdG8udGFwT25Db21wbGV0ZWQgPSBmdW5jdGlvbiAob25Db21wbGV0ZWQsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy50YXAobm9vcCwgbnVsbCwgdHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKCkgeyBvbkNvbXBsZXRlZC5jYWxsKHRoaXNBcmcpOyB9IDogb25Db21wbGV0ZWQpO1xuICB9O1xuXG4gIHZhciBGaW5hbGx5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmluYWxseU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRmluYWxseU9ic2VydmFibGUoc291cmNlLCBmbiwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGJpbmRDYWxsYmFjayhmbiwgdGhpc0FyZywgMCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGaW5hbGx5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZCA9IHRyeUNhdGNoKHRoaXMuc291cmNlLnN1YnNjcmliZSkuY2FsbCh0aGlzLnNvdXJjZSwgbyk7XG4gICAgICBpZiAoZCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fZm4oKTtcbiAgICAgICAgdGhyb3dlcihkLmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEZpbmFsbHlEaXNwb3NhYmxlKGQsIHRoaXMuX2ZuKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRmluYWxseURpc3Bvc2FibGUocywgZm4pIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgIH1cbiAgICBGaW5hbGx5RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9zLmRpc3Bvc2UpLmNhbGwodGhpcy5fcyk7XG4gICAgICAgIHRoaXMuX2ZuKCk7XG4gICAgICAgIHJlcyA9PT0gZXJyb3JPYmogJiYgdGhyb3dlcihyZXMuZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGaW5hbGx5T2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBJbnZva2VzIGEgc3BlY2lmaWVkIGFjdGlvbiBhZnRlciB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdGVybWluYXRlcyBncmFjZWZ1bGx5IG9yIGV4Y2VwdGlvbmFsbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmFsbHlBY3Rpb24gQWN0aW9uIHRvIGludm9rZSBhZnRlciB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdGVybWluYXRlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNvdXJjZSBzZXF1ZW5jZSB3aXRoIHRoZSBhY3Rpb24taW52b2tpbmcgdGVybWluYXRpb24gYmVoYXZpb3IgYXBwbGllZC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90b1snZmluYWxseSddID0gZnVuY3Rpb24gKGFjdGlvbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmluYWxseU9ic2VydmFibGUodGhpcywgYWN0aW9uLCB0aGlzQXJnKTtcbiAgfTtcblxuICB2YXIgSWdub3JlRWxlbWVudHNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSWdub3JlRWxlbWVudHNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIobykpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5vbk5leHQgPSBub29wO1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZighdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm8ub25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZighdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHsgdGhpcy5pc1N0b3BwZWQgPSB0cnVlOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgSWdub3JlcyBhbGwgZWxlbWVudHMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBsZWF2aW5nIG9ubHkgdGhlIHRlcm1pbmF0aW9uIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gZW1wdHkgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNpZ25hbHMgdGVybWluYXRpb24sIHN1Y2Nlc3NmdWwgb3IgZXhjZXB0aW9uYWwsIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uaWdub3JlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJZ25vcmVFbGVtZW50c09ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIE1hdGVyaWFsaXplT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWF0ZXJpYWxpemVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE1hdGVyaWFsaXplT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXRlcmlhbGl6ZU9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hdGVyaWFsaXplT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBNYXRlcmlhbGl6ZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhNYXRlcmlhbGl6ZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxpemVPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9vLm9uTmV4dChub3RpZmljYXRpb25DcmVhdGVPbk5leHQoeCkpIH07XG4gICAgTWF0ZXJpYWxpemVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uTmV4dChub3RpZmljYXRpb25DcmVhdGVPbkVycm9yKGUpKTsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuICAgIE1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25Db21wbGV0ZWQoKSk7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBNYXRlcmlhbGl6ZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIE1hdGVyaWFsaXplcyB0aGUgaW1wbGljaXQgbm90aWZpY2F0aW9ucyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFzIGV4cGxpY2l0IG5vdGlmaWNhdGlvbiB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIG1hdGVyaWFsaXplZCBub3RpZmljYXRpb24gdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5tYXRlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE1hdGVyaWFsaXplT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJlcGVhdHMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLiBJZiB0aGUgcmVwZWF0IGNvdW50IGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBzZXF1ZW5jZSByZXBlYXRzIGluZGVmaW5pdGVseS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXBlYXRDb3VudF0gIE51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHNlcXVlbmNlLiBJZiBub3QgcHJvdmlkZWQsIHJlcGVhdHMgdGhlIHNlcXVlbmNlIGluZGVmaW5pdGVseS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNlcXVlbmNlIHJlcGVhdGVkbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gKHJlcGVhdENvdW50KSB7XG4gICAgcmV0dXJuIGVudW1lcmFibGVSZXBlYXQodGhpcywgcmVwZWF0Q291bnQpLmNvbmNhdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUmVwZWF0cyB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMgb3IgdW50aWwgaXQgc3VjY2Vzc2Z1bGx5IHRlcm1pbmF0ZXMuIElmIHRoZSByZXRyeSBjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCBpdCByZXRyaWVzIGluZGVmaW5pdGVseS5cbiAgICogIE5vdGUgaWYgeW91IGVuY291bnRlciBhbiBlcnJvciBhbmQgd2FudCBpdCB0byByZXRyeSBvbmNlLCB0aGVuIHlvdSBtdXN0IHVzZSAucmV0cnkoMik7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gcmV0cmllZCA9IHJldHJ5LnJlcGVhdCgpO1xuICAgKiAgdmFyIHJlcyA9IHJldHJpZWQgPSByZXRyeS5yZXBlYXQoMik7XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV0cnlDb3VudF0gIE51bWJlciBvZiB0aW1lcyB0byByZXRyeSB0aGUgc2VxdWVuY2UuIElmIG5vdCBwcm92aWRlZCwgcmV0cnkgdGhlIHNlcXVlbmNlIGluZGVmaW5pdGVseS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2UgcmVwZWF0ZWRseSB1bnRpbCBpdCB0ZXJtaW5hdGVzIHN1Y2Nlc3NmdWxseS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5yZXRyeSA9IGZ1bmN0aW9uIChyZXRyeUNvdW50KSB7XG4gICAgcmV0dXJuIGVudW1lcmFibGVSZXBlYXQodGhpcywgcmV0cnlDb3VudCkuY2F0Y2hFcnJvcigpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAnQEBpdGVyYXRvcic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgUmV0cnlXaGVuT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVEaXNwb3NhYmxlKHN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0Rpc3Bvc2VkOiBmYWxzZSxcbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJldHJ5V2hlbk9ic2VydmFibGUoc291cmNlLCBub3RpZmllcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoUmV0cnlXaGVuT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIFJldHJ5V2hlbk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGV4Y2VwdGlvbnMgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBub3RpZmllciA9IG5ldyBTdWJqZWN0KCksXG4gICAgICAgIGhhbmRsZWQgPSB0aGlzLl9ub3RpZmllcihleGNlcHRpb25zKSxcbiAgICAgICAgbm90aWZpY2F0aW9uRGlzcG9zYWJsZSA9IGhhbmRsZWQuc3Vic2NyaWJlKG5vdGlmaWVyKTtcblxuICAgICAgdmFyIGUgPSB0aGlzLnNvdXJjZVsnQEBpdGVyYXRvciddKCk7XG5cbiAgICAgIHZhciBzdGF0ZSA9IHsgaXNEaXNwb3NlZDogZmFsc2UgfSxcbiAgICAgICAgbGFzdEVycm9yLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIGNhbmNlbGFibGUgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKG51bGwsIGZ1bmN0aW9uIChfLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5pc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgY3VycmVudEl0ZW0gPSBlLm5leHQoKTtcblxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkge1xuICAgICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIG8ub25FcnJvcihsYXN0RXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRJdGVtLnZhbHVlO1xuICAgICAgICBpc1Byb21pc2UoY3VycmVudFZhbHVlKSAmJiAoY3VycmVudFZhbHVlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICAgIHZhciBvdXRlciA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICB2YXIgaW5uZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUobmV3IEJpbmFyeURpc3Bvc2FibGUoaW5uZXIsIG91dGVyKSk7XG4gICAgICAgIG91dGVyLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbih4KSB7IG8ub25OZXh0KHgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChleG4pIHtcbiAgICAgICAgICAgIGlubmVyLnNldERpc3Bvc2FibGUobm90aWZpZXIuc3Vic2NyaWJlKHJlY3Vyc2UsIGZ1bmN0aW9uKGV4KSB7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihleCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBleGNlcHRpb25zLm9uTmV4dChleG4pO1xuICAgICAgICAgICAgb3V0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IG8ub25Db21wbGV0ZWQoKTsgfSkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW25vdGlmaWNhdGlvbkRpc3Bvc2FibGUsIHN1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSwgY3JlYXRlRGlzcG9zYWJsZShzdGF0ZSldKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJldHJ5V2hlbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBvYnNlcnZhYmxlUHJvdG8ucmV0cnlXaGVuID0gZnVuY3Rpb24gKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXRyeVdoZW5PYnNlcnZhYmxlKHJlcGVhdCh0aGlzKSwgbm90aWZpZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAnQEBpdGVyYXRvcic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgUmVwZWF0V2hlbk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGlzcG9zYWJsZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXBlYXRXaGVuT2JzZXJ2YWJsZShzb3VyY2UsIG5vdGlmaWVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX25vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhSZXBlYXRXaGVuT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIFJlcGVhdFdoZW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjb21wbGV0aW9ucyA9IG5ldyBTdWJqZWN0KCksXG4gICAgICAgIG5vdGlmaWVyID0gbmV3IFN1YmplY3QoKSxcbiAgICAgICAgaGFuZGxlZCA9IHRoaXMuX25vdGlmaWVyKGNvbXBsZXRpb25zKSxcbiAgICAgICAgbm90aWZpY2F0aW9uRGlzcG9zYWJsZSA9IGhhbmRsZWQuc3Vic2NyaWJlKG5vdGlmaWVyKTtcblxuICAgICAgdmFyIGUgPSB0aGlzLnNvdXJjZVsnQEBpdGVyYXRvciddKCk7XG5cbiAgICAgIHZhciBzdGF0ZSA9IHsgaXNEaXNwb3NlZDogZmFsc2UgfSxcbiAgICAgICAgbGFzdEVycm9yLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIGNhbmNlbGFibGUgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKG51bGwsIGZ1bmN0aW9uIChfLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5pc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgY3VycmVudEl0ZW0gPSBlLm5leHQoKTtcblxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkge1xuICAgICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIG8ub25FcnJvcihsYXN0RXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRJdGVtLnZhbHVlO1xuICAgICAgICBpc1Byb21pc2UoY3VycmVudFZhbHVlKSAmJiAoY3VycmVudFZhbHVlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICAgIHZhciBvdXRlciA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICB2YXIgaW5uZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUobmV3IEJpbmFyeURpc3Bvc2FibGUoaW5uZXIsIG91dGVyKSk7XG4gICAgICAgIG91dGVyLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbih4KSB7IG8ub25OZXh0KHgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChleG4pIHsgby5vbkVycm9yKGV4bik7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbm5lci5zZXREaXNwb3NhYmxlKG5vdGlmaWVyLnN1YnNjcmliZShyZWN1cnNlLCBmdW5jdGlvbihleCkge1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY29tcGxldGlvbnMub25OZXh0KG51bGwpO1xuICAgICAgICAgICAgb3V0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtub3RpZmljYXRpb25EaXNwb3NhYmxlLCBzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXBlYXRXaGVuT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIG9ic2VydmFibGVQcm90by5yZXBlYXRXaGVuID0gZnVuY3Rpb24gKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXBlYXRXaGVuT2JzZXJ2YWJsZShyZXBlYXQodGhpcyksIG5vdGlmaWVyKTtcbiAgfTtcblxuICB2YXIgU2Nhbk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2Nhbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2Nhbk9ic2VydmFibGUoc291cmNlLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICB0aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNjYW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2Nhbk9ic2VydmVyKG8sdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2Nhbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2Nhbk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTY2FuT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2Nhbk9ic2VydmVyKG8sIHBhcmVudCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fZm4gPSBwYXJlbnQuYWNjdW11bGF0b3I7XG4gICAgICB0aGlzLl9ocyA9IHBhcmVudC5oYXNTZWVkO1xuICAgICAgdGhpcy5fcyA9IHBhcmVudC5zZWVkO1xuICAgICAgdGhpcy5faGEgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2EgPSBudWxsO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2Nhbk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICF0aGlzLl9odiAmJiAodGhpcy5faHYgPSB0cnVlKTtcbiAgICAgIGlmICh0aGlzLl9oYSkge1xuICAgICAgICB0aGlzLl9hID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHRoaXMuX2EsIHgsIHRoaXMuX2ksIHRoaXMuX3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYSA9IHRoaXMuX2hzID8gdHJ5Q2F0Y2godGhpcy5fZm4pKHRoaXMuX3MsIHgsIHRoaXMuX2ksIHRoaXMuX3ApIDogeDtcbiAgICAgICAgdGhpcy5faGEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2EgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IodGhpcy5fYS5lKTsgfVxuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fYSk7XG4gICAgICB0aGlzLl9pKys7XG4gICAgfTtcblxuICAgIFNjYW5PYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBTY2FuT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICF0aGlzLl9odiAmJiB0aGlzLl9ocyAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9zKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjYW5PYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCByZXR1cm5zIGVhY2ggaW50ZXJtZWRpYXRlIHJlc3VsdC4gVGhlIG9wdGlvbmFsIHNlZWQgdmFsdWUgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgKiAgRm9yIGFnZ3JlZ2F0aW9uIGJlaGF2aW9yIHdpdGggbm8gaW50ZXJtZWRpYXRlIHJlc3VsdHMsIHNlZSBPYnNlcnZhYmxlLmFnZ3JlZ2F0ZS5cbiAgKiBAcGFyYW0ge01peGVkfSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gYWNjdW11bGF0b3IgQW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBvbiBlYWNoIGVsZW1lbnQuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2NhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzU2VlZCA9IGZhbHNlLCBzZWVkLCBhY2N1bXVsYXRvciA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaGFzU2VlZCA9IHRydWU7XG4gICAgICBzZWVkID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNjYW5PYnNlcnZhYmxlKHRoaXMsIGFjY3VtdWxhdG9yLCBoYXNTZWVkLCBzZWVkKTtcbiAgfTtcblxuICB2YXIgU2tpcExhc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwTGFzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcExhc3RPYnNlcnZhYmxlKHNvdXJjZSwgYykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBMYXN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwTGFzdE9ic2VydmVyKG8sIHRoaXMuX2MpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwTGFzdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwTGFzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0T2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fcS5wdXNoKHgpO1xuICAgICAgdGhpcy5fcS5sZW5ndGggPiB0aGlzLl9jICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX3Euc2hpZnQoKSk7XG4gICAgfTtcblxuICAgIFNraXBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU2tpcExhc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcExhc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBCeXBhc3NlcyBhIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSB0aGUgZmlyc3QgYGNvdW50YCBlbGVtZW50cy4gQXMgbW9yZSBlbGVtZW50cyBhcmVcbiAgICogIHJlY2VpdmVkLCBlbGVtZW50cyBhcmUgdGFrZW4gZnJvbSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGUgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkLlxuICAgKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJ5cGFzcyBhdCB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSBlbGVtZW50cyBleGNlcHQgZm9yIHRoZSBieXBhc3NlZCBvbmVzIGF0IHRoZSBlbmQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcExhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgcmV0dXJuIG5ldyBTa2lwTGFzdE9ic2VydmFibGUodGhpcywgY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJlcGVuZHMgYSBzZXF1ZW5jZSBvZiB2YWx1ZXMgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIHNjaGVkdWxlciBhbmQgYW4gYXJndW1lbnQgbGlzdCBvZiB2YWx1ZXMgdG8gcHJlcGVuZC5cbiAgICogIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gc291cmNlLnN0YXJ0V2l0aCgxLCAyLCAzKTtcbiAgICogIHZhciByZXMgPSBzb3VyY2Uuc3RhcnRXaXRoKFJ4LlNjaGVkdWxlci50aW1lb3V0LCAxLCAyLCAzKTtcbiAgICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3MgVGhlIHNwZWNpZmllZCB2YWx1ZXMgdG8gcHJlcGVuZCB0byB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZVxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSBwcmVwZW5kZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zdGFydFdpdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlcywgc2NoZWR1bGVyLCBzdGFydCA9IDA7XG4gICAgaWYgKCEhYXJndW1lbnRzLmxlbmd0aCAmJiBpc1NjaGVkdWxlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcbiAgICB9XG4gICAgZm9yKHZhciBhcmdzID0gW10sIGkgPSBzdGFydCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3MucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgcmV0dXJuIG9ic2VydmFibGVDb25jYXQuYXBwbHkobnVsbCwgW29ic2VydmFibGVGcm9tQXJyYXkoYXJncywgc2NoZWR1bGVyKSwgdGhpc10pO1xuICB9O1xuXG4gIHZhciBUYWtlTGFzdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlTGFzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0T2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fcS5wdXNoKHgpO1xuICAgICAgdGhpcy5fcS5sZW5ndGggPiB0aGlzLl9jICYmIHRoaXMuX3Euc2hpZnQoKTtcbiAgICB9O1xuXG4gICAgVGFrZUxhc3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUYWtlTGFzdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodGhpcy5fcS5sZW5ndGggPiAwKSB7IHRoaXMuX28ub25OZXh0KHRoaXMuX3Euc2hpZnQoKSk7IH1cbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VMYXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgYnVmZmVyIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIGNvdW50IGVsZW1lbnRzLiBVcG9uIGNvbXBsZXRpb24gb2ZcbiAgICogIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIHRoaXMgYnVmZmVyIGlzIGRyYWluZWQgb24gdGhlIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgdGhlIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZSBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlTGFzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlTGFzdE9ic2VydmVyKG8sIGNvdW50KSk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgVGFrZUxhc3RCdWZmZXJPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RCdWZmZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdEJ1ZmZlck9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlTGFzdEJ1ZmZlck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9xLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVGFrZUxhc3RCdWZmZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fcSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlTGFzdEJ1ZmZlck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjb250aWd1b3VzIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBidWZmZXIgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgY291bnQgZWxlbWVudHMuIFVwb24gY29tcGxldGlvbiBvZiB0aGVcbiAgICogIHNvdXJjZSBzZXF1ZW5jZSwgdGhpcyBidWZmZXIgaXMgcHJvZHVjZWQgb24gdGhlIHJlc3VsdCBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3RCdWZmZXIgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RCdWZmZXJPYnNlcnZlcihvLCBjb3VudCkpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSB3aW5kb3dzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiBlbGVtZW50IGNvdW50IGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTGVuZ3RoIG9mIGVhY2ggd2luZG93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NraXBdIE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGJldHdlZW4gY3JlYXRpb24gb2YgY29uc2VjdXRpdmUgd2luZG93cy4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdGhlIGNvdW50LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLndpbmRvd1dpdGhDb3VudCA9IG9ic2VydmFibGVQcm90by53aW5kb3dDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgc2tpcCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgICtjb3VudCB8fCAoY291bnQgPSAwKTtcbiAgICBNYXRoLmFicyhjb3VudCkgPT09IEluZmluaXR5ICYmIChjb3VudCA9IDApO1xuICAgIGlmIChjb3VudCA8PSAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgc2tpcCA9PSBudWxsICYmIChza2lwID0gY291bnQpO1xuICAgICtza2lwIHx8IChza2lwID0gMCk7XG4gICAgTWF0aC5hYnMoc2tpcCkgPT09IEluZmluaXR5ICYmIChza2lwID0gMCk7XG5cbiAgICBpZiAoc2tpcCA8PSAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShtKSxcbiAgICAgICAgbiA9IDAsXG4gICAgICAgIHEgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlV2luZG93ICgpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICBxLnB1c2gocyk7XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocywgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZVdpbmRvdygpO1xuXG4gICAgICBtLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uTmV4dCh4KTsgfVxuICAgICAgICAgIHZhciBjID0gbiAtIGNvdW50ICsgMTtcbiAgICAgICAgICBjID49IDAgJiYgYyAlIHNraXAgPT09IDAgJiYgcS5zaGlmdCgpLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgKytuICUgc2tpcCA9PT0gMCAmJiBjcmVhdGVXaW5kb3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7IHEuc2hpZnQoKS5vbkVycm9yKGUpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDApIHsgcS5zaGlmdCgpLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICAgIHJldHVybiByZWZDb3VudERpc3Bvc2FibGU7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjb25jYXRNYXAoc291cmNlLCBzZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHZhciBzZWxlY3RvckZ1bmMgPSBiaW5kQ2FsbGJhY2soc2VsZWN0b3IsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBzb3VyY2UubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZWN0b3JGdW5jKHgsIGksIHNvdXJjZSk7XG4gICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgKGlzQXJyYXlMaWtlKHJlc3VsdCkgfHwgaXNJdGVyYWJsZShyZXN1bHQpKSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb20ocmVzdWx0KSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pLmNvbmNhdEFsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqICBPbmUgb2YgdGhlIEZvbGxvd2luZzpcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIG1lcmdlcyB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gc291cmNlLmNvbmNhdE1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5yYW5nZSgwLCB4KTsgfSk7XG4gICAqICBPcjpcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIGludm9rZXMgdGhlIHJlc3VsdCBzZWxlY3RvciBmb3IgdGhlIHNvdXJjZSBlbGVtZW50IGFuZCBlYWNoIG9mIHRoZSBjb3JyZXNwb25kaW5nIGlubmVyIHNlcXVlbmNlJ3MgZWxlbWVudHMsIGFuZCBtZXJnZXMgdGhlIHJlc3VsdHMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogIHZhciByZXMgPSBzb3VyY2UuY29uY2F0TWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLnJhbmdlKDAsIHgpOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCArIHk7IH0pO1xuICAgKiAgT3I6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIHRoZSBvdGhlciBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBtZXJnZXMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5jb25jYXRNYXAoUnguT2JzZXJ2YWJsZS5mcm9tQXJyYXkoWzEsMiwzXSkpO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQgb3IgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBwcm9qZWN0IGVhY2ggZWxlbWVudCBmcm9tIHRoZVxuICAgKiBzb3VyY2Ugc2VxdWVuY2Ugb250byB3aGljaCBjb3VsZCBiZSBlaXRoZXIgYW4gb2JzZXJ2YWJsZSBvciBQcm9taXNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzdWx0U2VsZWN0b3JdICBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIGludGVybWVkaWF0ZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIG9uZS10by1tYW55IHRyYW5zZm9ybSBmdW5jdGlvbiBjb2xsZWN0aW9uU2VsZWN0b3Igb24gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSBhbmQgdGhlbiBtYXBwaW5nIGVhY2ggb2YgdGhvc2Ugc2VxdWVuY2UgZWxlbWVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgc291cmNlIGVsZW1lbnQgdG8gYSByZXN1bHQgZWxlbWVudC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zZWxlY3RDb25jYXQgPSBvYnNlcnZhYmxlUHJvdG8uY29uY2F0TWFwID0gZnVuY3Rpb24gKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSAmJiBpc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uY2F0TWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvclJlc3VsdCA9IHNlbGVjdG9yKHgsIGkpO1xuICAgICAgICBpc1Byb21pc2Uoc2VsZWN0b3JSZXN1bHQpICYmIChzZWxlY3RvclJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzZWxlY3RvclJlc3VsdCkpO1xuICAgICAgICAoaXNBcnJheUxpa2Uoc2VsZWN0b3JSZXN1bHQpIHx8IGlzSXRlcmFibGUoc2VsZWN0b3JSZXN1bHQpKSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbShzZWxlY3RvclJlc3VsdCkpO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3RvclJlc3VsdC5tYXAoZnVuY3Rpb24gKHksIGkyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKHgsIHksIGksIGkyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oc2VsZWN0b3IpID9cbiAgICAgIGNvbmNhdE1hcCh0aGlzLCBzZWxlY3RvciwgdGhpc0FyZykgOlxuICAgICAgY29uY2F0TWFwKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yOyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvamVjdHMgZWFjaCBub3RpZmljYXRpb24gb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBjb25jYXRzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyByZWFjaGVkLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIFwidGhpc1wiIHRvIHVzZSB0byBpbnZva2UgZWFjaCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG5vdGlmaWNhdGlvbiBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29uY2F0TWFwT2JzZXJ2ZXIgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0Q29uY2F0T2JzZXJ2ZXIgPSBmdW5jdGlvbihvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMsXG4gICAgICAgIG9uTmV4dEZ1bmMgPSBiaW5kQ2FsbGJhY2sob25OZXh0LCB0aGlzQXJnLCAyKSxcbiAgICAgICAgb25FcnJvckZ1bmMgPSBiaW5kQ2FsbGJhY2sob25FcnJvciwgdGhpc0FyZywgMSksXG4gICAgICAgIG9uQ29tcGxldGVkRnVuYyA9IGJpbmRDYWxsYmFjayhvbkNvbXBsZXRlZCwgdGhpc0FyZywgMCk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uTmV4dEZ1bmMoeCwgaW5kZXgrKyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uRXJyb3JGdW5jKGVycik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25Db21wbGV0ZWRGdW5jKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKS5jb25jYXRBbGwoKTtcbiAgfTtcblxuICB2YXIgRGVmYXVsdElmRW1wdHlPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVmYXVsdElmRW1wdHlPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SWZFbXB0eU9ic2VydmVyKG8sIGQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9mID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEZWZhdWx0SWZFbXB0eU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2YgPSB0cnVlO1xuICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgRGVmYXVsdElmRW1wdHlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgIXRoaXMuX2YgJiYgdGhpcy5fby5vbk5leHQodGhpcy5fZCk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBEZWZhdWx0SWZFbXB0eU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgdGhlIGVsZW1lbnRzIG9mIHRoZSBzcGVjaWZpZWQgc2VxdWVuY2Ugb3IgdGhlIHNwZWNpZmllZCB2YWx1ZSBpbiBhIHNpbmdsZXRvbiBzZXF1ZW5jZSBpZiB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuXG4gICAqXG4gICAqICB2YXIgcmVzID0gb2JzID0geHMuZGVmYXVsdElmRW1wdHkoKTtcbiAgICogIDIgLSBvYnMgPSB4cy5kZWZhdWx0SWZFbXB0eShmYWxzZSk7XG4gICAqXG4gICAqIEBtZW1iZXJPZiBPYnNlcnZhYmxlI1xuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHNlcXVlbmNlIGlzIGVtcHR5LiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgZGVmYXVsdHMgdG8gbnVsbC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGRlZmF1bHQgdmFsdWUgaWYgdGhlIHNvdXJjZSBpcyBlbXB0eTsgb3RoZXJ3aXNlLCB0aGUgZWxlbWVudHMgb2YgdGhlIHNvdXJjZSBpdHNlbGYuXG4gICAqL1xuICAgIG9ic2VydmFibGVQcm90by5kZWZhdWx0SWZFbXB0eSA9IGZ1bmN0aW9uIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgICAgZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQgJiYgKGRlZmF1bHRWYWx1ZSA9IG51bGwpO1xuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWZhdWx0SWZFbXB0eU9ic2VydmVyKG8sIGRlZmF1bHRWYWx1ZSkpO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9O1xuXG4gIC8vIFN3YXAgb3V0IGZvciBBcnJheS5maW5kSW5kZXhcbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mQ29tcGFyZXIoYXJyYXksIGl0ZW0sIGNvbXBhcmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY29tcGFyZXIoYXJyYXlbaV0sIGl0ZW0pKSB7IHJldHVybiBpOyB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhhc2hTZXQoY29tcGFyZXIpIHtcbiAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXI7XG4gICAgdGhpcy5zZXQgPSBbXTtcbiAgfVxuICBIYXNoU2V0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmV0VmFsdWUgPSBhcnJheUluZGV4T2ZDb21wYXJlcih0aGlzLnNldCwgdmFsdWUsIHRoaXMuY29tcGFyZXIpID09PSAtMTtcbiAgICByZXRWYWx1ZSAmJiB0aGlzLnNldC5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gcmV0VmFsdWU7XG4gIH07XG5cbiAgdmFyIERpc3RpbmN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGlzdGluY3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0T2JzZXJ2YWJsZShzb3VyY2UsIGtleUZuLCBjbXBGbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9rZXlGbiA9IGtleUZuO1xuICAgICAgdGhpcy5fY21wRm4gPSBjbXBGbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERpc3RpbmN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdE9ic2VydmVyKG8sIHRoaXMuX2tleUZuLCB0aGlzLl9jbXBGbikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGlzdGluY3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIERpc3RpbmN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RPYnNlcnZlcihvLCBrZXlGbiwgY21wRm4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fa2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuX2ggPSBuZXcgSGFzaFNldChjbXBGbik7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEaXN0aW5jdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrZXkgPSB4O1xuICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fa2V5Rm4pKSB7XG4gICAgICAgIGtleSA9IHRyeUNhdGNoKHRoaXMuX2tleUZuKSh4KTtcbiAgICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihrZXkuZSk7IH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2gucHVzaChrZXkpICYmIHRoaXMuX28ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBEaXN0aW5jdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBEaXN0aW5jdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBEaXN0aW5jdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIG9ubHkgZGlzdGluY3QgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBrZXlTZWxlY3RvciBhbmQgdGhlIGNvbXBhcmVyLlxuICAgKiAgVXNhZ2Ugb2YgdGhpcyBvcGVyYXRvciBzaG91bGQgYmUgY29uc2lkZXJlZCBjYXJlZnVsbHkgZHVlIHRvIHRoZSBtYWludGVuYW5jZSBvZiBhbiBpbnRlcm5hbCBsb29rdXAgc3RydWN0dXJlIHdoaWNoIGNhbiBncm93IGxhcmdlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IG9icyA9IHhzLmRpc3RpbmN0KCk7XG4gICAqICAyIC0gb2JzID0geHMuZGlzdGluY3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pO1xuICAgKiAgMiAtIG9icyA9IHhzLmRpc3RpbmN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9LCBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhID09PSBiOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2tleVNlbGVjdG9yXSAgQSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBjb21wYXJpc29uIGtleSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdICBVc2VkIHRvIGNvbXBhcmUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgY29udGFpbmluZyB0aGUgZGlzdGluY3QgZWxlbWVudHMsIGJhc2VkIG9uIGEgY29tcHV0ZWQga2V5IHZhbHVlLCBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZGlzdGluY3QgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGNvbXBhcmVyKSB7XG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdENvbXBhcmVyKTtcbiAgICByZXR1cm4gbmV3IERpc3RpbmN0T2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgY29tcGFyZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBrZXkgc2VsZWN0b3IgZnVuY3Rpb24gYW5kIGNvbXBhcmVyIGFuZCBzZWxlY3RzIHRoZSByZXN1bHRpbmcgZWxlbWVudHMgYnkgdXNpbmcgYSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcbiAgICogIDIgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9KTtcbiAgICogIDMgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgQSBmdW5jdGlvbiB0byBleHRyYWN0IHRoZSBrZXkgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2VsZW1lbnRTZWxlY3Rvcl0gIEEgZnVuY3Rpb24gdG8gbWFwIGVhY2ggc291cmNlIGVsZW1lbnQgdG8gYW4gZWxlbWVudCBpbiBhbiBvYnNlcnZhYmxlIGdyb3VwLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIGdyb3VwcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUsIGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIHRoYXQgc2hhcmUgdGhhdCBzYW1lIGtleSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5ncm91cEJ5ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cEJ5VW50aWwoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3Rvciwgb2JzZXJ2YWJsZU5ldmVyKTtcbiAgfTtcblxuICAgIC8qKlxuICAgICAqICBHcm91cHMgdGhlIGVsZW1lbnRzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYWNjb3JkaW5nIHRvIGEgc3BlY2lmaWVkIGtleSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICAgKiAgQSBkdXJhdGlvbiBzZWxlY3RvciBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIGxpZmV0aW1lIG9mIGdyb3Vwcy4gV2hlbiBhIGdyb3VwIGV4cGlyZXMsIGl0IHJlY2VpdmVzIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi4gV2hlbiBhIG5ldyBlbGVtZW50IHdpdGggdGhlIHNhbWVcbiAgICAgKiAga2V5IHZhbHVlIGFzIGEgcmVjbGFpbWVkIGdyb3VwIG9jY3VycywgdGhlIGdyb3VwIHdpbGwgYmUgcmVib3JuIHdpdGggYSBuZXcgbGlmZXRpbWUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciByZXMgPSBvYnNlcnZhYmxlLmdyb3VwQnlVbnRpbChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSwgbnVsbCwgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUubmV2ZXIoKTsgfSk7XG4gICAgICogIDIgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9LCAgZnVuY3Rpb24gKCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5uZXZlcigpOyB9KTtcbiAgICAgKiAgMyAtIG9ic2VydmFibGUuZ3JvdXBCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSksIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0sICBmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLm5ldmVyKCk7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH0pO1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gZXh0cmFjdCB0aGUga2V5IGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNpZ25hbCB0aGUgZXhwaXJhdGlvbiBvZiBhIGdyb3VwLlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfVxuICAgICAqICBBIHNlcXVlbmNlIG9mIG9ic2VydmFibGUgZ3JvdXBzLCBlYWNoIG9mIHdoaWNoIGNvcnJlc3BvbmRzIHRvIGEgdW5pcXVlIGtleSB2YWx1ZSwgY29udGFpbmluZyBhbGwgZWxlbWVudHMgdGhhdCBzaGFyZSB0aGF0IHNhbWUga2V5IHZhbHVlLlxuICAgICAqICBJZiBhIGdyb3VwJ3MgbGlmZXRpbWUgZXhwaXJlcywgYSBuZXcgZ3JvdXAgd2l0aCB0aGUgc2FtZSBrZXkgdmFsdWUgY2FuIGJlIGNyZWF0ZWQgb25jZSBhbiBlbGVtZW50IHdpdGggc3VjaCBhIGtleSB2YWx1ZSBpcyBlbmNvdXRlcmVkLlxuICAgICAqXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLmdyb3VwQnlVbnRpbCA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcCgpLFxuICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cERpc3Bvc2FibGUpLFxuICAgICAgICAgIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0ub25FcnJvcihlKTsgfTsgfTtcblxuICAgICAgICBncm91cERpc3Bvc2FibGUuYWRkKFxuICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0cnlDYXRjaChrZXlTZWxlY3RvcikoeCk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICBtYXAuZm9yRWFjaChoYW5kbGVFcnJvcihrZXkuZSkpO1xuICAgICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKGtleS5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpcmVOZXdNYXBFbnRyeSA9IGZhbHNlLCB3cml0ZXIgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAod3JpdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgd3JpdGVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICAgICAgbWFwLnNldChrZXksIHdyaXRlcik7XG4gICAgICAgICAgICAgIGZpcmVOZXdNYXBFbnRyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJlTmV3TWFwRW50cnkpIHtcbiAgICAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgd3JpdGVyLCByZWZDb3VudERpc3Bvc2FibGUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uR3JvdXAgPSBuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCB3cml0ZXIpO1xuICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChkdXJhdGlvblNlbGVjdG9yKShkdXJhdGlvbkdyb3VwKTtcbiAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGR1cmF0aW9uLmUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgby5vbk5leHQoZ3JvdXApO1xuXG4gICAgICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgICAgICBncm91cERpc3Bvc2FibGUuYWRkKG1kKTtcblxuICAgICAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXBbJ2RlbGV0ZSddKGtleSkpIHsgd3JpdGVyLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICAgICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZS5yZW1vdmUobWQpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB4O1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZWxlbWVudFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gdHJ5Q2F0Y2goZWxlbWVudFNlbGVjdG9yKSh4KTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgbWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZWxlbWVudC5lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihlbGVtZW50LmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyaXRlci5vbk5leHQoZWxlbWVudCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0ub25Db21wbGV0ZWQoKTsgfSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KSk7XG5cbiAgICAgIHJldHVybiByZWZDb3VudERpc3Bvc2FibGU7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgTWFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWFwT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1hcE9ic2VydmFibGUoc291cmNlLCBzZWxlY3RvciwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLnNlbGVjdG9yID0gYmluZENhbGxiYWNrKHNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVyTWFwKHNlbGVjdG9yLCBzZWxmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGksIG8pIHsgcmV0dXJuIHNlbGVjdG9yLmNhbGwodGhpcywgc2VsZi5zZWxlY3Rvcih4LCBpLCBvKSwgaSwgbyk7IH07XG4gICAgfVxuXG4gICAgTWFwT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW50ZXJuYWxNYXAgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwT2JzZXJ2YWJsZSh0aGlzLnNvdXJjZSwgaW5uZXJNYXAoc2VsZWN0b3IsIHRoaXMpLCB0aGlzQXJnKTtcbiAgICB9O1xuXG4gICAgTWFwT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8sIHRoaXMuc2VsZWN0b3IsIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvLCBzZWxlY3Rvciwgc291cmNlKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmkgPSAwO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5zZWxlY3RvcikoeCwgdGhpcy5pKyssIHRoaXMuc291cmNlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLm8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIHRoaXMuby5vbk5leHQocmVzdWx0KTtcbiAgICB9O1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIG5ldyBmb3JtIGJ5IGluY29ycG9yYXRpbmcgdGhlIGVsZW1lbnQncyBpbmRleC5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHNvdXJjZSBlbGVtZW50OyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIHNvdXJjZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1hcCA9IG9ic2VydmFibGVQcm90by5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgc2VsZWN0b3JGbiA9IHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0b3I7IH07XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBNYXBPYnNlcnZhYmxlID9cbiAgICAgIHRoaXMuaW50ZXJuYWxNYXAoc2VsZWN0b3JGbiwgdGhpc0FyZykgOlxuICAgICAgbmV3IE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3JGbiwgdGhpc0FyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGx1Y2tlcihhcmdzLCBsZW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwcGVyKHgpIHtcbiAgICAgIHZhciBjdXJyZW50UHJvcCA9IHg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gY3VycmVudFByb3BbYXJnc1tpXV07XG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjdXJyZW50UHJvcCA9IHA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRQcm9wO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW5cbiAgICogdGhlIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmd1bWVudHMgVGhlIG5lc3RlZCBwcm9wZXJ0aWVzIHRvIHBsdWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gUmV0dXJucyBhIG5ldyBPYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wbHVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGlmIChsZW4gPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdMaXN0IG9mIHByb3BlcnRpZXMgY2Fubm90IGJlIGVtcHR5LicpOyB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gdGhpcy5tYXAocGx1Y2tlcihhcmdzLCBsZW4pKTtcbiAgfTtcblxub2JzZXJ2YWJsZVByb3RvLmZsYXRNYXAgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0TWFueSA9IG9ic2VydmFibGVQcm90by5tZXJnZU1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5tZXJnZUFsbCgpO1xufTtcblxuICAvKipcbiAgICogUHJvamVjdHMgZWFjaCBub3RpZmljYXRpb24gb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBtZXJnZXMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50OyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHdoZW4gYW4gZXJyb3Igb2NjdXJzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHdoZW4gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlIGlzIHJlYWNoZWQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgXCJ0aGlzXCIgdG8gdXNlIHRvIGludm9rZSBlYWNoIHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIG9uZS10by1tYW55IHRyYW5zZm9ybSBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggbm90aWZpY2F0aW9uIGluIHRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5mbGF0TWFwT2JzZXJ2ZXIgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0TWFueU9ic2VydmVyID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQsIHRoaXNBcmcpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvbk5leHQuY2FsbCh0aGlzQXJnLCB4LCBpbmRleCsrKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25FcnJvci5jYWxsKHRoaXNBcmcsIGVycik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25Db21wbGV0ZWQuY2FsbCh0aGlzQXJnKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0sIHNvdXJjZSkubWVyZ2VBbGwoKTtcbiAgfTtcblxub2JzZXJ2YWJsZVByb3RvLmZsYXRNYXBMYXRlc3QgPSBvYnNlcnZhYmxlUHJvdG8uc3dpdGNoTWFwID0gZnVuY3Rpb24oc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0TWFwT2JzZXJ2YWJsZSh0aGlzLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpLnN3aXRjaExhdGVzdCgpO1xufTtcblxuICB2YXIgU2tpcE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcE9ic2VydmFibGUoc291cmNlLCBjb3VudCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcE9ic2VydmVyKG8sIHRoaXMuX2NvdW50KSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFNraXBPYnNlcnZlcihvLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3IgPSBjO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFNraXBPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBTa2lwT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX3IgPD0gMCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ItLTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNraXBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTa2lwT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gU2tpcE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQnlwYXNzZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIHRoZW4gcmV0dXJucyB0aGUgcmVtYWluaW5nIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgdGhhdCBvY2N1ciBhZnRlciB0aGUgc3BlY2lmaWVkIGluZGV4IGluIHRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5za2lwID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgU2tpcE9ic2VydmFibGUodGhpcywgY291bnQpO1xuICB9O1xuXG4gIHZhciBTa2lwV2hpbGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwV2hpbGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBXaGlsZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcFdoaWxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwV2hpbGVPYnNlcnZlcihvLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwV2hpbGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBXaGlsZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwV2hpbGVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNraXBXaGlsZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX3IgPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBXaGlsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICghdGhpcy5fcikge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fcC5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcCk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgIHRoaXMuX3IgPSAhcmVzO1xuICAgICAgfVxuICAgICAgdGhpcy5fciAmJiB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICB9O1xuICAgIFNraXBXaGlsZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gU2tpcFdoaWxlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgQnlwYXNzZXMgZWxlbWVudHMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBsb25nIGFzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbiBpcyB0cnVlIGFuZCB0aGVuIHJldHVybnMgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAgICogIFRoZSBlbGVtZW50J3MgaW5kZXggaXMgdXNlZCBpbiB0aGUgbG9naWMgb2YgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogIHZhciByZXMgPSBzb3VyY2Uuc2tpcFdoaWxlKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPCAxMDsgfSk7XG4gICAqICB2YXIgcmVzID0gc291cmNlLnNraXBXaGlsZShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiB2YWx1ZSA8IDEwIHx8IGluZGV4IDwgMTA7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb247IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBzZXF1ZW5jZSBzdGFydGluZyBhdCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGluZWFyIHNlcmllcyB0aGF0IGRvZXMgbm90IHBhc3MgdGhlIHRlc3Qgc3BlY2lmaWVkIGJ5IHByZWRpY2F0ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5za2lwV2hpbGUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdmFyIGZuID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgcmV0dXJuIG5ldyBTa2lwV2hpbGVPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgVGFrZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZU9ic2VydmFibGUoc291cmNlLCBjb3VudCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGFrZU9ic2VydmVyKG8sIHRoaXMuX2NvdW50KSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFRha2VPYnNlcnZlcihvLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fciA9IGM7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoVGFrZU9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcblxuICAgIFRha2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fci0tID4gMCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgdGhpcy5fciA8PSAwICYmIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFrZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBUYWtlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFRha2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgc3BlY2lmaWVkIG51bWJlciBvZiBjb250aWd1b3VzIGVsZW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIGZvciB0aGUgZWRnZSBjYXNlIG9mIHRha2UoMCkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB1c2VkIHRvIHByb2R1Y2UgYW4gT25Db21wbGV0ZWQgbWVzc2FnZSBpbiBjYXNlIDxwYXJhbXJlZiBuYW1lPVwiY291bnQgY291bnQ8L3BhcmFtcmVmPiBpcyBzZXQgdG8gMC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZSA9IGZ1bmN0aW9uIChjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIGlmIChjb3VudCA9PT0gMCkgeyByZXR1cm4gb2JzZXJ2YWJsZUVtcHR5KHNjaGVkdWxlcik7IH1cbiAgICByZXR1cm4gbmV3IFRha2VPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICB2YXIgVGFrZVdoaWxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVdoaWxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlV2hpbGVPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VXaGlsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVdoaWxlT2JzZXJ2ZXIobywgdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZVdoaWxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUYWtlV2hpbGVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVdoaWxlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBUYWtlV2hpbGVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9yID0gdHJ1ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VXaGlsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9yKSB7XG4gICAgICAgIHRoaXMuX3IgPSB0cnlDYXRjaCh0aGlzLl9wLl9mbikoeCwgdGhpcy5faSsrLCB0aGlzLl9wKTtcbiAgICAgICAgaWYgKHRoaXMuX3IgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IodGhpcy5fci5lKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3IpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBUYWtlV2hpbGVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGFrZVdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFRha2VXaGlsZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgZWxlbWVudHMgZnJvbSBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFzIGxvbmcgYXMgYSBzcGVjaWZpZWQgY29uZGl0aW9uIGlzIHRydWUuXG4gICAqICBUaGUgZWxlbWVudCdzIGluZGV4IGlzIHVzZWQgaW4gdGhlIGxvZ2ljIG9mIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbjsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIGZyb20gdGhlIGlucHV0IHNlcXVlbmNlIHRoYXQgb2NjdXIgYmVmb3JlIHRoZSBlbGVtZW50IGF0IHdoaWNoIHRoZSB0ZXN0IG5vIGxvbmdlciBwYXNzZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZVdoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgVGFrZVdoaWxlT2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIEZpbHRlck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZpbHRlck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBGaWx0ZXJPYnNlcnZhYmxlKHNvdXJjZSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMucHJlZGljYXRlID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGaWx0ZXJPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIobywgdGhpcy5wcmVkaWNhdGUsIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5uZXJQcmVkaWNhdGUocHJlZGljYXRlLCBzZWxmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCwgaSwgbykgeyByZXR1cm4gc2VsZi5wcmVkaWNhdGUoeCwgaSwgbykgJiYgcHJlZGljYXRlLmNhbGwodGhpcywgeCwgaSwgbyk7IH1cbiAgICB9XG5cbiAgICBGaWx0ZXJPYnNlcnZhYmxlLnByb3RvdHlwZS5pbnRlcm5hbEZpbHRlciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJPYnNlcnZhYmxlKHRoaXMuc291cmNlLCBpbm5lclByZWRpY2F0ZShwcmVkaWNhdGUsIHRoaXMpLCB0aGlzQXJnKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvLCBwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmkgPSAwO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgc2hvdWxkWWllbGQgPSB0cnlDYXRjaCh0aGlzLnByZWRpY2F0ZSkoeCwgdGhpcy5pKyssIHRoaXMuc291cmNlKTtcbiAgICAgIGlmIChzaG91bGRZaWVsZCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuby5vbkVycm9yKHNob3VsZFlpZWxkLmUpO1xuICAgICAgfVxuICAgICAgc2hvdWxkWWllbGQgJiYgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICB9O1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmlsdGVyT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogIEZpbHRlcnMgdGhlIGVsZW1lbnRzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYmFzZWQgb24gYSBwcmVkaWNhdGUgYnkgaW5jb3Jwb3JhdGluZyB0aGUgZWxlbWVudCdzIGluZGV4LlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBzb3VyY2UgZWxlbWVudCBmb3IgYSBjb25kaXRpb247IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBzZXF1ZW5jZSB0aGF0IHNhdGlzZnkgdGhlIGNvbmRpdGlvbi5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZpbHRlciA9IG9ic2VydmFibGVQcm90by53aGVyZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEZpbHRlck9ic2VydmFibGUgPyB0aGlzLmludGVybmFsRmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykgOlxuICAgICAgbmV3IEZpbHRlck9ic2VydmFibGUodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgfTtcblxuICB2YXIgRXh0cmVtYUJ5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXh0cmVtYUJ5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHRyZW1hQnlPYnNlcnZhYmxlKHNvdXJjZSwgaywgYykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXh0cmVtYUJ5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBFeHRyZW1hQnlPYnNlcnZlcihvLCB0aGlzLl9rLCB0aGlzLl9jKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHRyZW1hQnlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEV4dHJlbWFCeU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFeHRyZW1hQnlPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHRyZW1hQnlPYnNlcnZlcihvLCBrLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2sgPSBrO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9sID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFeHRyZW1hQnlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIga2V5ID0gdHJ5Q2F0Y2godGhpcy5faykoeCk7XG4gICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGtleS5lKTsgfVxuICAgICAgdmFyIGNvbXBhcmlzb24gPSAwO1xuICAgICAgaWYgKCF0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3YgPSBrZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wYXJpc29uID0gdHJ5Q2F0Y2godGhpcy5fYykoa2V5LCB0aGlzLl92KTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IoY29tcGFyaXNvbi5lKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmlzb24gPiAwKSB7XG4gICAgICAgIHRoaXMuX3YgPSBrZXk7XG4gICAgICAgIHRoaXMuX2wgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJpc29uID49IDApIHsgdGhpcy5fbC5wdXNoKHgpOyB9XG4gICAgfTtcblxuICAgIEV4dHJlbWFCeU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIEV4dHJlbWFCeU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9sKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV4dHJlbWFCeU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICBmdW5jdGlvbiBmaXJzdE9ubHkoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRW1wdHlFcnJvcigpOyB9XG4gICAgcmV0dXJuIHhbMF07XG4gIH1cblxuICB2YXIgUmVkdWNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSZWR1Y2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFJlZHVjZU9ic2VydmFibGUoc291cmNlLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICB0aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFJlZHVjZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgUmVkdWNlT2JzZXJ2ZXIob2JzZXJ2ZXIsdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVkdWNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBSZWR1Y2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVkdWNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVkdWNlT2JzZXJ2ZXIobywgcGFyZW50KSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwYXJlbnQ7XG4gICAgICB0aGlzLl9mbiA9IHBhcmVudC5hY2N1bXVsYXRvcjtcbiAgICAgIHRoaXMuX2hzID0gcGFyZW50Lmhhc1NlZWQ7XG4gICAgICB0aGlzLl9zID0gcGFyZW50LnNlZWQ7XG4gICAgICB0aGlzLl9oYSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYSA9IG51bGw7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZWR1Y2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAhdGhpcy5faHYgJiYgKHRoaXMuX2h2ID0gdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5faGEpIHtcbiAgICAgICAgdGhpcy5fYSA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9hLCB4LCB0aGlzLl9pLCB0aGlzLl9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2EgPSB0aGlzLl9ocyA/IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9zLCB4LCB0aGlzLl9pLCB0aGlzLl9wKSA6IHg7XG4gICAgICAgIHRoaXMuX2hhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX2EuZSk7IH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuXG4gICAgUmVkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgUmVkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2h2ICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX2EpO1xuICAgICAgIXRoaXMuX2h2ICYmIHRoaXMuX2hzICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX3MpO1xuICAgICAgIXRoaXMuX2h2ICYmICF0aGlzLl9ocyAmJiB0aGlzLl9vLm9uRXJyb3IobmV3IEVtcHR5RXJyb3IoKSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZWR1Y2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogQXBwbGllcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiBvdmVyIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZSBhZ2dyZWdhdGlvbiBhcyBhIHNpbmdsZSBlbGVtZW50IGluIHRoZSByZXN1bHQgc2VxdWVuY2UuIFRoZSBzcGVjaWZpZWQgc2VlZCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIGluY3JlbWVudGFsIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5zY2FuLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAqIEBwYXJhbSB7QW55fSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIGZpbmFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmVkdWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNTZWVkID0gZmFsc2UsIHNlZWQsIGFjY3VtdWxhdG9yID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBoYXNTZWVkID0gdHJ1ZTtcbiAgICAgIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkdWNlT2JzZXJ2YWJsZSh0aGlzLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCk7XG4gIH07XG5cbiAgdmFyIFNvbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTb21lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTb21lT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTb21lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTb21lT2JzZXJ2ZXIobywgdGhpcy5fZm4sIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTb21lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTb21lT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNvbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNvbWVPYnNlcnZlcihvLCBmbiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNvbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgaWYgKEJvb2xlYW4ocmVzdWx0KSkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgU29tZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTb21lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KGZhbHNlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNvbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbnkgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHNhdGlzZmllcyBhIGNvbmRpdGlvbiBpZiBwcmVzZW50LCBlbHNlIGlmIGFueSBpdGVtcyBhcmUgaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXSBBIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgYW55IGVsZW1lbnRzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UgcGFzcyB0aGUgdGVzdCBpbiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSBpZiBnaXZlbiwgZWxzZSBpZiBhbnkgaXRlbXMgYXJlIGluIHRoZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zb21lID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU29tZU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIHZhciBJc0VtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSXNFbXB0eU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSXNFbXB0eU9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElzRW1wdHlPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElzRW1wdHlPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJc0VtcHR5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBJc0VtcHR5T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSXNFbXB0eU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElzRW1wdHlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KGZhbHNlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuICAgIElzRW1wdHlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgSXNFbXB0eU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0cnVlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElzRW1wdHlPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgc291cmNlIHNlcXVlbmNlIGlzIGVtcHR5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJc0VtcHR5T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgRXZlcnlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFdmVyeU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXZlcnlPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV2ZXJ5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBFdmVyeU9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXZlcnlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEV2ZXJ5T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV2ZXJ5T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBFdmVyeU9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXZlcnlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgaWYgKCFCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoZmFsc2UpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBFdmVyeU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBFdmVyeU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0cnVlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZXJ5T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYWxsIGVsZW1lbnRzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugc2F0aXNmeSBhIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV0gQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb24uXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgZGV0ZXJtaW5pbmcgd2hldGhlciBhbGwgZWxlbWVudHMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZSBwYXNzIHRoZSB0ZXN0IGluIHRoZSBzcGVjaWZpZWQgcHJlZGljYXRlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgRXZlcnlPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgSW5jbHVkZXNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmNsdWRlc09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSW5jbHVkZXNPYnNlcnZhYmxlKHNvdXJjZSwgZWxlbSwgaWR4KSB7XG4gICAgICB2YXIgbiA9ICtpZHggfHwgMDtcbiAgICAgIE1hdGguYWJzKG4pID09PSBJbmZpbml0eSAmJiAobiA9IDApO1xuXG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5fbiA9IG47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbmNsdWRlc09ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX24gPCAwKSB7XG4gICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbmNsdWRlc09ic2VydmVyKG8sIHRoaXMuX2VsZW0sIHRoaXMuX24pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEluY2x1ZGVzT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBJbmNsdWRlc09ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmNsdWRlc09ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluY2x1ZGVzT2JzZXJ2ZXIobywgZWxlbSwgbikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlcihhLCBiKSB7XG4gICAgICByZXR1cm4gKGEgPT09IDAgJiYgYiA9PT0gMCkgfHwgKGEgPT09IGIgfHwgKGlzTmFOKGEpICYmIGlzTmFOKGIpKSk7XG4gICAgfVxuXG4gICAgSW5jbHVkZXNPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSsrID49IHRoaXMuX24gJiYgY29tcGFyZXIoeCwgdGhpcy5fZWxlbSkpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEluY2x1ZGVzT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIEluY2x1ZGVzT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbk5leHQoZmFsc2UpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gSW5jbHVkZXNPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGluY2x1ZGVzIGEgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBhbiBvcHRpb25hbCBlcXVhbGl0eSBjb21wYXJlci5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb21JbmRleF0gQW4gZXF1YWxpdHkgY29tcGFyZXIgdG8gY29tcGFyZSBlbGVtZW50cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpbmNsdWRlcyBhbiBlbGVtZW50IHRoYXQgaGFzIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uaW5jbHVkZXMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBJbmNsdWRlc09ic2VydmFibGUodGhpcywgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfTtcblxuICB2YXIgQ291bnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb3VudE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ291bnRPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENvdW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb3VudE9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ291bnRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvdW50T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvdW50T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBDb3VudE9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fYyA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb3VudE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9mbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgIEJvb2xlYW4ocmVzdWx0KSAmJiAodGhpcy5fYysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2MrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIENvdW50T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIENvdW50T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX2MpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ291bnRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGhvdyBtYW55IGVsZW1lbnRzIGluIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBzYXRpc2Z5IGEgY29uZGl0aW9uIGlmIHByb3ZpZGVkLCBlbHNlIHRoZSBjb3VudCBvZiBpdGVtcy5cbiAgICogQGV4YW1wbGVcbiAgICogcmVzID0gc291cmNlLmNvdW50KCk7XG4gICAqIHJlcyA9IHNvdXJjZS5jb3VudChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA+IDM7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXUEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIGhvdyBtYW55IGVsZW1lbnRzIGluIHRoZSBpbnB1dCBzZXF1ZW5jZSBzYXRpc2Z5IHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpZiBwcm92aWRlZCwgZWxzZSB0aGUgY291bnQgb2YgaXRlbXMgaW4gdGhlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvdW50ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgQ291bnRPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgSW5kZXhPZk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEluZGV4T2ZPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluZGV4T2ZPYnNlcnZhYmxlKHNvdXJjZSwgZSwgbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5kZXhPZk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX24gPCAwKSB7XG4gICAgICAgIG8ub25OZXh0KC0xKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbmRleE9mT2JzZXJ2ZXIobywgdGhpcy5fZSwgdGhpcy5fbikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW5kZXhPZk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgSW5kZXhPZk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmRleE9mT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSW5kZXhPZk9ic2VydmVyKG8sIGUsIG4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pID49IHRoaXMuX24gJiYgeCA9PT0gdGhpcy5fZSkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9pKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG4gICAgSW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBJbmRleE9mT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbk5leHQoLTEpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gSW5kZXhPZk9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QW55fSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gMC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuZCBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgbiA9ICtmcm9tSW5kZXggfHwgMDtcbiAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcbiAgICByZXR1cm4gbmV3IEluZGV4T2ZPYnNlcnZhYmxlKHRoaXMsIHNlYXJjaEVsZW1lbnQsIG4pO1xuICB9O1xuXG4gIHZhciBTdW1PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdW1PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN1bU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU3VtT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTdW1PYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1bU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU3VtT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN1bU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU3VtT2JzZXJ2ZXIobywgZm4sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9jID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN1bU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9mbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgIHRoaXMuX2MgKz0gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYyArPSB4O1xuICAgICAgfVxuICAgIH07XG4gICAgU3VtT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFN1bU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9jKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1bU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiBhIHNlcXVlbmNlIG9mIHZhbHVlcyB0aGF0IGFyZSBvYnRhaW5lZCBieSBpbnZva2luZyBhbiBvcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSwgZWxzZSBpZiBub3Qgc3BlY2lmaWVkIGNvbXB1dGVzIHRoZSBzdW0gb24gZWFjaCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zdW0gPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2soa2V5U2VsZWN0b3IsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU3VtT2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgbWluaW11bSBrZXkgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWluQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudmFsdWU7IH0pO1xuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbkJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCAtIHk7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBLZXkgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGtleSB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHplcm8gb3IgbW9yZSBlbGVtZW50cyB0aGF0IGhhdmUgYSBtaW5pbXVtIGtleSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5taW5CeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgY29tcGFyZXIpIHtcbiAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0U3ViQ29tcGFyZXIpO1xuICAgIHJldHVybiBuZXcgRXh0cmVtYUJ5T2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGNvbXBhcmVyKHgsIHkpICogLTE7IH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbmFsIGNvbXBhcmVyIGVsc2UgYSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZXNzIHRoYW4gY2hlY2suXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWluKCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UubWluKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlIC0geS52YWx1ZTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgbWluaW11bSBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWluID0gZnVuY3Rpb24gKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubWluQnkoaWRlbnRpdHksIGNvbXBhcmVyKS5tYXAoZmlyc3RPbmx5KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudHMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBtYXhpbXVtICBrZXkgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWF4QnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudmFsdWU7IH0pO1xuICAgKiB2YXIgcmVzID0gc291cmNlLm1heEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCAtIHk7OyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgS2V5IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdICBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUga2V5IHZhbHVlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIGxpc3Qgb2YgemVybyBvciBtb3JlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1heGltdW0ga2V5IHZhbHVlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1heEJ5ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRTdWJDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBFeHRyZW1hQnlPYnNlcnZhYmxlKHRoaXMsIGtleVNlbGVjdG9yLCBjb21wYXJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBjb21wYXJlci5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXgoKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXgoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgLSB5LnZhbHVlOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBtYXhpbXVtIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5tYXggPSBmdW5jdGlvbiAoY29tcGFyZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhCeShpZGVudGl0eSwgY29tcGFyZXIpLm1hcChmaXJzdE9ubHkpO1xuICB9O1xuXG4gIHZhciBBdmVyYWdlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQXZlcmFnZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQXZlcmFnZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQXZlcmFnZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgQXZlcmFnZU9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXZlcmFnZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQXZlcmFnZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEF2ZXJhZ2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBBdmVyYWdlT2JzZXJ2ZXIobywgZm4sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fYyA9IDA7XG4gICAgICB0aGlzLl90ID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEF2ZXJhZ2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZih0aGlzLl9mbikge1xuICAgICAgICB2YXIgciA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9jKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAociA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyLmUpOyB9XG4gICAgICAgIHRoaXMuX3QgKz0gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2MrKztcbiAgICAgICAgdGhpcy5fdCArPSB4O1xuICAgICAgfVxuICAgIH07XG4gICAgQXZlcmFnZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBBdmVyYWdlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9jID09PSAwKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IobmV3IEVtcHR5RXJyb3IoKSk7IH1cbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3QgLyB0aGlzLl9jKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF2ZXJhZ2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBhdmVyYWdlIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgdmFsdWVzIHRoYXQgYXJlIGluIHRoZSBzZXF1ZW5jZSBvciBvYnRhaW5lZCBieSBpbnZva2luZyBhIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIGF2ZXJhZ2Ugb2YgdGhlIHNlcXVlbmNlIG9mIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5hdmVyYWdlID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMsIGZuO1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleVNlbGVjdG9yKSkge1xuICAgICAgZm4gPSBiaW5kQ2FsbGJhY2soa2V5U2VsZWN0b3IsIHRoaXNBcmcsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEF2ZXJhZ2VPYnNlcnZhYmxlKHNvdXJjZSwgZm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBzZXF1ZW5jZXMgYXJlIGVxdWFsIGJ5IGNvbXBhcmluZyB0aGUgZWxlbWVudHMgcGFpcndpc2UgdXNpbmcgYSBzcGVjaWZpZWQgZXF1YWxpdHkgY29tcGFyZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2Uuc2VxdWVuY2VFcXVhbChbMSwyLDNdKTtcbiAgICogdmFyIHJlcyA9IHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFt7IHZhbHVlOiA0MiB9XSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgPT09IHkudmFsdWU7IH0pO1xuICAgKiAzIC0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoUnguT2JzZXJ2YWJsZS5yZXR1cm5WYWx1ZSg0MikpO1xuICAgKiA0IC0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoUnguT2JzZXJ2YWJsZS5yZXR1cm5WYWx1ZSh7IHZhbHVlOiA0MiB9KSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgPT09IHkudmFsdWU7IH0pO1xuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNlY29uZCBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBhcnJheSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBib3RoIHNlcXVlbmNlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBhIHNpbmdsZSBlbGVtZW50IHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIGJvdGggc2VxdWVuY2VzIGFyZSBvZiBlcXVhbCBsZW5ndGggYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgYXJlIGVxdWFsIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGVxdWFsaXR5IGNvbXBhcmVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNlcXVlbmNlRXF1YWwgPSBmdW5jdGlvbiAoc2Vjb25kLCBjb21wYXJlcikge1xuICAgIHZhciBmaXJzdCA9IHRoaXM7XG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdENvbXBhcmVyKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkb25lbCA9IGZhbHNlLCBkb25lciA9IGZhbHNlLCBxbCA9IFtdLCBxciA9IFtdO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjEgPSBmaXJzdC5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHFyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdiA9IHFyLnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIGVxdWFsID0gdHJ5Q2F0Y2goY29tcGFyZXIpKHYsIHgpO1xuICAgICAgICAgIGlmIChlcXVhbCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihlcXVhbC5lKTsgfVxuICAgICAgICAgIGlmICghZXF1YWwpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZXIpIHtcbiAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHFsLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uKGUpIHsgby5vbkVycm9yKGUpOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmVsID0gdHJ1ZTtcbiAgICAgICAgaWYgKHFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmIChxci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb25lcikge1xuICAgICAgICAgICAgby5vbk5leHQodHJ1ZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgKGlzQXJyYXlMaWtlKHNlY29uZCkgfHwgaXNJdGVyYWJsZShzZWNvbmQpKSAmJiAoc2Vjb25kID0gb2JzZXJ2YWJsZUZyb20oc2Vjb25kKSk7XG4gICAgICBpc1Byb21pc2Uoc2Vjb25kKSAmJiAoc2Vjb25kID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNlY29uZCkpO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjIgPSBzZWNvbmQuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChxbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHYgPSBxbC5zaGlmdCgpO1xuICAgICAgICAgIHZhciBlcXVhbCA9IHRyeUNhdGNoKGNvbXBhcmVyKSh2LCB4KTtcbiAgICAgICAgICBpZiAoZXF1YWwgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZXF1YWwuZSk7IH1cbiAgICAgICAgICBpZiAoIWVxdWFsKSB7XG4gICAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmVsKSB7XG4gICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxci5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlKSB7IG8ub25FcnJvcihlKTsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lciA9IHRydWU7XG4gICAgICAgIGlmIChxci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAocWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9uZWwpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KHRydWUpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uMSwgc3Vic2NyaXB0aW9uMik7XG4gICAgfSwgZmlyc3QpO1xuICB9O1xuXG4gIHZhciBFbGVtZW50QXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFbGVtZW50QXRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBdE9ic2VydmFibGUoc291cmNlLCBpLCBkKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFbGVtZW50QXRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IEVsZW1lbnRBdE9ic2VydmVyKG8sIHRoaXMuX2ksIHRoaXMuX2QpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEVsZW1lbnRBdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRWxlbWVudEF0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEVsZW1lbnRBdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRWxlbWVudEF0T2JzZXJ2ZXIobywgaSwgZCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9pID0gaTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRWxlbWVudEF0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2ktLSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudEF0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIEVsZW1lbnRBdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9kKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRWxlbWVudEF0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4IGluIGEgc2VxdWVuY2Ugb3IgZGVmYXVsdCB2YWx1ZSBpZiBub3QgZm91bmQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXRyaWV2ZS5cbiAgICogQHBhcmFtIHtBbnl9IFtkZWZhdWx0VmFsdWVdIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBlbGVtZW50QXQgZG9lcyBub3QgZmluZCBhIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5lbGVtZW50QXQgPSAgZnVuY3Rpb24gKGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50QXRPYnNlcnZhYmxlKHRoaXMsIGluZGV4LCBkZWZhdWx0VmFsdWUpO1xuICB9O1xuXG4gIHZhciBTaW5nbGVPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTaW5nbGVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTaW5nbGVPYnNlcnZlcihvLCBvYmosIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNpbmdsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaG91bGRZaWVsZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29iai5wcmVkaWNhdGUpKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgIEJvb2xlYW4ocmVzKSAmJiAoc2hvdWxkWWllbGQgPSB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgc2hvdWxkWWllbGQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFlpZWxkKSB7XG4gICAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vLm9uRXJyb3IobmV3IEVycm9yKCdTZXF1ZW5jZSBjb250YWlucyBtb3JlIHRoYW4gb25lIG1hdGNoaW5nIGVsZW1lbnQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgICB0aGlzLl92ID0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNpbmdsZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTaW5nbGVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2h2KSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLl9vYmouZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFNpbmdsZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb25seSBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgb3B0aW9uYWwgcHJlZGljYXRlLCBhbmQgcmVwb3J0cyBhbiBleGNlcHRpb24gaWYgdGhlcmUgaXMgbm90IGV4YWN0bHkgb25lIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNpbmdsZSBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZS5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc2luZ2xlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIG9iaiA9IHt9LCBzb3VyY2UgPSB0aGlzO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHtcbiAgICAgICAgICBwcmVkaWNhdGU6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICB0aGlzQXJnOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBhcmd1bWVudHNbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Z1bmN0aW9uIChvYmoucHJlZGljYXRlKSkge1xuICAgICAgICB2YXIgZm4gPSBvYmoucHJlZGljYXRlO1xuICAgICAgICBvYmoucHJlZGljYXRlID0gYmluZENhbGxiYWNrKGZuLCBvYmoudGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNpbmdsZU9ic2VydmVyKG8sIG9iaiwgc291cmNlKSk7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH07XG5cbiAgdmFyIEZpcnN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmlyc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpcnN0T2JzZXJ2YWJsZShzb3VyY2UsIG9iaikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGaXJzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRmlyc3RPYnNlcnZlcihvLCB0aGlzLl9vYmosIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGaXJzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRmlyc3RPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaXJzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpcnN0T2JzZXJ2ZXIobywgb2JqLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYmoucHJlZGljYXRlKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICBpZiAoQm9vbGVhbihyZXMpKSB7XG4gICAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX29iai5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGaXJzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBpZiBwcmVzZW50IGVsc2UgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gU2VxdWVuY2UgY29udGFpbmluZyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgaWYgcHJvdmlkZWQsIGVsc2UgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB7fSwgc291cmNlID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqID0ge1xuICAgICAgICBwcmVkaWNhdGU6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgdGhpc0FyZzogYXJndW1lbnRzWzFdLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGFyZ3VtZW50c1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24gKG9iai5wcmVkaWNhdGUpKSB7XG4gICAgICB2YXIgZm4gPSBvYmoucHJlZGljYXRlO1xuICAgICAgb2JqLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhmbiwgb2JqLnRoaXNBcmcsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpcnN0T2JzZXJ2YWJsZSh0aGlzLCBvYmopO1xuICB9O1xuXG4gIHZhciBMYXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTGFzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTGFzdE9ic2VydmFibGUoc291cmNlLCBvYmopIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTGFzdE9ic2VydmVyKG8sIHRoaXMuX29iaiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIExhc3RPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhMYXN0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTGFzdE9ic2VydmVyKG8sIG9iaiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3YgPSBudWxsO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaG91bGRZaWVsZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29iai5wcmVkaWNhdGUpKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgIEJvb2xlYW4ocmVzKSAmJiAoc2hvdWxkWWllbGQgPSB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgc2hvdWxkWWllbGQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFlpZWxkKSB7XG4gICAgICAgIHRoaXMuX2h2ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdiA9IHg7XG4gICAgICB9XG4gICAgfTtcbiAgICBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIExhc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2h2KSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLl9vYmouZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBpZiBzcGVjaWZpZWQsIGVsc2UgdGhlIGxhc3QgZWxlbWVudC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge30sIHNvdXJjZSA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IHtcbiAgICAgICAgcHJlZGljYXRlOiBhcmd1bWVudHNbMF0sXG4gICAgICAgIHRoaXNBcmc6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uIChvYmoucHJlZGljYXRlKSkge1xuICAgICAgdmFyIGZuID0gb2JqLnByZWRpY2F0ZTtcbiAgICAgIG9iai5wcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2soZm4sIG9iai50aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMYXN0T2JzZXJ2YWJsZSh0aGlzLCBvYmopO1xuICB9O1xuXG4gIHZhciBGaW5kVmFsdWVPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaW5kVmFsdWVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGaW5kVmFsdWVPYnNlcnZlcihvYnNlcnZlciwgc291cmNlLCBjYWxsYmFjaywgeWllbGRJbmRleCkge1xuICAgICAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5fcyA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2NiID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLl95ID0geWllbGRJbmRleDtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmluZFZhbHVlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHNob3VsZFJ1biA9IHRyeUNhdGNoKHRoaXMuX2NiKSh4LCB0aGlzLl9pLCB0aGlzLl9zKTtcbiAgICAgIGlmIChzaG91bGRSdW4gPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioc2hvdWxkUnVuLmUpOyB9XG4gICAgICBpZiAoc2hvdWxkUnVuKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3kgPyB0aGlzLl9pIDogeCk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2krKztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRmluZFZhbHVlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgRmluZFZhbHVlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3kgJiYgdGhpcy5fby5vbk5leHQoLTEpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmluZFZhbHVlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIGZ1bmN0aW9uIGZpbmRWYWx1ZSAoc291cmNlLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHlpZWxkSW5kZXgpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5kVmFsdWVPYnNlcnZlcihvLCBzb3VyY2UsIGNhbGxiYWNrLCB5aWVsZEluZGV4KSk7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgZGVmaW5lZCBieSB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSwgYW5kIHJldHVybnMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugd2l0aGluIHRoZSBlbnRpcmUgT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdGhhdCBkZWZpbmVzIHRoZSBjb25kaXRpb25zIG9mIHRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgZGVmaW5lZCBieSB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSwgaWYgZm91bmQ7IG90aGVyd2lzZSwgdW5kZWZpbmVkLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZpbmRWYWx1ZSh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGFuZCByZXR1cm5zXG4gICAqIGFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSB3aXRoaW4gdGhlIGVudGlyZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbmRpdGlvbnMgb2YgdGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyB0aGUgcHJlZGljYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgbWF0Y2gsIGlmIGZvdW5kOyBvdGhlcndpc2UsIOKAkzEuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5maW5kSW5kZXggPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZpbmRWYWx1ZSh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHRydWUpO1xuICB9O1xuXG4gIHZhciBUb1NldE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRvU2V0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUb1NldE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRvU2V0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUb1NldE9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvU2V0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUb1NldE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb1NldE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvU2V0T2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gbmV3IHJvb3QuU2V0KCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb1NldE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3MuYWRkKHgpO1xuICAgIH07XG5cbiAgICBUb1NldE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFRvU2V0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3MpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9TZXRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGEgU2V0IGlmIGl0IGV4aXN0cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSB2YWx1ZSBvZiBhIFNldCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50b1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHJvb3QuU2V0ID09PSAndW5kZWZpbmVkJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFRvU2V0T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVG9NYXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb01hcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9NYXBPYnNlcnZhYmxlKHNvdXJjZSwgaywgZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9NYXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRvTWFwT2JzZXJ2ZXIobywgdGhpcy5faywgdGhpcy5fZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9NYXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRvTWFwT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRvTWFwT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9NYXBPYnNlcnZlcihvLCBrLCBlKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2sgPSBrO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9tID0gbmV3IHJvb3QuTWFwKCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb01hcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrZXkgPSB0cnlDYXRjaCh0aGlzLl9rKSh4KTtcbiAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB2YXIgZWxlbSA9IHg7XG4gICAgICBpZiAodGhpcy5fZSkge1xuICAgICAgICBlbGVtID0gdHJ5Q2F0Y2godGhpcy5fZSkoeCk7XG4gICAgICAgIGlmIChlbGVtID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGVsZW0uZSk7IH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fbS5zZXQoa2V5LCBlbGVtKTtcbiAgICB9O1xuXG4gICAgVG9NYXBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUb01hcE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9tKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvTWFwT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIENvbnZlcnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGEgTWFwIGlmIGl0IGV4aXN0cy5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBBIGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIHRoZSBrZXkgZm9yIHRoZSBNYXAuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW2VsZW1lbnRTZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggcHJvZHVjZXMgdGhlIGVsZW1lbnQgZm9yIHRoZSBNYXAuIElmIG5vdCBwcmVzZW50LCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIHZhbHVlIG9mIGEgTWFwIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udG9NYXAgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3Rvcikge1xuICAgIGlmICh0eXBlb2Ygcm9vdC5NYXAgPT09ICd1bmRlZmluZWQnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgVG9NYXBPYnNlcnZhYmxlKHRoaXMsIGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpO1xuICB9O1xuXG4gIHZhciBTbGljZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNsaWNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTbGljZU9ic2VydmFibGUoc291cmNlLCBiLCBlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTbGljZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2xpY2VPYnNlcnZlcihvLCB0aGlzLl9iLCB0aGlzLl9lKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTbGljZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2xpY2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2xpY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNsaWNlT2JzZXJ2ZXIobywgYiwgZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9iID0gYjtcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTbGljZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pID49IHRoaXMuX2IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2UgPT09IHRoaXMuX2kpIHtcbiAgICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuICAgIFNsaWNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFNsaWNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNsaWNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qXG4gICogVGhlIHNsaWNlKCkgbWV0aG9kIHJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIGFuIE9ic2VydmFibGUgaW50byBhIG5ldyBPYnNlcnZhYmxlIG9iamVjdC5cbiAgKiBVbmxpa2UgdGhlIGFycmF5IHZlcnNpb24sIHRoaXMgZG9lcyBub3Qgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzIGZvciBiZWluZyBvciBlbmQuXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtiZWdpbl0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLiBJZiBvbWl0dGVkLCB0aGlzIHdpbGwgZGVmYXVsdCB0byB6ZXJvLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kXSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGVuZCBleHRyYWN0aW9uLiBzbGljZSBleHRyYWN0cyB1cCB0byBidXQgbm90IGluY2x1ZGluZyBlbmQuXG4gICogSWYgb21pdHRlZCwgdGhpcyB3aWxsIGVtaXQgdGhlIHJlc3Qgb2YgdGhlIE9ic2VydmFibGUgb2JqZWN0LlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgYW4gT2JzZXJ2YWJsZSBpbnRvIGEgbmV3IE9ic2VydmFibGUgb2JqZWN0LlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2xpY2UgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgIHZhciBzdGFydCA9IGJlZ2luIHx8IDA7XG4gICAgaWYgKHN0YXJ0IDwgMCkgeyB0aHJvdyBuZXcgUnguQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJiBlbmQgPCBzdGFydCkge1xuICAgICAgdGhyb3cgbmV3IFJ4LkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2xpY2VPYnNlcnZhYmxlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICB9O1xuXG4gIHZhciBMYXN0SW5kZXhPZk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKExhc3RJbmRleE9mT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBMYXN0SW5kZXhPZk9ic2VydmFibGUoc291cmNlLCBlLCBuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5fbiA9IG47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBMYXN0SW5kZXhPZk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX24gPCAwKSB7XG4gICAgICAgIG8ub25OZXh0KC0xKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBMYXN0SW5kZXhPZk9ic2VydmVyKG8sIHRoaXMuX2UsIHRoaXMuX24pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RJbmRleE9mT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBMYXN0SW5kZXhPZk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhMYXN0SW5kZXhPZk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIExhc3RJbmRleE9mT2JzZXJ2ZXIobywgZSwgbikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgdGhpcy5fdiA9IDA7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBMYXN0SW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pID49IHRoaXMuX24gJiYgeCA9PT0gdGhpcy5fZSkge1xuICAgICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3YgPSB0aGlzLl9pO1xuICAgICAgfVxuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG4gICAgTGFzdEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgTGFzdEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2h2KSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoLTEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGFzdEluZGV4T2ZPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QW55fSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gMC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuZCBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgbiA9ICtmcm9tSW5kZXggfHwgMDtcbiAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcbiAgICByZXR1cm4gbmV3IExhc3RJbmRleE9mT2JzZXJ2YWJsZSh0aGlzLCBzZWFyY2hFbGVtZW50LCBuKTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLndyYXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKCkge1xuICAgICAgcmV0dXJuIE9ic2VydmFibGUuc3Bhd24uY2FsbCh0aGlzLCBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVPYnNlcnZhYmxlLl9fZ2VuZXJhdG9yRnVuY3Rpb25fXyA9IGZuO1xuICAgIHJldHVybiBjcmVhdGVPYnNlcnZhYmxlO1xuICB9O1xuXG4gIHZhciBzcGF3biA9IE9ic2VydmFibGUuc3Bhd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGFyZ3VtZW50c1swXSwgc2VsZiA9IHRoaXMsIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3MucHVzaChhcmd1bWVudHNbaV0pOyB9XG5cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oZ2VuKSkgeyBnZW4gPSBnZW4uYXBwbHkoc2VsZiwgYXJncyk7IH1cbiAgICAgIGlmICghZ2VuIHx8ICFpc0Z1bmN0aW9uKGdlbi5uZXh0KSkge1xuICAgICAgICBvLm9uTmV4dChnZW4pO1xuICAgICAgICByZXR1cm4gby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzR2VuZXJhdG9yKHJlcykge1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goZ2VuLm5leHQpLmNhbGwoZ2VuLCByZXMpO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJldC5lKTsgfVxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NHZW5lcmF0b3IoKTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGdlbi5uZXh0KS5jYWxsKGdlbiwgZXJyKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXQuZSk7IH1cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICBpZiAocmV0LmRvbmUpIHtcbiAgICAgICAgICBvLm9uTmV4dChyZXQudmFsdWUpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9icyA9IHRvT2JzZXJ2YWJsZS5jYWxsKHNlbGYsIHJldC52YWx1ZSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob2JzKSkge1xuICAgICAgICAgIGcuYWRkKG9icy5zdWJzY3JpYmUoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbDtcbiAgICAgICAgICB9LCBvbkVycm9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhhc1ZhbHVlICYmIHByb2Nlc3NHZW5lcmF0b3IodmFsdWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkVycm9yKG5ldyBUeXBlRXJyb3IoJ3R5cGUgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b09ic2VydmFibGUob2JqKSB7XG4gICAgaWYgKCFvYmopIHsgcmV0dXJuIG9iajsgfVxuICAgIGlmIChPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShvYmopKSB7IHJldHVybiBvYmo7IH1cbiAgICBpZiAoaXNQcm9taXNlKG9iaikpIHsgcmV0dXJuIE9ic2VydmFibGUuZnJvbVByb21pc2Uob2JqKTsgfVxuICAgIGlmIChpc0dlbmVyYXRvckZ1bmN0aW9uKG9iaikgfHwgaXNHZW5lcmF0b3Iob2JqKSkgeyByZXR1cm4gc3Bhd24uY2FsbCh0aGlzLCBvYmopOyB9XG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSkgeyByZXR1cm4gdGh1bmtUb09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmopOyB9XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgfHwgaXNJdGVyYWJsZShvYmopKSB7IHJldHVybiBhcnJheVRvT2JzZXJ2YWJsZS5jYWxsKHRoaXMsIG9iaik7IH1cbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge3JldHVybiBvYmplY3RUb09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmopO31cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlUb09ic2VydmFibGUgKG9iaikge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20ob2JqKS5jb25jYXRNYXAoZnVuY3Rpb24obykge1xuICAgICAgaWYoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUobykgfHwgaXNPYmplY3QobykpIHtcbiAgICAgICAgcmV0dXJuIHRvT2JzZXJ2YWJsZS5jYWxsKG51bGwsIG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuanVzdChvKTtcbiAgICAgIH1cbiAgICB9KS50b0FycmF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RUb09ic2VydmFibGUgKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpLCBrZXlzID0gT2JqZWN0LmtleXMob2JqKSwgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRvT2JzZXJ2YWJsZS5jYWxsKHRoaXMsIG9ialtrZXldKTtcblxuICAgICAgaWYob2JzZXJ2YWJsZSAmJiBPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSkge1xuICAgICAgICBkZWZlcihvYnNlcnZhYmxlLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9ic2VydmFibGUuZm9ya0pvaW4uYXBwbHkoT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZXMpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pO1xuXG5cbiAgICBmdW5jdGlvbiBkZWZlciAob2JzZXJ2YWJsZSwga2V5KSB7XG4gICAgICByZXN1bHRzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICBvYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUubWFwKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJlc3VsdHNba2V5XSA9IG5leHQ7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGh1bmtUb09ic2VydmFibGUoZm4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICBmbi5jYWxsKHNlbGYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXSwgcmVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBvLm9uRXJyb3IoZXJyKTsgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7IH1cbiAgICAgICAgICByZXMgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlcyk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZW5lcmF0b3Iob2JqKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24gKG9iai5uZXh0KSAmJiBpc0Z1bmN0aW9uIChvYmpbJ3Rocm93J10pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoIWN0b3IpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGN0b3IubmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJyB8fCBjdG9yLmRpc3BsYXlOYW1lID09PSAnR2VuZXJhdG9yRnVuY3Rpb24nKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmV0dXJuIGlzR2VuZXJhdG9yKGN0b3IucHJvdG90eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBPYmplY3QgPT0gdmFsLmNvbnN0cnVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBhc3luY2hyb25vdXNseSBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciwgc3VyZmFjaW5nIHRoZSByZXN1bHQgdGhyb3VnaCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5zdGFydChmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdoZWxsbycpOyB9KTtcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuc3RhcnQoZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnaGVsbG8nKTsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5zdGFydChmdW5jdGlvbiAoKSB7IHRoaXMubG9nKCdoZWxsbycpOyB9LCBSeC5TY2hlZHVsZXIudGltZW91dCwgY29uc29sZSk7XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gcnVuIGFzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIGZ1bmN0aW9uIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cbiAgICogQHBhcmFtIFtjb250ZXh0XSAgVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IHZhbHVlLCBvciBhbiBleGNlcHRpb24uXG4gICAqXG4gICAqIFJlbWFya3NcbiAgICogKiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIGltbWVkaWF0ZWx5LCBub3QgZHVyaW5nIHRoZSBzdWJzY3JpcHRpb24gb2YgdGhlIHJlc3VsdGluZyBzZXF1ZW5jZS5cbiAgICogKiBNdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2FuIG9ic2VydmUgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5zdGFydCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0LCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZVRvQXN5bmMoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZnVuY3Rpb24gaW50byBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uIEVhY2ggaW52b2NhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBjYXVzZXMgYW4gaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIEZ1bmN0aW9uIHRvIGNvbnZlcnQgdG8gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZnVuY3Rpb24gb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGV4dF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBc3luY2hyb25vdXMgZnVuY3Rpb24uXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZVRvQXN5bmMgPSBPYnNlcnZhYmxlLnRvQXN5bmMgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBzdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuXG4gICAgICBzY2hlZHVsZXIuc2NoZWR1bGUobnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdWJqZWN0Lm9uRXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YmplY3Qub25OZXh0KHJlc3VsdCk7XG4gICAgICAgIHN1YmplY3Qub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgfTtcblxuZnVuY3Rpb24gY3JlYXRlQ2JPYnNlcnZhYmxlKGZuLCBjdHgsIHNlbGVjdG9yLCBhcmdzKSB7XG4gIHZhciBvID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuXG4gIGFyZ3MucHVzaChjcmVhdGVDYkhhbmRsZXIobywgY3R4LCBzZWxlY3RvcikpO1xuICBmbi5hcHBseShjdHgsIGFyZ3MpO1xuXG4gIHJldHVybiBvLmFzT2JzZXJ2YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYkhhbmRsZXIobywgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgcmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICByZXN1bHRzID0gdHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KGN0eCwgcmVzdWx0cyk7XG4gICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgby5vbk5leHQocmVzdWx0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvLm9uQ29tcGxldGVkKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG8gY29udmVydCB0byBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtNaXhlZH0gW2N0eF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGNhbGxiYWNrIHRvIHByb2R1Y2UgYSBzaW5nbGUgaXRlbSB0byB5aWVsZCBvbiBuZXh0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uLCB3aGVuIGV4ZWN1dGVkIHdpdGggdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgbWludXMgdGhlIGNhbGxiYWNrLCBwcm9kdWNlcyBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50cyB0byB0aGUgY2FsbGJhY2sgYXMgYW4gYXJyYXkuXG4gKi9cbk9ic2VydmFibGUuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuLCBjdHgsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHlwZW9mIGN0eCA9PT0gJ3VuZGVmaW5lZCcgJiYgKGN0eCA9IHRoaXMpOyBcblxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBjcmVhdGVDYk9ic2VydmFibGUoZm4sIGN0eCwgc2VsZWN0b3IsIGFyZ3MpO1xuICB9O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZU9ic2VydmFibGUoZm4sIGN0eCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgdmFyIG8gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG5cbiAgYXJncy5wdXNoKGNyZWF0ZU5vZGVIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpKTtcbiAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcblxuICByZXR1cm4gby5hc09ic2VydmFibGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUhhbmRsZXIobywgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBvLm9uRXJyb3IoZXJyKTsgfVxuXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHsgcmVzdWx0c1tpIC0gMV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0cnlDYXRjaChzZWxlY3RvcikuYXBwbHkoY3R4LCByZXN1bHRzKTtcbiAgICAgIGlmIChyZXN1bHRzID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdHMuZSk7IH1cbiAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBvLm9uTmV4dChyZXN1bHRzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIE5vZGUuanMgY2FsbGJhY2sgc3R5bGUgZnVuY3Rpb24gdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gIFRoaXMgbXVzdCBiZSBpbiBmdW5jdGlvbiAoZXJyLCAuLi4pIGZvcm1hdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge01peGVkfSBbY3R4XSBUaGUgY29udGV4dCBmb3IgdGhlIGZ1bmMgcGFyYW1ldGVyIHRvIGJlIGV4ZWN1dGVkLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgY2FsbGJhY2sgbWludXMgdGhlIGVycm9yIHRvIHByb2R1Y2UgYSBzaW5nbGUgaXRlbSB0byB5aWVsZCBvbiBuZXh0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCB3aGVuIGFwcGxpZWQsIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBjYWxsYmFjayBhcmd1bWVudHMgYXMgYW4gYXJyYXkuXG4gKi9cbk9ic2VydmFibGUuZnJvbU5vZGVDYWxsYmFjayA9IGZ1bmN0aW9uIChmbiwgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHR5cGVvZiBjdHggPT09ICd1bmRlZmluZWQnICYmIChjdHggPSB0aGlzKTsgXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlT2JzZXJ2YWJsZShmbiwgY3R4LCBzZWxlY3RvciwgYXJncyk7XG4gIH07XG59O1xuXG4gIGZ1bmN0aW9uIGlzTm9kZUxpc3QoZWwpIHtcbiAgICBpZiAocm9vdC5TdGF0aWNOb2RlTGlzdCkge1xuICAgICAgLy8gSUU4IFNwZWNpZmljXG4gICAgICAvLyBpbnN0YW5jZW9mIGlzIHNsb3dlciB0aGFuIE9iamVjdCN0b1N0cmluZywgYnV0IE9iamVjdCN0b1N0cmluZyB3aWxsIG5vdCB3b3JrIGFzIGludGVuZGVkIGluIElFOFxuICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2Ygcm9vdC5TdGF0aWNOb2RlTGlzdCB8fCBlbCBpbnN0YW5jZW9mIHJvb3QuTm9kZUxpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwpID09PSAnW29iamVjdCBOb2RlTGlzdF0nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIExpc3RlbkRpc3Bvc2FibGUoZSwgbiwgZm4pIHtcbiAgICB0aGlzLl9lID0gZTtcbiAgICB0aGlzLl9uID0gbjtcbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX2UuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9uLCB0aGlzLl9mbiwgZmFsc2UpO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9XG4gIExpc3RlbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuX2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9uLCB0aGlzLl9mbiwgZmFsc2UpO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRMaXN0ZW5lciAoZWwsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHZhciBkaXNwb3NhYmxlcyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG5cbiAgICAvLyBBc3VtZSBOb2RlTGlzdCBvciBIVE1MQ29sbGVjdGlvblxuICAgIHZhciBlbGVtVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwpO1xuICAgIGlmIChpc05vZGVMaXN0KGVsKSB8fCBlbGVtVG9TdHJpbmcgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBkaXNwb3NhYmxlcy5hZGQoY3JlYXRlRXZlbnRMaXN0ZW5lcihlbC5pdGVtKGkpLCBldmVudE5hbWUsIGhhbmRsZXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICBkaXNwb3NhYmxlcy5hZGQobmV3IExpc3RlbkRpc3Bvc2FibGUoZWwsIGV2ZW50TmFtZSwgaGFuZGxlcikpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXNwb3NhYmxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbiB0byBkZXRlcm1pbmUgd2hldGhlciB0byB1c2UgbmF0aXZlIGV2ZW50cyBvbmx5XG4gICAqL1xuICBSeC5jb25maWcudXNlTmF0aXZlRXZlbnRzID0gZmFsc2U7XG5cbiAgdmFyIEV2ZW50T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFdmVudE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXZlbnRPYnNlcnZhYmxlKGVsLCBuYW1lLCBmbikge1xuICAgICAgdGhpcy5fZWwgPSBlbDtcbiAgICAgIHRoaXMuX24gPSBuYW1lO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXIobywgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgIHJlc3VsdHMgPSB0cnlDYXRjaChmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICAgIH1cbiAgICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEV2ZW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgdGhpcy5fZWwsXG4gICAgICAgIHRoaXMuX24sXG4gICAgICAgIGNyZWF0ZUhhbmRsZXIobywgdGhpcy5fZm4pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBtYXRjaGluZyBET01FbGVtZW50IG9yIGVhY2ggaXRlbSBpbiB0aGUgTm9kZUxpc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IFRoZSBET01FbGVtZW50IG9yIE5vZGVMaXN0IHRvIGF0dGFjaCBhIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGF0dGFjaCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgZXZlbnRzIGZyb20gdGhlIHNwZWNpZmllZCBlbGVtZW50IGFuZCB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3Rvcikge1xuICAgIC8vIE5vZGUuanMgc3BlY2lmaWNcbiAgICBpZiAoZWxlbWVudC5hZGRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGZyb21FdmVudFBhdHRlcm4oXG4gICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBoKTsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGgpOyB9LFxuICAgICAgICBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLy8gVXNlIG9ubHkgaWYgbm9uLW5hdGl2ZSBldmVudHMgYXJlIGFsbG93ZWRcbiAgICBpZiAoIVJ4LmNvbmZpZy51c2VOYXRpdmVFdmVudHMpIHtcbiAgICAgIC8vIEhhbmRsZXMganEsIEFuZ3VsYXIuanMsIFplcHRvLCBNYXJpb25ldHRlLCBFbWJlci5qc1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbGVtZW50Lm9mZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50UGF0dGVybihcbiAgICAgICAgICBmdW5jdGlvbiAoaCkgeyBlbGVtZW50Lm9uKGV2ZW50TmFtZSwgaCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5vZmYoZXZlbnROYW1lLCBoKTsgfSxcbiAgICAgICAgICBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFdmVudE9ic2VydmFibGUoZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3RvcikucHVibGlzaCgpLnJlZkNvdW50KCk7XG4gIH07XG5cbiAgdmFyIEV2ZW50UGF0dGVybk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFdmVudFBhdHRlcm5PYnNlcnZhYmxlKGFkZCwgZGVsLCBmbikge1xuICAgICAgdGhpcy5fYWRkID0gYWRkO1xuICAgICAgdGhpcy5fZGVsID0gZGVsO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXIobywgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgIHJlc3VsdHMgPSB0cnlDYXRjaChmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICAgIH1cbiAgICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEV2ZW50UGF0dGVybk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGZuID0gY3JlYXRlSGFuZGxlcihvLCB0aGlzLl9mbik7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0aGlzLl9hZGQoZm4pO1xuICAgICAgcmV0dXJuIG5ldyBFdmVudFBhdHRlcm5EaXNwb3NhYmxlKHRoaXMuX2RlbCwgZm4sIHJldHVyblZhbHVlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZShkZWwsIGZuLCByZXQpIHtcbiAgICAgIHRoaXMuX2RlbCA9IGRlbDtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9yZXQgPSByZXQ7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBFdmVudFBhdHRlcm5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICBpc0Z1bmN0aW9uKHRoaXMuX2RlbCkgJiYgdGhpcy5fZGVsKHRoaXMuX2ZuLCB0aGlzLl9yZXQpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBhbiBldmVudCBlbWl0dGVyIHZpYSBhbiBhZGRIYW5kbGVyL3JlbW92ZUhhbmRsZXIgcGFpci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWRkSGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gYWRkIGEgaGFuZGxlciB0byB0aGUgZW1pdHRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlbW92ZUhhbmRsZXJdIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byByZW1vdmUgYSBoYW5kbGVyIGZyb20gYW4gZW1pdHRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggd3JhcHMgYW4gZXZlbnQgZnJvbSBhbiBldmVudCBlbWl0dGVyXG4gICAqL1xuICB2YXIgZnJvbUV2ZW50UGF0dGVybiA9IE9ic2VydmFibGUuZnJvbUV2ZW50UGF0dGVybiA9IGZ1bmN0aW9uIChhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3RvcikucHVibGlzaCgpLnJlZkNvdW50KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludm9rZXMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiwgc3VyZmFjaW5nIHRoZSByZXN1bHQgdGhyb3VnaCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbkFzeW5jIEFzeW5jaHJvbm91cyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSB0byBydW4uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGV4cG9zaW5nIHRoZSBmdW5jdGlvbidzIHJlc3VsdCB2YWx1ZSwgb3IgYW4gZXhjZXB0aW9uLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5zdGFydEFzeW5jID0gZnVuY3Rpb24gKGZ1bmN0aW9uQXN5bmMpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRyeUNhdGNoKGZ1bmN0aW9uQXN5bmMpKCk7XG4gICAgaWYgKHByb21pc2UgPT09IGVycm9yT2JqKSB7IHJldHVybiBvYnNlcnZhYmxlVGhyb3cocHJvbWlzZS5lKTsgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbVByb21pc2UocHJvbWlzZSk7XG4gIH07XG5cbiAgdmFyIFBhdXNhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUGF1c2FibGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhdXNhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHBhdXNlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gICAgICBpZiAocGF1c2VyICYmIHBhdXNlci5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXIubWVyZ2UocGF1c2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBQYXVzYWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGNvbm4gPSB0aGlzLnNvdXJjZS5wdWJsaXNoKCksXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IGNvbm4uc3Vic2NyaWJlKG8pLFxuICAgICAgICBjb25uZWN0aW9uID0gZGlzcG9zYWJsZUVtcHR5O1xuXG4gICAgICB2YXIgcGF1c2FibGUgPSB0aGlzLnBhdXNlci5zdGFydFdpdGgoIXRoaXMucGF1c2VkKS5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGNvbm5lY3Rpb24gPSBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICBjb25uZWN0aW9uID0gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbc3Vic2NyaXB0aW9uLCBjb25uZWN0aW9uLCBwYXVzYWJsZV0pO1xuICAgIH07XG5cbiAgICBQYXVzYWJsZU9ic2VydmFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250cm9sbGVyLm9uTmV4dChmYWxzZSk7XG4gICAgfTtcblxuICAgIFBhdXNhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQodHJ1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXVzYWJsZU9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIHVwb24gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggeWllbGRzIHRydWUvZmFsc2UuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwYXVzZXIgPSBuZXcgUnguU3ViamVjdCgpO1xuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDApLnBhdXNhYmxlKHBhdXNlcik7XG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcGF1c2VyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHVzZWQgdG8gcGF1c2UgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhdXNhYmxlID0gZnVuY3Rpb24gKHBhdXNlcikge1xuICAgIHJldHVybiBuZXcgUGF1c2FibGVPYnNlcnZhYmxlKHRoaXMsIHBhdXNlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tYmluZUxhdGVzdFNvdXJjZShzb3VyY2UsIHN1YmplY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgaGFzVmFsdWUgPSBbZmFsc2UsIGZhbHNlXSxcbiAgICAgICAgaGFzVmFsdWVBbGwgPSBmYWxzZSxcbiAgICAgICAgaXNEb25lID0gZmFsc2UsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheSgyKSxcbiAgICAgICAgZXJyO1xuXG4gICAgICBmdW5jdGlvbiBuZXh0KHgsIGkpIHtcbiAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgaGFzVmFsdWVbaV0gPSB0cnVlO1xuICAgICAgICBpZiAoaGFzVmFsdWVBbGwgfHwgKGhhc1ZhbHVlQWxsID0gaGFzVmFsdWUuZXZlcnkoaWRlbnRpdHkpKSkge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIG8ub25FcnJvcihlcnIpOyB9XG4gICAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKS5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgICAgby5vbk5leHQocmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpc0RvbmUgJiYgdmFsdWVzWzFdICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBuZXh0KHgsIDApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbMV0pIHtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZXNbMV0gJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH0pLFxuICAgICAgICBzdWJqZWN0LnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgbmV4dCh4LCAxKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dCh0cnVlLCAxKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICB2YXIgUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlKHNvdXJjZSwgcGF1c2VyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG5cbiAgICAgIGlmIChwYXVzZXIgJiYgcGF1c2VyLnN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLnBhdXNlciA9IHRoaXMuY29udHJvbGxlci5tZXJnZShwYXVzZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXI7XG4gICAgICB9XG5cbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBxID0gW10sIHByZXZpb3VzU2hvdWxkRmlyZTtcblxuICAgICAgZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHsgd2hpbGUgKHEubGVuZ3RoID4gMCkgeyBvLm9uTmV4dChxLnNoaWZ0KCkpOyB9IH1cblxuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9XG4gICAgICAgIGNvbWJpbmVMYXRlc3RTb3VyY2UoXG4gICAgICAgICAgdGhpcy5zb3VyY2UsXG4gICAgICAgICAgdGhpcy5wYXVzZXIuc3RhcnRXaXRoKCF0aGlzLnBhdXNlZCkuZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgICBmdW5jdGlvbiAoZGF0YSwgc2hvdWxkRmlyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgc2hvdWxkRmlyZTogc2hvdWxkRmlyZSB9O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1Nob3VsZEZpcmUgIT09IHVuZGVmaW5lZCAmJiByZXN1bHRzLnNob3VsZEZpcmUgIT09IHByZXZpb3VzU2hvdWxkRmlyZSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkRmlyZSA9IHJlc3VsdHMuc2hvdWxkRmlyZTtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgaW4gc2hvdWxkRmlyZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLnNob3VsZEZpcmUpIHsgZHJhaW5RdWV1ZSgpOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTaG91bGRGaXJlID0gcmVzdWx0cy5zaG91bGRGaXJlO1xuICAgICAgICAgICAgICAgIC8vIG5ldyBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuc2hvdWxkRmlyZSkge1xuICAgICAgICAgICAgICAgICAgby5vbk5leHQocmVzdWx0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcS5wdXNoKHJlc3VsdHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247ICAgICAgXG4gICAgfTtcblxuICAgIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQodHJ1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogUGF1c2VzIHRoZSB1bmRlcmx5aW5nIG9ic2VydmFibGUgc2VxdWVuY2UgYmFzZWQgdXBvbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCB5aWVsZHMgdHJ1ZS9mYWxzZSxcbiAgICogYW5kIHlpZWxkcyB0aGUgdmFsdWVzIHRoYXQgd2VyZSBidWZmZXJlZCB3aGlsZSBwYXVzZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwYXVzZXIgPSBuZXcgUnguU3ViamVjdCgpO1xuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDApLnBhdXNhYmxlQnVmZmVyZWQocGF1c2VyKTtcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBwYXVzZXIgVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwYXVzZSB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIHBhdXNlZCBiYXNlZCB1cG9uIHRoZSBwYXVzZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGF1c2FibGVCdWZmZXJlZCA9IGZ1bmN0aW9uIChwYXVzZXIpIHtcbiAgICByZXR1cm4gbmV3IFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlKHRoaXMsIHBhdXNlcik7XG4gIH07XG5cbiAgdmFyIENvbnRyb2xsZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb250cm9sbGVkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb250cm9sbGVkT2JzZXJ2YWJsZSAoc291cmNlLCBlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc3ViamVjdCA9IG5ldyBDb250cm9sbGVkU3ViamVjdChlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlLm11bHRpY2FzdCh0aGlzLnN1YmplY3QpLnJlZkNvdW50KCk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShvKTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlZE9ic2VydmFibGUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcykge1xuICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5yZXF1ZXN0KG51bWJlck9mSXRlbXMgPT0gbnVsbCA/IC0xIDogbnVtYmVyT2ZJdGVtcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb250cm9sbGVkT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGUpKTtcblxuICB2YXIgQ29udHJvbGxlZFN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbnRyb2xsZWRTdWJqZWN0LCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbnRyb2xsZWRTdWJqZWN0KGVuYWJsZVF1ZXVlLCBzY2hlZHVsZXIpIHtcbiAgICAgIGVuYWJsZVF1ZXVlID09IG51bGwgJiYgKGVuYWJsZVF1ZXVlID0gdHJ1ZSk7XG5cbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgIHRoaXMuZW5hYmxlUXVldWUgPSBlbmFibGVRdWV1ZTtcbiAgICAgIHRoaXMucXVldWUgPSBlbmFibGVRdWV1ZSA/IFtdIDogbnVsbDtcbiAgICAgIHRoaXMucmVxdWVzdGVkQ291bnQgPSAwO1xuICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlciB8fCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoQ29udHJvbGxlZFN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlciwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5zdWJzY3JpYmUobyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUXVldWUgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnN1YmplY3Qub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVldWUucHVzaChOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVRdWV1ZSB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuc3ViamVjdC5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVldWUucHVzaChOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvcihlcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkQ291bnQgPD0gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlUXVldWUgJiYgdGhpcy5xdWV1ZS5wdXNoKE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAodGhpcy5yZXF1ZXN0ZWRDb3VudC0tID09PSAwKSAmJiB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICAgIHRoaXMuc3ViamVjdC5vbk5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3Byb2Nlc3NSZXF1ZXN0OiBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcykge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVRdWV1ZSkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgKG51bWJlck9mSXRlbXMgPiAwIHx8IHRoaXMucXVldWVbMF0ua2luZCAhPT0gJ04nKSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgZmlyc3QuYWNjZXB0KHRoaXMuc3ViamVjdCk7XG4gICAgICAgICAgICBpZiAoZmlyc3Qua2luZCA9PT0gJ04nKSB7XG4gICAgICAgICAgICAgIG51bWJlck9mSXRlbXMtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZUN1cnJlbnRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYmVyT2ZJdGVtcztcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUN1cnJlbnRSZXF1ZXN0KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLnJlcXVlc3RlZERpc3Bvc2FibGUgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShudW1iZXIsXG4gICAgICAgIGZ1bmN0aW9uKHMsIGkpIHtcbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gc2VsZi5fcHJvY2Vzc1JlcXVlc3QoaSk7XG4gICAgICAgICAgdmFyIHN0b3BwZWQgPSBzZWxmLmhhc0NvbXBsZXRlZCB8fCBzZWxmLmhhc0ZhaWxlZDtcbiAgICAgICAgICBpZiAoIXN0b3BwZWQgJiYgcmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0ZWRDb3VudCA9IHJlbWFpbmluZztcblxuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZWxmLnJlcXVlc3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBTY2hlZHVsZWQgaXRlbSBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gUmV0dXJuIGEgbmV3XG4gICAgICAgICAgICAgIC8vIGRpc3Bvc2FibGUgdG8gYWxsb3cgdGhlIHJlcXVlc3QgdG8gYmUgaW50ZXJydXB0ZWRcbiAgICAgICAgICAgICAgLy8gdmlhIGRpc3Bvc2UuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2VDdXJyZW50UmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RlZERpc3Bvc2FibGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ29udHJvbGxlZFN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIGNvbnRyb2xsZXIgdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgYWJpbGl0eSB0byBxdWV1ZS5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwKS5jb250cm9sbGVkKCk7XG4gICAqIHNvdXJjZS5yZXF1ZXN0KDMpOyAvLyBSZWFkcyAzIHZhbHVlc1xuICAgKiBAcGFyYW0ge2Jvb2x9IGVuYWJsZVF1ZXVlIHRydXRoeSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIHNob3VsZCBiZSBxdWV1ZWQgcGVuZGluZyB0aGUgbmV4dCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgZGV0ZXJtaW5lcyBob3cgdGhlIHJlcXVlc3RzIHdpbGwgYmUgc2NoZWR1bGVkXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBvbmx5IHByb3BhZ2F0ZXMgdmFsdWVzIG9uIHJlcXVlc3QuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29udHJvbGxlZCA9IGZ1bmN0aW9uIChlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKSB7XG5cbiAgICBpZiAoZW5hYmxlUXVldWUgJiYgaXNTY2hlZHVsZXIoZW5hYmxlUXVldWUpKSB7XG4gICAgICBzY2hlZHVsZXIgPSBlbmFibGVRdWV1ZTtcbiAgICAgIGVuYWJsZVF1ZXVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlUXVldWUgPT0gbnVsbCkgeyAgZW5hYmxlUXVldWUgPSB0cnVlOyB9XG4gICAgcmV0dXJuIG5ldyBDb250cm9sbGVkT2JzZXJ2YWJsZSh0aGlzLCBlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU3RvcEFuZFdhaXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdG9wQW5kV2FpdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3RvcEFuZFdhaXRPYnNlcnZhYmxlIChzb3VyY2UpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuc291cmNlLnJlcXVlc3QoMSk7XG4gICAgfVxuXG4gICAgU3RvcEFuZFdhaXRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTdG9wQW5kV2FpdE9ic2VydmVyKG8sIHRoaXMsIHRoaXMuc3Vic2NyaXB0aW9uKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLFxuICAgICAgICBkZWZhdWx0U2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIHNjaGVkdWxlTWV0aG9kKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIFN0b3BBbmRXYWl0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3ViX18pIHtcbiAgICAgIGluaGVyaXRzKFN0b3BBbmRXYWl0T2JzZXJ2ZXIsIF9fc3ViX18pO1xuICAgICAgZnVuY3Rpb24gU3RvcEFuZFdhaXRPYnNlcnZlciAob2JzZXJ2ZXIsIG9ic2VydmFibGUsIGNhbmNlbCkge1xuICAgICAgICBfX3N1Yl9fLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgU3RvcEFuZFdhaXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgU3RvcEFuZFdhaXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBpbm5lclNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYub2JzZXJ2YWJsZS5zb3VyY2UucmVxdWVzdCgxKTtcbiAgICAgIH1cblxuICAgICAgU3RvcEFuZFdhaXRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gZGVmYXVsdFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBpbm5lclNjaGVkdWxlTWV0aG9kKTtcbiAgICAgIH07XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbCkge1xuICAgICAgICAgIHRoaXMuY2FuY2VsLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLmNhbmNlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZURpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfX3N1Yl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU3RvcEFuZFdhaXRPYnNlcnZlcjtcbiAgICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAgIHJldHVybiBTdG9wQW5kV2FpdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgc3RvcCBhbmQgd2FpdCBvYnNlcnZhYmxlIHRvIHRoZSBjdXJyZW50IG9ic2VydmFibGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIHN0b3AgYW5kIHdhaXQgb2JzZXJ2YWJsZS5cbiAgICovXG4gIENvbnRyb2xsZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdG9wQW5kV2FpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3BBbmRXYWl0T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgV2luZG93ZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaW5kb3dlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2luZG93ZWRPYnNlcnZhYmxlKHNvdXJjZSwgd2luZG93U2l6ZSkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuc291cmNlLnJlcXVlc3Qoc2VsZi53aW5kb3dTaXplKTtcbiAgICB9XG5cbiAgICBXaW5kb3dlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFdpbmRvd2VkT2JzZXJ2ZXIobywgdGhpcywgdGhpcy5zdWJzY3JpcHRpb24pKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24sXG4gICAgICAgIGRlZmF1bHRTY2hlZHVsZXIuc2NoZWR1bGUodGhpcywgc2NoZWR1bGVNZXRob2QpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgV2luZG93ZWRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdWJfXykge1xuICAgICAgaW5oZXJpdHMoV2luZG93ZWRPYnNlcnZlciwgX19zdWJfXyk7XG4gICAgICBmdW5jdGlvbiBXaW5kb3dlZE9ic2VydmVyKG9ic2VydmVyLCBvYnNlcnZhYmxlLCBjYW5jZWwpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgICAgX19zdWJfXy5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBXaW5kb3dlZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICBXaW5kb3dlZE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGlubmVyU2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgICByZXR1cm4gc2VsZi5vYnNlcnZhYmxlLnNvdXJjZS5yZXF1ZXN0KHNlbGYub2JzZXJ2YWJsZS53aW5kb3dTaXplKTtcbiAgICAgIH1cblxuICAgICAgV2luZG93ZWRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSArK3RoaXMucmVjZWl2ZWQgJSB0aGlzLm9ic2VydmFibGUud2luZG93U2l6ZTtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9PT0gMCAmJiAodGhpcy5zY2hlZHVsZURpc3Bvc2FibGUgPSBkZWZhdWx0U2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIGlubmVyU2NoZWR1bGVNZXRob2QpKTtcbiAgICAgIH07XG5cbiAgICAgIFdpbmRvd2VkT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbC5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSkge1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgX19zdWJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFdpbmRvd2VkT2JzZXJ2ZXI7XG4gICAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgICByZXR1cm4gV2luZG93ZWRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNsaWRpbmcgd2luZG93ZWQgb2JzZXJ2YWJsZSBiYXNlZCB1cG9uIHRoZSB3aW5kb3cgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd1NpemUgVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgd2luZG93XG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIHdpbmRvd2VkIG9ic2VydmFibGUgYmFzZWQgdXBvbiB0aGUgd2luZG93IHNpemUuXG4gICAqL1xuICBDb250cm9sbGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93ZWQgPSBmdW5jdGlvbiAod2luZG93U2l6ZSkge1xuICAgIHJldHVybiBuZXcgV2luZG93ZWRPYnNlcnZhYmxlKHRoaXMsIHdpbmRvd1NpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQaXBlcyB0aGUgZXhpc3RpbmcgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIGEgTm9kZS5qcyBTdHJlYW0uXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBkZXN0IFRoZSBkZXN0aW5hdGlvbiBOb2RlLmpzIHN0cmVhbS5cbiAgICogQHJldHVybnMge1N0cmVhbX0gVGhlIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5wYXVzYWJsZUJ1ZmZlcmVkKCk7XG5cbiAgICBmdW5jdGlvbiBvbkRyYWluKCkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIGRlc3QuYWRkTGlzdGVuZXIoJ2RyYWluJywgb25EcmFpbik7XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgIWRlc3Qud3JpdGUoeCkgJiYgc291cmNlLnBhdXNlKCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEhhY2sgY2hlY2sgYmVjYXVzZSBTVERJTyBpcyBub3QgY2xvc2FibGVcbiAgICAgICAgIWRlc3QuX2lzU3RkaW8gJiYgZGVzdC5lbmQoKTtcbiAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbkRyYWluKTtcbiAgICAgIH0pO1xuXG4gICAgc291cmNlLnJlc3VtZSgpO1xuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH07XG5cbiAgdmFyIE11bHRpY2FzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE11bHRpY2FzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTXVsdGljYXN0T2JzZXJ2YWJsZShzb3VyY2UsIGZuMSwgZm4yKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuMSA9IGZuMTtcbiAgICAgIHRoaXMuX2ZuMiA9IGZuMjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE11bHRpY2FzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5zb3VyY2UubXVsdGljYXN0KHRoaXMuX2ZuMSgpKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZSh0aGlzLl9mbjIoY29ubmVjdGFibGUpLnN1YnNjcmliZShvKSwgY29ubmVjdGFibGUuY29ubmVjdCgpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE11bHRpY2FzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogTXVsdGljYXN0cyB0aGUgc291cmNlIHNlcXVlbmNlIG5vdGlmaWNhdGlvbnMgdGhyb3VnaCBhbiBpbnN0YW50aWF0ZWQgc3ViamVjdCBpbnRvIGFsbCB1c2VzIG9mIHRoZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi4gRWFjaFxuICAgKiBzdWJzY3JpcHRpb24gdG8gdGhlIHJlc3VsdGluZyBzZXF1ZW5jZSBjYXVzZXMgYSBzZXBhcmF0ZSBtdWx0aWNhc3QgaW52b2NhdGlvbiwgZXhwb3NpbmcgdGhlIHNlcXVlbmNlIHJlc3VsdGluZyBmcm9tIHRoZSBzZWxlY3RvciBmdW5jdGlvbidzXG4gICAqIGludm9jYXRpb24uIEZvciBzcGVjaWFsaXphdGlvbnMgd2l0aCBmaXhlZCBzdWJqZWN0IHR5cGVzLCBzZWUgUHVibGlzaCwgUHVibGlzaExhc3QsIGFuZCBSZXBsYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDEgLSByZXMgPSBzb3VyY2UubXVsdGljYXN0KG9ic2VydmFibGUpO1xuICAgKiAyIC0gcmVzID0gc291cmNlLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3ViamVjdCgpOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3ViamVjdH0gc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yXG4gICAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGludGVybWVkaWF0ZSBzdWJqZWN0IHRocm91Z2ggd2hpY2ggdGhlIHNvdXJjZSBzZXF1ZW5jZSdzIGVsZW1lbnRzIHdpbGwgYmUgbXVsdGljYXN0IHRvIHRoZSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICogT3I6XG4gICAqIFN1YmplY3QgdG8gcHVzaCBzb3VyY2UgZWxlbWVudHMgaW50by5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2Ugc3ViamVjdCB0byB0aGUgcG9saWNpZXMgZW5mb3JjZWQgYnkgdGhlIGNyZWF0ZWQgc3ViamVjdC4gU3BlY2lmaWVkIG9ubHkgaWYgPHBhcmFtcmVmIG5hbWU9XCJzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3JcIiBpcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubXVsdGljYXN0ID0gZnVuY3Rpb24gKHN1YmplY3RPclN1YmplY3RTZWxlY3Rvciwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IpID9cbiAgICAgIG5ldyBNdWx0aWNhc3RPYnNlcnZhYmxlKHRoaXMsIHN1YmplY3RPclN1YmplY3RTZWxlY3Rvciwgc2VsZWN0b3IpIDpcbiAgICAgIG5ldyBDb25uZWN0YWJsZU9ic2VydmFibGUodGhpcywgc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS5cbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIE11bHRpY2FzdCB1c2luZyBhIHJlZ3VsYXIgU3ViamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlc3JlcyA9IHNvdXJjZS5wdWJsaXNoKCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlIHRpbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wdWJsaXNoID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yICYmIGlzRnVuY3Rpb24oc2VsZWN0b3IpID9cbiAgICAgIHRoaXMubXVsdGljYXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdWJqZWN0KCk7IH0sIHNlbGVjdG9yKSA6XG4gICAgICB0aGlzLm11bHRpY2FzdChuZXcgU3ViamVjdCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS5cbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIHB1Ymxpc2ggd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNoYXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiBhIGNvbm5lY3RhYmxlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIGNvbnRhaW5pbmcgb25seSB0aGUgbGFzdCBub3RpZmljYXRpb24uXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSBBc3luY1N1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaExhc3QoKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5wdWJsaXNoTGFzdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciBbT3B0aW9uYWxdIFNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIG9ubHkgcmVjZWl2ZSB0aGUgbGFzdCBub3RpZmljYXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wdWJsaXNoTGFzdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXN5bmNTdWJqZWN0KCk7IH0sIHNlbGVjdG9yKSA6XG4gICAgICB0aGlzLm11bHRpY2FzdChuZXcgQXN5bmNTdWJqZWN0KCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiBhIGNvbm5lY3RhYmxlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIGFuZCBzdGFydHMgd2l0aCBpbml0aWFsVmFsdWUuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSBCZWhhdmlvclN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaFZhbHVlKDQyKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5wdWJsaXNoVmFsdWUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2VsZWN0KGZ1bmN0aW9uICh5KSB7IHJldHVybiB5ICogeTsgfSkgfSwgNDIpO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgaW1tZWRpYXRlbHkgcmVjZWl2ZSB0aGUgaW5pdGlhbCB2YWx1ZSwgZm9sbG93ZWQgYnkgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxWYWx1ZSBJbml0aWFsIHZhbHVlIHJlY2VpdmVkIGJ5IG9ic2VydmVycyB1cG9uIHN1YnNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wdWJsaXNoVmFsdWUgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlT3JTZWxlY3RvciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgP1xuICAgICAgdGhpcy5tdWx0aWNhc3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJlaGF2aW9yU3ViamVjdChpbml0aWFsVmFsdWUpO1xuICAgICAgfSwgaW5pdGlhbFZhbHVlT3JTZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IEJlaGF2aW9yU3ViamVjdChpbml0aWFsVmFsdWVPclNlbGVjdG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgYW5kIHN0YXJ0cyB3aXRoIGFuIGluaXRpYWxWYWx1ZS5cbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIHB1Ymxpc2hWYWx1ZSB3aGljaCBjcmVhdGVzIGEgc3Vic2NyaXB0aW9uIHdoZW4gdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgZ29lcyBmcm9tIHplcm8gdG8gb25lLCB0aGVuIHNoYXJlcyB0aGF0IHN1YnNjcmlwdGlvbiB3aXRoIGFsbCBzdWJzZXF1ZW50IG9ic2VydmVycyB1bnRpbCB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyByZXR1cm5zIHRvIHplcm8sIGF0IHdoaWNoIHBvaW50IHRoZSBzdWJzY3JpcHRpb24gaXMgZGlzcG9zZWQuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxWYWx1ZSBJbml0aWFsIHZhbHVlIHJlY2VpdmVkIGJ5IG9ic2VydmVycyB1cG9uIHN1YnNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZVZhbHVlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hWYWx1ZShpbml0aWFsVmFsdWUpLnJlZkNvdW50KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgcmVwbGF5aW5nIG5vdGlmaWNhdGlvbnMgc3ViamVjdCB0byBhIG1heGltdW0gdGltZSBsZW5ndGggZm9yIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgUmVwbGF5U3ViamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5yZXBsYXkobnVsbCwgMyk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KG51bGwsIDMsIDUwMCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KG51bGwsIDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5yZXBsYXkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudGFrZSg2KS5yZXBlYXQoKTsgfSwgMywgNTAwLCBzY2hlZHVsZXIpO1xuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgW09wdGlvbmFsXSBTZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGFsbCB0aGUgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIHN1YmplY3QgdG8gdGhlIHNwZWNpZmllZCByZXBsYXkgYnVmZmVyIHRyaW1taW5nIHBvbGljeS5cbiAgICogQHBhcmFtIGJ1ZmZlclNpemUgW09wdGlvbmFsXSBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSB3aW5kb3dTaXplIFtPcHRpb25hbF0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHNjaGVkdWxlciBbT3B0aW9uYWxdIFNjaGVkdWxlciB3aGVyZSBjb25uZWN0ZWQgb2JzZXJ2ZXJzIHdpdGhpbiB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnJlcGxheSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yICYmIGlzRnVuY3Rpb24oc2VsZWN0b3IpID9cbiAgICAgIHRoaXMubXVsdGljYXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBSZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1NpemUsIHNjaGVkdWxlcik7IH0sIHNlbGVjdG9yKSA6XG4gICAgICB0aGlzLm11bHRpY2FzdChuZXcgUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSByZXBsYXlpbmcgbm90aWZpY2F0aW9ucyBzdWJqZWN0IHRvIGEgbWF4aW11bSB0aW1lIGxlbmd0aCBmb3IgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiByZXBsYXkgd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMsIDUwMCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2Uuc2hhcmVSZXBsYXkoMywgNTAwLCBzY2hlZHVsZXIpO1xuICAgKlxuXG4gICAqIEBwYXJhbSBidWZmZXJTaXplIFtPcHRpb25hbF0gTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gd2luZG93IFtPcHRpb25hbF0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHNjaGVkdWxlciBbT3B0aW9uYWxdIFNjaGVkdWxlciB3aGVyZSBjb25uZWN0ZWQgb2JzZXJ2ZXJzIHdpdGhpbiB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNoYXJlUmVwbGF5ID0gZnVuY3Rpb24gKGJ1ZmZlclNpemUsIHdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiB0aGlzLnJlcGxheShudWxsLCBidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpLnJlZkNvdW50KCk7XG4gIH07XG5cbiAgdmFyIElubmVyU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHMsIG8pIHtcbiAgICB0aGlzLl9zID0gcztcbiAgICB0aGlzLl9vID0gbztcbiAgfTtcblxuICBJbm5lclN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3MuaXNEaXNwb3NlZCAmJiB0aGlzLl9vICE9PSBudWxsKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5fcy5vYnNlcnZlcnMuaW5kZXhPZih0aGlzLl9vKTtcbiAgICAgIHRoaXMuX3Mub2JzZXJ2ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgdGhpcy5fbyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciBSZWZDb3VudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlZkNvdW50T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgIHRoaXMuX2Nvbm5lY3RhYmxlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFJlZkNvdW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG8pO1xuICAgICAgKyt0aGlzLl9jb3VudCA9PT0gMSAmJiAodGhpcy5fY29ubmVjdGFibGVTdWJzY3JpcHRpb24gPSB0aGlzLnNvdXJjZS5jb25uZWN0KCkpO1xuICAgICAgcmV0dXJuIG5ldyBSZWZDb3VudERpc3Bvc2FibGUodGhpcywgc3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmQ291bnREaXNwb3NhYmxlKHAsIHMpIHtcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBSZWZDb3VudERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zLmRpc3Bvc2UoKTtcbiAgICAgICAgLS10aGlzLl9wLl9jb3VudCA9PT0gMCAmJiB0aGlzLl9wLl9jb25uZWN0YWJsZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBSZWZDb3VudE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gUnguQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29ubmVjdERpc3Bvc2FibGUocGFyZW50LCBzdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3AgPSBwYXJlbnQ7XG4gICAgICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xuICAgIH1cblxuICAgIENvbm5lY3REaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3MpIHtcbiAgICAgICAgdGhpcy5fcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9wLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3NvdXJjZS5zdWJzY3JpYmUodGhpcy5fc3ViamVjdCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdERpc3Bvc2FibGUodGhpcywgc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uO1xuICAgIH07XG5cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Quc3Vic2NyaWJlKG8pO1xuICAgIH07XG5cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWZDb3VudE9ic2VydmFibGUodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLiBUaGlzIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogY2FuIGJlIHJlc3Vic2NyaWJlZCB0bywgZXZlbiBpZiBhbGwgcHJpb3Igc3Vic2NyaXB0aW9ucyBoYXZlIGVuZGVkLiAodW5saWtlIGAucHVibGlzaCgpLnJlZkNvdW50KClgKVxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNpbmdsZUluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMsIGhhc09ic2VydmFibGUgPSBmYWxzZSwgb2JzZXJ2YWJsZTtcblxuICAgIGZ1bmN0aW9uIGdldE9ic2VydmFibGUoKSB7XG4gICAgICBpZiAoIWhhc09ic2VydmFibGUpIHtcbiAgICAgICAgaGFzT2JzZXJ2YWJsZSA9IHRydWU7XG4gICAgICAgIG9ic2VydmFibGUgPSBzb3VyY2VbJ2ZpbmFsbHknXShmdW5jdGlvbigpIHsgaGFzT2JzZXJ2YWJsZSA9IGZhbHNlOyB9KS5wdWJsaXNoKCkucmVmQ291bnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gZ2V0T2JzZXJ2YWJsZSgpLnN1YnNjcmliZShvKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogIENvcnJlbGF0ZXMgdGhlIGVsZW1lbnRzIG9mIHR3byBzZXF1ZW5jZXMgYmFzZWQgb24gb3ZlcmxhcHBpbmcgZHVyYXRpb25zLlxuICAgKlxuICAgKiAgQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodCBUaGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBqb2luIGVsZW1lbnRzIGZvci5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IGxlZnREdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gc2VsZWN0IHRoZSBkdXJhdGlvbiAoZXhwcmVzc2VkIGFzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UpIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgbGVmdCBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2VkIHRvIGRldGVybWluZSBvdmVybGFwLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gcmlnaHREdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gc2VsZWN0IHRoZSBkdXJhdGlvbiAoZXhwcmVzc2VkIGFzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UpIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNlZCB0byBkZXRlcm1pbmUgb3ZlcmxhcC5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEEgZnVuY3Rpb24gaW52b2tlZCB0byBjb21wdXRlIGEgcmVzdWx0IGVsZW1lbnQgZm9yIGFueSB0d28gb3ZlcmxhcHBpbmcgZWxlbWVudHMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2VzLiBUaGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGNvcnJlc3BvbmQgd2l0aCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgc291cmNlIHNlcXVlbmNlcyBmb3Igd2hpY2ggb3ZlcmxhcCBvY2N1cnMuXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHJlc3VsdCBlbGVtZW50cyBjb21wdXRlZCBmcm9tIHNvdXJjZSBlbGVtZW50cyB0aGF0IGhhdmUgYW4gb3ZlcmxhcHBpbmcgZHVyYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uam9pbiA9IGZ1bmN0aW9uIChyaWdodCwgbGVmdER1cmF0aW9uU2VsZWN0b3IsIHJpZ2h0RHVyYXRpb25TZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICB2YXIgbGVmdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIGxlZnREb25lID0gZmFsc2UsIHJpZ2h0RG9uZSA9IGZhbHNlO1xuICAgICAgdmFyIGxlZnRJZCA9IDAsIHJpZ2h0SWQgPSAwO1xuICAgICAgdmFyIGxlZnRNYXAgPSBuZXcgTWFwKCksIHJpZ2h0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9O1xuXG4gICAgICBncm91cC5hZGQobGVmdC5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IGxlZnRJZCsrLCBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuXG4gICAgICAgICAgbGVmdE1hcC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgICBncm91cC5hZGQobWQpO1xuXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2gobGVmdER1cmF0aW9uU2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZHVyYXRpb24uZSk7IH1cblxuICAgICAgICAgIG1kLnNldERpc3Bvc2FibGUoZHVyYXRpb24udGFrZSgxKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGxlZnRNYXBbJ2RlbGV0ZSddKGlkKSAmJiBsZWZ0TWFwLnNpemUgPT09IDAgJiYgbGVmdERvbmUgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgICBncm91cC5yZW1vdmUobWQpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgcmlnaHRNYXAuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKSh2YWx1ZSwgdik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICAgICAgby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZWZ0RG9uZSA9IHRydWU7XG4gICAgICAgICAgKHJpZ2h0RG9uZSB8fCBsZWZ0TWFwLnNpemUgPT09IDApICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGdyb3VwLmFkZChyaWdodC5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IHJpZ2h0SWQrKywgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgICAgIHJpZ2h0TWFwLnNldChpZCwgdmFsdWUpO1xuICAgICAgICAgIGdyb3VwLmFkZChtZCk7XG5cbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChyaWdodER1cmF0aW9uU2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZHVyYXRpb24uZSk7IH1cblxuICAgICAgICAgIG1kLnNldERpc3Bvc2FibGUoZHVyYXRpb24udGFrZSgxKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJpZ2h0TWFwWydkZWxldGUnXShpZCkgJiYgcmlnaHRNYXAuc2l6ZSA9PT0gMCAmJiByaWdodERvbmUgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgICBncm91cC5yZW1vdmUobWQpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2gocmVzdWx0U2VsZWN0b3IpKHYsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgICAgICBvLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJpZ2h0RG9uZSA9IHRydWU7XG4gICAgICAgICAgKGxlZnREb25lIHx8IHJpZ2h0TWFwLnNpemUgPT09IDApICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSwgbGVmdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDb3JyZWxhdGVzIHRoZSBlbGVtZW50cyBvZiB0d28gc2VxdWVuY2VzIGJhc2VkIG9uIG92ZXJsYXBwaW5nIGR1cmF0aW9ucywgYW5kIGdyb3VwcyB0aGUgcmVzdWx0cy5cbiAgICpcbiAgICogIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcmlnaHQgVGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UgdG8gam9pbiBlbGVtZW50cyBmb3IuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBsZWZ0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIGxlZnQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNlZCB0byBkZXRlcm1pbmUgb3ZlcmxhcC5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJpZ2h0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBBIGZ1bmN0aW9uIGludm9rZWQgdG8gY29tcHV0ZSBhIHJlc3VsdCBlbGVtZW50IGZvciBhbnkgZWxlbWVudCBvZiB0aGUgbGVmdCBzZXF1ZW5jZSB3aXRoIG92ZXJsYXBwaW5nIGVsZW1lbnRzIGZyb20gdGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UuIFRoZSBmaXJzdCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBpcyBhbiBlbGVtZW50IG9mIHRoZSBsZWZ0IHNlcXVlbmNlLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBlbGVtZW50cyBmcm9tIHRoZSByaWdodCBzZXF1ZW5jZSB0aGF0IG92ZXJsYXAgd2l0aCB0aGUgbGVmdCBzZXF1ZW5jZSdzIGVsZW1lbnQuXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHJlc3VsdCBlbGVtZW50cyBjb21wdXRlZCBmcm9tIHNvdXJjZSBlbGVtZW50cyB0aGF0IGhhdmUgYW4gb3ZlcmxhcHBpbmcgZHVyYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZ3JvdXBKb2luID0gZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0RHVyYXRpb25TZWxlY3RvciwgcmlnaHREdXJhdGlvblNlbGVjdG9yLCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHZhciBsZWZ0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICB2YXIgciA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXApO1xuICAgICAgdmFyIGxlZnRNYXAgPSBuZXcgTWFwKCksIHJpZ2h0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIGxlZnRJZCA9IDAsIHJpZ2h0SWQgPSAwO1xuICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHYub25FcnJvcihlKTsgfTsgfTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZSkgeyB9O1xuXG4gICAgICBncm91cC5hZGQobGVmdC5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICB2YXIgaWQgPSBsZWZ0SWQrKztcbiAgICAgICAgICBsZWZ0TWFwLnNldChpZCwgcyk7XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2gocmVzdWx0U2VsZWN0b3IpKHZhbHVlLCBhZGRSZWYocywgcikpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IocmVzdWx0LmUpKTtcbiAgICAgICAgICAgIHJldHVybiBvLm9uRXJyb3IocmVzdWx0LmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvLm9uTmV4dChyZXN1bHQpO1xuXG4gICAgICAgICAgcmlnaHRNYXAuZm9yRWFjaChmdW5jdGlvbiAodikgeyBzLm9uTmV4dCh2KTsgfSk7XG5cbiAgICAgICAgICB2YXIgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICBncm91cC5hZGQobWQpO1xuXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2gobGVmdER1cmF0aW9uU2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZHVyYXRpb24uZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGxlZnRNYXBbJ2RlbGV0ZSddKGlkKSAmJiBzLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgby5vbkNvbXBsZXRlZCgpOyB9KVxuICAgICAgKTtcblxuICAgICAgZ3JvdXAuYWRkKHJpZ2h0LnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGlkID0gcmlnaHRJZCsrO1xuICAgICAgICAgIHJpZ2h0TWFwLnNldChpZCwgdmFsdWUpO1xuXG4gICAgICAgICAgdmFyIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoKHJpZ2h0RHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihkdXJhdGlvbi5lKSk7XG4gICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1kLnNldERpc3Bvc2FibGUoZHVyYXRpb24udGFrZSgxKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmlnaHRNYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChmdW5jdGlvbiAodikgeyB2Lm9uTmV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgbGVmdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9BcnJheSh4KSB7IHJldHVybiB4LnRvQXJyYXkoKTsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgYnVmZmVycy5cbiAgICogIEBwYXJhbSB7TWl4ZWR9IGJ1ZmZlck9wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBkZW5vdGUgdGhlIGNyZWF0aW9uIG9mIG5ldyB3aW5kb3dzLCBvciwgYSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcHJvZHVjZWQgd2luZG93cyAoYSBuZXcgd2luZG93IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb25lIGlzIGNsb3NlZCwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzKS5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtidWZmZXJDbG9zaW5nU2VsZWN0b3JdIEEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGNsb3Npbmcgb2YgZWFjaCBwcm9kdWNlZCB3aW5kb3cuIElmIGEgY2xvc2luZyBzZWxlY3RvciBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQuXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53aW5kb3cuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgLmZsYXRNYXAodG9BcnJheSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSB3aW5kb3dzLlxuICAgKlxuICAgKiAgQHBhcmFtIHtNaXhlZH0gd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvciBPYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGRlbm90ZSB0aGUgY3JlYXRpb24gb2YgbmV3IHdpbmRvd3MsIG9yLCBhIGZ1bmN0aW9uIGludm9rZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwcm9kdWNlZCB3aW5kb3dzIChhIG5ldyB3aW5kb3cgaXMgc3RhcnRlZCB3aGVuIHRoZSBwcmV2aW91cyBvbmUgaXMgY2xvc2VkLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIHdpbmRvd3MpLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW3dpbmRvd0Nsb3NpbmdTZWxlY3Rvcl0gQSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgY2xvc2luZyBvZiBlYWNoIHByb2R1Y2VkIHdpbmRvdy4gSWYgYSBjbG9zaW5nIHNlbGVjdG9yIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlciwgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHdpbmRvd3MuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2luZG93ID0gZnVuY3Rpb24gKHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IsIHdpbmRvd0Nsb3NpbmdTZWxlY3Rvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlV2luZG93V2l0aEJvdW5kYXJpZXMuY2FsbCh0aGlzLCB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yID09PSAnZnVuY3Rpb24nID9cbiAgICAgIG9ic2VydmFibGVXaW5kb3dXaXRoQ2xvc2luZ1NlbGVjdG9yLmNhbGwodGhpcywgd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvcikgOlxuICAgICAgb2JzZXJ2YWJsZVdpbmRvd1dpdGhPcGVuaW5ncy5jYWxsKHRoaXMsIHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IsIHdpbmRvd0Nsb3NpbmdTZWxlY3Rvcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVdpbmRvd1dpdGhPcGVuaW5ncyh3aW5kb3dPcGVuaW5ncywgd2luZG93Q2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd09wZW5pbmdzLmdyb3VwSm9pbih0aGlzLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IsIG9ic2VydmFibGVFbXB0eSwgZnVuY3Rpb24gKF8sIHdpbikge1xuICAgICAgcmV0dXJuIHdpbjtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVXaW5kb3dXaXRoQm91bmRhcmllcyh3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHdpbiA9IG5ldyBTdWJqZWN0KCksXG4gICAgICAgIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxuICAgICAgICByID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShkKTtcblxuICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZih3aW4sIHIpKTtcblxuICAgICAgZC5hZGQoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICB3aW4ub25OZXh0KHgpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB3aW4ub25FcnJvcihlcnIpO1xuICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSkpO1xuXG4gICAgICBpc1Byb21pc2Uod2luZG93Qm91bmRhcmllcykgJiYgKHdpbmRvd0JvdW5kYXJpZXMgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uod2luZG93Qm91bmRhcmllcykpO1xuXG4gICAgICBkLmFkZCh3aW5kb3dCb3VuZGFyaWVzLnN1YnNjcmliZShmdW5jdGlvbiAodykge1xuICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgd2luID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZih3aW4sIHIpKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVXaW5kb3dXaXRoQ2xvc2luZ1NlbGVjdG9yKHdpbmRvd0Nsb3NpbmdTZWxlY3Rvcikge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBtID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgZCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKG0pLFxuICAgICAgICByID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShkKSxcbiAgICAgICAgd2luID0gbmV3IFN1YmplY3QoKTtcbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG4gICAgICBkLmFkZChzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgd2luLm9uTmV4dCh4KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB3aW4ub25FcnJvcihlcnIpO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVXaW5kb3dDbG9zZSAoKSB7XG4gICAgICAgIHZhciB3aW5kb3dDbG9zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3dDbG9zZSA9IHdpbmRvd0Nsb3NpbmdTZWxlY3RvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpc1Byb21pc2Uod2luZG93Q2xvc2UpICYmICh3aW5kb3dDbG9zZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh3aW5kb3dDbG9zZSkpO1xuXG4gICAgICAgIHZhciBtMSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBtLnNldERpc3Bvc2FibGUobTEpO1xuICAgICAgICBtMS5zZXREaXNwb3NhYmxlKHdpbmRvd0Nsb3NlLnRha2UoMSkuc3Vic2NyaWJlKG5vb3AsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB3aW4ub25FcnJvcihlcnIpO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIHdpbiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZih3aW4sIHIpKTtcbiAgICAgICAgICBjcmVhdGVXaW5kb3dDbG9zZSgpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZVdpbmRvd0Nsb3NlKCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgdmFyIFBhaXJ3aXNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUGFpcndpc2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUGFpcndpc2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFBhaXJ3aXNlT2JzZXJ2ZXIobykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGFpcndpc2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFBhaXJ3aXNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUGFpcndpc2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IG51bGw7XG4gICAgICB0aGlzLl9ocCA9IGZhbHNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUGFpcndpc2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faHApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoW3RoaXMuX3AsIHhdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3AgPSB4O1xuICAgIH07XG4gICAgUGFpcndpc2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRoaXMuX28ub25FcnJvcihlcnIpOyB9O1xuICAgIFBhaXJ3aXNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFBhaXJ3aXNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9ic2VydmFibGUgdGhhdCB0cmlnZ2VycyBvbiB0aGUgc2Vjb25kIGFuZCBzdWJzZXF1ZW50IHRyaWdnZXJpbmdzIG9mIHRoZSBpbnB1dCBvYnNlcnZhYmxlLlxuICAgKiBUaGUgTnRoIHRyaWdnZXJpbmcgb2YgdGhlIGlucHV0IG9ic2VydmFibGUgcGFzc2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgTi0xdGggYW5kIE50aCB0cmlnZ2VyaW5nIGFzIGEgcGFpci5cbiAgICogVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgTi0xdGggdHJpZ2dlcmluZyBpcyBoZWxkIGluIGhpZGRlbiBpbnRlcm5hbCBzdGF0ZSB1bnRpbCB0aGUgTnRoIHRyaWdnZXJpbmcgb2NjdXJzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSB0aGF0IHRyaWdnZXJzIG9uIHN1Y2Nlc3NpdmUgcGFpcnMgb2Ygb2JzZXJ2YXRpb25zIGZyb20gdGhlIGlucHV0IG9ic2VydmFibGUgYXMgYW4gYXJyYXkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGFpcndpc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQYWlyd2lzZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHdvIG9ic2VydmFibGVzIHdoaWNoIHBhcnRpdGlvbiB0aGUgb2JzZXJ2YXRpb25zIG9mIHRoZSBzb3VyY2UgYnkgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgd2lsbCB0cmlnZ2VyIG9ic2VydmF0aW9ucyBmb3IgdGhvc2UgdmFsdWVzIGZvciB3aGljaCB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS5cbiAgICogVGhlIHNlY29uZCB3aWxsIHRyaWdnZXIgb2JzZXJ2YXRpb25zIGZvciB0aG9zZSB2YWx1ZXMgd2hlcmUgdGhlIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlLlxuICAgKiBUaGUgcHJlZGljYXRlIGlzIGV4ZWN1dGVkIG9uY2UgZm9yIGVhY2ggc3Vic2NyaWJlZCBvYnNlcnZlci5cbiAgICogQm90aCBhbHNvIHByb3BhZ2F0ZSBhbGwgZXJyb3Igb2JzZXJ2YXRpb25zIGFyaXNpbmcgZnJvbSB0aGUgc291cmNlIGFuZCBlYWNoIGNvbXBsZXRlc1xuICAgKiB3aGVuIHRoZSBzb3VyY2UgY29tcGxldGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogICAgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIHRyaWdnZXIgYSBwYXJ0aWN1bGFyIG9ic2VydmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqICAgIEFuIGFycmF5IG9mIG9ic2VydmFibGVzLiBUaGUgZmlyc3QgdHJpZ2dlcnMgd2hlbiB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSxcbiAgICogICAgYW5kIHRoZSBzZWNvbmQgdHJpZ2dlcnMgd2hlbiB0aGUgcHJlZGljYXRlIHJldHVybnMgZmFsc2UuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5wYXJ0aXRpb24gPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gW1xuICAgICAgdGhpcy5maWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSxcbiAgICAgIHRoaXMuZmlsdGVyKGZ1bmN0aW9uICh4LCBpLCBvKSB7IHJldHVybiAhZm4oeCwgaSwgbyk7IH0pXG4gICAgXTtcbiAgfTtcblxuICB2YXIgV2hpbGVFbnVtZXJhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFdoaWxlRW51bWVyYWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBXaGlsZUVudW1lcmFibGUoYywgcykge1xuICAgICAgdGhpcy5jID0gYztcbiAgICAgIHRoaXMucyA9IHM7XG4gICAgfVxuICAgIFdoaWxlRW51bWVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuYygpID9cbiAgICAgICAgICAgeyBkb25lOiBmYWxzZSwgdmFsdWU6IHNlbGYucyB9IDpcbiAgICAgICAgICAgeyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gV2hpbGVFbnVtZXJhYmxlO1xuICB9KEVudW1lcmFibGUpKTtcbiAgXG4gIGZ1bmN0aW9uIGVudW1lcmFibGVXaGlsZShjb25kaXRpb24sIHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgV2hpbGVFbnVtZXJhYmxlKGNvbmRpdGlvbiwgc291cmNlKTtcbiAgfSAgXG5cbiAgIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gdGhlIHNvdXJjZSBzZXF1ZW5jZSwgd2l0aG91dCBzaGFyaW5nIHN1YnNjcmlwdGlvbnMuXG4gICAqICBUaGlzIG9wZXJhdG9yIGFsbG93cyBmb3IgYSBmbHVlbnQgc3R5bGUgb2Ygd3JpdGluZyBxdWVyaWVzIHRoYXQgdXNlIHRoZSBzYW1lIHNlcXVlbmNlIG11bHRpcGxlIHRpbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubGV0QmluZCA9IG9ic2VydmFibGVQcm90b1snbGV0J10gPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jKHRoaXMpO1xuICB9O1xuXG4gICAvKipcbiAgICogIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gY29udGFpbnMgdmFsdWVzLiBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSk7XG4gICAqICAyIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pZihjb25kaXRpb24sIG9iczEsIG9iczIpO1xuICAgKiAgMyAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaWYoY29uZGl0aW9uLCBvYnMxLCBzY2hlZHVsZXIpO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSB0aGVuU291cmNlIG9yIGVsc2VTb3VyY2Ugd2lsbCBiZSBydW4uXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gdGhlblNvdXJjZSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gW2Vsc2VTb3VyY2VdIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UuIElmIHRoaXMgaXMgbm90IHByb3ZpZGVkLCBpdCBkZWZhdWx0cyB0byBSeC5PYnNlcnZhYmUuRW1wdHkgd2l0aCB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgZWl0aGVyIHRoZSB0aGVuU291cmNlIG9yIGVsc2VTb3VyY2UuXG4gICAqL1xuICBPYnNlcnZhYmxlWydpZiddID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgdGhlblNvdXJjZSwgZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBlbHNlU291cmNlT3JTY2hlZHVsZXIgfHwgKGVsc2VTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVFbXB0eSgpKTtcblxuICAgICAgaXNQcm9taXNlKHRoZW5Tb3VyY2UpICYmICh0aGVuU291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHRoZW5Tb3VyY2UpKTtcbiAgICAgIGlzUHJvbWlzZShlbHNlU291cmNlT3JTY2hlZHVsZXIpICYmIChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSk7XG5cbiAgICAgIC8vIEFzc3VtZSBhIHNjaGVkdWxlciBmb3IgZW1wdHkgb25seVxuICAgICAgdHlwZW9mIGVsc2VTb3VyY2VPclNjaGVkdWxlci5ub3cgPT09ICdmdW5jdGlvbicgJiYgKGVsc2VTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVFbXB0eShlbHNlU291cmNlT3JTY2hlZHVsZXIpKTtcbiAgICAgIHJldHVybiBjb25kaXRpb24oKSA/IHRoZW5Tb3VyY2UgOiBlbHNlU291cmNlT3JTY2hlZHVsZXI7XG4gICAgfSk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgQ29uY2F0ZW5hdGVzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlcyBvYnRhaW5lZCBieSBydW5uaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZvciBlYWNoIGVsZW1lbnQgaW4gc291cmNlLlxuICAgKiBUaGVyZSBpcyBhbiBhbGlhcyBmb3IgdGhpcyBtZXRob2QgY2FsbGVkICdmb3JJbicgZm9yIGJyb3dzZXJzIDxJRTlcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlcyBBbiBhcnJheSBvZiB2YWx1ZXMgdG8gdHVybiBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIHRoZSBzb3VyY2VzIGFycmF5IHRvIHR1cm4gaXQgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIHRoZSBjb25jYXRlbmF0ZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqL1xuICBPYnNlcnZhYmxlWydmb3InXSA9IE9ic2VydmFibGUuZm9ySW4gPSBmdW5jdGlvbiAoc291cmNlcywgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZW51bWVyYWJsZU9mKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5jb25jYXQoKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBSZXBlYXRzIHNvdXJjZSBhcyBsb25nIGFzIGNvbmRpdGlvbiBob2xkcyBlbXVsYXRpbmcgYSB3aGlsZSBsb29wLlxuICAgKiBUaGVyZSBpcyBhbiBhbGlhcyBmb3IgdGhpcyBtZXRob2QgY2FsbGVkICd3aGlsZURvJyBmb3IgYnJvd3NlcnMgPElFOVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBzb3VyY2Ugd2lsbCBiZSByZXBlYXRlZC5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzb3VyY2UgVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgcmVwZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY29uZGl0aW9uIGhvbGRzLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVXaGlsZURvID0gT2JzZXJ2YWJsZVsnd2hpbGUnXSA9IE9ic2VydmFibGUud2hpbGVEbyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHNvdXJjZSkge1xuICAgIGlzUHJvbWlzZShzb3VyY2UpICYmIChzb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc291cmNlKSk7XG4gICAgcmV0dXJuIGVudW1lcmFibGVXaGlsZShjb25kaXRpb24sIHNvdXJjZSkuY29uY2F0KCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgUmVwZWF0cyBzb3VyY2UgYXMgbG9uZyBhcyBjb25kaXRpb24gaG9sZHMgZW11bGF0aW5nIGEgZG8gd2hpbGUgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgc291cmNlIHdpbGwgYmUgcmVwZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc291cmNlIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIHRydWUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIHJlcGVhdGVkIGFzIGxvbmcgYXMgdGhlIGNvbmRpdGlvbiBob2xkcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kb1doaWxlID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlQ29uY2F0KFt0aGlzLCBvYnNlcnZhYmxlV2hpbGVEbyhjb25kaXRpb24sIHRoaXMpXSk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgVXNlcyBzZWxlY3RvciB0byBkZXRlcm1pbmUgd2hpY2ggc291cmNlIGluIHNvdXJjZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBUaGUgZnVuY3Rpb24gd2hpY2ggZXh0cmFjdHMgdGhlIHZhbHVlIGZvciB0byB0ZXN0IGluIGEgY2FzZSBzdGF0ZW1lbnQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZXMgQSBvYmplY3Qgd2hpY2ggaGFzIGtleXMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY2FzZSBzdGF0ZW1lbnQgbGFiZWxzLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IFtlbHNlU291cmNlXSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBtYXRjaGVkLiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gUnguT2JzZXJ2YWJlLmVtcHR5IHdpdGggdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIGRldGVybWluZWQgYnkgYSBjYXNlIHN0YXRlbWVudC5cbiAgICovXG4gIE9ic2VydmFibGVbJ2Nhc2UnXSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc291cmNlcywgZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBpc1Byb21pc2UoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSAmJiAoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikpO1xuICAgICAgZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyIHx8IChkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoKSk7XG5cbiAgICAgIGlzU2NoZWR1bGVyKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikgJiYgKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVFbXB0eShkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZXNbc2VsZWN0b3IoKV07XG4gICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcjtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgRXhwYW5kT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFeHBhbmRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV4cGFuZE9ic2VydmFibGUoc291cmNlLCBmbiwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlY3Vyc2l2ZShhcmdzLCByZWN1cnNlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBhcmdzWzBdLCBzZWxmID0gYXJnc1sxXTtcbiAgICAgIHZhciB3b3JrO1xuICAgICAgaWYgKHN0YXRlLnEubGVuZ3RoID4gMCkge1xuICAgICAgICB3b3JrID0gc3RhdGUucS5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuaXNBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbTEgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHN0YXRlLmQuYWRkKG0xKTtcbiAgICAgIG0xLnNldERpc3Bvc2FibGUod29yay5zdWJzY3JpYmUobmV3IEV4cGFuZE9ic2VydmVyKHN0YXRlLCBzZWxmLCBtMSkpKTtcbiAgICAgIHJlY3Vyc2UoW3N0YXRlLCBzZWxmXSk7XG4gICAgfVxuXG4gICAgRXhwYW5kT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2Vuc3VyZUFjdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIGlzT3duZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzdGF0ZS5xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXNPd25lciA9ICFzdGF0ZS5pc0FjcXVpcmVkO1xuICAgICAgICBzdGF0ZS5pc0FjcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlzT3duZXIgJiYgc3RhdGUubS5zZXREaXNwb3NhYmxlKHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShbc3RhdGUsIHRoaXNdLCBzY2hlZHVsZVJlY3Vyc2l2ZSkpO1xuICAgIH07XG5cbiAgICBFeHBhbmRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBtID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgZCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKG0pLFxuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICBxOiBbXSxcbiAgICAgICAgICBtOiBtLFxuICAgICAgICAgIGQ6IGQsXG4gICAgICAgICAgYWN0aXZlQ291bnQ6IDAsXG4gICAgICAgICAgaXNBY3F1aXJlZDogZmFsc2UsXG4gICAgICAgICAgbzogb1xuICAgICAgICB9O1xuXG4gICAgICBzdGF0ZS5xLnB1c2godGhpcy5zb3VyY2UpO1xuICAgICAgc3RhdGUuYWN0aXZlQ291bnQrKztcbiAgICAgIHRoaXMuX2Vuc3VyZUFjdGl2ZShzdGF0ZSk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV4cGFuZE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRXhwYW5kT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXhwYW5kT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXhwYW5kT2JzZXJ2ZXIoc3RhdGUsIHBhcmVudCwgbTEpIHtcbiAgICAgIHRoaXMuX3MgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX3AgPSBwYXJlbnQ7XG4gICAgICB0aGlzLl9tMSA9IG0xO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXhwYW5kT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fcy5vLm9uTmV4dCh4KTtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9wLl9mbikoeCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fcy5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICB0aGlzLl9zLnEucHVzaChyZXN1bHQpO1xuICAgICAgdGhpcy5fcy5hY3RpdmVDb3VudCsrO1xuICAgICAgdGhpcy5fcC5fZW5zdXJlQWN0aXZlKHRoaXMuX3MpO1xuICAgIH07XG5cbiAgICBFeHBhbmRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIEV4cGFuZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zLmQucmVtb3ZlKHRoaXMuX20xKTtcbiAgICAgIHRoaXMuX3MuYWN0aXZlQ291bnQtLTtcbiAgICAgIHRoaXMuX3MuYWN0aXZlQ291bnQgPT09IDAgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHBhbmRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgIC8qKlxuICAgKiAgRXhwYW5kcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHJlY3Vyc2l2ZWx5IGludm9raW5nIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggcHJvZHVjZWQgZWxlbWVudCwgcmVzdWx0aW5nIGluIGFub3RoZXIgc2VxdWVuY2UgdG8gd2hpY2ggdGhlIHNlbGVjdG9yIHdpbGwgYmUgaW52b2tlZCByZWN1cnNpdmVseSBhZ2Fpbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciBvbiB3aGljaCB0byBwZXJmb3JtIHRoZSBleHBhbnNpb24uIElmIG5vdCBwcm92aWRlZCwgdGhpcyBkZWZhdWx0cyB0byB0aGUgY3VycmVudCB0aHJlYWQgc2NoZWR1bGVyLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgcHJvZHVjZWQgYnkgdGhlIHJlY3Vyc2l2ZSBleHBhbnNpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZXhwYW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEV4cGFuZE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXJndW1lbnRzVG9BcnJheSgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICB2YXIgRm9ya0pvaW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGb3JrSm9pbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRm9ya0pvaW5PYnNlcnZhYmxlKHNvdXJjZXMsIGNiKSB7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gc291cmNlcztcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGb3JrSm9pbk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gdGhpcy5fc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGZpbmlzaGVkOiBmYWxzZSxcbiAgICAgICAgaGFzUmVzdWx0czogbmV3IEFycmF5KGNvdW50KSxcbiAgICAgICAgaGFzQ29tcGxldGVkOiBuZXcgQXJyYXkoY291bnQpLFxuICAgICAgICByZXN1bHRzOiBuZXcgQXJyYXkoY291bnQpXG4gICAgICB9O1xuXG4gICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fc291cmNlc1tpXTtcbiAgICAgICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5hZGQoc291cmNlLnN1YnNjcmliZShuZXcgRm9ya0pvaW5PYnNlcnZlcihvLCBzdGF0ZSwgaSwgdGhpcy5fY2IsIHN1YnNjcmlwdGlvbnMpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb25zO1xuICAgIH07XG5cbiAgICByZXR1cm4gRm9ya0pvaW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEZvcmtKb2luT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRm9ya0pvaW5PYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGb3JrSm9pbk9ic2VydmVyKG8sIHMsIGksIGNiLCBzdWJzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3VicyA9IHN1YnM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGb3JrSm9pbk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICghdGhpcy5fcy5maW5pc2hlZCkge1xuICAgICAgICB0aGlzLl9zLmhhc1Jlc3VsdHNbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9zLnJlc3VsdHNbdGhpcy5faV0gPSB4O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBGb3JrSm9pbk9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICAgIHRoaXMuX3N1YnMuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICBGb3JrSm9pbk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3MuZmluaXNoZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zLmhhc1Jlc3VsdHNbdGhpcy5faV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3MuaGFzQ29tcGxldGVkW3RoaXMuX2ldID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3MuaGFzQ29tcGxldGVkW2ldKSB7IHJldHVybjsgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3MuZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9jYikuYXBwbHkobnVsbCwgdGhpcy5fcy5yZXN1bHRzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cblxuICAgICAgICB0aGlzLl9vLm9uTmV4dChyZXMpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGb3JrSm9pbk9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAgLyoqXG4gICAqICBSdW5zIGFsbCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiBwYXJhbGxlbCBhbmQgY29sbGVjdCB0aGVpciBsYXN0IGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuZm9ya0pvaW4oW29iczEsIG9iczJdKTtcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmZvcmtKb2luKG9iczEsIG9iczIsIC4uLik7XG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYW4gYXJyYXkgY29sbGVjdGluZyB0aGUgbGFzdCBlbGVtZW50cyBvZiBhbGwgdGhlIGlucHV0IHNlcXVlbmNlcy5cbiAgICovXG4gIE9ic2VydmFibGUuZm9ya0pvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG4gICAgcmV0dXJuIG5ldyBGb3JrSm9pbk9ic2VydmFibGUoYXJncywgcmVzdWx0U2VsZWN0b3IpO1xuICB9O1xuXG4gICAvKipcbiAgICogIFJ1bnMgdHdvIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHBhcmFsbGVsIGFuZCBjb21iaW5lcyB0aGVpciBsYXN0IGVsZW1lbmV0cy5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzZWNvbmQgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCB0aGUgbGFzdCBlbGVtZW50cyBvZiBib3RoIHNlcXVlbmNlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIGxhc3QgZWxlbWVudHMgb2YgYm90aCBpbnB1dCBzZXF1ZW5jZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZm9ya0pvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzWzBdLnVuc2hpZnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9ic2VydmFibGUuZm9ya0pvaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbW9uYWRpYyBiaW5kIG9wZXJhdG9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlZHVsZXIgU2NoZWR1bGVyIHVzZWQgdG8gZXhlY3V0ZSB0aGUgb3BlcmF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgSW1tZWRpYXRlU2NoZWR1bGVyLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCByZXN1bHRzIGZyb20gdGhlIGNvbW9uYWRpYyBiaW5kIG9wZXJhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5tYW55U2VsZWN0ID0gb2JzZXJ2YWJsZVByb3RvLmV4dGVuZCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gUnguU2NoZWR1bGVyLmltbWVkaWF0ZSk7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2hhaW47XG5cbiAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHZhciBjdXJyID0gbmV3IENoYWluT2JzZXJ2YWJsZSh4KTtcblxuICAgICAgICAgIGNoYWluICYmIGNoYWluLm9uTmV4dCh4KTtcbiAgICAgICAgICBjaGFpbiA9IGN1cnI7XG5cbiAgICAgICAgICByZXR1cm4gY3VycjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRhcChcbiAgICAgICAgICBub29wLFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IGNoYWluICYmIGNoYWluLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24gKCkgeyBjaGFpbiAmJiBjaGFpbi5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgIClcbiAgICAgICAgLm9ic2VydmVPbihzY2hlZHVsZXIpXG4gICAgICAgIC5tYXAoc2VsZWN0b3IpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIENoYWluT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ2hhaW5PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENoYWluT2JzZXJ2YWJsZShoZWFkKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgICB0aGlzLnRhaWwgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhDaGFpbk9ic2VydmFibGUucHJvdG90eXBlLCBPYnNlcnZlciwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGcgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgICBnLmFkZChjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIGZ1bmN0aW9uIChfLCBzZWxmKSB7XG4gICAgICAgICAgby5vbk5leHQoc2VsZi5oZWFkKTtcbiAgICAgICAgICBnLmFkZChzZWxmLnRhaWwubWVyZ2VBbGwoKS5zdWJzY3JpYmUobykpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbk5leHQoT2JzZXJ2YWJsZS5lbXB0eSgpKTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLm9uTmV4dChPYnNlcnZhYmxlWyd0aHJvdyddKGUpKTtcbiAgICAgIH0sXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMudGFpbC5vbk5leHQodik7XG4gICAgICAgIHRoaXMudGFpbC5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIENoYWluT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGUpKTtcblxuICB2YXIgTWFwID0gcm9vdC5NYXAgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuXG4gICAgTWFwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgdGhpcy5fdmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5zaXplLS07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgcmV0dXJuIGkgPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5fdmFsdWVzW2ldO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5fdmFsdWVzW2ldLCB0aGlzLl9rZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcDtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIFJlcHJlc2VudHMgYSBqb2luIHBhdHRlcm4gb3ZlciBvYnNlcnZhYmxlIHNlcXVlbmNlcy5cbiAgICovXG4gIGZ1bmN0aW9uIFBhdHRlcm4ocGF0dGVybnMpIHtcbiAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gIH1cblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBwbGFuIG1hdGNoZXMgYW5kIHdoZW4gdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXMgYW4gYXZhaWxhYmxlIHZhbHVlLlxuICAgKiAgQHBhcmFtIG90aGVyIE9ic2VydmFibGUgc2VxdWVuY2UgdG8gbWF0Y2ggaW4gYWRkaXRpb24gdG8gdGhlIGN1cnJlbnQgcGF0dGVybi5cbiAgICogIEByZXR1cm4ge1BhdHRlcm59IFBhdHRlcm4gb2JqZWN0IHRoYXQgbWF0Y2hlcyB3aGVuIGFsbCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybiBoYXZlIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICovXG4gIFBhdHRlcm4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBuZXcgUGF0dGVybih0aGlzLnBhdHRlcm5zLmNvbmNhdChvdGhlcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgTWF0Y2hlcyB3aGVuIGFsbCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybiAoc3BlY2lmaWVkIHVzaW5nIGEgY2hhaW4gb2YgYW5kIG9wZXJhdG9ycykgaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUgYW5kIHByb2plY3RzIHRoZSB2YWx1ZXMuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aXRoIGF2YWlsYWJsZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlcywgaW4gdGhlIHNhbWUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybi5cbiAgICogIEByZXR1cm4ge1BsYW59IFBsYW4gdGhhdCBwcm9kdWNlcyB0aGUgcHJvamVjdGVkIHZhbHVlcywgdG8gYmUgZmVkICh3aXRoIG90aGVyIHBsYW5zKSB0byB0aGUgd2hlbiBvcGVyYXRvci5cbiAgICovXG4gIFBhdHRlcm4ucHJvdG90eXBlLnRoZW5EbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgUGxhbih0aGlzLCBzZWxlY3Rvcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gUGxhbihleHByZXNzaW9uLCBzZWxlY3Rvcikge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT25FcnJvcihvKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH07IH1cbiAgZnVuY3Rpb24gaGFuZGxlT25OZXh0KHNlbGYsIG9ic2VydmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTmV4dCAoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goc2VsZi5zZWxlY3RvcikuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvYnNlcnZlci5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgfVxuXG4gIFBsYW4ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGV4dGVybmFsU3Vic2NyaXB0aW9ucywgb2JzZXJ2ZXIsIGRlYWN0aXZhdGUpIHtcbiAgICB2YXIgam9pbk9ic2VydmVycyA9IFtdLCBlcnJIYW5kbGVyID0gaGFuZGxlT25FcnJvcihvYnNlcnZlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZXhwcmVzc2lvbi5wYXR0ZXJucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgam9pbk9ic2VydmVycy5wdXNoKHBsYW5DcmVhdGVPYnNlcnZlcihleHRlcm5hbFN1YnNjcmlwdGlvbnMsIHRoaXMuZXhwcmVzc2lvbi5wYXR0ZXJuc1tpXSwgZXJySGFuZGxlcikpO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlUGxhbiA9IG5ldyBBY3RpdmVQbGFuKGpvaW5PYnNlcnZlcnMsIGhhbmRsZU9uTmV4dCh0aGlzLCBvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gam9pbk9ic2VydmVycy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgam9pbk9ic2VydmVyc1tqXS5yZW1vdmVBY3RpdmVQbGFuKGFjdGl2ZVBsYW4pO1xuICAgICAgfVxuICAgICAgZGVhY3RpdmF0ZShhY3RpdmVQbGFuKTtcbiAgICB9KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBqb2luT2JzZXJ2ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBqb2luT2JzZXJ2ZXJzW2ldLmFkZEFjdGl2ZVBsYW4oYWN0aXZlUGxhbik7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVQbGFuO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBsYW5DcmVhdGVPYnNlcnZlcihleHRlcm5hbFN1YnNjcmlwdGlvbnMsIG9ic2VydmFibGUsIG9uRXJyb3IpIHtcbiAgICB2YXIgZW50cnkgPSBleHRlcm5hbFN1YnNjcmlwdGlvbnMuZ2V0KG9ic2VydmFibGUpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBKb2luT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgb25FcnJvcik7XG4gICAgICBleHRlcm5hbFN1YnNjcmlwdGlvbnMuc2V0KG9ic2VydmFibGUsIG9ic2VydmVyKTtcbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgZnVuY3Rpb24gQWN0aXZlUGxhbihqb2luT2JzZXJ2ZXJBcnJheSwgb25OZXh0LCBvbkNvbXBsZXRlZCkge1xuICAgIHRoaXMuam9pbk9ic2VydmVyQXJyYXkgPSBqb2luT2JzZXJ2ZXJBcnJheTtcbiAgICB0aGlzLm9uTmV4dCA9IG9uTmV4dDtcbiAgICB0aGlzLm9uQ29tcGxldGVkID0gb25Db21wbGV0ZWQ7XG4gICAgdGhpcy5qb2luT2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmpvaW5PYnNlcnZlckFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgam9pbk9ic2VydmVyID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXTtcbiAgICAgIHRoaXMuam9pbk9ic2VydmVycy5zZXQoam9pbk9ic2VydmVyLCBqb2luT2JzZXJ2ZXIpO1xuICAgIH1cbiAgfVxuXG4gIEFjdGl2ZVBsYW4ucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5qb2luT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5xdWV1ZS5zaGlmdCgpOyB9KTtcbiAgfTtcblxuICBBY3RpdmVQbGFuLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSwgbGVuLCBoYXNWYWx1ZXMgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmpvaW5PYnNlcnZlckFycmF5W2ldLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNWYWx1ZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNWYWx1ZXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbHVlcyA9IFtdLFxuICAgICAgICAgIGlzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmpvaW5PYnNlcnZlckFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpcnN0VmFsdWVzLnB1c2godGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXS5xdWV1ZVswXSk7XG4gICAgICAgIHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV0ucXVldWVbMF0ua2luZCA9PT0gJ0MnICYmIChpc0NvbXBsZXRlZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZpcnN0VmFsdWVzLmxlbmd0aDsgaSA8IGZpcnN0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2goZmlyc3RWYWx1ZXNbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25OZXh0LmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBKb2luT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEpvaW5PYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIEpvaW5PYnNlcnZlcihzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5hY3RpdmVQbGFucyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBKb2luT2JzZXJ2ZXJQcm90b3R5cGUgPSBKb2luT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLmtpbmQgPT09ICdFJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3Iobm90aWZpY2F0aW9uLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobm90aWZpY2F0aW9uKTtcbiAgICAgICAgdmFyIGFjdGl2ZVBsYW5zID0gdGhpcy5hY3RpdmVQbGFucy5zbGljZSgwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGl2ZVBsYW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYWN0aXZlUGxhbnNbaV0ubWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuZXJyb3IgPSBub29wO1xuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5jb21wbGV0ZWQgPSBub29wO1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmFkZEFjdGl2ZVBsYW4gPSBmdW5jdGlvbiAoYWN0aXZlUGxhbikge1xuICAgICAgdGhpcy5hY3RpdmVQbGFucy5wdXNoKGFjdGl2ZVBsYW4pO1xuICAgIH07XG5cbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5tYXRlcmlhbGl6ZSgpLnN1YnNjcmliZSh0aGlzKSk7XG4gICAgfTtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5yZW1vdmVBY3RpdmVQbGFuID0gZnVuY3Rpb24gKGFjdGl2ZVBsYW4pIHtcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMuc3BsaWNlKHRoaXMuYWN0aXZlUGxhbnMuaW5kZXhPZihhY3RpdmVQbGFuKSwgMSk7XG4gICAgICB0aGlzLmFjdGl2ZVBsYW5zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEpvaW5PYnNlcnZlcjtcbiAgfSAoQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHdoZW4gYm90aCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXZlIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICpcbiAgICogIEBwYXJhbSByaWdodCBPYnNlcnZhYmxlIHNlcXVlbmNlIHRvIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgc2VxdWVuY2UuXG4gICAqICBAcmV0dXJuIHtQYXR0ZXJufSBQYXR0ZXJuIG9iamVjdCB0aGF0IG1hdGNoZXMgd2hlbiBib3RoIG9ic2VydmFibGUgc2VxdWVuY2VzIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmFuZCA9IGZ1bmN0aW9uIChyaWdodCkge1xuICAgIHJldHVybiBuZXcgUGF0dGVybihbdGhpcywgcmlnaHRdKTtcbiAgfTtcblxuICAvKipcbiAgICogIE1hdGNoZXMgd2hlbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBoYXMgYW4gYXZhaWxhYmxlIHZhbHVlIGFuZCBwcm9qZWN0cyB0aGUgdmFsdWUuXG4gICAqXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgdmFsdWVzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqICBAcmV0dXJucyB7UGxhbn0gUGxhbiB0aGF0IHByb2R1Y2VzIHRoZSBwcm9qZWN0ZWQgdmFsdWVzLCB0byBiZSBmZWQgKHdpdGggb3RoZXIgcGxhbnMpIHRvIHRoZSB3aGVuIG9wZXJhdG9yLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRoZW5EbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgUGF0dGVybihbdGhpc10pLnRoZW5EbyhzZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICBKb2lucyB0b2dldGhlciB0aGUgcmVzdWx0cyBmcm9tIHNldmVyYWwgcGF0dGVybnMuXG4gICAqXG4gICAqICBAcGFyYW0gcGxhbnMgQSBzZXJpZXMgb2YgcGxhbnMgKHNwZWNpZmllZCBhcyBhbiBBcnJheSBvZiBhcyBhIHNlcmllcyBvZiBhcmd1bWVudHMpIGNyZWF0ZWQgYnkgdXNlIG9mIHRoZSBUaGVuIG9wZXJhdG9yIG9uIHBhdHRlcm5zLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgcmVzdWx0cyBmb3JtIG1hdGNoaW5nIHNldmVyYWwgcGF0dGVybnMuXG4gICAqL1xuICBPYnNlcnZhYmxlLndoZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsYW5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHBsYW5zID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGFucyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHBsYW5zW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFjdGl2ZVBsYW5zID0gW10sXG4gICAgICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIG91dE9ic2VydmVyID0gb2JzZXJ2ZXJDcmVhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7IG8ub25OZXh0KHgpOyB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5vbkVycm9yKGVycik7IH0pO1xuICAgICAgICAgIG8ub25FcnJvcihlcnIpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoeCkgeyBvLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGxhbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBhY3RpdmVQbGFucy5wdXNoKHBsYW5zW2ldLmFjdGl2YXRlKGV4dGVybmFsU3Vic2NyaXB0aW9ucywgb3V0T2JzZXJ2ZXIsIGZ1bmN0aW9uIChhY3RpdmVQbGFuKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gYWN0aXZlUGxhbnMuaW5kZXhPZihhY3RpdmVQbGFuKTtcbiAgICAgICAgICAgIGFjdGl2ZVBsYW5zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgYWN0aXZlUGxhbnMubGVuZ3RoID09PSAwICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVUaHJvdyhlKS5zdWJzY3JpYmUobyk7XG4gICAgICB9XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGpvaW5PYnNlcnZlcikge1xuICAgICAgICBqb2luT2JzZXJ2ZXIuc3Vic2NyaWJlKCk7XG4gICAgICAgIGdyb3VwLmFkZChqb2luT2JzZXJ2ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRpbWVyT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUaW1lck9ic2VydmFibGUoZHQsIHMpIHtcbiAgICAgIHRoaXMuX2R0ID0gZHQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcy5zY2hlZHVsZUZ1dHVyZShvLCB0aGlzLl9kdCwgc2NoZWR1bGVNZXRob2QpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBvKSB7XG4gICAgICBvLm9uTmV4dCgwKTtcbiAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgZnVuY3Rpb24gX29ic2VydmFibGVUaW1lcihkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkID0gZHVlVGltZSwgcCA9IG5vcm1hbGl6ZVRpbWUocGVyaW9kKTtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUoMCwgZCwgZnVuY3Rpb24gKGNvdW50LCBzZWxmKSB7XG4gICAgICAgIGlmIChwID4gMCkge1xuICAgICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCk7XG4gICAgICAgICAgZCA9IG5ldyBEYXRlKGQuZ2V0VGltZSgpICsgcCk7XG4gICAgICAgICAgZC5nZXRUaW1lKCkgPD0gbm93ICYmIChkID0gbmV3IERhdGUobm93ICsgcCkpO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChjb3VudCk7XG4gICAgICAgIHNlbGYoY291bnQgKyAxLCBuZXcgRGF0ZShkKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVUaW1lclRpbWVTcGFuQW5kUGVyaW9kKGR1ZVRpbWUsIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIGR1ZVRpbWUgPT09IHBlcmlvZCA/XG4gICAgICBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZVBlcmlvZGljKDAsIHBlcmlvZCwgZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGNvdW50KTtcbiAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xuICAgICAgICB9KTtcbiAgICAgIH0pIDpcbiAgICAgIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlVGltZXJEYXRlQW5kUGVyaW9kKG5ldyBEYXRlKHNjaGVkdWxlci5ub3coKSArIGR1ZVRpbWUpLCBwZXJpb2QsIHNjaGVkdWxlcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgcHJvZHVjZXMgYSB2YWx1ZSBhZnRlciBlYWNoIHBlcmlvZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgKiAgMiAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kIFBlcmlvZCBmb3IgcHJvZHVjaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIHJlc3VsdGluZyBzZXF1ZW5jZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBSeC5TY2hlZHVsZXIudGltZW91dCBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZWFjaCBwZXJpb2QuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZWludGVydmFsID0gT2JzZXJ2YWJsZS5pbnRlcnZhbCA9IGZ1bmN0aW9uIChwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlVGltZXJUaW1lU3BhbkFuZFBlcmlvZChwZXJpb2QsIHBlcmlvZCwgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSA/IHNjaGVkdWxlciA6IGRlZmF1bHRTY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgcHJvZHVjZXMgYSB2YWx1ZSBhZnRlciBkdWVUaW1lIGhhcyBlbGFwc2VkIGFuZCB0aGVuIGFmdGVyIGVhY2ggcGVyaW9kLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSAoc3BlY2lmaWVkIGFzIGEgRGF0ZSBvYmplY3QpIG9yIHJlbGF0aXZlIHRpbWUgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykgYXQgd2hpY2ggdG8gcHJvZHVjZSB0aGUgZmlyc3QgdmFsdWUuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtwZXJpb2RPclNjaGVkdWxlcl0gIFBlcmlvZCB0byBwcm9kdWNlIHN1YnNlcXVlbnQgdmFsdWVzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciB0aGUgc2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSByZXN1bHRpbmcgdGltZXIgaXMgbm90IHJlY3VycmluZy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgcHJvZHVjZXMgYSB2YWx1ZSBhZnRlciBkdWUgdGltZSBoYXMgZWxhcHNlZCBhbmQgdGhlbiBlYWNoIHBlcmlvZC5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlVGltZXIgPSBPYnNlcnZhYmxlLnRpbWVyID0gZnVuY3Rpb24gKGR1ZVRpbWUsIHBlcmlvZE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgcGVyaW9kO1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIGlmIChwZXJpb2RPclNjaGVkdWxlciAhPSBudWxsICYmIHR5cGVvZiBwZXJpb2RPclNjaGVkdWxlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBlcmlvZCA9IHBlcmlvZE9yU2NoZWR1bGVyO1xuICAgIH0gZWxzZSBpZiAoaXNTY2hlZHVsZXIocGVyaW9kT3JTY2hlZHVsZXIpKSB7XG4gICAgICBzY2hlZHVsZXIgPSBwZXJpb2RPclNjaGVkdWxlcjtcbiAgICB9XG4gICAgaWYgKChkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgZHVlVGltZSA9PT0gJ251bWJlcicpICYmIHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX29ic2VydmFibGVUaW1lcihkdWVUaW1lLCBzY2hlZHVsZXIpO1xuICAgIH1cbiAgICBpZiAoZHVlVGltZSBpbnN0YW5jZW9mIERhdGUgJiYgcGVyaW9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlVGltZXJEYXRlQW5kUGVyaW9kKGR1ZVRpbWUsIHBlcmlvZE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW5BbmRQZXJpb2QoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVEZWxheVJlbGF0aXZlKHNvdXJjZSwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYWN0aXZlID0gZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBleGNlcHRpb24gPSBudWxsLFxuICAgICAgICBxID0gW10sXG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZSxcbiAgICAgICAgc3Vic2NyaXB0aW9uO1xuICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLm1hdGVyaWFsaXplKCkudGltZXN0YW1wKHNjaGVkdWxlcikuc3Vic2NyaWJlKGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgdmFyIGQsIHNob3VsZFJ1bjtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi52YWx1ZS5raW5kID09PSAnRScpIHtcbiAgICAgICAgICBxID0gW107XG4gICAgICAgICAgcS5wdXNoKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgZXhjZXB0aW9uID0gbm90aWZpY2F0aW9uLnZhbHVlLmVycm9yO1xuICAgICAgICAgIHNob3VsZFJ1biA9ICFydW5uaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHEucHVzaCh7IHZhbHVlOiBub3RpZmljYXRpb24udmFsdWUsIHRpbWVzdGFtcDogbm90aWZpY2F0aW9uLnRpbWVzdGFtcCArIGR1ZVRpbWUgfSk7XG4gICAgICAgICAgc2hvdWxkUnVuID0gIWFjdGl2ZTtcbiAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSdW4pIHtcbiAgICAgICAgICBpZiAoZXhjZXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IoZXhjZXB0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgICAgY2FuY2VsYWJsZS5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgICAgICAgZC5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZShudWxsLCBkdWVUaW1lLCBmdW5jdGlvbiAoXywgc2VsZikge1xuICAgICAgICAgICAgICB2YXIgZSwgcmVjdXJzZUR1ZVRpbWUsIHJlc3VsdCwgc2hvdWxkUmVjdXJzZTtcbiAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID4gMCAmJiBxWzBdLnRpbWVzdGFtcCAtIHNjaGVkdWxlci5ub3coKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBxLnNoaWZ0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5hY2NlcHQobyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IHdoaWxlIChyZXN1bHQgIT09IG51bGwpO1xuICAgICAgICAgICAgICBzaG91bGRSZWN1cnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJlY3Vyc2VEdWVUaW1lID0gMDtcbiAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNob3VsZFJlY3Vyc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlY3Vyc2VEdWVUaW1lID0gTWF0aC5tYXgoMCwgcVswXS50aW1lc3RhbXAgLSBzY2hlZHVsZXIubm93KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGUgPSBleGNlcHRpb247XG4gICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUmVjdXJzZSkge1xuICAgICAgICAgICAgICAgIHNlbGYobnVsbCwgcmVjdXJzZUR1ZVRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlRGVsYXlBYnNvbHV0ZShzb3VyY2UsIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9ic2VydmFibGVEZWxheVJlbGF0aXZlKHNvdXJjZSwgZHVlVGltZSAtIHNjaGVkdWxlci5ub3coKSwgc2NoZWR1bGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGF5V2l0aFNlbGVjdG9yKHNvdXJjZSwgc3Vic2NyaXB0aW9uRGVsYXksIGRlbGF5RHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHZhciBzdWJEZWxheSwgc2VsZWN0b3I7XG4gICAgaWYgKGlzRnVuY3Rpb24oc3Vic2NyaXB0aW9uRGVsYXkpKSB7XG4gICAgICBzZWxlY3RvciA9IHN1YnNjcmlwdGlvbkRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJEZWxheSA9IHN1YnNjcmlwdGlvbkRlbGF5O1xuICAgICAgc2VsZWN0b3IgPSBkZWxheUR1cmF0aW9uU2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGRlbGF5cyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksIGF0RW5kID0gZmFsc2UsIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSB0cnlDYXRjaChzZWxlY3RvcikoeCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZGVsYXkuZSk7IH1cbiAgICAgICAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgICBkZWxheXMuYWRkKGQpO1xuICAgICAgICAgICAgZC5zZXREaXNwb3NhYmxlKGRlbGF5LnN1YnNjcmliZShcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG8ub25OZXh0KHgpO1xuICAgICAgICAgICAgICAgIGRlbGF5cy5yZW1vdmUoZCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICAgICAgICBkZWxheXMucmVtb3ZlKGQpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAgICAgYXRFbmQgJiYgZGVsYXlzLmxlbmd0aCA9PT0gMCAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3ViRGVsYXkpIHtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHN1YkRlbGF5LnN1YnNjcmliZShzdGFydCwgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LCBzdGFydCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBkZWxheXMpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogIFRpbWUgc2hpZnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGR1ZVRpbWUuXG4gICAqICBUaGUgcmVsYXRpdmUgdGltZSBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIEFic29sdXRlIChzcGVjaWZpZWQgYXMgYSBEYXRlIG9iamVjdCkgb3IgcmVsYXRpdmUgdGltZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSBieSB3aGljaCB0byBzaGlmdCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGRlbGF5IHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaW1lLXNoaWZ0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZGVsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0QXJnID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09ICdudW1iZXInIHx8IGZpcnN0QXJnIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdmFyIGR1ZVRpbWUgPSBmaXJzdEFyZywgc2NoZWR1bGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgICByZXR1cm4gZHVlVGltZSBpbnN0YW5jZW9mIERhdGUgP1xuICAgICAgICBvYnNlcnZhYmxlRGVsYXlBYnNvbHV0ZSh0aGlzLCBkdWVUaW1lLCBzY2hlZHVsZXIpIDpcbiAgICAgICAgb2JzZXJ2YWJsZURlbGF5UmVsYXRpdmUodGhpcywgZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgICB9IGVsc2UgaWYgKE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKGZpcnN0QXJnKSB8fCBpc0Z1bmN0aW9uKGZpcnN0QXJnKSkge1xuICAgICAgcmV0dXJuIGRlbGF5V2l0aFNlbGVjdG9yKHRoaXMsIGZpcnN0QXJnLCBhcmd1bWVudHNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBEZWJvdW5jZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlYm91bmNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZU9ic2VydmFibGUoc291cmNlLCBkdCwgcykge1xuICAgICAgaXNTY2hlZHVsZXIocykgfHwgKHMgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZHQgPSBkdDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVib3VuY2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZU9ic2VydmVyKG8sIHRoaXMuX2R0LCB0aGlzLl9zLCBjYW5jZWxhYmxlKSksXG4gICAgICAgIGNhbmNlbGFibGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVib3VuY2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIERlYm91bmNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlYm91bmNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VPYnNlcnZlcihvYnNlcnZlciwgZHVlVGltZSwgc2NoZWR1bGVyLCBjYW5jZWxhYmxlKSB7XG4gICAgICB0aGlzLl9vID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLl9kID0gZHVlVGltZTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMuX2MgPSBjYW5jZWxhYmxlO1xuICAgICAgdGhpcy5fdiA9IG51bGw7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faWQgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGdXR1cmUocywgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnNlbGYuX2h2ICYmIHN0YXRlLnNlbGYuX2lkID09PSBzdGF0ZS5jdXJyZW50SWQgJiYgc3RhdGUuc2VsZi5fby5vbk5leHQoc3RhdGUueCk7XG4gICAgICBzdGF0ZS5zZWxmLl9odiA9IGZhbHNlO1xuICAgIH1cblxuICAgIERlYm91bmNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgdGhpcy5fdiA9IHg7XG4gICAgICB2YXIgY3VycmVudElkID0gKyt0aGlzLl9pZCwgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgdGhpcy5fYy5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZSh0aGlzLCB0aGlzLl9kLCBmdW5jdGlvbiAoXywgc2VsZikge1xuICAgICAgICBzZWxmLl9odiAmJiBzZWxmLl9pZCA9PT0gY3VycmVudElkICYmIHNlbGYuX28ub25OZXh0KHgpO1xuICAgICAgICBzZWxmLl9odiA9IGZhbHNlO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBEZWJvdW5jZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZCsrO1xuICAgIH07XG5cbiAgICBEZWJvdW5jZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2h2ICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lkKys7XG4gICAgfTtcblxuICAgIHJldHVybiBEZWJvdW5jZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICBmdW5jdGlvbiBkZWJvdW5jZVdpdGhTZWxlY3Rvcihzb3VyY2UsIGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciB2YWx1ZSwgaGFzVmFsdWUgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksIGlkID0gMDtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHZhciB0aHJvdHRsZSA9IHRyeUNhdGNoKGR1cmF0aW9uU2VsZWN0b3IpKHgpO1xuICAgICAgICAgIGlmICh0aHJvdHRsZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcih0aHJvdHRsZS5lKTsgfVxuXG4gICAgICAgICAgaXNQcm9taXNlKHRocm90dGxlKSAmJiAodGhyb3R0bGUgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UodGhyb3R0bGUpKTtcblxuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZSA9IHg7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgICB2YXIgY3VycmVudGlkID0gaWQsIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICBjYW5jZWxhYmxlLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICAgICAgZC5zZXREaXNwb3NhYmxlKHRocm90dGxlLnN1YnNjcmliZShcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaGFzVmFsdWUgJiYgaWQgPT09IGN1cnJlbnRpZCAmJiBvLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaGFzVmFsdWUgJiYgaWQgPT09IGN1cnJlbnRpZCAmJiBvLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNhbmNlbGFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlkKys7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYW5jZWxhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICBoYXNWYWx1ZSAmJiBvLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICBvYnNlcnZhYmxlUHJvdG8uZGVib3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24gKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHJldHVybiBkZWJvdW5jZVdpdGhTZWxlY3Rvcih0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuZXcgRGVib3VuY2VPYnNlcnZhYmxlKHRoaXMsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gemVybyBvciBtb3JlIHdpbmRvd3Mgd2hpY2ggYXJlIHByb2R1Y2VkIGJhc2VkIG9uIHRpbWluZyBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIExlbmd0aCBvZiBlYWNoIHdpbmRvdyAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RpbWVTaGlmdE9yU2NoZWR1bGVyXSAgSW50ZXJ2YWwgYmV0d2VlbiBjcmVhdGlvbiBvZiBjb25zZWN1dGl2ZSB3aW5kb3dzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciBhbiBvcHRpb25hbCBzY2hlZHVsZXIgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZSBzaGlmdCBjb3JyZXNwb25kcyB0byB0aGUgdGltZVNwYW4gcGFyYW1ldGVyLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIGFkamFjZW50IHdpbmRvd3MuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB3aW5kb3dpbmcgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoVGltZSA9IG9ic2VydmFibGVQcm90by53aW5kb3dUaW1lID0gZnVuY3Rpb24gKHRpbWVTcGFuLCB0aW1lU2hpZnRPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMsIHRpbWVTaGlmdDtcbiAgICB0aW1lU2hpZnRPclNjaGVkdWxlciA9PSBudWxsICYmICh0aW1lU2hpZnQgPSB0aW1lU3Bhbik7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgaWYgKHR5cGVvZiB0aW1lU2hpZnRPclNjaGVkdWxlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVTaGlmdCA9IHRpbWVTaGlmdE9yU2NoZWR1bGVyO1xuICAgIH0gZWxzZSBpZiAoaXNTY2hlZHVsZXIodGltZVNoaWZ0T3JTY2hlZHVsZXIpKSB7XG4gICAgICB0aW1lU2hpZnQgPSB0aW1lU3BhbjtcbiAgICAgIHNjaGVkdWxlciA9IHRpbWVTaGlmdE9yU2NoZWR1bGVyO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZ3JvdXBEaXNwb3NhYmxlLFxuICAgICAgICBuZXh0U2hpZnQgPSB0aW1lU2hpZnQsXG4gICAgICAgIG5leHRTcGFuID0gdGltZVNwYW4sXG4gICAgICAgIHEgPSBbXSxcbiAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlLFxuICAgICAgICB0aW1lckQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICB0b3RhbFRpbWUgPSAwO1xuICAgICAgICBncm91cERpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSh0aW1lckQpLFxuICAgICAgICByZWZDb3VudERpc3Bvc2FibGUgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGdyb3VwRGlzcG9zYWJsZSk7XG5cbiAgICAgICBmdW5jdGlvbiBjcmVhdGVUaW1lciAoKSB7XG4gICAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgICAgaXNTcGFuID0gZmFsc2UsXG4gICAgICAgICAgaXNTaGlmdCA9IGZhbHNlO1xuICAgICAgICB0aW1lckQuc2V0RGlzcG9zYWJsZShtKTtcbiAgICAgICAgaWYgKG5leHRTcGFuID09PSBuZXh0U2hpZnQpIHtcbiAgICAgICAgICBpc1NwYW4gPSB0cnVlO1xuICAgICAgICAgIGlzU2hpZnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRTcGFuIDwgbmV4dFNoaWZ0KSB7XG4gICAgICAgICAgICBpc1NwYW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzU2hpZnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdUb3RhbFRpbWUgPSBpc1NwYW4gPyBuZXh0U3BhbiA6IG5leHRTaGlmdCxcbiAgICAgICAgICB0cyA9IG5ld1RvdGFsVGltZSAtIHRvdGFsVGltZTtcbiAgICAgICAgdG90YWxUaW1lID0gbmV3VG90YWxUaW1lO1xuICAgICAgICBpZiAoaXNTcGFuKSB7XG4gICAgICAgICAgbmV4dFNwYW4gKz0gdGltZVNoaWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NoaWZ0KSB7XG4gICAgICAgICAgbmV4dFNoaWZ0ICs9IHRpbWVTaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBtLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKG51bGwsIHRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzU2hpZnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICAgIHEucHVzaChzKTtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocywgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3BhbiAmJiBxLnNoaWZ0KCkub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBjcmVhdGVUaW1lcigpO1xuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgcS5wdXNoKG5ldyBTdWJqZWN0KCkpO1xuICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihxWzBdLCByZWZDb3VudERpc3Bvc2FibGUpKTtcbiAgICAgIGNyZWF0ZVRpbWVyKCk7XG4gICAgICBncm91cERpc3Bvc2FibGUuYWRkKHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbk5leHQoeCk7IH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uRXJyb3IoZSk7IH1cbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIGEgd2luZG93IHRoYXQgaXMgY29tcGxldGVkIHdoZW4gZWl0aGVyIGl0J3MgZnVsbCBvciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lIGhhcyBlbGFwc2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiBhIHdpbmRvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE1heGltdW0gZWxlbWVudCBjb3VudCBvZiBhIHdpbmRvdy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHdpbmRvd2luZyB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLndpbmRvd1dpdGhUaW1lT3JDb3VudCA9IG9ic2VydmFibGVQcm90by53aW5kb3dUaW1lT3JDb3VudCA9IGZ1bmN0aW9uICh0aW1lU3BhbiwgY291bnQsIHNjaGVkdWxlcikge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciB0aW1lckQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHRpbWVyRCksXG4gICAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cERpc3Bvc2FibGUpLFxuICAgICAgICAgIG4gPSAwLFxuICAgICAgICAgIHdpbmRvd0lkID0gMCxcbiAgICAgICAgICBzID0gbmV3IFN1YmplY3QoKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVGltZXIoaWQpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdGltZXJELnNldERpc3Bvc2FibGUobSk7XG4gICAgICAgIG0uc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUobnVsbCwgdGltZVNwYW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaWQgIT09IHdpbmRvd0lkKSB7IHJldHVybjsgfVxuICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgIHZhciBuZXdJZCA9ICsrd2luZG93SWQ7XG4gICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocywgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICAgICAgY3JlYXRlVGltZXIobmV3SWQpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocywgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICBjcmVhdGVUaW1lcigwKTtcblxuICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHZhciBuZXdJZCA9IDAsIG5ld1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgIHMub25OZXh0KHgpO1xuICAgICAgICAgIGlmICgrK24gPT09IGNvdW50KSB7XG4gICAgICAgICAgICBuZXdXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICBuZXdJZCA9ICsrd2luZG93SWQ7XG4gICAgICAgICAgICBzLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocywgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld1dpbmRvdyAmJiBjcmVhdGVUaW1lcihuZXdJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcy5vbkVycm9yKGUpO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9BcnJheSh4KSB7IHJldHVybiB4LnRvQXJyYXkoKTsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgYnVmZmVycyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gdGltaW5nIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTGVuZ3RoIG9mIGVhY2ggYnVmZmVyIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGltZVNoaWZ0T3JTY2hlZHVsZXJdICBJbnRlcnZhbCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIGJ1ZmZlcnMgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcyksIG9yIGFuIG9wdGlvbmFsIHNjaGVkdWxlciBwYXJhbWV0ZXIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lIHNoaWZ0IGNvcnJlc3BvbmRzIHRvIHRoZSB0aW1lU3BhbiBwYXJhbWV0ZXIsIHJlc3VsdGluZyBpbiBub24tb3ZlcmxhcHBpbmcgYWRqYWNlbnQgYnVmZmVycy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIGJ1ZmZlciB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhUaW1lID0gb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlclRpbWUgPSBmdW5jdGlvbiAodGltZVNwYW4sIHRpbWVTaGlmdE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoVGltZSh0aW1lU3BhbiwgdGltZVNoaWZ0T3JTY2hlZHVsZXIsIHNjaGVkdWxlcikuZmxhdE1hcCh0b0FycmF5KTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0FycmF5KHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIGEgYnVmZmVyIHRoYXQgaXMgY29tcGxldGVkIHdoZW4gZWl0aGVyIGl0J3MgZnVsbCBvciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lIGhhcyBlbGFwc2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiBhIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE1heGltdW0gZWxlbWVudCBjb3VudCBvZiBhIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIGJ1ZmZlcmluIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGJ1ZmZlcnMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyV2l0aFRpbWVPckNvdW50ID0gb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlclRpbWVPckNvdW50ID0gZnVuY3Rpb24gKHRpbWVTcGFuLCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIHRoaXMud2luZG93V2l0aFRpbWVPckNvdW50KHRpbWVTcGFuLCBjb3VudCwgc2NoZWR1bGVyKS5mbGF0TWFwKHRvQXJyYXkpO1xuICB9O1xuXG4gIHZhciBUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbE9ic2VydmFibGUoc291cmNlLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZUludGVydmFsT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lSW50ZXJ2YWxPYnNlcnZlcihvLCB0aGlzLl9zKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRpbWVJbnRlcnZhbE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lSW50ZXJ2YWxPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbE9ic2VydmVyKG8sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9sID0gcy5ub3coKTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRpbWVJbnRlcnZhbE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBub3cgPSB0aGlzLl9zLm5vdygpLCBzcGFuID0gbm93IC0gdGhpcy5fbDtcbiAgICAgIHRoaXMuX2wgPSBub3c7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh7IHZhbHVlOiB4LCBpbnRlcnZhbDogc3BhbiB9KTtcbiAgICB9O1xuICAgIFRpbWVJbnRlcnZhbE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBUaW1lSW50ZXJ2YWxPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gVGltZUludGVydmFsT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmVjb3JkcyB0aGUgdGltZSBpbnRlcnZhbCBiZXR3ZWVuIGNvbnNlY3V0aXZlIHZhbHVlcyBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS50aW1lSW50ZXJ2YWwoKTtcbiAgICogIDIgLSByZXMgPSBzb3VyY2UudGltZUludGVydmFsKFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICpcbiAgICogQHBhcmFtIFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdXNlZCB0byBjb21wdXRlIHRpbWUgaW50ZXJ2YWxzLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aW1lIGludGVydmFsIGluZm9ybWF0aW9uIG9uIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50aW1lSW50ZXJ2YWwgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlKHRoaXMsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFRpbWVzdGFtcE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRpbWVzdGFtcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGltZXN0YW1wT2JzZXJ2YWJsZShzb3VyY2UsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lc3RhbXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVzdGFtcE9ic2VydmVyKG8sIHRoaXMuX3MpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRpbWVzdGFtcE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGltZXN0YW1wT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRpbWVzdGFtcE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRpbWVzdGFtcE9ic2VydmVyKG8sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lc3RhbXBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh7IHZhbHVlOiB4LCB0aW1lc3RhbXA6IHRoaXMuX3Mubm93KCkgfSk7XG4gICAgfTtcblxuICAgIFRpbWVzdGFtcE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFRpbWVzdGFtcE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUaW1lc3RhbXBPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZWNvcmRzIHRoZSB0aW1lc3RhbXAgZm9yIGVhY2ggdmFsdWUgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGltZXN0YW1wKCk7IC8vIHByb2R1Y2VzIHsgdmFsdWU6IHgsIHRpbWVzdGFtcDogdHMgfVxuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS50aW1lc3RhbXAoUnguU2NoZWR1bGVyLmRlZmF1bHQpO1xuICAgKlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB1c2VkIHRvIGNvbXB1dGUgdGltZXN0YW1wcy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGltZXN0YW1wIGluZm9ybWF0aW9uIG9uIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50aW1lc3RhbXAgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXBPYnNlcnZhYmxlKHRoaXMsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFNhbXBsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2FtcGxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTYW1wbGVPYnNlcnZhYmxlKHNvdXJjZSwgc2FtcGxlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zYW1wbGVyID0gc2FtcGxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNhbXBsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBvOiBvLFxuICAgICAgICBhdEVuZDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVN1YnNjcmlwdGlvbjogbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKClcbiAgICAgIH07XG5cbiAgICAgIHN0YXRlLnNvdXJjZVN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2FtcGxlU291cmNlT2JzZXJ2ZXIoc3RhdGUpKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHN0YXRlLnNvdXJjZVN1YnNjcmlwdGlvbixcbiAgICAgICAgdGhpcy5fc2FtcGxlci5zdWJzY3JpYmUobmV3IFNhbXBsZXJPYnNlcnZlcihzdGF0ZSkpXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2FtcGxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTYW1wbGVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2FtcGxlck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNhbXBsZXJPYnNlcnZlcihzKSB7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNhbXBsZXJPYnNlcnZlci5wcm90b3R5cGUuX2hhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fcy5oYXNWYWx1ZSkge1xuICAgICAgICB0aGlzLl9zLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Muby5vbk5leHQodGhpcy5fcy52YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zLmF0RW5kICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBTYW1wbGVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hhbmRsZU1lc3NhZ2UoKTsgfTtcbiAgICBTYW1wbGVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fcy5vbkVycm9yKGUpOyB9O1xuICAgIFNhbXBsZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oYW5kbGVNZXNzYWdlKCk7IH07XG5cbiAgICByZXR1cm4gU2FtcGxlck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgU2FtcGxlU291cmNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2FtcGxlU291cmNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2FtcGxlU291cmNlT2JzZXJ2ZXIocykge1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTYW1wbGVTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3MudmFsdWUgPSB4O1xuICAgIH07XG4gICAgU2FtcGxlU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fcy5vLm9uRXJyb3IoZSk7IH07XG4gICAgU2FtcGxlU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3MuYXRFbmQgPSB0cnVlO1xuICAgICAgdGhpcy5fcy5zb3VyY2VTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2FtcGxlU291cmNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgU2FtcGxlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhdCBlYWNoIGludGVydmFsLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5zYW1wbGUoc2FtcGxlT2JzZXJ2YWJsZSk7IC8vIFNhbXBsZXIgdGljayBzZXF1ZW5jZVxuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS5zYW1wbGUoNTAwMCk7IC8vIDUgc2Vjb25kc1xuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS5zYW1wbGUoNTAwMCwgUnguU2NoZWR1bGVyLnRpbWVvdXQpOyAvLyA1IHNlY29uZHNcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gaW50ZXJ2YWxPclNhbXBsZXIgSW50ZXJ2YWwgYXQgd2hpY2ggdG8gc2FtcGxlIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpIG9yIFNhbXBsZXIgT2JzZXJ2YWJsZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSBzYW1wbGluZyB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTYW1wbGVkIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2FtcGxlID0gZnVuY3Rpb24gKGludGVydmFsT3JTYW1wbGVyLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gdHlwZW9mIGludGVydmFsT3JTYW1wbGVyID09PSAnbnVtYmVyJyA/XG4gICAgICBuZXcgU2FtcGxlT2JzZXJ2YWJsZSh0aGlzLCBvYnNlcnZhYmxlaW50ZXJ2YWwoaW50ZXJ2YWxPclNhbXBsZXIsIHNjaGVkdWxlcikpIDpcbiAgICAgIG5ldyBTYW1wbGVPYnNlcnZhYmxlKHRoaXMsIGludGVydmFsT3JTYW1wbGVyKTtcbiAgfTtcblxuICB2YXIgVGltZW91dEVycm9yID0gUnguVGltZW91dEVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RpbWVvdXQgaGFzIG9jY3VycmVkJztcbiAgICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBUaW1lb3V0RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIHRpbWVvdXRXaXRoU2VsZWN0b3Ioc291cmNlLCBmaXJzdFRpbWVvdXQsIHRpbWVvdXREdXJhdGlvblNlbGVjdG9yLCBvdGhlcikge1xuICAgIGlmIChpc0Z1bmN0aW9uKGZpcnN0VGltZW91dCkpIHtcbiAgICAgIG90aGVyID0gdGltZW91dER1cmF0aW9uU2VsZWN0b3I7XG4gICAgICB0aW1lb3V0RHVyYXRpb25TZWxlY3RvciA9IGZpcnN0VGltZW91dDtcbiAgICAgIGZpcnN0VGltZW91dCA9IG9ic2VydmFibGVOZXZlcigpO1xuICAgIH1cbiAgICBPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShvdGhlcikgfHwgKG90aGVyID0gb2JzZXJ2YWJsZVRocm93KG5ldyBUaW1lb3V0RXJyb3IoKSkpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIHRpbWVyID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgb3JpZ2luYWwgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3JpZ2luYWwpO1xuXG4gICAgICB2YXIgaWQgPSAwLCBzd2l0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBzZXRUaW1lcih0aW1lb3V0KSB7XG4gICAgICAgIHZhciBteUlkID0gaWQsIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgICBmdW5jdGlvbiB0aW1lcldpbnMoKSB7XG4gICAgICAgICAgc3dpdGNoZWQgPSAobXlJZCA9PT0gaWQpO1xuICAgICAgICAgIHJldHVybiBzd2l0Y2hlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVyLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aW1lb3V0LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGltZXJXaW5zKCkgJiYgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG8pKTtcbiAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aW1lcldpbnMoKSAmJiBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aW1lcldpbnMoKSAmJiBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShvdGhlci5zdWJzY3JpYmUobykpO1xuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICBzZXRUaW1lcihmaXJzdFRpbWVvdXQpO1xuXG4gICAgICBmdW5jdGlvbiBvV2lucygpIHtcbiAgICAgICAgdmFyIHJlcyA9ICFzd2l0Y2hlZDtcbiAgICAgICAgaWYgKHJlcykgeyBpZCsrOyB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIG9yaWdpbmFsLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAob1dpbnMoKSkge1xuICAgICAgICAgIG8ub25OZXh0KHgpO1xuICAgICAgICAgIHZhciB0aW1lb3V0ID0gdHJ5Q2F0Y2godGltZW91dER1cmF0aW9uU2VsZWN0b3IpKHgpO1xuICAgICAgICAgIGlmICh0aW1lb3V0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHRpbWVvdXQuZSk7IH1cbiAgICAgICAgICBzZXRUaW1lcihpc1Byb21pc2UodGltZW91dCkgPyBvYnNlcnZhYmxlRnJvbVByb21pc2UodGltZW91dCkgOiB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgb1dpbnMoKSAmJiBvLm9uRXJyb3IoZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9XaW5zKCkgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgdGltZXIpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lb3V0KHNvdXJjZSwgZHVlVGltZSwgb3RoZXIsIHNjaGVkdWxlcikge1xuICAgIGlmIChpc1NjaGVkdWxlcihvdGhlcikpIHtcbiAgICAgIHNjaGVkdWxlciA9IG90aGVyO1xuICAgICAgb3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cobmV3IFRpbWVvdXRFcnJvcigpKTtcbiAgICB9XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgRXJyb3IpIHsgb3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cob3RoZXIpOyB9XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob3RoZXIpIHx8IChvdGhlciA9IG9ic2VydmFibGVUaHJvdyhuZXcgVGltZW91dEVycm9yKCkpKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBpZCA9IDAsXG4gICAgICAgIG9yaWdpbmFsID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIHN3aXRjaGVkID0gZmFsc2UsXG4gICAgICAgIHRpbWVyID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcblxuICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3JpZ2luYWwpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVUaW1lcigpIHtcbiAgICAgICAgdmFyIG15SWQgPSBpZDtcbiAgICAgICAgdGltZXIuc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUobnVsbCwgZHVlVGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaGVkID0gaWQgPT09IG15SWQ7XG4gICAgICAgICAgaWYgKHN3aXRjaGVkKSB7XG4gICAgICAgICAgICBpc1Byb21pc2Uob3RoZXIpICYmIChvdGhlciA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlVGltZXIoKTtcblxuICAgICAgb3JpZ2luYWwuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghc3dpdGNoZWQpIHtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICAgIG8ub25OZXh0KHgpO1xuICAgICAgICAgIGNyZWF0ZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghc3dpdGNoZWQpIHtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXN3aXRjaGVkKSB7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIHRpbWVyKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgb2JzZXJ2YWJsZVByb3RvLnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0QXJnID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChmaXJzdEFyZyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGZpcnN0QXJnID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRpbWVvdXQodGhpcywgZmlyc3RBcmcsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB9IGVsc2UgaWYgKE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKGZpcnN0QXJnKSB8fCBpc0Z1bmN0aW9uKGZpcnN0QXJnKSkge1xuICAgICAgcmV0dXJuIHRpbWVvdXRXaXRoU2VsZWN0b3IodGhpcywgZmlyc3RBcmcsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlKHN0YXRlLCBjbmRGbiwgaXRyRm4sIHJlc0ZuLCB0aW1lRm4sIHMpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9jbmRGbiA9IGNuZEZuO1xuICAgICAgdGhpcy5faXRyRm4gPSBpdHJGbjtcbiAgICAgIHRoaXMuX3Jlc0ZuID0gcmVzRm47XG4gICAgICB0aGlzLl90aW1lRm4gPSB0aW1lRm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBzdGF0ZS5oYXNSZXN1bHQgJiYgc3RhdGUuby5vbk5leHQoc3RhdGUucmVzdWx0KTtcblxuICAgICAgaWYgKHN0YXRlLmZpcnN0KSB7XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5uZXdTdGF0ZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2l0ckZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5uZXdTdGF0ZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5uZXdTdGF0ZS5lKTsgfVxuICAgICAgfVxuICAgICAgc3RhdGUuaGFzUmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fY25kRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5oYXNSZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUuaGFzUmVzdWx0LmUpOyB9XG4gICAgICBpZiAoc3RhdGUuaGFzUmVzdWx0KSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3Jlc0ZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5yZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUucmVzdWx0LmUpOyB9XG4gICAgICAgIHZhciB0aW1lID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fdGltZUZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmICh0aW1lID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHRpbWUuZSk7IH1cbiAgICAgICAgcmVjdXJzZShzdGF0ZSwgdGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBvOiBvLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgICAgICBuZXdTdGF0ZTogdGhpcy5fc3RhdGUsXG4gICAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgICBoYXNSZXN1bHQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX3Muc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUoc3RhdGUsIG5ldyBEYXRlKHRoaXMuX3Mubm93KCkpLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVBYnNvbHV0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBpdGVyYXRpbmcgYSBzdGF0ZSBmcm9tIGFuIGluaXRpYWwgc3RhdGUgdW50aWwgdGhlIGNvbmRpdGlvbiBmYWlscy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHJlcyA9IHNvdXJjZS5nZW5lcmF0ZVdpdGhBYnNvbHV0ZVRpbWUoMCxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmV0dXJuIHRydWU7IH0sXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiBuZXcgRGF0ZSgpOyB9XG4gICAqICB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFN0YXRlIEluaXRpYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZSBJdGVyYXRpb24gc3RlcCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gZm9yIHJlc3VsdHMgcHJvZHVjZWQgaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lU2VsZWN0b3IgVGltZSBzZWxlY3RvciBmdW5jdGlvbiB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB2YWx1ZXMgYmVpbmcgcHJvZHVjZWQgZWFjaCBpdGVyYXRpb24sIHJldHVybmluZyBEYXRlIHZhbHVlcy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5nZW5lcmF0ZVdpdGhBYnNvbHV0ZVRpbWUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZShzdGF0ZSwgY25kRm4sIGl0ckZuLCByZXNGbiwgdGltZUZuLCBzKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fY25kRm4gPSBjbmRGbjtcbiAgICAgIHRoaXMuX2l0ckZuID0gaXRyRm47XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fdGltZUZuID0gdGltZUZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgc3RhdGUuaGFzUmVzdWx0ICYmIHN0YXRlLm8ub25OZXh0KHN0YXRlLnJlc3VsdCk7XG5cbiAgICAgIGlmIChzdGF0ZS5maXJzdCkge1xuICAgICAgICBzdGF0ZS5maXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubmV3U3RhdGUgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9pdHJGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUubmV3U3RhdGUgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUubmV3U3RhdGUuZSk7IH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUuaGFzUmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fY25kRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5oYXNSZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUuaGFzUmVzdWx0LmUpOyB9XG4gICAgICBpZiAoc3RhdGUuaGFzUmVzdWx0KSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3Jlc0ZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5yZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUucmVzdWx0LmUpOyB9XG4gICAgICAgIHZhciB0aW1lID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fdGltZUZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmICh0aW1lID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHRpbWUuZSk7IH1cbiAgICAgICAgcmVjdXJzZShzdGF0ZSwgdGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBvOiBvLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgICAgICBuZXdTdGF0ZTogdGhpcy5fc3RhdGUsXG4gICAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgICBoYXNSZXN1bHQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX3Muc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUoc3RhdGUsIDAsIHNjaGVkdWxlUmVjdXJzaXZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBpdGVyYXRpbmcgYSBzdGF0ZSBmcm9tIGFuIGluaXRpYWwgc3RhdGUgdW50aWwgdGhlIGNvbmRpdGlvbiBmYWlscy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHJlcyA9IHNvdXJjZS5nZW5lcmF0ZVdpdGhSZWxhdGl2ZVRpbWUoMCxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmV0dXJuIHRydWU7IH0sXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiA1MDA7IH1cbiAgICogICk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQ29uZGl0aW9uIHRvIHRlcm1pbmF0ZSBnZW5lcmF0aW9uICh1cG9uIHJldHVybmluZyBmYWxzZSkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGUgSXRlcmF0aW9uIHN0ZXAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZVNlbGVjdG9yIFRpbWUgc2VsZWN0b3IgZnVuY3Rpb24gdG8gY29udHJvbCB0aGUgc3BlZWQgb2YgdmFsdWVzIGJlaW5nIHByb2R1Y2VkIGVhY2ggaXRlcmF0aW9uLCByZXR1cm5pbmcgaW50ZWdlciB2YWx1ZXMgZGVub3RpbmcgbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciBvbiB3aGljaCB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBPYnNlcnZhYmxlLmdlbmVyYXRlV2l0aFJlbGF0aXZlVGltZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHRpbWVTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHRpbWVTZWxlY3Rvciwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgRGVsYXlTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVsYXlTdWJzY3JpcHRpb24sIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVsYXlTdWJzY3JpcHRpb24oc291cmNlLCBkdCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kdCA9IGR0O1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEZWxheVN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZCA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG5cbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zLnNjaGVkdWxlRnV0dXJlKFt0aGlzLnNvdXJjZSwgbywgZF0sIHRoaXMuX2R0LCBzY2hlZHVsZU1ldGhvZCkpO1xuXG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc3RhdGUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZVswXSwgbyA9IHN0YXRlWzFdLCBkID0gc3RhdGVbMl07XG4gICAgICBkLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShvKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIERlbGF5U3Vic2NyaXB0aW9uO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBUaW1lIHNoaWZ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBkZWxheWluZyB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIHNwZWNpZmllZCByZWxhdGl2ZSB0aW1lIGR1cmF0aW9uLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5kZWxheVN1YnNjcmlwdGlvbig1MDAwKTsgLy8gNXNcbiAgICogIDIgLSByZXMgPSBzb3VyY2UuZGVsYXlTdWJzY3JpcHRpb24oNTAwMCwgUnguU2NoZWR1bGVyLmRlZmF1bHQpOyAvLyA1IHNlY29uZHNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgUmVsYXRpdmUgb3IgYWJzb2x1dGUgdGltZSBzaGlmdCBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHN1YnNjcmlwdGlvbiBkZWxheSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaW1lLXNoaWZ0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZGVsYXlTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBEZWxheVN1YnNjcmlwdGlvbih0aGlzLCBkdWVUaW1lLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBkLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIobywgdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gcC5fcztcbiAgICAgIHRoaXMuX2QgPSBwLl9kO1xuICAgICAgdGhpcy5fcSA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBub3cgPSB0aGlzLl9zLm5vdygpO1xuICAgICAgdGhpcy5fcS5wdXNoKHsgaW50ZXJ2YWw6IG5vdywgdmFsdWU6IHggfSk7XG4gICAgICB3aGlsZSAodGhpcy5fcS5sZW5ndGggPiAwICYmIG5vdyAtIHRoaXMuX3FbMF0uaW50ZXJ2YWwgPj0gdGhpcy5fZCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub3cgPSB0aGlzLl9zLm5vdygpO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCAmJiBub3cgLSB0aGlzLl9xWzBdLmludGVydmFsID49IHRoaXMuX2QpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fcS5zaGlmdCgpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBTa2lwcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxuICAgKiAgQXMgbW9yZSBlbGVtZW50cyBhcmUgcmVjZWl2ZWQsIGVsZW1lbnRzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBhcmUgdGFrZW4gZnJvbSB0aGUgcXVldWUgYW5kIHByb2R1Y2VkIG9uIHRoZVxuICAgKiAgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkIHdpdGggZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3Igc2tpcHBpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXRcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgc2tpcHBlZCBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5za2lwTGFzdFdpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlKHRoaXMsIGR1cmF0aW9uLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBkLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIobywgdGhpcy5fZCwgdGhpcy5fcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIobywgZCwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fcSA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBub3cgPSB0aGlzLl9zLm5vdygpO1xuICAgICAgdGhpcy5fcS5wdXNoKHsgaW50ZXJ2YWw6IG5vdywgdmFsdWU6IHggfSk7XG4gICAgICB3aGlsZSAodGhpcy5fcS5sZW5ndGggPiAwICYmIG5vdyAtIHRoaXMuX3FbMF0uaW50ZXJ2YWwgPj0gdGhpcy5fZCkge1xuICAgICAgICB0aGlzLl9xLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vdyA9IHRoaXMuX3Mubm93KCk7XG4gICAgICB3aGlsZSAodGhpcy5fcS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5fcS5zaGlmdCgpO1xuICAgICAgICBpZiAobm93IC0gbmV4dC5pbnRlcnZhbCA8PSB0aGlzLl9kKSB7IHRoaXMuX28ub25OZXh0KG5leHQudmFsdWUpOyB9XG4gICAgICB9XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBlbGVtZW50cyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlcnMgdG8gcnVuIHRpbWVycyBhbmQgdG8gZHJhaW4gdGhlIGNvbGxlY3RlZCBlbGVtZW50cy5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBpbml0aWFsIGR1cmF0aW9uIHdpbmRvdy5cbiAgICogIEFzIG1vcmUgZWxlbWVudHMgYXJlIHJlY2VpdmVkLCBlbGVtZW50cyBvbGRlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gYXJlIHRha2VuIGZyb20gdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGVcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgdGFrZW4gZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3RXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSh0aGlzLCBkdXJhdGlvbiwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBpbml0aWFsIGR1cmF0aW9uIHdpbmRvdy5cbiAgICogIEFzIG1vcmUgZWxlbWVudHMgYXJlIHJlY2VpdmVkLCBlbGVtZW50cyBvbGRlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gYXJlIHRha2VuIGZyb20gdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGVcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0YWtlbiBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlTGFzdEJ1ZmZlcldpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBxID0gW107XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICBxLnB1c2goeyBpbnRlcnZhbDogbm93LCB2YWx1ZTogeCB9KTtcbiAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCAmJiBub3cgLSBxWzBdLmludGVydmFsID49IGR1cmF0aW9uKSB7XG4gICAgICAgICAgcS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKSwgcmVzID0gW107XG4gICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHEuc2hpZnQoKTtcbiAgICAgICAgICBub3cgLSBuZXh0LmludGVydmFsIDw9IGR1cmF0aW9uICYmIHJlcy5wdXNoKG5leHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlcyk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIFRha2VXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaXRoVGltZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZShzb3VyY2UsIGQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIG8pIHtcbiAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICB9XG5cbiAgICBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5fcy5zY2hlZHVsZUZ1dHVyZShvLCB0aGlzLl9kLCBzY2hlZHVsZU1ldGhvZCksXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShvKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VXaXRoVGltZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIFRha2VzIGVsZW1lbnRzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGFrZVdpdGhUaW1lKDUwMDAsICBbb3B0aW9uYWwgc2NoZWR1bGVyXSk7XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgdGFrZW4gZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlV2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZSh0aGlzLCBkdXJhdGlvbiwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgZCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgc2VsZi5fb3BlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUodGhpcywgdGhpcy5fZCwgc2NoZWR1bGVNZXRob2QpLFxuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBXaXRoVGltZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcFdpdGhUaW1lT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU2tpcFdpdGhUaW1lT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcC5fb3BlbiAmJiB0aGlzLl9vLm9uTmV4dCh4KTsgfTtcbiAgICBTa2lwV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBXaXRoVGltZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFNraXBzIGVsZW1lbnRzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBTcGVjaWZ5aW5nIGEgemVybyB2YWx1ZSBmb3IgZHVyYXRpb24gZG9lc24ndCBndWFyYW50ZWUgbm8gZWxlbWVudHMgd2lsbCBiZSBkcm9wcGVkIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqICBUaGlzIGlzIGEgc2lkZS1lZmZlY3Qgb2YgdGhlIGFzeW5jaHJvbnkgaW50cm9kdWNlZCBieSB0aGUgc2NoZWR1bGVyLCB3aGVyZSB0aGUgYWN0aW9uIHRoYXQgY2F1c2VzIGNhbGxiYWNrcyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UgdG8gYmUgZm9yd2FyZGVkXG4gICAqICBtYXkgbm90IGV4ZWN1dGUgaW1tZWRpYXRlbHksIGRlc3BpdGUgdGhlIHplcm8gZHVlIHRpbWUuXG4gICAqXG4gICAqICBFcnJvcnMgcHJvZHVjZWQgYnkgdGhlIHNvdXJjZSBzZXF1ZW5jZSBhcmUgYWx3YXlzIGZvcndhcmRlZCB0byB0aGUgcmVzdWx0IHNlcXVlbmNlLCBldmVuIGlmIHRoZSBlcnJvciBvY2N1cnMgYmVmb3JlIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciBza2lwcGluZyBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyBza2lwcGVkIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFdpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFNraXBXaXRoVGltZU9ic2VydmFibGUodGhpcywgZHVyYXRpb24sIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZShzb3VyY2UsIHN0YXJ0VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3N0ID0gc3RhcnRUaW1lO1xuICAgICAgdGhpcy5fcyA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5fb3BlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5fcy5zY2hlZHVsZUZ1dHVyZSh0aGlzLCB0aGlzLl9zdCwgc2NoZWR1bGVNZXRob2QpLFxuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIobywgdGhpcykpXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcC5fb3BlbiAmJiB0aGlzLl9vLm9uTmV4dCh4KTsgfTtcbiAgICBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuXG4gIC8qKlxuICAgKiAgU2tpcHMgZWxlbWVudHMgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UgdW50aWwgdGhlIHNwZWNpZmllZCBzdGFydCB0aW1lLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKiAgRXJyb3JzIHByb2R1Y2VkIGJ5IHRoZSBzb3VyY2Ugc2VxdWVuY2UgYXJlIGFsd2F5cyBmb3J3YXJkZWQgdG8gdGhlIHJlc3VsdCBzZXF1ZW5jZSwgZXZlbiBpZiB0aGUgZXJyb3Igb2NjdXJzIGJlZm9yZSB0aGUgc3RhcnQgdGltZS5cbiAgICpcbiAgICogQGV4YW1wbGVzXG4gICAqICAxIC0gcmVzID0gc291cmNlLnNraXBVbnRpbFdpdGhUaW1lKG5ldyBEYXRlKCksIFtzY2hlZHVsZXJdKTtcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2tpcFVudGlsV2l0aFRpbWUoNTAwMCwgW3NjaGVkdWxlcl0pO1xuICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBzdGFydFRpbWUgVGltZSB0byBzdGFydCB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLiBJZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBEYXRlKCksIG5vIGVsZW1lbnRzIHdpbGwgYmUgc2tpcHBlZC5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgc2tpcHBlZCB1bnRpbCB0aGUgc3BlY2lmaWVkIHN0YXJ0IHRpbWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFVudGlsV2l0aFRpbWUgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZSh0aGlzLCBzdGFydFRpbWUsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICBUYWtlcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiB1bnRpbCB0aGUgc3BlY2lmaWVkIGVuZCB0aW1lLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKiBAcGFyYW0ge051bWJlciB8IERhdGV9IGVuZFRpbWUgVGltZSB0byBzdG9wIHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIElmIHRoaXMgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG5ldyBEYXRlKCksIHRoZSByZXN1bHQgc3RyZWFtIHdpbGwgY29tcGxldGUgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgdGFrZW4gdW50aWwgdGhlIHNwZWNpZmllZCBlbmQgdGltZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlVW50aWxXaXRoVGltZSA9IGZ1bmN0aW9uIChlbmRUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKG8sIGVuZFRpbWUsIGZ1bmN0aW9uIChfLCBvKSB7IG8ub25Db21wbGV0ZWQoKTsgfSksXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUobykpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgZHVyaW5nIHNlcXVlbnRpYWwgdGltZSB3aW5kb3dzIG9mIGEgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2luZG93RHVyYXRpb24gdGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyBhbm90aGVyIGl0ZW0gYWZ0ZXIgZW1pdHRpbmcgdGhlIGxhc3QgaXRlbVxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gdGhlIFNjaGVkdWxlciB0byB1c2UgaW50ZXJuYWxseSB0byBtYW5hZ2UgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aW1lb3V0IGZvciBlYWNoIGl0ZW0uIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIHRocm90dGxlIG9wZXJhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50aHJvdHRsZSA9IGZ1bmN0aW9uICh3aW5kb3dEdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgdmFyIGR1cmF0aW9uID0gK3dpbmRvd0R1cmF0aW9uIHx8IDA7XG4gICAgaWYgKGR1cmF0aW9uIDw9IDApIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dpbmRvd0R1cmF0aW9uIGNhbm5vdCBiZSBsZXNzIG9yIGVxdWFsIHplcm8uJyk7IH1cbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBsYXN0T25OZXh0ID0gMDtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCk7XG4gICAgICAgICAgaWYgKGxhc3RPbk5leHQgPT09IDAgfHwgbm93IC0gbGFzdE9uTmV4dCA+PSBkdXJhdGlvbikge1xuICAgICAgICAgICAgbGFzdE9uTmV4dCA9IG5vdztcbiAgICAgICAgICAgIG8ub25OZXh0KHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sIGZ1bmN0aW9uICgpIHsgby5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICApO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIFRyYW5zZHVjZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUcmFuc2R1Y2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUcmFuc2R1Y2VPYnNlcnZlcihvLCB4Zm9ybSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl94Zm9ybSA9IHhmb3JtO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVHJhbnNkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3hmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKS5jYWxsKHRoaXMuX3hmb3JtLCB0aGlzLl9vLCB4KTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICB9O1xuXG4gICAgVHJhbnNkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuXG4gICAgVHJhbnNkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3hmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy5fbyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmFuc2R1Y2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtRm9yT2JzZXJ2ZXIobykge1xuICAgIHJldHVybiB7XG4gICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LFxuICAgICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24ob2JzLCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gb2JzLm9uTmV4dChpbnB1dCk7XG4gICAgICB9LFxuICAgICAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBmdW5jdGlvbihvYnMpIHtcbiAgICAgICAgcmV0dXJuIG9icy5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSB0cmFuc2R1Y2VyIHRvIHRyYW5zZm9ybSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZVxuICAgKiBAcGFyYW0ge1RyYW5zZHVjZXJ9IHRyYW5zZHVjZXIgQSB0cmFuc2R1Y2VyIHRvIGV4ZWN1dGVcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0cyBmcm9tIHRoZSB0cmFuc2R1Y2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRyYW5zZHVjZSA9IGZ1bmN0aW9uKHRyYW5zZHVjZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24obykge1xuICAgICAgdmFyIHhmb3JtID0gdHJhbnNkdWNlcih0cmFuc2Zvcm1Gb3JPYnNlcnZlcihvKSk7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVHJhbnNkdWNlT2JzZXJ2ZXIobywgeGZvcm0pKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBTd2l0Y2hGaXJzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN3aXRjaEZpcnN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaEZpcnN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgaGFzQ3VycmVudDogZmFsc2UsXG4gICAgICAgICAgaXNTdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICBvOiBvLFxuICAgICAgICAgIGc6IGdcbiAgICAgICAgfTtcblxuICAgICAgZy5hZGQobSk7XG4gICAgICBtLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hGaXJzdE9ic2VydmVyKHN0YXRlKSkpO1xuICAgICAgcmV0dXJuIGc7XG4gICAgfTtcblxuICAgIHJldHVybiBTd2l0Y2hGaXJzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU3dpdGNoRmlyc3RPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hGaXJzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0T2JzZXJ2ZXIoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3MgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaEZpcnN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF0aGlzLl9zLmhhc0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5fcy5oYXNDdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNQcm9taXNlKHgpICYmICh4ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHgpKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX3MuZy5hZGQoaW5uZXIpO1xuICAgICAgICBpbm5lci5zZXREaXNwb3NhYmxlKHguc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMuX3MsIGlubmVyKSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTd2l0Y2hGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU3dpdGNoRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgIXRoaXMuX3MuaGFzQ3VycmVudCAmJiB0aGlzLl9zLmcubGVuZ3RoID09PSAxICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIoc3RhdGUsIGlubmVyKSB7XG4gICAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgICB0aGlzLl9pID0gaW5uZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcy5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3MuZy5yZW1vdmUodGhpcy5faSk7XG4gICAgICB0aGlzLl9zLmhhc0N1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3MuaXNTdG9wcGVkICYmIHRoaXMuX3MuZy5sZW5ndGggPT09IDEgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTd2l0Y2hGaXJzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBleGNsdXNpdmUgd2FpdGluZyBmb3IgdGhlIGZpcnN0IHRvIGZpbmlzaCBiZWZvcmUgc3Vic2NyaWJpbmcgdG8gYW5vdGhlciBvYnNlcnZhYmxlLlxuICAgKiBPYnNlcnZhYmxlcyB0aGF0IGNvbWUgaW4gYmV0d2VlbiBzdWJzY3JpcHRpb25zIHdpbGwgYmUgZHJvcHBlZCBvbiB0aGUgZmxvb3IuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIGV4Y2x1c2l2ZSBvYnNlcnZhYmxlIHdpdGggb25seSB0aGUgcmVzdWx0cyB0aGF0IGhhcHBlbiB3aGVuIHN1YnNjcmliZWQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3dpdGNoRmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTd2l0Y2hGaXJzdE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwRmlyc3QgPSBvYnNlcnZhYmxlUHJvdG8uZXhoYXVzdE1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5zd2l0Y2hGaXJzdCgpO1xufTtcblxub2JzZXJ2YWJsZVByb3RvLmZsYXRNYXBXaXRoTWF4Q29uY3VycmVudCA9IG9ic2VydmFibGVQcm90by5mbGF0TWFwTWF4Q29uY3VycmVudCA9IGZ1bmN0aW9uKGxpbWl0LCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykubWVyZ2UobGltaXQpO1xufTtcblxuICAvKiogUHJvdmlkZXMgYSBzZXQgb2YgZXh0ZW5zaW9uIG1ldGhvZHMgZm9yIHZpcnR1YWwgdGltZSBzY2hlZHVsaW5nLiAqL1xuICB2YXIgVmlydHVhbFRpbWVTY2hlZHVsZXIgPSBSeC5WaXJ0dWFsVGltZVNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVmlydHVhbFRpbWVTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZpcnR1YWwgdGltZSBzY2hlZHVsZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgY2xvY2sgdmFsdWUgYW5kIGFic29sdXRlIHRpbWUgY29tcGFyZXIuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5pdGlhbENsb2NrIEluaXRpYWwgdmFsdWUgZm9yIHRoZSBjbG9jay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBDb21wYXJlciB0byBkZXRlcm1pbmUgY2F1c2FsaXR5IG9mIGV2ZW50cyBiYXNlZCBvbiBhYnNvbHV0ZSB0aW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpcnR1YWxUaW1lU2NoZWR1bGVyKGluaXRpYWxDbG9jaywgY29tcGFyZXIpIHtcbiAgICAgIHRoaXMuY2xvY2sgPSBpbml0aWFsQ2xvY2s7XG4gICAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXI7XG4gICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKDEwMjQpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlID0gVmlydHVhbFRpbWVTY2hlZHVsZXIucHJvdG90eXBlO1xuXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BYnNvbHV0ZVRpbWUodGhpcy5jbG9jayk7XG4gICAgfTtcblxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlQWJzb2x1dGUoc3RhdGUsIHRoaXMuY2xvY2ssIGFjdGlvbik7XG4gICAgfTtcblxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHZhciBkdCA9IGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgdGhpcy50b1JlbGF0aXZlVGltZShkdWVUaW1lIC0gdGhpcy5ub3coKSkgOlxuICAgICAgICB0aGlzLnRvUmVsYXRpdmVUaW1lKGR1ZVRpbWUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVJlbGF0aXZlKHN0YXRlLCBkdCwgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHRpbWUgdmFsdWUgdG8gYW4gYWJzb2x1dGUgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxhdGl2ZSBSZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuYWRkID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSB0aW1lIHRvIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHtBbnl9IFRoZSBhYnNvbHV0ZSB0aW1lLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhYnNvbHV0ZSB0aW1lIGluIG1zXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUudG9BYnNvbHV0ZVRpbWUgPSBub3RJbXBsZW1lbnRlZDtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBUaW1lU3BhbiB2YWx1ZSB0byBhIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gVGltZVNwYW4gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvcnJlc3BvbmRpbmcgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnRvUmVsYXRpdmVUaW1lID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBwZXJpb2RpYyBwaWVjZSBvZiB3b3JrIGJ5IGR5bmFtaWNhbGx5IGRpc2NvdmVyaW5nIHRoZSBzY2hlZHVsZXIncyBjYXBhYmlsaXRpZXMuIFRoZSBwZXJpb2RpYyB0YXNrIHdpbGwgYmUgZW11bGF0ZWQgdXNpbmcgcmVjdXJzaXZlIHNjaGVkdWxpbmcuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB1cG9uIHRoZSBmaXJzdCBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZCBQZXJpb2QgZm9yIHJ1bm5pbmcgdGhlIHdvcmsgcGVyaW9kaWNhbGx5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQsIHBvdGVudGlhbGx5IHVwZGF0aW5nIHRoZSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVjdXJyaW5nIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlUGVyaW9kaWMgPSBmdW5jdGlvbiAoc3RhdGUsIHBlcmlvZCwgYWN0aW9uKSB7XG4gICAgICB2YXIgcyA9IG5ldyBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlKHRoaXMsIHN0YXRlLCBwZXJpb2QsIGFjdGlvbik7XG4gICAgICByZXR1cm4gcy5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGR1ZVRpbWUuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgUmVsYXRpdmUgdGltZSBhZnRlciB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2NoZWR1bGVSZWxhdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgcnVuQXQgPSB0aGlzLmFkZCh0aGlzLmNsb2NrLCBkdWVUaW1lKTtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlQWJzb2x1dGUoc3RhdGUsIHJ1bkF0LCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHZpcnR1YWwgdGltZSBzY2hlZHVsZXIuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZXIobmV4dC5kdWVUaW1lLCB0aGlzLmNsb2NrKSA+IDAgJiYgKHRoaXMuY2xvY2sgPSBuZXh0LmR1ZVRpbWUpO1xuICAgICAgICAgICAgbmV4dC5pbnZva2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuaXNFbmFibGVkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIHZpcnR1YWwgdGltZSBzY2hlZHVsZXIuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2VzIHRoZSBzY2hlZHVsZXIncyBjbG9jayB0byB0aGUgc3BlY2lmaWVkIHRpbWUsIHJ1bm5pbmcgYWxsIHdvcmsgdGlsbCB0aGF0IHBvaW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIEFic29sdXRlIHRpbWUgdG8gYWR2YW5jZSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgdG8uXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuYWR2YW5jZVRvID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHZhciBkdWVUb0Nsb2NrID0gdGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCB0aW1lKTtcbiAgICAgIGlmICh0aGlzLmNvbXBhcmVyKHRoaXMuY2xvY2ssIHRpbWUpID4gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgICAgaWYgKGR1ZVRvQ2xvY2sgPT09IDApIHsgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgICAgaWYgKG5leHQgIT09IG51bGwgJiYgdGhpcy5jb21wYXJlcihuZXh0LmR1ZVRpbWUsIHRpbWUpIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZXIobmV4dC5kdWVUaW1lLCB0aGlzLmNsb2NrKSA+IDAgJiYgKHRoaXMuY2xvY2sgPSBuZXh0LmR1ZVRpbWUpO1xuICAgICAgICAgICAgbmV4dC5pbnZva2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuaXNFbmFibGVkKTtcbiAgICAgICAgdGhpcy5jbG9jayA9IHRpbWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2VzIHRoZSBzY2hlZHVsZXIncyBjbG9jayBieSB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHRpbWUsIHJ1bm5pbmcgYWxsIHdvcmsgc2NoZWR1bGVkIGZvciB0aGF0IHRpbWVzcGFuLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFJlbGF0aXZlIHRpbWUgdG8gYWR2YW5jZSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuYWR2YW5jZUJ5ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHZhciBkdCA9IHRoaXMuYWRkKHRoaXMuY2xvY2ssIHRpbWUpLFxuICAgICAgICAgIGR1ZVRvQ2xvY2sgPSB0aGlzLmNvbXBhcmVyKHRoaXMuY2xvY2ssIGR0KTtcbiAgICAgIGlmIChkdWVUb0Nsb2NrID4gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgICAgaWYgKGR1ZVRvQ2xvY2sgPT09IDApIHsgIHJldHVybjsgfVxuXG4gICAgICB0aGlzLmFkdmFuY2VUbyhkdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2VzIHRoZSBzY2hlZHVsZXIncyBjbG9jayBieSB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHRpbWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgUmVsYXRpdmUgdGltZSB0byBhZHZhbmNlIHRoZSBzY2hlZHVsZXIncyBjbG9jayBieS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLmFkZCh0aGlzLmNsb2NrLCB0aW1lKTtcbiAgICAgIGlmICh0aGlzLmNvbXBhcmVyKHRoaXMuY2xvY2ssIGR0KSA+PSAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG5cbiAgICAgIHRoaXMuY2xvY2sgPSBkdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCBzY2hlZHVsZWQgaXRlbSB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJucyB7U2NoZWR1bGVkSXRlbX0gVGhlIG5leHQgc2NoZWR1bGVkIGl0ZW0uXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnF1ZXVlLnBlZWsoKTtcbiAgICAgICAgaWYgKG5leHQuaXNDYW5jZWxsZWQoKSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCBhdCBkdWVUaW1lLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIEFic29sdXRlIHRpbWUgYXQgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlQWJzb2x1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBydW4oc2NoZWR1bGVyLCBzdGF0ZTEpIHtcbiAgICAgICAgc2VsZi5xdWV1ZS5yZW1vdmUoc2kpO1xuICAgICAgICByZXR1cm4gYWN0aW9uKHNjaGVkdWxlciwgc3RhdGUxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpID0gbmV3IFNjaGVkdWxlZEl0ZW0odGhpcywgc3RhdGUsIHJ1biwgZHVlVGltZSwgdGhpcy5jb21wYXJlcik7XG4gICAgICB0aGlzLnF1ZXVlLmVucXVldWUoc2kpO1xuXG4gICAgICByZXR1cm4gc2kuZGlzcG9zYWJsZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFZpcnR1YWxUaW1lU2NoZWR1bGVyO1xuICB9KFNjaGVkdWxlcikpO1xuXG4gIC8qKiBQcm92aWRlcyBhIHZpcnR1YWwgdGltZSBzY2hlZHVsZXIgdGhhdCB1c2VzIERhdGUgZm9yIGFic29sdXRlIHRpbWUgYW5kIG51bWJlciBmb3IgcmVsYXRpdmUgdGltZS4gKi9cbiAgUnguSGlzdG9yaWNhbFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSGlzdG9yaWNhbFNjaGVkdWxlciwgX19zdXBlcl9fKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaGlzdG9yaWNhbCBzY2hlZHVsZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgY2xvY2sgdmFsdWUuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluaXRpYWxDbG9jayBJbml0aWFsIHZhbHVlIGZvciB0aGUgY2xvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgQ29tcGFyZXIgdG8gZGV0ZXJtaW5lIGNhdXNhbGl0eSBvZiBldmVudHMgYmFzZWQgb24gYWJzb2x1dGUgdGltZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIaXN0b3JpY2FsU2NoZWR1bGVyKGluaXRpYWxDbG9jaywgY29tcGFyZXIpIHtcbiAgICAgIHZhciBjbG9jayA9IGluaXRpYWxDbG9jayA9PSBudWxsID8gMCA6IGluaXRpYWxDbG9jaztcbiAgICAgIHZhciBjbXAgPSBjb21wYXJlciB8fCBkZWZhdWx0U3ViQ29tcGFyZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBjbG9jaywgY21wKTtcbiAgICB9XG5cbiAgICB2YXIgSGlzdG9yaWNhbFNjaGVkdWxlclByb3RvID0gSGlzdG9yaWNhbFNjaGVkdWxlci5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVsYXRpdmUgdGltZSB2YWx1ZSB0byBhbiBhYnNvbHV0ZSB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF0aXZlIFJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZSB0byBhZGQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBSZXN1bHRpbmcgYWJzb2x1dGUgdmlydHVhbCB0aW1lIHN1bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8uYWRkID0gZnVuY3Rpb24gKGFic29sdXRlLCByZWxhdGl2ZSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlICsgcmVsYXRpdmU7XG4gICAgfTtcblxuICAgIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90by50b0Fic29sdXRlVGltZSA9IGZ1bmN0aW9uIChhYnNvbHV0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGFic29sdXRlKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBUaW1lU3BhbiB2YWx1ZSB0byBhIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyT2YgSGlzdG9yaWNhbFNjaGVkdWxlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBUaW1lU3BhbiB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ29ycmVzcG9uZGluZyByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICovXG4gICAgSGlzdG9yaWNhbFNjaGVkdWxlclByb3RvLnRvUmVsYXRpdmVUaW1lID0gZnVuY3Rpb24gKHRpbWVTcGFuKSB7XG4gICAgICByZXR1cm4gdGltZVNwYW47XG4gICAgfTtcblxuICAgIHJldHVybiBIaXN0b3JpY2FsU2NoZWR1bGVyO1xuICB9KFJ4LlZpcnR1YWxUaW1lU2NoZWR1bGVyKSk7XG5cbmZ1bmN0aW9uIE9uTmV4dFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbn1cblxuT25OZXh0UHJlZGljYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmIChvdGhlciA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAob3RoZXIua2luZCAhPT0gJ04nKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdGhpcy5wcmVkaWNhdGUob3RoZXIudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gT25FcnJvclByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG59XG5cbk9uRXJyb3JQcmVkaWNhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAob3RoZXIgPT09IHRoaXMpIHsgcmV0dXJuIHRydWU7IH1cbiAgaWYgKG90aGVyID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChvdGhlci5raW5kICE9PSAnRScpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0aGlzLnByZWRpY2F0ZShvdGhlci5lcnJvcik7XG59O1xuXG52YXIgUmVhY3RpdmVUZXN0ID0gUnguUmVhY3RpdmVUZXN0ID0ge1xuICAvKiogRGVmYXVsdCB2aXJ0dWFsIHRpbWUgdXNlZCBmb3IgY3JlYXRpb24gb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdW5pdCB0ZXN0cy4gKi9cbiAgY3JlYXRlZDogMTAwLFxuICAvKiogRGVmYXVsdCB2aXJ0dWFsIHRpbWUgdXNlZCB0byBzdWJzY3JpYmUgdG8gb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdW5pdCB0ZXN0cy4gKi9cbiAgc3Vic2NyaWJlZDogMjAwLFxuICAvKiogRGVmYXVsdCB2aXJ0dWFsIHRpbWUgdXNlZCB0byBkaXNwb3NlIHN1YnNjcmlwdGlvbnMgaW4gdW5pdCB0ZXN0cy4gKi9cbiAgZGlzcG9zZWQ6IDEwMDAsXG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBhbiBPbk5leHQgbm90aWZpY2F0aW9uIHJlY29yZCBhdCBhIGdpdmVuIHRpbWUgd2l0aCBhIGdpdmVuIHZhbHVlIG9yIGEgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAxIC0gUmVhY3RpdmVUZXN0Lm9uTmV4dCgyMDAsIDQyKTtcbiAgICogMiAtIFJlYWN0aXZlVGVzdC5vbk5leHQoMjAwLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPT0gMjsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBSZWNvcmRlZCB2aXJ0dWFsIHRpbWUgdGhlIE9uTmV4dCBub3RpZmljYXRpb24gb2NjdXJzLlxuICAgKiBAcGFyYW0gdmFsdWUgUmVjb3JkZWQgdmFsdWUgc3RvcmVkIGluIHRoZSBPbk5leHQgbm90aWZpY2F0aW9uIG9yIGEgcHJlZGljYXRlLlxuICAgKiBAcmV0dXJuIFJlY29yZGVkIE9uTmV4dCBub3RpZmljYXRpb24uXG4gICAqL1xuICBvbk5leHQ6IGZ1bmN0aW9uICh0aWNrcywgdmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID9cbiAgICAgIG5ldyBSZWNvcmRlZCh0aWNrcywgbmV3IE9uTmV4dFByZWRpY2F0ZSh2YWx1ZSkpIDpcbiAgICAgIG5ldyBSZWNvcmRlZCh0aWNrcywgTm90aWZpY2F0aW9uLmNyZWF0ZU9uTmV4dCh2YWx1ZSkpO1xuICB9LFxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgZm9yIGFuIE9uRXJyb3Igbm90aWZpY2F0aW9uIHJlY29yZCBhdCBhIGdpdmVuIHRpbWUgd2l0aCBhIGdpdmVuIGVycm9yLlxuICAgKlxuICAgKiAxIC0gUmVhY3RpdmVUZXN0Lm9uTmV4dCgyMDAsIG5ldyBFcnJvcignZXJyb3InKSk7XG4gICAqIDIgLSBSZWFjdGl2ZVRlc3Qub25OZXh0KDIwMCwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubWVzc2FnZSA9PT0gJ2Vycm9yJzsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBSZWNvcmRlZCB2aXJ0dWFsIHRpbWUgdGhlIE9uRXJyb3Igbm90aWZpY2F0aW9uIG9jY3Vycy5cbiAgICogQHBhcmFtIGV4Y2VwdGlvbiBSZWNvcmRlZCBleGNlcHRpb24gc3RvcmVkIGluIHRoZSBPbkVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICogQHJldHVybiBSZWNvcmRlZCBPbkVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIG9uRXJyb3I6IGZ1bmN0aW9uICh0aWNrcywgZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgICAgIG5ldyBSZWNvcmRlZCh0aWNrcywgbmV3IE9uRXJyb3JQcmVkaWNhdGUoZXJyb3IpKSA6XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkVycm9yKGVycm9yKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYW4gT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uIHJlY29yZCBhdCBhIGdpdmVuIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBSZWNvcmRlZCB2aXJ0dWFsIHRpbWUgdGhlIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiBvY2N1cnMuXG4gICAqIEByZXR1cm4gUmVjb3JkZWQgT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICh0aWNrcykge1xuICAgIHJldHVybiBuZXcgUmVjb3JkZWQodGlja3MsIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkNvbXBsZXRlZCgpKTtcbiAgfSxcbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBhIHN1YnNjcmlwdGlvbiByZWNvcmQgYmFzZWQgb24gYSBnaXZlbiBzdWJzY3JpcHRpb24gYW5kIGRpc3Bvc2FsIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydCBWaXJ0dWFsIHRpbWUgaW5kaWNhdGluZyB3aGVuIHRoZSBzdWJzY3JpcHRpb24gd2FzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBlbmQgVmlydHVhbCB0aW1lIGluZGljYXRpbmcgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHdhcyBkaXNwb3NlZC5cbiAgICogQHJldHVybiBTdWJzY3JpcHRpb24gb2JqZWN0LlxuICAgKi9cbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKHN0YXJ0LCBlbmQpO1xuICB9XG59O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCByZWNvcmRpbmcgdGhlIHByb2R1Y3Rpb24gb2YgdGhlIHNwZWNpZmllZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdmlydHVhbCB0aW1lLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVmlydHVhbCB0aW1lIHRoZSB2YWx1ZSB3YXMgcHJvZHVjZWQgb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFZhbHVlIHRoYXQgd2FzIHByb2R1Y2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBBbiBvcHRpb25hbCBjb21wYXJlci5cbiAgICovXG4gIHZhciBSZWNvcmRlZCA9IFJ4LlJlY29yZGVkID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlLCBjb21wYXJlcikge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlciB8fCBkZWZhdWx0Q29tcGFyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiByZWNvcmRlZCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkZWR9IG90aGVyIFJlY29yZGVkIG9iamVjdCB0byBjaGVjayBmb3IgZXF1YWxpdHkuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGJvdGggb2JqZWN0cyBhcmUgZXF1YWw7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIFJlY29yZGVkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lID09PSBvdGhlci50aW1lICYmIHRoaXMuY29tcGFyZXIodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFJlY29yZGVkIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgUmVjb3JkZWQgdmFsdWUuXG4gICAqL1xuICBSZWNvcmRlZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKSArICdAJyArIHRoaXMudGltZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdWJzY3JpcHRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZpcnR1YWwgc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiB0aW1lLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN1YnNjcmliZSBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiBvY2N1cnJlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHVuc3Vic2NyaWJlIFZpcnR1YWwgdGltZSBhdCB3aGljaCB0aGUgdW5zdWJzY3JpcHRpb24gb2NjdXJyZWQuXG4gICAqL1xuICB2YXIgU3Vic2NyaXB0aW9uID0gUnguU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHN0YXJ0O1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBlbmQgfHwgTnVtYmVyLk1BWF9WQUxVRTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHN1YnNjcmlwdGlvbiBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG90aGVyIFN1YnNjcmlwdGlvbiBvYmplY3QgdG8gY2hlY2sgZm9yIGVxdWFsaXR5LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBib3RoIG9iamVjdHMgYXJlIGVxdWFsOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSA9PT0gb3RoZXIuc3Vic2NyaWJlICYmIHRoaXMudW5zdWJzY3JpYmUgPT09IG90aGVyLnVuc3Vic2NyaWJlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbiB2YWx1ZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbiB2YWx1ZS5cbiAgICovXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcoJyArIHRoaXMuc3Vic2NyaWJlICsgJywgJyArICh0aGlzLnVuc3Vic2NyaWJlID09PSBOdW1iZXIuTUFYX1ZBTFVFID8gJ0luZmluaXRlJyA6IHRoaXMudW5zdWJzY3JpYmUpICsgJyknO1xuICB9O1xuXG4gIHZhciBNb2NrRGlzcG9zYWJsZSA9IFJ4Lk1vY2tEaXNwb3NhYmxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuZGlzcG9zZXMgPSBbXTtcbiAgICB0aGlzLmRpc3Bvc2VzLnB1c2godGhpcy5zY2hlZHVsZXIuY2xvY2spO1xuICB9O1xuXG4gIE1vY2tEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcG9zZXMucHVzaCh0aGlzLnNjaGVkdWxlci5jbG9jayk7XG4gIH07XG5cbiAgdmFyIE1vY2tPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTW9ja09ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gTW9ja09ic2VydmVyKHNjaGVkdWxlcikge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgTW9ja09ic2VydmVyUHJvdG90eXBlID0gTW9ja09ic2VydmVyLnByb3RvdHlwZTtcblxuICAgIE1vY2tPYnNlcnZlclByb3RvdHlwZS5vbk5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChuZXcgUmVjb3JkZWQodGhpcy5zY2hlZHVsZXIuY2xvY2ssIE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQodmFsdWUpKSk7XG4gICAgfTtcblxuICAgIE1vY2tPYnNlcnZlclByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChuZXcgUmVjb3JkZWQodGhpcy5zY2hlZHVsZXIuY2xvY2ssIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkVycm9yKGUpKSk7XG4gICAgfTtcblxuICAgIE1vY2tPYnNlcnZlclByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChuZXcgUmVjb3JkZWQodGhpcy5zY2hlZHVsZXIuY2xvY2ssIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkNvbXBsZXRlZCgpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2NrT2JzZXJ2ZXI7XG4gIH0pKE9ic2VydmVyKTtcblxuICBmdW5jdGlvbiBNb2NrUHJvbWlzZShzY2hlZHVsZXIsIG1lc3NhZ2VzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV0sXG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgIChmdW5jdGlvbiAoaW5uZXJOb3RpZmljYXRpb24pIHtcbiAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgbWVzc2FnZS50aW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9icyA9IHNlbGYub2JzZXJ2ZXJzLnNsaWNlKDApO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBvYnMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICBpbm5lck5vdGlmaWNhdGlvbi5hY2NlcHQob2JzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfSk7XG4gICAgICB9KShub3RpZmljYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIE1vY2tQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc2NoZWR1bGVyLmNsb2NrKSk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgbmV3UHJvbWlzZTtcblxuICAgIHZhciBvYnNlcnZlciA9IFJ4Lk9ic2VydmVyLmNyZWF0ZShcbiAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXRWYWx1ZSA9IG9uUmVzb2x2ZWQoeCk7XG4gICAgICAgIGlmIChyZXRWYWx1ZSAmJiB0eXBlb2YgcmV0VmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG5ld1Byb21pc2UgPSByZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGlja3MgPSBzZWxmLnNjaGVkdWxlci5jbG9jaztcbiAgICAgICAgICBuZXdQcm9taXNlID0gbmV3IE1vY2tQcm9taXNlKHNlbGYuc2NoZWR1bGVyLCBbUnguUmVhY3RpdmVUZXN0Lm9uTmV4dCh0aWNrcywgdW5kZWZpbmVkKSwgUnguUmVhY3RpdmVUZXN0Lm9uQ29tcGxldGVkKHRpY2tzKV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHggPSBzZWxmLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcbiAgICAgICAgc2VsZi5vYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBzZWxmLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBvblJlamVjdGVkKGVycik7XG4gICAgICAgIHZhciBpZHggPSBzZWxmLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcbiAgICAgICAgc2VsZi5vYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBzZWxmLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcblxuICAgIHJldHVybiBuZXdQcm9taXNlIHx8IG5ldyBNb2NrUHJvbWlzZSh0aGlzLnNjaGVkdWxlciwgdGhpcy5tZXNzYWdlcyk7XG4gIH07XG5cbiAgdmFyIEhvdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEhvdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBIb3RPYnNlcnZhYmxlKHNjaGVkdWxlciwgbWVzc2FnZXMpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdmFyIG1lc3NhZ2UsIG5vdGlmaWNhdGlvbiwgb2JzZXJ2YWJsZSA9IHRoaXM7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgICBub3RpZmljYXRpb24gPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAoZnVuY3Rpb24gKGlubmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgbWVzc2FnZS50aW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JzID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gb2JzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgICBpbm5lck5vdGlmaWNhdGlvbi5hY2NlcHQob2JzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKG5vdGlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSG90T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXM7XG4gICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2gobmV3IFN1YnNjcmlwdGlvbih0aGlzLnNjaGVkdWxlci5jbG9jaykpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSBvYnNlcnZhYmxlLm9ic2VydmVycy5pbmRleE9mKG8pO1xuICAgICAgICBvYnNlcnZhYmxlLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zdWJzY3JpcHRpb25zW2luZGV4XSA9IG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2YWJsZS5zdWJzY3JpcHRpb25zW2luZGV4XS5zdWJzY3JpYmUsIG9ic2VydmFibGUuc2NoZWR1bGVyLmNsb2NrKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gSG90T2JzZXJ2YWJsZTtcbiAgfSkoT2JzZXJ2YWJsZSk7XG5cbiAgdmFyIENvbGRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb2xkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIENvbGRPYnNlcnZhYmxlKHNjaGVkdWxlciwgbWVzc2FnZXMpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICBDb2xkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbWVzc2FnZSwgbm90aWZpY2F0aW9uLCBvYnNlcnZhYmxlID0gdGhpcztcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb24odGhpcy5zY2hlZHVsZXIuY2xvY2spKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubWVzc2FnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICAgIG5vdGlmaWNhdGlvbiA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgIChmdW5jdGlvbiAoaW5uZXJOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICBkLmFkZChvYnNlcnZhYmxlLnNjaGVkdWxlci5zY2hlZHVsZVJlbGF0aXZlKG51bGwsIG1lc3NhZ2UudGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5uZXJOb3RpZmljYXRpb24uYWNjZXB0KG8pO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKG5vdGlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBvYnNlcnZhYmxlLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb2xkT2JzZXJ2YWJsZTtcbiAgfSkoT2JzZXJ2YWJsZSk7XG5cbiAgLyoqIFZpcnR1YWwgdGltZSBzY2hlZHVsZXIgdXNlZCBmb3IgdGVzdGluZyBhcHBsaWNhdGlvbnMgYW5kIGxpYnJhcmllcyBidWlsdCB1c2luZyBSZWFjdGl2ZSBFeHRlbnNpb25zLiAqL1xuICBSeC5UZXN0U2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUZXN0U2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gYmFzZUNvbXBhcmVyKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID4geSA/IDEgOiAoeCA8IHkgPyAtMSA6IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRlc3RTY2hlZHVsZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCAwLCBiYXNlQ29tcGFyZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgdGhlIHNwZWNpZmllZCB2aXJ0dWFsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIGR1ZVRpbWUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIGF0IHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJuIERpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVBYnNvbHV0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICBkdWVUaW1lIDw9IHRoaXMuY2xvY2sgJiYgKGR1ZVRpbWUgPSB0aGlzLmNsb2NrICsgMSk7XG4gICAgICByZXR1cm4gX19zdXBlcl9fLnByb3RvdHlwZS5zY2hlZHVsZUFic29sdXRlLmNhbGwodGhpcywgc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHRvIGFuIGFic29sdXRlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHJlbGF0aXZlIFJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZSB0byBhZGQuXG4gICAgICogQHJldHVybiBSZXN1bHRpbmcgYWJzb2x1dGUgdmlydHVhbCB0aW1lIHN1bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWJzb2x1dGUsIHJlbGF0aXZlKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGUgKyByZWxhdGl2ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYSBEYXRlVGltZU9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIENvcnJlc3BvbmRpbmcgRGF0ZVRpbWVPZmZzZXQgdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUudG9BYnNvbHV0ZVRpbWUgPSBmdW5jdGlvbiAoYWJzb2x1dGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShhYnNvbHV0ZSkuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIFRpbWVTcGFuIHZhbHVlIHRvIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiBDb3JyZXNwb25kaW5nIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS50b1JlbGF0aXZlVGltZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xuICAgICAgcmV0dXJuIHRpbWVTcGFuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSB0ZXN0IHNjaGVkdWxlciBhbmQgdXNlcyB0aGUgc3BlY2lmaWVkIHZpcnR1YWwgdGltZXMgdG8gaW52b2tlIHRoZSBmYWN0b3J5IGZ1bmN0aW9uLCBzdWJzY3JpYmUgdG8gdGhlIHJlc3VsdGluZyBzZXF1ZW5jZSwgYW5kIGRpc3Bvc2UgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjcmVhdGUgRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIGNyZWF0ZWQgVmlydHVhbCB0aW1lIGF0IHdoaWNoIHRvIGludm9rZSB0aGUgZmFjdG9yeSB0byBjcmVhdGUgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlZCBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdG8gc3Vic2NyaWJlIHRvIHRoZSBjcmVhdGVkIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIGRpc3Bvc2VkIFZpcnR1YWwgdGltZSBhdCB3aGljaCB0byBkaXNwb3NlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICogQHJldHVybiBPYnNlcnZlciB3aXRoIHRpbWVzdGFtcGVkIHJlY29yZGluZ3Mgb2Ygbm90aWZpY2F0aW9uIG1lc3NhZ2VzIHRoYXQgd2VyZSByZWNlaXZlZCBkdXJpbmcgdGhlIHZpcnR1YWwgdGltZSB3aW5kb3cgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2FzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5zdGFydFNjaGVkdWxlciA9IGZ1bmN0aW9uIChjcmVhdGVGbiwgc2V0dGluZ3MpIHtcbiAgICAgIHNldHRpbmdzIHx8IChzZXR0aW5ncyA9IHt9KTtcbiAgICAgIHNldHRpbmdzLmNyZWF0ZWQgPT0gbnVsbCAmJiAoc2V0dGluZ3MuY3JlYXRlZCA9IFJlYWN0aXZlVGVzdC5jcmVhdGVkKTtcbiAgICAgIHNldHRpbmdzLnN1YnNjcmliZWQgPT0gbnVsbCAmJiAoc2V0dGluZ3Muc3Vic2NyaWJlZCA9IFJlYWN0aXZlVGVzdC5zdWJzY3JpYmVkKTtcbiAgICAgIHNldHRpbmdzLmRpc3Bvc2VkID09IG51bGwgJiYgKHNldHRpbmdzLmRpc3Bvc2VkID0gUmVhY3RpdmVUZXN0LmRpc3Bvc2VkKTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5jcmVhdGVPYnNlcnZlcigpLCBzb3VyY2UsIHN1YnNjcmlwdGlvbjtcblxuICAgICAgdGhpcy5zY2hlZHVsZUFic29sdXRlKG51bGwsIHNldHRpbmdzLmNyZWF0ZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc291cmNlID0gY3JlYXRlRm4oKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgc2V0dGluZ3Muc3Vic2NyaWJlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgc2V0dGluZ3MuZGlzcG9zZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhvdCBvYnNlcnZhYmxlIHVzaW5nIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wZWQgbm90aWZpY2F0aW9uIG1lc3NhZ2VzIGVpdGhlciBhcyBhbiBhcnJheSBvciBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIE5vdGlmaWNhdGlvbnMgdG8gc3VyZmFjZSB0aHJvdWdoIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGF0IHRoZWlyIHNwZWNpZmllZCBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWVzLlxuICAgICAqIEByZXR1cm4gSG90IG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHRpbWluZyBvZiBzdWJzY3JpcHRpb25zIGFuZCBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZUhvdE9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEhvdE9ic2VydmFibGUodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb2xkIG9ic2VydmFibGUgdXNpbmcgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBlZCBub3RpZmljYXRpb24gbWVzc2FnZXMgZWl0aGVyIGFzIGFuIGFycmF5IG9yIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgTm90aWZpY2F0aW9ucyB0byBzdXJmYWNlIHRocm91Z2ggdGhlIGNyZWF0ZWQgc2VxdWVuY2UgYXQgdGhlaXIgc3BlY2lmaWVkIHZpcnR1YWwgdGltZSBvZmZzZXRzIGZyb20gdGhlIHNlcXVlbmNlIHN1YnNjcmlwdGlvbiB0aW1lLlxuICAgICAqIEByZXR1cm4gQ29sZCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB0aW1pbmcgb2Ygc3Vic2NyaXB0aW9ucyBhbmQgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVDb2xkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29sZE9ic2VydmFibGUodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXNvbHZlZCBwcm9taXNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIGFuZCB0aWNrc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aWNrcyBUaGUgYWJzb2x1dGUgdGltZSBvZiB0aGUgcmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHlpZWxkIGF0IHRoZSBnaXZlbiB0aWNrLlxuICAgICAqIEByZXR1cm5zIHtNb2NrUHJvbWlzZX0gQSBtb2NrIFByb21pc2Ugd2hpY2ggZnVsZmlsbHMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlUmVzb2x2ZWRQcm9taXNlID0gZnVuY3Rpb24gKHRpY2tzLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBNb2NrUHJvbWlzZSh0aGlzLCBbUnguUmVhY3RpdmVUZXN0Lm9uTmV4dCh0aWNrcywgdmFsdWUpLCBSeC5SZWFjdGl2ZVRlc3Qub25Db21wbGV0ZWQodGlja3MpXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWplY3RlZCBwcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlYXNvbiBhbmQgdGlja3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGlja3MgVGhlIGFic29sdXRlIHRpbWUgb2YgdGhlIHJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IHJlYXNvbiBUaGUgcmVhc29uIGZvciByZWplY3Rpb24gdG8geWllbGQgYXQgdGhlIGdpdmVuIHRpY2suXG4gICAgICogQHJldHVybnMge01vY2tQcm9taXNlfSBBIG1vY2sgUHJvbWlzZSB3aGljaCByZWplY3RzIHdpdGggdGhlIGdpdmVuIHJlYXNvbi5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVSZWplY3RlZFByb21pc2UgPSBmdW5jdGlvbiAodGlja3MsIHJlYXNvbikge1xuICAgICAgcmV0dXJuIG5ldyBNb2NrUHJvbWlzZSh0aGlzLCBbUnguUmVhY3RpdmVUZXN0Lm9uRXJyb3IodGlja3MsIHJlYXNvbildKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZlciB0aGF0IHJlY29yZHMgcmVjZWl2ZWQgbm90aWZpY2F0aW9uIG1lc3NhZ2VzIGFuZCB0aW1lc3RhbXBzIHRob3NlLlxuICAgICAqIEByZXR1cm4gT2JzZXJ2ZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHRpbWluZyBvZiByZWNlaXZlZCBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNb2NrT2JzZXJ2ZXIodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXN0U2NoZWR1bGVyO1xuICB9KShWaXJ0dWFsVGltZVNjaGVkdWxlcik7XG5cbiAgdmFyIEFub255bW91c09ic2VydmFibGUgPSBSeC5Bbm9ueW1vdXNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBbm9ueW1vdXNPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgLy8gRml4IHN1YnNjcmliZXIgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBvciBmdW5jdGlvbiByZXR1cm5lZCB0byBkZWNvcmF0ZSBhcyBEaXNwb3NhYmxlXG4gICAgZnVuY3Rpb24gZml4U3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlciAmJiBpc0Z1bmN0aW9uKHN1YnNjcmliZXIuZGlzcG9zZSkgPyBzdWJzY3JpYmVyIDpcbiAgICAgICAgaXNGdW5jdGlvbihzdWJzY3JpYmVyKSA/IGRpc3Bvc2FibGVDcmVhdGUoc3Vic2NyaWJlcikgOiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGlzcG9zYWJsZShzLCBzdGF0ZSkge1xuICAgICAgdmFyIGFkbyA9IHN0YXRlWzBdLCBzZWxmID0gc3RhdGVbMV07XG4gICAgICB2YXIgc3ViID0gdHJ5Q2F0Y2goc2VsZi5fX3N1YnNjcmliZSkuY2FsbChzZWxmLCBhZG8pO1xuICAgICAgaWYgKHN1YiA9PT0gZXJyb3JPYmogJiYgIWFkby5mYWlsKGVycm9yT2JqLmUpKSB7IHRocm93ZXIoZXJyb3JPYmouZSk7IH1cbiAgICAgIGFkby5zZXREaXNwb3NhYmxlKGZpeFN1YnNjcmliZXIoc3ViKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQW5vbnltb3VzT2JzZXJ2YWJsZShzdWJzY3JpYmUsIHBhcmVudCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBwYXJlbnQ7XG4gICAgICB0aGlzLl9fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQW5vbnltb3VzT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYWRvID0gbmV3IEF1dG9EZXRhY2hPYnNlcnZlcihvKSwgc3RhdGUgPSBbYWRvLCB0aGlzXTtcblxuICAgICAgaWYgKGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZXF1aXJlZCgpKSB7XG4gICAgICAgIGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNldERpc3Bvc2FibGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RGlzcG9zYWJsZShudWxsLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRvO1xuICAgIH07XG5cbiAgICByZXR1cm4gQW5vbnltb3VzT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGUpKTtcblxuICB2YXIgQXV0b0RldGFjaE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBdXRvRGV0YWNoT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBBdXRvRGV0YWNoT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5tID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgfVxuXG4gICAgdmFyIEF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZSA9IEF1dG9EZXRhY2hPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMub2JzZXJ2ZXIub25OZXh0KS5jYWxsKHRoaXMub2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB0aHJvd2VyKHJlc3VsdC5lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMub2JzZXJ2ZXIub25FcnJvcikuY2FsbCh0aGlzLm9ic2VydmVyLCBlcnIpO1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICByZXN1bHQgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzdWx0LmUpO1xuICAgIH07XG5cbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMub2JzZXJ2ZXIub25Db21wbGV0ZWQpLmNhbGwodGhpcy5vYnNlcnZlcik7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIHJlc3VsdCA9PT0gZXJyb3JPYmogJiYgdGhyb3dlcihyZXN1bHQuZSk7XG4gICAgfTtcblxuICAgIEF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZS5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMubS5zZXREaXNwb3NhYmxlKHZhbHVlKTsgfTtcbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuZ2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubS5nZXREaXNwb3NhYmxlKCk7IH07XG5cbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5tLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF1dG9EZXRhY2hPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIFVuZGVybHlpbmdPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhVbmRlcmx5aW5nT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBVbmRlcmx5aW5nT2JzZXJ2YWJsZShtLCB1KSB7XG4gICAgICB0aGlzLl9tID0gbTtcbiAgICAgIHRoaXMuX3UgPSB1O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVW5kZXJseWluZ09ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHRoaXMuX20uZ2V0RGlzcG9zYWJsZSgpLCB0aGlzLl91LnN1YnNjcmliZShvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBVbmRlcmx5aW5nT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBHcm91cGVkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoR3JvdXBlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gR3JvdXBlZE9ic2VydmFibGUoa2V5LCB1bmRlcmx5aW5nT2JzZXJ2YWJsZSwgbWVyZ2VkRGlzcG9zYWJsZSkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMudW5kZXJseWluZ09ic2VydmFibGUgPSAhbWVyZ2VkRGlzcG9zYWJsZSA/XG4gICAgICAgIHVuZGVybHlpbmdPYnNlcnZhYmxlIDpcbiAgICAgICAgbmV3IFVuZGVybHlpbmdPYnNlcnZhYmxlKG1lcmdlZERpc3Bvc2FibGUsIHVuZGVybHlpbmdPYnNlcnZhYmxlKTtcbiAgICB9XG5cbiAgICBHcm91cGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nT2JzZXJ2YWJsZS5zdWJzY3JpYmUobyk7XG4gICAgfTtcblxuICAgIHJldHVybiBHcm91cGVkT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqICBSZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGlzIGJvdGggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyB3ZWxsIGFzIGFuIG9ic2VydmVyLlxuICAgKiAgRWFjaCBub3RpZmljYXRpb24gaXMgYnJvYWRjYXN0ZWQgdG8gYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzLlxuICAgKi9cbiAgdmFyIFN1YmplY3QgPSBSeC5TdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdWJqZWN0LCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobykge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvKTtcbiAgICAgICAgICByZXR1cm4gbmV3IElubmVyU3Vic2NyaXB0aW9uKHRoaXMsIG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgby5vbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqL1xuICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7IGNoZWNrRGlzcG9zZWQodGhpcyk7IHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGggPiAwOyB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9zW2ldLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgYXJyaXZhbCBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb3NbaV0ub25OZXh0KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFVuc3Vic2NyaWJlIGFsbCBvYnNlcnZlcnMgYW5kIHJlbGVhc2UgcmVzb3VyY2VzLlxuICAgICAgICovXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdWJqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBvYnNlcnZlciBhbmQgb2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlciBUaGUgb2JzZXJ2ZXIgdXNlZCB0byBzZW5kIG1lc3NhZ2VzIHRvIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB1c2VkIHRvIHN1YnNjcmliZSB0byBtZXNzYWdlcyBzZW50IGZyb20gdGhlIHN1YmplY3QuXG4gICAgICogQHJldHVybnMge1N1YmplY3R9IFN1YmplY3QgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIGdpdmVuIG9ic2VydmVyIGFuZCBvYnNlcnZhYmxlLlxuICAgICAqL1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmVyLCBvYnNlcnZhYmxlKSB7XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3Qob2JzZXJ2ZXIsIG9ic2VydmFibGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3ViamVjdDtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqICBSZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi5cbiAgICogIFRoZSBsYXN0IHZhbHVlIGJlZm9yZSB0aGUgT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLCBvciB0aGUgZXJyb3IgcmVjZWl2ZWQgdGhyb3VnaCBPbkVycm9yLCBpcyBzZW50IHRvIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycy5cbiAgICovXG4gIHZhciBBc3luY1N1YmplY3QgPSBSeC5Bc3luY1N1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEFzeW5jU3ViamVjdCwgX19zdXBlcl9fKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdWJqZWN0IHRoYXQgY2FuIG9ubHkgcmVjZWl2ZSBvbmUgdmFsdWUgYW5kIHRoYXQgdmFsdWUgaXMgY2FjaGVkIGZvciBhbGwgZnV0dXJlIG9ic2VydmF0aW9ucy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1N1YmplY3QoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhBc3luY1N1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gobyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbm5lclN1YnNjcmlwdGlvbih0aGlzLCBvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgby5vbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICBvLm9uTmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKi9cbiAgICAgIGhhc09ic2VydmVyczogZnVuY3Rpb24gKCkgeyBjaGVja0Rpc3Bvc2VkKHRoaXMpOyByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDsgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBhbHNvIGNhdXNpbmcgdGhlIGxhc3QgcmVjZWl2ZWQgdmFsdWUgdG8gYmUgc2VudCBvdXQgKGlmIGFueSkuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBsZW47XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgdmFyIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSBvc1tpXTtcbiAgICAgICAgICAgICAgby5vbk5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIG9zW2ldLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBlcnJvci5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IGVycm9yIFRoZSBFcnJvciB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb3NbaV0ub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogU2VuZHMgYSB2YWx1ZSB0byB0aGUgc3ViamVjdC4gVGhlIGxhc3QgdmFsdWUgcmVjZWl2ZWQgYmVmb3JlIHN1Y2Nlc3NmdWwgdGVybWluYXRpb24gd2lsbCBiZSBzZW50IHRvIGFsbCBzdWJzY3JpYmVkIGFuZCBmdXR1cmUgb2JzZXJ2ZXJzLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoZSBzdWJqZWN0LlxuICAgICAgICovXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBBc3luY1N1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiAgUmVwcmVzZW50cyBhIHZhbHVlIHRoYXQgY2hhbmdlcyBvdmVyIHRpbWUuXG4gICAqICBPYnNlcnZlcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgc3ViamVjdCB0byByZWNlaXZlIHRoZSBsYXN0IChvciBpbml0aWFsKSB2YWx1ZSBhbmQgYWxsIHN1YnNlcXVlbnQgbm90aWZpY2F0aW9ucy5cbiAgICovXG4gIHZhciBCZWhhdmlvclN1YmplY3QgPSBSeC5CZWhhdmlvclN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEJlaGF2aW9yU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBCZWhhdmlvclN1YmplY3QodmFsdWUpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUsIE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gobyk7XG4gICAgICAgICAgby5vbk5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbm5lclN1YnNjcmlwdGlvbih0aGlzLCBvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIG8ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAqIFZhbHVlIGlzIGZyb3plbiBhZnRlciBvbkNvbXBsZXRlZCBpcyBjYWxsZWQuXG4gICAgICAgKiBBZnRlciBvbkVycm9yIGlzIGNhbGxlZCBhbHdheXMgdGhyb3dzIHRoZSBzcGVjaWZpZWQgZXhjZXB0aW9uLlxuICAgICAgICogQW4gZXhjZXB0aW9uIGlzIGFsd2F5cyB0aHJvd24gYWZ0ZXIgZGlzcG9zZSBpcyBjYWxsZWQuXG4gICAgICAgKiBAcmV0dXJucyB7TWl4ZWR9IFRoZSBpbml0aWFsIHZhbHVlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IgdW50aWwgb25OZXh0IGlzIGNhbGxlZDsgYWZ0ZXIgd2hpY2gsIHRoZSBsYXN0IHZhbHVlIHBhc3NlZCB0byBvbk5leHQuXG4gICAgICAgKi9cbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7IHRocm93ZXIodGhpcy5lcnJvcik7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqL1xuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIG9zW2ldLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBUaGUgZXhjZXB0aW9uIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIG9zW2ldLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgYXJyaXZhbCBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIG9zW2ldLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFVuc3Vic2NyaWJlIGFsbCBvYnNlcnZlcnMgYW5kIHJlbGVhc2UgcmVzb3VyY2VzLlxuICAgICAgICovXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEJlaGF2aW9yU3ViamVjdDtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IHRoYXQgaXMgYm90aCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFzIHdlbGwgYXMgYW4gb2JzZXJ2ZXIuXG4gICAqIEVhY2ggbm90aWZpY2F0aW9uIGlzIGJyb2FkY2FzdGVkIHRvIGFsbCBzdWJzY3JpYmVkIGFuZCBmdXR1cmUgb2JzZXJ2ZXJzLCBzdWJqZWN0IHRvIGJ1ZmZlciB0cmltbWluZyBwb2xpY2llcy5cbiAgICovXG4gIHZhciBSZXBsYXlTdWJqZWN0ID0gUnguUmVwbGF5U3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG5cbiAgICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVtb3ZhYmxlRGlzcG9zYWJsZShzdWJqZWN0LCBvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZlci5kaXNwb3NlKCk7XG4gICAgICAgICFzdWJqZWN0LmlzRGlzcG9zZWQgJiYgc3ViamVjdC5vYnNlcnZlcnMuc3BsaWNlKHN1YmplY3Qub2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFJlcGxheVN1YmplY3QsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiAgSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFJlcGxheVN1YmplY3QgY2xhc3Mgd2l0aCB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBzaXplLCB3aW5kb3cgc2l6ZSBhbmQgc2NoZWR1bGVyLlxuICAgICAqICBAcGFyYW0ge051bWJlcn0gW2J1ZmZlclNpemVdIE1heGltdW0gZWxlbWVudCBjb3VudCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dTaXplXSBNYXhpbXVtIHRpbWUgbGVuZ3RoIG9mIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgICAqICBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRoZSBvYnNlcnZlcnMgYXJlIGludm9rZWQgb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemUgPT0gbnVsbCA/IG1heFNhZmVJbnRlZ2VyIDogYnVmZmVyU2l6ZTtcbiAgICAgIHRoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemUgPT0gbnVsbCA/IG1heFNhZmVJbnRlZ2VyIDogd2luZG93U2l6ZTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyIHx8IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXI7XG4gICAgICB0aGlzLnEgPSBbXTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoUmVwbGF5U3ViamVjdC5wcm90b3R5cGUsIE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgdmFyIHNvID0gbmV3IFNjaGVkdWxlZE9ic2VydmVyKHRoaXMuc2NoZWR1bGVyLCBvKSwgc3Vic2NyaXB0aW9uID0gY3JlYXRlUmVtb3ZhYmxlRGlzcG9zYWJsZSh0aGlzLCBzbyk7XG5cbiAgICAgICAgdGhpcy5fdHJpbSh0aGlzLnNjaGVkdWxlci5ub3coKSk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc28pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzby5vbk5leHQodGhpcy5xW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgc28ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHNvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzby5lbnN1cmVBY3RpdmUoKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKi9cbiAgICAgIGhhc09ic2VydmVyczogZnVuY3Rpb24gKCkgeyBjaGVja0Rpc3Bvc2VkKHRoaXMpOyByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDsgfSxcbiAgICAgIF90cmltOiBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnEubGVuZ3RoID4gdGhpcy5idWZmZXJTaXplKSB7XG4gICAgICAgICAgdGhpcy5xLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMucS5sZW5ndGggPiAwICYmIChub3cgLSB0aGlzLnFbMF0uaW50ZXJ2YWwpID4gdGhpcy53aW5kb3dTaXplKSB7XG4gICAgICAgICAgdGhpcy5xLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgYXJyaXZhbCBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHRoaXMucS5wdXNoKHsgaW50ZXJ2YWw6IG5vdywgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB0aGlzLl90cmltKG5vdyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gb3NbaV07XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcbiAgICAgICAgICBvYnNlcnZlci5lbnN1cmVBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBUaGUgZXhjZXB0aW9uIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gb3NbaV07XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgb2JzZXJ2ZXIuZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqL1xuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLnNjaGVkdWxlci5ub3coKTtcbiAgICAgICAgdGhpcy5fdHJpbShub3cpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBvc1tpXTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIG9ic2VydmVyLmVuc3VyZUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVwbGF5U3ViamVjdDtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIEFub255bW91c1N1YmplY3QgPSBSeC5Bbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBbm9ueW1vdXNTdWJqZWN0LCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3Qob2JzZXJ2ZXIsIG9ic2VydmFibGUpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKEFub255bW91c1N1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUuc3Vic2NyaWJlKG8pO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICAgIH0sXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICogVXNlZCB0byBwYXVzZSBhbmQgcmVzdW1lIHN0cmVhbXMuXG4gICovXG4gIFJ4LlBhdXNlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUGF1c2VyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhdXNlcigpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBQYXVzZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLm9uTmV4dChmYWxzZSk7IH07XG5cbiAgICAvKipcbiAgICAqIFJlc3VtZXMgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAgKi9cbiAgICBQYXVzZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5vbk5leHQodHJ1ZSk7IH07XG5cbiAgICByZXR1cm4gUGF1c2VyO1xuICB9KFN1YmplY3QpKTtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICByb290LlJ4ID0gUng7XG5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUng7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gUngpLlJ4ID0gUng7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLlJ4ID0gUng7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHJvb3QuUnggPSBSeDtcbiAgfVxuXG4gIC8vIEFsbCBjb2RlIGJlZm9yZSB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMuXG4gIHZhciByRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbn0uY2FsbCh0aGlzKSk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVycyAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCk7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwICsgMSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGZvciBlYWNoIGJ1ZmZlcmVkIGJ5dGUgb2YgYSAocGFydGlhbClcbi8vIGNoYXJhY3RlciBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgb3V0cHV0LlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCcucmVwZWF0KHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsImZ1bmN0aW9uIEFnZW50KCkge1xuICB0aGlzLl9kZWZhdWx0cyA9IFtdO1xufVxuXG5bXCJ1c2VcIiwgXCJvblwiLCBcIm9uY2VcIiwgXCJzZXRcIiwgXCJxdWVyeVwiLCBcInR5cGVcIiwgXCJhY2NlcHRcIiwgXCJhdXRoXCIsIFwid2l0aENyZWRlbnRpYWxzXCIsIFwic29ydFF1ZXJ5XCIsIFwicmV0cnlcIiwgXCJva1wiLCBcInJlZGlyZWN0c1wiLFxuIFwidGltZW91dFwiLCBcImJ1ZmZlclwiLCBcInNlcmlhbGl6ZVwiLCBcInBhcnNlXCIsIFwiY2FcIiwgXCJrZXlcIiwgXCJwZnhcIiwgXCJjZXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgLyoqIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudCAqL1xuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24oLyp2YXJhcmdzKi8pIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbjpmbiwgYXJndW1lbnRzOmFyZ3VtZW50c30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICByZXFbZGVmLmZuXS5hcHBseShyZXEsIGRlZi5hcmd1bWVudHMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxudmFyIHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBSZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xudmFyIFJlc3BvbnNlQmFzZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UtYmFzZScpO1xudmFyIEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudC1iYXNlJyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbnZhciByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn1cblxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICAgJiYgKCFyb290LmxvY2F0aW9uIHx8ICdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbFxuICAgICAgICAgIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgfSBlbHNlIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICB9XG4gIHRocm93IEVycm9yKFwiQnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBjb3VsZCBub3QgZmluZCBYSFJcIik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHRyaW0gPSAnJy50cmltXG4gID8gZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH1cbiAgOiBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpOyB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgb2JqW2tleV0pO1xuICB9XG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogSGVscHMgJ3NlcmlhbGl6ZScgd2l0aCBzZXJpYWxpemluZyBhcnJheXMuXG4gKiBNdXRhdGVzIHRoZSBwYWlycyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKi9cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGZvcih2YXIgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5ICsgJ1snICsgc3Via2V5ICsgJ10nLCB2YWxbc3Via2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAocG9zID09IC0xKSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIpXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UoMCwgcG9zKSldID1cbiAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5yZXF1ZXN0LnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5cbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICd0ZXh0L3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXJpYWxpemF0aW9uIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcbiAqICAgICAgIHJldHVybiAnZ2VuZXJhdGVkIHhtbCBoZXJlJztcbiAqICAgICB9O1xuICpcbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHNlcmlhbGl6ZSxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnN0cmluZ2lmeSxcbn07XG5cbi8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlLFxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgeyAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdmFyIHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgc3RhdHVzID0gMjA0O1xuICB9XG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAobnVsbCA9PT0gdGhpcy50ZXh0ICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuUmVzcG9uc2VCYXNlKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3BhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgdmFyIG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbmNvZGVyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcblxuLyoqXG4gKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4gKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiAqICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIG9wdGlvbnMpe1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblJlcXVlc3QucHJvdG90eXBlLmJ1ZmZlciA9IFJlcXVlc3QucHJvdG90eXBlLmNhID0gUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGhpcyB0aHJvd3MsIGJlY2F1c2UgaXQgY2FuJ3Qgc2VuZC9yZWNlaXZlIGRhdGEgYXMgZXhwZWN0ZWRcblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKCl7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIik7XG4gIH1cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gKHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKSk7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID49IDIgJiYgc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIGlmICg0ICE9IHJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoIXN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQgfHwgc2VsZi5fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cbiAgICBlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ2Rvd25sb2FkJyk7XG4gICAgICBpZiAoeGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB0cnkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBzZWUgIzExNDlcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICghdGhpcy5fZm9ybURhdGEgJiYgJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5yZXF1ZXN0LmFnZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQWdlbnQoKTtcbn07XG5cbltcIkdFVFwiLCBcIlBPU1RcIiwgXCJPUFRJT05TXCIsIFwiUEFUQ0hcIiwgXCJQVVRcIiwgXCJERUxFVEVcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgZm4pIHtcbiAgICB2YXIgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG51bGwgIT09IG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0QmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0QmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHN3aXRjaChvcHRpb24pIHtcbiAgICAgIGNhc2UgJ2RlYWRsaW5lJzpcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMuZGVhZGxpbmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gdGltZW91dCBvcHRpb25cIiwgb3B0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIHJldHJ5KGNvdW50LCBmbil7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIEVSUk9SX0NPREVTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUFERFJJTkZPJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCdcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChCb3Jyb3dlZCBmcm9tIHNlZ21lbnRpby9zdXBlcmFnZW50LXJldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXNcIik7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkge1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3RcbiAqIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCh7IGZvbzogJ2JhcicsIGJhejogJ3F1eCcgfSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobnVsbCA9PT0gbmFtZSB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICB0aGlzLmZpZWxkKG5hbWUsIHZhbFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWwpIHtcbiAgICB2YWwgPSAnJyArIHZhbDtcbiAgfVxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIGJhc2U2NEVuY29kZXIodXNlciArICc6JyArIHBhc3MpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB1c2VyKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24ob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXhpbXVtIHNpemUgb2YgYnVmZmVyZWQgcmVzcG9uc2UgYm9keSwgaW4gYnl0ZXMuIENvdW50cyB1bmNvbXByZXNzZWQgc2l6ZS5cbiAqIERlZmF1bHQgMjAwTUIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24obil7XG4gIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIG4pIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICB9XG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXIsXG4gIH07XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbihzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBxdWVyeUFyciA9IHRoaXMudXJsLnN1YnN0cmluZyhpbmRleCArIDEpLnNwbGl0KCcmJyk7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX3NvcnQpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpIHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihyZWFzb24gKyB0aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIHZhciBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgdGhpcy50eXBlID0gdXRpbHMudHlwZShjdCk7XG5cbiAgICAvLyBwYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgICAvLyBzdGF0dXMgLyBjbGFzc1xuICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgICAvLyBiYXNpY3NcbiAgICB0aGlzLmluZm8gPSAxID09IHR5cGU7XG4gICAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgICB0aGlzLnJlZGlyZWN0ID0gMyA9PSB0eXBlO1xuICAgIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XG4gICAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgICAgID8gdGhpcy50b0Vycm9yKClcbiAgICAgICAgOiBmYWxzZTtcblxuICAgIC8vIHN1Z2FyXG4gICAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub0NvbnRlbnQgPSAyMDQgPT0gc3RhdHVzO1xuICAgIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90QWNjZXB0YWJsZSA9IDQwNiA9PSBzdGF0dXM7XG4gICAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyYW1zID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICB2YXIgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlTGlua3MgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZShmdW5jdGlvbihvYmosIHN0cil7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKjsgKi8pO1xuICAgIHZhciB1cmwgPSBwYXJ0c1swXS5zbGljZSgxLCAtMSk7XG4gICAgdmFyIHJlbCA9IHBhcnRzWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsIC0xKTtcbiAgICBvYmpbcmVsXSA9IHVybDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlciwgY2hhbmdlc09yaWdpbil7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyWydob3N0J107XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnYXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2Nvb2tpZSddO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiLyohXG4gKiB3YXZlc3VyZmVyLmpzIDIuMS4wIChNb24gT2N0IDAxIDIwMTggMTE6MzQ6NTQgR01UKzAyMDAgKENlbnRyYWwgRXVyb3BlYW4gU3VtbWVyIFRpbWUpKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2thdHNwYXVnaC93YXZlc3VyZmVyLmpzXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcbiAqL1xuIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJyZWdpb25zXCIsW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5yZWdpb25zPXQoKTooZS5XYXZlU3VyZmVyPWUuV2F2ZVN1cmZlcnx8e30sZS5XYXZlU3VyZmVyLnJlZ2lvbnM9dCgpKX0od2luZG93LGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3ZhciBuPXt9O2Z1bmN0aW9uIGkoZSl7aWYobltlXSlyZXR1cm4gbltlXS5leHBvcnRzO3ZhciB0PW5bZV09e2k6ZSxsOiExLGV4cG9ydHM6e319O3JldHVybiByW2VdLmNhbGwodC5leHBvcnRzLHQsdC5leHBvcnRzLGkpLHQubD0hMCx0LmV4cG9ydHN9cmV0dXJuIGkubT1yLGkuYz1uLGkuZD1mdW5jdGlvbihlLHQscil7aS5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0saS5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGkudD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9aSh0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGkucihyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIG4gaW4gdClpLmQocixuLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsbikpO3JldHVybiByfSxpLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIGkuZCh0LFwiYVwiLHQpLHR9LGkubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0saS5wPVwibG9jYWxob3N0OjgwODAvZGlzdC9wbHVnaW4vXCIsaShpLnM9Mil9KHsyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBuKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBzKGUsdCxyKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxyJiZuKGUsciksZX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihlLHQpe3ZhciByPXRoaXM7aSh0aGlzLG4pLHRoaXMud2F2ZXN1cmZlcj10LHRoaXMud3JhcHBlcj10LmRyYXdlci53cmFwcGVyLHRoaXMudXRpbD10LnV0aWwsdGhpcy5zdHlsZT10aGlzLnV0aWwuc3R5bGUsdGhpcy5pZD1udWxsPT1lLmlkP3QudXRpbC5nZXRJZCgpOmUuaWQsdGhpcy5zdGFydD1OdW1iZXIoZS5zdGFydCl8fDAsdGhpcy5lbmQ9bnVsbD09ZS5lbmQ/dGhpcy5zdGFydCs0L3RoaXMud3JhcHBlci5zY3JvbGxXaWR0aCp0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTpOdW1iZXIoZS5lbmQpLHRoaXMucmVzaXplPXZvaWQgMD09PWUucmVzaXplfHxCb29sZWFuKGUucmVzaXplKSx0aGlzLmRyYWc9dm9pZCAwPT09ZS5kcmFnfHxCb29sZWFuKGUuZHJhZyksdGhpcy5sb29wPUJvb2xlYW4oZS5sb29wKSx0aGlzLmNvbG9yPWUuY29sb3J8fFwicmdiYSgwLCAwLCAwLCAwLjEpXCIsdGhpcy5kYXRhPWUuZGF0YXx8e30sdGhpcy5hdHRyaWJ1dGVzPWUuYXR0cmlidXRlc3x8e30sdGhpcy5tYXhMZW5ndGg9ZS5tYXhMZW5ndGgsdGhpcy5taW5MZW5ndGg9ZS5taW5MZW5ndGgsdGhpcy5fb25SZWRyYXc9ZnVuY3Rpb24oKXtyZXR1cm4gci51cGRhdGVSZW5kZXIoKX0sdGhpcy5zY3JvbGw9ITEhPT1lLnNjcm9sbCYmdC5wYXJhbXMuc2Nyb2xsUGFyZW50LHRoaXMuc2Nyb2xsU3BlZWQ9ZS5zY3JvbGxTcGVlZHx8MSx0aGlzLnNjcm9sbFRocmVzaG9sZD1lLnNjcm9sbFRocmVzaG9sZHx8MTAsdGhpcy5iaW5kSW5PdXQoKSx0aGlzLnJlbmRlcigpLHRoaXMud2F2ZXN1cmZlci5vbihcInpvb21cIix0aGlzLl9vblJlZHJhdyksdGhpcy53YXZlc3VyZmVyLm9uKFwicmVkcmF3XCIsdGhpcy5fb25SZWRyYXcpLHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoXCJyZWdpb24tY3JlYXRlZFwiLHRoaXMpfXJldHVybiBzKG4sW3trZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXtudWxsIT1lLnN0YXJ0JiYodGhpcy5zdGFydD1OdW1iZXIoZS5zdGFydCkpLG51bGwhPWUuZW5kJiYodGhpcy5lbmQ9TnVtYmVyKGUuZW5kKSksbnVsbCE9ZS5sb29wJiYodGhpcy5sb29wPUJvb2xlYW4oZS5sb29wKSksbnVsbCE9ZS5jb2xvciYmKHRoaXMuY29sb3I9ZS5jb2xvciksbnVsbCE9ZS5kYXRhJiYodGhpcy5kYXRhPWUuZGF0YSksbnVsbCE9ZS5yZXNpemUmJih0aGlzLnJlc2l6ZT1Cb29sZWFuKGUucmVzaXplKSksbnVsbCE9ZS5kcmFnJiYodGhpcy5kcmFnPUJvb2xlYW4oZS5kcmFnKSksbnVsbCE9ZS5tYXhMZW5ndGgmJih0aGlzLm1heExlbmd0aD1OdW1iZXIoZS5tYXhMZW5ndGgpKSxudWxsIT1lLm1pbkxlbmd0aCYmKHRoaXMubWluTGVuZ3RoPU51bWJlcihlLm1pbkxlbmd0aCkpLG51bGwhPWUuYXR0cmlidXRlcyYmKHRoaXMuYXR0cmlidXRlcz1lLmF0dHJpYnV0ZXMpLHRoaXMudXBkYXRlUmVuZGVyKCksdGhpcy5maXJlRXZlbnQoXCJ1cGRhdGVcIiksdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudChcInJlZ2lvbi11cGRhdGVkXCIsdGhpcyl9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQmJih0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KSx0aGlzLmVsZW1lbnQ9bnVsbCx0aGlzLmZpcmVFdmVudChcInJlbW92ZVwiKSx0aGlzLndhdmVzdXJmZXIudW4oXCJ6b29tXCIsdGhpcy5fb25SZWRyYXcpLHRoaXMud2F2ZXN1cmZlci51bihcInJlZHJhd1wiLHRoaXMuX29uUmVkcmF3KSx0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KFwicmVnaW9uLXJlbW92ZWRcIix0aGlzKSl9fSx7a2V5OlwicGxheVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53YXZlc3VyZmVyLnBsYXkodGhpcy5zdGFydCx0aGlzLmVuZCksdGhpcy5maXJlRXZlbnQoXCJwbGF5XCIpLHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoXCJyZWdpb24tcGxheVwiLHRoaXMpfX0se2tleTpcInBsYXlMb29wXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGxheSgpLHRoaXMub25jZShcIm91dFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGUucGxheUxvb3AoKX0pfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInJlZ2lvblwiKTtmb3IodmFyIHQgaW4gZS5jbGFzc05hbWU9XCJ3YXZlc3VyZmVyLXJlZ2lvblwiLGUudGl0bGU9dGhpcy5mb3JtYXRUaW1lKHRoaXMuc3RhcnQsdGhpcy5lbmQpLGUuc2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiLHRoaXMuaWQpLHRoaXMuYXR0cmlidXRlcyllLnNldEF0dHJpYnV0ZShcImRhdGEtcmVnaW9uLVwiK3QsdGhpcy5hdHRyaWJ1dGVzW3RdKTt0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGg7aWYodGhpcy5zdHlsZShlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsekluZGV4OjIsaGVpZ2h0OlwiMTAwJVwiLHRvcDpcIjBweFwifSksdGhpcy5yZXNpemUpe3ZhciByPWUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImhhbmRsZVwiKSksbj1lLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoYW5kbGVcIikpO3IuY2xhc3NOYW1lPVwid2F2ZXN1cmZlci1oYW5kbGUgd2F2ZXN1cmZlci1oYW5kbGUtc3RhcnRcIixuLmNsYXNzTmFtZT1cIndhdmVzdXJmZXItaGFuZGxlIHdhdmVzdXJmZXItaGFuZGxlLWVuZFwiO3ZhciBpPXtjdXJzb3I6XCJjb2wtcmVzaXplXCIscG9zaXRpb246XCJhYnNvbHV0ZVwiLGxlZnQ6XCIwcHhcIix0b3A6XCIwcHhcIix3aWR0aDpcIjElXCIsbWF4V2lkdGg6XCI0cHhcIixoZWlnaHQ6XCIxMDAlXCJ9O3RoaXMuc3R5bGUocixpKSx0aGlzLnN0eWxlKG4saSksdGhpcy5zdHlsZShuLHtsZWZ0OlwiMTAwJVwifSl9dGhpcy5lbGVtZW50PXRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChlKSx0aGlzLnVwZGF0ZVJlbmRlcigpLHRoaXMuYmluZEV2ZW50cyhlKX19LHtrZXk6XCJmb3JtYXRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4oZT09dD9bZV06W2UsdF0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm5bTWF0aC5mbG9vcihlJTM2MDAvNjApLChcIjAwXCIrTWF0aC5mbG9vcihlJTYwKSkuc2xpY2UoLTIpXS5qb2luKFwiOlwiKX0pLmpvaW4oXCItXCIpfX0se2tleTpcImdldFdpZHRoXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YXZlc3VyZmVyLmRyYXdlci53aWR0aC90aGlzLndhdmVzdXJmZXIucGFyYW1zLnBpeGVsUmF0aW99fSx7a2V5OlwidXBkYXRlUmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKSx0PXRoaXMuZ2V0V2lkdGgoKTtpZih0aGlzLnN0YXJ0PDAmJih0aGlzLnN0YXJ0PTAsdGhpcy5lbmQ9dGhpcy5lbmQtdGhpcy5zdGFydCksdGhpcy5lbmQ+ZSYmKHRoaXMuZW5kPWUsdGhpcy5zdGFydD1lLSh0aGlzLmVuZC10aGlzLnN0YXJ0KSksbnVsbCE9dGhpcy5taW5MZW5ndGgmJih0aGlzLmVuZD1NYXRoLm1heCh0aGlzLnN0YXJ0K3RoaXMubWluTGVuZ3RoLHRoaXMuZW5kKSksbnVsbCE9dGhpcy5tYXhMZW5ndGgmJih0aGlzLmVuZD1NYXRoLm1pbih0aGlzLnN0YXJ0K3RoaXMubWF4TGVuZ3RoLHRoaXMuZW5kKSksbnVsbCE9dGhpcy5lbGVtZW50KXt2YXIgcj1NYXRoLnJvdW5kKHRoaXMuc3RhcnQvZSp0KSxuPU1hdGgucm91bmQodGhpcy5lbmQvZSp0KS1yO2Zvcih2YXIgaSBpbiB0aGlzLnN0eWxlKHRoaXMuZWxlbWVudCx7bGVmdDpyK1wicHhcIix3aWR0aDpuK1wicHhcIixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5jb2xvcixjdXJzb3I6dGhpcy5kcmFnP1wibW92ZVwiOlwiZGVmYXVsdFwifSksdGhpcy5hdHRyaWJ1dGVzKXRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlZ2lvbi1cIitpLHRoaXMuYXR0cmlidXRlc1tpXSk7dGhpcy5lbGVtZW50LnRpdGxlPXRoaXMuZm9ybWF0VGltZSh0aGlzLnN0YXJ0LHRoaXMuZW5kKX19fSx7a2V5OlwiYmluZEluT3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuZmlyZWRJbj0hMSx0aGlzLmZpcmVkT3V0PSExO3ZhciBlPWZ1bmN0aW9uKGUpeyF0LmZpcmVkT3V0JiZ0LmZpcmVkSW4mJih0LnN0YXJ0Pj1NYXRoLnJvdW5kKDEwMCplKS8xMDB8fHQuZW5kPD1NYXRoLnJvdW5kKDEwMCplKS8xMDApJiYodC5maXJlZE91dD0hMCx0LmZpcmVkSW49ITEsdC5maXJlRXZlbnQoXCJvdXRcIiksdC53YXZlc3VyZmVyLmZpcmVFdmVudChcInJlZ2lvbi1vdXRcIix0KSksIXQuZmlyZWRJbiYmdC5zdGFydDw9ZSYmdC5lbmQ+ZSYmKHQuZmlyZWRJbj0hMCx0LmZpcmVkT3V0PSExLHQuZmlyZUV2ZW50KFwiaW5cIiksdC53YXZlc3VyZmVyLmZpcmVFdmVudChcInJlZ2lvbi1pblwiLHQpKX07dGhpcy53YXZlc3VyZmVyLmJhY2tlbmQub24oXCJhdWRpb3Byb2Nlc3NcIixlKSx0aGlzLm9uKFwicmVtb3ZlXCIsZnVuY3Rpb24oKXt0LndhdmVzdXJmZXIuYmFja2VuZC51bihcImF1ZGlvcHJvY2Vzc1wiLGUpfSksdGhpcy5vbihcIm91dFwiLGZ1bmN0aW9uKCl7dC5sb29wJiZ0LndhdmVzdXJmZXIucGxheSh0LnN0YXJ0KX0pfX0se2tleTpcImJpbmRFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBvLHUsbCxkLGgsYyxmLHYscCxtLGcsdyxlLHQscix5PXRoaXM7dGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsZnVuY3Rpb24oZSl7eS5maXJlRXZlbnQoXCJtb3VzZWVudGVyXCIsZSkseS53YXZlc3VyZmVyLmZpcmVFdmVudChcInJlZ2lvbi1tb3VzZWVudGVyXCIseSxlKX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLGZ1bmN0aW9uKGUpe3kuZmlyZUV2ZW50KFwibW91c2VsZWF2ZVwiLGUpLHkud2F2ZXN1cmZlci5maXJlRXZlbnQoXCJyZWdpb24tbW91c2VsZWF2ZVwiLHksZSl9KSx0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHkuZmlyZUV2ZW50KFwiY2xpY2tcIixlKSx5LndhdmVzdXJmZXIuZmlyZUV2ZW50KFwicmVnaW9uLWNsaWNrXCIseSxlKX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIixmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx5LmZpcmVFdmVudChcImRibGNsaWNrXCIsZSkseS53YXZlc3VyZmVyLmZpcmVFdmVudChcInJlZ2lvbi1kYmxjbGlja1wiLHksZSl9KSwodGhpcy5kcmFnfHx0aGlzLnJlc2l6ZSkmJih2PXkud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyLHA9eS53YXZlc3VyZmVyLmdldER1cmF0aW9uKCksbT15LnNjcm9sbFNwZWVkLGc9eS5zY3JvbGxUaHJlc2hvbGQsdz0hMSxlPWZ1bmN0aW9uKGUpe2UudG91Y2hlcyYmMTxlLnRvdWNoZXMubGVuZ3RofHwodT1lLnRhcmdldFRvdWNoZXM/ZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXI6bnVsbCxlLnN0b3BQcm9wYWdhdGlvbigpLG89eS53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCEwKSpwLGQ9eS53cmFwcGVyLnNjcm9sbFdpZHRoLXkud3JhcHBlci5jbGllbnRXaWR0aCxmPXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxoPVwiaGFuZGxlXCI9PWUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKT9lLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJ3YXZlc3VyZmVyLWhhbmRsZS1zdGFydFwiKT9cInN0YXJ0XCI6XCJlbmRcIjohKGw9ITApKX0sdD1mdW5jdGlvbihlKXtlLnRvdWNoZXMmJjE8ZS50b3VjaGVzLmxlbmd0aHx8KChsfHxoKSYmKGM9bnVsbCxoPWw9ITEpLHcmJih3PSExLHkudXRpbC5wcmV2ZW50Q2xpY2soKSx5LmZpcmVFdmVudChcInVwZGF0ZS1lbmRcIixlKSx5LndhdmVzdXJmZXIuZmlyZUV2ZW50KFwicmVnaW9uLXVwZGF0ZS1lbmRcIix5LGUpKSl9LHI9ZnVuY3Rpb24oZSl7aWYoIShlLnRvdWNoZXMmJjE8ZS50b3VjaGVzLmxlbmd0aCkmJighZS50YXJnZXRUb3VjaGVzfHxlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllcj09dSkmJihsfHxoKSl7dmFyIHQ9byxyPXkud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZSkqcCxuPXItbztpZihvPXIseS5kcmFnJiZsJiYodz13fHwhIW4seS5vbkRyYWcobikpLHkucmVzaXplJiZoJiYodz13fHwhIW4seS5vblJlc2l6ZShuLGgpKSx5LnNjcm9sbCYmdi5jbGllbnRXaWR0aDx5LndyYXBwZXIuc2Nyb2xsV2lkdGgpe2lmKGwpe3ZhciBpPXkuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxzPWkubGVmdC1mLmxlZnQ7cjx0JiYwPD1zP2M9LTE6dDxyJiZzK2kud2lkdGg8PWYucmlnaHQmJihjPTEpLCgtMT09PWMmJmc8c3x8MT09PWMmJnMraS53aWR0aDxmLnJpZ2h0LWcpJiYoYz1udWxsKX1lbHNle3ZhciBhPWUuY2xpZW50WC1mLmxlZnQ7Yz1hPD1nPy0xOmE+PWYucmlnaHQtZz8xOm51bGx9YyYmZnVuY3Rpb24gZSh0KXtpZihjJiYobHx8aCkpe3ZhciByPXkud3JhcHBlci5zY3JvbGxMZWZ0K20qYzt5LndyYXBwZXIuc2Nyb2xsTGVmdD1yPU1hdGgubWluKGQsTWF0aC5tYXgoMCxyKSk7dmFyIG49eS53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudCh0KSpwLGk9bi1vO289bixsP3kub25EcmFnKGkpOnkub25SZXNpemUoaSxoKSx3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7ZSh0KX0pfX0oZSl9fX0seS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixlKSx5LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixlKSx5LndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHIpLHkud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsciksZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHQpLGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdCkseS5vbihcInJlbW92ZVwiLGZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHQpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdCkseS53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixyKSx5LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHIpfSkseS53YXZlc3VyZmVyLm9uKFwiZGVzdHJveVwiLGZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHQpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdCl9KSl9fSx7a2V5Olwib25EcmFnXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7dGhpcy5lbmQrZT50fHx0aGlzLnN0YXJ0K2U8MHx8dGhpcy51cGRhdGUoe3N0YXJ0OnRoaXMuc3RhcnQrZSxlbmQ6dGhpcy5lbmQrZX0pfX0se2tleTpcIm9uUmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtcInN0YXJ0XCI9PXQ/dGhpcy51cGRhdGUoe3N0YXJ0Ok1hdGgubWluKHRoaXMuc3RhcnQrZSx0aGlzLmVuZCksZW5kOk1hdGgubWF4KHRoaXMuc3RhcnQrZSx0aGlzLmVuZCl9KTp0aGlzLnVwZGF0ZSh7c3RhcnQ6TWF0aC5taW4odGhpcy5lbmQrZSx0aGlzLnN0YXJ0KSxlbmQ6TWF0aC5tYXgodGhpcy5lbmQrZSx0aGlzLnN0YXJ0KX0pfX1dKSxufSgpLG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKGUsdCl7dmFyIHI9dGhpcztpKHRoaXMsbiksdGhpcy5wYXJhbXM9ZSx0aGlzLndhdmVzdXJmZXI9dCx0aGlzLnV0aWw9dC51dGlsLE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMudXRpbC5PYnNlcnZlci5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24oZSl7YS5wcm90b3R5cGVbZV09ci51dGlsLk9ic2VydmVyLnByb3RvdHlwZVtlXX0pLHRoaXMud2F2ZXN1cmZlci5SZWdpb249YSx0aGlzLmxpc3Q9e30sdGhpcy5fb25SZWFkeT1mdW5jdGlvbigpe3Iud3JhcHBlcj1yLndhdmVzdXJmZXIuZHJhd2VyLndyYXBwZXIsci5wYXJhbXMucmVnaW9ucyYmci5wYXJhbXMucmVnaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IuYWRkKGUpfSksci5wYXJhbXMuZHJhZ1NlbGVjdGlvbiYmci5lbmFibGVEcmFnU2VsZWN0aW9uKHIucGFyYW1zKX19cmV0dXJuIHMobixudWxsLFt7a2V5OlwiY3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6XCJyZWdpb25zXCIsZGVmZXJJbml0OiEoIWV8fCFlLmRlZmVySW5pdCkmJmUuZGVmZXJJbml0LHBhcmFtczplLHN0YXRpY1Byb3BzOntpbml0UmVnaW9uczpmdW5jdGlvbigpe2NvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbml0UmVnaW9ucyEgVXNlIHdhdmVzdXJmZXIuaW5pdFBsdWdpbnMoXCJyZWdpb25zXCIpIGluc3RlYWQhJyksdGhpcy5pbml0UGx1Z2luKFwicmVnaW9uc1wiKX0sYWRkUmVnaW9uOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdC5yZWdpb25zfHx0aGlzLmluaXRQbHVnaW4oXCJyZWdpb25zXCIpLHRoaXMucmVnaW9ucy5hZGQoZSl9LGNsZWFyUmVnaW9uczpmdW5jdGlvbigpe3RoaXMucmVnaW9ucyYmdGhpcy5yZWdpb25zLmNsZWFyKCl9LGVuYWJsZURyYWdTZWxlY3Rpb246ZnVuY3Rpb24oZSl7dGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QucmVnaW9uc3x8dGhpcy5pbml0UGx1Z2luKFwicmVnaW9uc1wiKSx0aGlzLnJlZ2lvbnMuZW5hYmxlRHJhZ1NlbGVjdGlvbihlKX0sZGlzYWJsZURyYWdTZWxlY3Rpb246ZnVuY3Rpb24oKXt0aGlzLnJlZ2lvbnMuZGlzYWJsZURyYWdTZWxlY3Rpb24oKX19LGluc3RhbmNlOm59fX1dKSxzKG4sW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLndhdmVzdXJmZXIuaXNSZWFkeSYmdGhpcy5fb25SZWFkeSgpLHRoaXMud2F2ZXN1cmZlci5vbihcInJlYWR5XCIsdGhpcy5fb25SZWFkeSl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53YXZlc3VyZmVyLnVuKFwicmVhZHlcIix0aGlzLl9vblJlYWR5KSx0aGlzLmRpc2FibGVEcmFnU2VsZWN0aW9uKCksdGhpcy5jbGVhcigpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj1uZXcgdGhpcy53YXZlc3VyZmVyLlJlZ2lvbihlLHRoaXMud2F2ZXN1cmZlcik7cmV0dXJuKHRoaXMubGlzdFtyLmlkXT1yKS5vbihcInJlbW92ZVwiLGZ1bmN0aW9uKCl7ZGVsZXRlIHQubGlzdFtyLmlkXX0pLHJ9fSx7a2V5OlwiY2xlYXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7T2JqZWN0LmtleXModGhpcy5saXN0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QubGlzdFtlXS5yZW1vdmUoKX0pfX0se2tleTpcImVuYWJsZURyYWdTZWxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihuKXt2YXIgaSxzLGEsbyx1LGwsZCxoPXRoaXMsYz1uLnNsb3B8fDIsZj10aGlzLndhdmVzdXJmZXIuZHJhd2VyLmNvbnRhaW5lcix2PSExIT09bi5zY3JvbGwmJnRoaXMud2F2ZXN1cmZlci5wYXJhbXMuc2Nyb2xsUGFyZW50LHA9bi5zY3JvbGxTcGVlZHx8MSxtPW4uc2Nyb2xsVGhyZXNob2xkfHwxMCxnPXRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpLHc9MCxlPWZ1bmN0aW9uKGUpe2UudG91Y2hlcyYmMTxlLnRvdWNoZXMubGVuZ3RofHwoZz1oLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKSx1PWUudGFyZ2V0VG91Y2hlcz9lLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllcjpudWxsLHM9aC53cmFwcGVyLnNjcm9sbFdpZHRoLWgud3JhcHBlci5jbGllbnRXaWR0aCxkPWgud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxpPSEwLGE9aC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCEwKSxsPW89bnVsbCl9O3RoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZSksdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsZSksdGhpcy5vbihcImRpc2FibGUtZHJhZy1zZWxlY3Rpb25cIixmdW5jdGlvbigpe2gud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGUpLGgud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZSl9KTt2YXIgdD1mdW5jdGlvbihlKXtlLnRvdWNoZXMmJjE8ZS50b3VjaGVzLmxlbmd0aHx8KGk9ITEsdz0wLGw9bnVsbCxvJiYoaC51dGlsLnByZXZlbnRDbGljaygpLG8uZmlyZUV2ZW50KFwidXBkYXRlLWVuZFwiLGUpLGgud2F2ZXN1cmZlci5maXJlRXZlbnQoXCJyZWdpb24tdXBkYXRlLWVuZFwiLG8sZSkpLG89bnVsbCl9O3RoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHQpLHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0KSxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdCksZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0KSx0aGlzLm9uKFwiZGlzYWJsZS1kcmFnLXNlbGVjdGlvblwiLGZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHQpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdCksaC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHQpLGgud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHQpfSk7dmFyIHI9ZnVuY3Rpb24oZSl7aWYoaSYmISgrK3c8PWN8fGUudG91Y2hlcyYmMTxlLnRvdWNoZXMubGVuZ3RofHxlLnRhcmdldFRvdWNoZXMmJmUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyIT11KSl7b3x8KG89aC5hZGQobnx8e30pKTt2YXIgdD1oLndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUpO2lmKG8udXBkYXRlKHtzdGFydDpNYXRoLm1pbih0KmcsYSpnKSxlbmQ6TWF0aC5tYXgodCpnLGEqZyl9KSx2JiZmLmNsaWVudFdpZHRoPGgud3JhcHBlci5zY3JvbGxXaWR0aCl7dmFyIHI9ZS5jbGllbnRYLWQubGVmdDsobD1yPD1tPy0xOnI+PWQucmlnaHQtbT8xOm51bGwpJiZmdW5jdGlvbiBlKHQpe2lmKG8mJmwpe3ZhciByPWgud3JhcHBlci5zY3JvbGxMZWZ0K3AqbDtoLndyYXBwZXIuc2Nyb2xsTGVmdD1yPU1hdGgubWluKHMsTWF0aC5tYXgoMCxyKSk7dmFyIG49aC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudCh0KTtvLnVwZGF0ZSh7c3RhcnQ6TWF0aC5taW4obipnLGEqZyksZW5kOk1hdGgubWF4KG4qZyxhKmcpfSkscjxzJiYwPHImJndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtlKHQpfSl9fShlKX19fTt0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHIpLHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsciksdGhpcy5vbihcImRpc2FibGUtZHJhZy1zZWxlY3Rpb25cIixmdW5jdGlvbigpe2gud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsciksaC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixyKX0pfX0se2tleTpcImRpc2FibGVEcmFnU2VsZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZpcmVFdmVudChcImRpc2FibGUtZHJhZy1zZWxlY3Rpb25cIil9fSx7a2V5OlwiZ2V0Q3VycmVudFJlZ2lvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcyxuPXRoaXMud2F2ZXN1cmZlci5nZXRDdXJyZW50VGltZSgpLGk9bnVsbDtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5saXN0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXIubGlzdFtlXTt0LnN0YXJ0PD1uJiZ0LmVuZD49biYmKCFpfHx0LmVuZC10LnN0YXJ0PGkuZW5kLWkuc3RhcnQpJiYoaT10KX0pLGl9fV0pLG59KCk7dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH19KX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci5yZWdpb25zLm1pbi5qcy5tYXAiLCIvKiFcbiAqIHdhdmVzdXJmZXIuanMgMi4xLjAgKE1vbiBPY3QgMDEgMjAxOCAxMTozNDo1NCBHTVQrMDIwMCAoQ2VudHJhbCBFdXJvcGVhbiBTdW1tZXIgVGltZSkpXG4gKiBodHRwczovL2dpdGh1Yi5jb20va2F0c3BhdWdoL3dhdmVzdXJmZXIuanNcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZVxuICovXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcInRpbWVsaW5lXCIsW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy50aW1lbGluZT10KCk6KGUuV2F2ZVN1cmZlcj1lLldhdmVTdXJmZXJ8fHt9LGUuV2F2ZVN1cmZlci50aW1lbGluZT10KCkpfSh3aW5kb3csZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSl7dmFyIHI9e307ZnVuY3Rpb24gbihlKXtpZihyW2VdKXJldHVybiByW2VdLmV4cG9ydHM7dmFyIHQ9cltlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGFbZV0uY2FsbCh0LmV4cG9ydHMsdCx0LmV4cG9ydHMsbiksdC5sPSEwLHQuZXhwb3J0c31yZXR1cm4gbi5tPWEsbi5jPXIsbi5kPWZ1bmN0aW9uKGUsdCxhKXtuLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6YX0pfSxuLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sbi50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1uKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBhPU9iamVjdC5jcmVhdGUobnVsbCk7aWYobi5yKGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgciBpbiB0KW4uZChhLHIsZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxyKSk7cmV0dXJuIGF9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnA9XCJsb2NhbGhvc3Q6ODA4MC9kaXN0L3BsdWdpbi9cIixuKG4ucz0wKX0oW2Z1bmN0aW9uKGUsdCxhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7Zm9yKHZhciBhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciByPXRbYV07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBuKGUsdCxhKXtyZXR1cm4gdCYmcihlLnByb3RvdHlwZSx0KSxhJiZyKGUsYSksZX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLHQpe3ZhciBhPXRoaXM7aWYoZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHIpLG8uY2FsbCh0aGlzKSx0aGlzLmNvbnRhaW5lcj1cInN0cmluZ1wiPT10eXBlb2YgZS5jb250YWluZXI/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlLmNvbnRhaW5lcik6ZS5jb250YWluZXIsIXRoaXMuY29udGFpbmVyKXRocm93IG5ldyBFcnJvcihcIk5vIGNvbnRhaW5lciBmb3Igd2F2ZXN1cmZlciB0aW1lbGluZVwiKTt0aGlzLndhdmVzdXJmZXI9dCx0aGlzLnV0aWw9dC51dGlsLHRoaXMucGFyYW1zPXRoaXMudXRpbC5leHRlbmQoe30se2hlaWdodDoyMCxub3RjaFBlcmNlbnRIZWlnaHQ6OTAsbGFiZWxQYWRkaW5nOjUsdW5sYWJlbGVkTm90Y2hDb2xvcjpcIiNjMGMwYzBcIixwcmltYXJ5Q29sb3I6XCIjMDAwXCIsc2Vjb25kYXJ5Q29sb3I6XCIjYzBjMGMwXCIscHJpbWFyeUZvbnRDb2xvcjpcIiMwMDBcIixzZWNvbmRhcnlGb250Q29sb3I6XCIjMDAwXCIsZm9udEZhbWlseTpcIkFyaWFsXCIsZm9udFNpemU6MTAsem9vbURlYm91bmNlOiExLGZvcm1hdFRpbWVDYWxsYmFjazp0aGlzLmRlZmF1bHRGb3JtYXRUaW1lQ2FsbGJhY2ssdGltZUludGVydmFsOnRoaXMuZGVmYXVsdFRpbWVJbnRlcnZhbCxwcmltYXJ5TGFiZWxJbnRlcnZhbDp0aGlzLmRlZmF1bHRQcmltYXJ5TGFiZWxJbnRlcnZhbCxzZWNvbmRhcnlMYWJlbEludGVydmFsOnRoaXMuZGVmYXVsdFNlY29uZGFyeUxhYmVsSW50ZXJ2YWx9LGUpLHRoaXMuY2FudmFzZXM9W10sdGhpcy53cmFwcGVyPW51bGwsdGhpcy5kcmF3ZXI9bnVsbCx0aGlzLnBpeGVsUmF0aW89bnVsbCx0aGlzLm1heENhbnZhc1dpZHRoPW51bGwsdGhpcy5tYXhDYW52YXNFbGVtZW50V2lkdGg9bnVsbCx0aGlzLl9vblpvb209dGhpcy5wYXJhbXMuem9vbURlYm91bmNlP3RoaXMud2F2ZXN1cmZlci51dGlsLmRlYm91bmNlKGZ1bmN0aW9uKCl7cmV0dXJuIGEucmVuZGVyKCl9LHRoaXMucGFyYW1zLnpvb21EZWJvdW5jZSk6ZnVuY3Rpb24oKXtyZXR1cm4gYS5yZW5kZXIoKX19cmV0dXJuIG4ocixudWxsLFt7a2V5OlwiY3JlYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6XCJ0aW1lbGluZVwiLGRlZmVySW5pdDohKCFlfHwhZS5kZWZlckluaXQpJiZlLmRlZmVySW5pdCxwYXJhbXM6ZSxpbnN0YW5jZTpyfX19XSksbihyLFt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53YXZlc3VyZmVyLm9uKFwicmVhZHlcIix0aGlzLl9vblJlYWR5KSx0aGlzLndhdmVzdXJmZXIuaXNSZWFkeSYmdGhpcy5fb25SZWFkeSgpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudW5BbGwoKSx0aGlzLndhdmVzdXJmZXIudW4oXCJyZWRyYXdcIix0aGlzLl9vblJlZHJhdyksdGhpcy53YXZlc3VyZmVyLnVuKFwiem9vbVwiLHRoaXMuX29uWm9vbSksdGhpcy53YXZlc3VyZmVyLnVuKFwicmVhZHlcIix0aGlzLl9vblJlYWR5KSx0aGlzLndhdmVzdXJmZXIuZHJhd2VyLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuX29uU2Nyb2xsKSx0aGlzLndyYXBwZXImJnRoaXMud3JhcHBlci5wYXJlbnROb2RlJiYodGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uV3JhcHBlckNsaWNrKSx0aGlzLndyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpLHRoaXMud3JhcHBlcj1udWxsKX19LHtrZXk6XCJjcmVhdGVXcmFwcGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndhdmVzdXJmZXIucGFyYW1zO3RoaXMuY29udGFpbmVyLmlubmVySFRNTD1cIlwiLHRoaXMud3JhcHBlcj10aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGltZWxpbmVcIikpLHRoaXMudXRpbC5zdHlsZSh0aGlzLndyYXBwZXIse2Rpc3BsYXk6XCJibG9ja1wiLHBvc2l0aW9uOlwicmVsYXRpdmVcIix1c2VyU2VsZWN0Olwibm9uZVwiLHdlYmtpdFVzZXJTZWxlY3Q6XCJub25lXCIsaGVpZ2h0OlwiXCIuY29uY2F0KHRoaXMucGFyYW1zLmhlaWdodCxcInB4XCIpfSksKGUuZmlsbFBhcmVudHx8ZS5zY3JvbGxQYXJlbnQpJiZ0aGlzLnV0aWwuc3R5bGUodGhpcy53cmFwcGVyLHt3aWR0aDpcIjEwMCVcIixvdmVyZmxvd1g6XCJoaWRkZW5cIixvdmVyZmxvd1k6XCJoaWRkZW5cIn0pLHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9vbldyYXBwZXJDbGljayl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLndyYXBwZXJ8fHRoaXMuY3JlYXRlV3JhcHBlcigpLHRoaXMudXBkYXRlQ2FudmFzZXMoKSx0aGlzLnVwZGF0ZUNhbnZhc2VzUG9zaXRpb25pbmcoKSx0aGlzLnJlbmRlckNhbnZhc2VzKCl9fSx7a2V5OlwidXBkYXRlQ2FudmFzZXNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZSx0LGE9dGhpcyxyPU1hdGgucm91bmQodGhpcy5kcmF3ZXIud3JhcHBlci5zY3JvbGxXaWR0aCksbj1NYXRoLmNlaWwoci90aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aCk7dGhpcy5jYW52YXNlcy5sZW5ndGg8bjspdm9pZCAwLGU9YS53cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpLGEuY2FudmFzZXMucHVzaChlKSxhLnV0aWwuc3R5bGUoZSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHpJbmRleDo0fSk7Zm9yKDt0aGlzLmNhbnZhc2VzLmxlbmd0aD5uOyl0PXZvaWQgMCwodD1hLmNhbnZhc2VzLnBvcCgpKS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHQpfX0se2tleTpcInVwZGF0ZUNhbnZhc2VzUG9zaXRpb25pbmdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciByPXRoaXMsbj10aGlzLmNhbnZhc2VzLmxlbmd0aDt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSx0KXt2YXIgYT10PT09bi0xP3IuZHJhd2VyLndyYXBwZXIuc2Nyb2xsV2lkdGgtci5tYXhDYW52YXNFbGVtZW50V2lkdGgqKG4tMSk6ci5tYXhDYW52YXNFbGVtZW50V2lkdGg7ZS53aWR0aD1hKnIucGl4ZWxSYXRpbyxlLmhlaWdodD0oci5wYXJhbXMuaGVpZ2h0KzEpKnIucGl4ZWxSYXRpbyxyLnV0aWwuc3R5bGUoZSx7d2lkdGg6XCJcIi5jb25jYXQoYSxcInB4XCIpLGhlaWdodDpcIlwiLmNvbmNhdChyLnBhcmFtcy5oZWlnaHQsXCJweFwiKSxsZWZ0OlwiXCIuY29uY2F0KHQqci5tYXhDYW52YXNFbGVtZW50V2lkdGgsXCJweFwiKX0pfSl9fSx7a2V5OlwicmVuZGVyQ2FudmFzZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciByPXRoaXMsZT10aGlzLndhdmVzdXJmZXIuYmFja2VuZC5nZXREdXJhdGlvbigpO2lmKCEoZTw9MCkpe3ZhciB0LGE9dGhpcy53YXZlc3VyZmVyLnBhcmFtcyxuPXRoaXMucGFyYW1zLmZvbnRTaXplKmEucGl4ZWxSYXRpbyxpPXBhcnNlSW50KGUsMTApKzEsbz1hLmZpbGxQYXJlbnQmJiFhLnNjcm9sbFBhcmVudD90aGlzLmRyYXdlci5nZXRXaWR0aCgpOnRoaXMuZHJhd2VyLndyYXBwZXIuc2Nyb2xsV2lkdGgqYS5waXhlbFJhdGlvLHM9dGhpcy5wYXJhbXMuaGVpZ2h0KnRoaXMucGl4ZWxSYXRpbyxsPXRoaXMucGFyYW1zLmhlaWdodCoodGhpcy5wYXJhbXMubm90Y2hQZXJjZW50SGVpZ2h0LzEwMCkqdGhpcy5waXhlbFJhdGlvLGM9by9lLHU9dGhpcy5wYXJhbXMuZm9ybWF0VGltZUNhbGxiYWNrLGg9ZnVuY3Rpb24oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZT9lKGMpOmV9LHA9aCh0aGlzLnBhcmFtcy50aW1lSW50ZXJ2YWwpLGY9aCh0aGlzLnBhcmFtcy5wcmltYXJ5TGFiZWxJbnRlcnZhbCksZD1oKHRoaXMucGFyYW1zLnNlY29uZGFyeUxhYmVsSW50ZXJ2YWwpLHY9MCxtPTAseT1bXTtmb3IodD0wO3Q8aS9wO3QrKyl5LnB1c2goW3QsbSx2XSksbSs9cCx2Kz1jKnA7dmFyIHc9ZnVuY3Rpb24odCl7eS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QoZVswXSxlWzFdLGVbMl0pfSl9O3RoaXMuc2V0RmlsbFN0eWxlcyh0aGlzLnBhcmFtcy5wcmltYXJ5Q29sb3IpLHRoaXMuc2V0Rm9udHMoXCJcIi5jb25jYXQobixcInB4IFwiKS5jb25jYXQodGhpcy5wYXJhbXMuZm9udEZhbWlseSkpLHRoaXMuc2V0RmlsbFN0eWxlcyh0aGlzLnBhcmFtcy5wcmltYXJ5Rm9udENvbG9yKSx3KGZ1bmN0aW9uKGUsdCxhKXtlJWY9PTAmJihyLmZpbGxSZWN0KGEsMCwxLHMpLHIuZmlsbFRleHQodSh0LGMpLGErci5wYXJhbXMubGFiZWxQYWRkaW5nKnIucGl4ZWxSYXRpbyxzKSl9KSx0aGlzLnNldEZpbGxTdHlsZXModGhpcy5wYXJhbXMuc2Vjb25kYXJ5Q29sb3IpLHRoaXMuc2V0Rm9udHMoXCJcIi5jb25jYXQobixcInB4IFwiKS5jb25jYXQodGhpcy5wYXJhbXMuZm9udEZhbWlseSkpLHRoaXMuc2V0RmlsbFN0eWxlcyh0aGlzLnBhcmFtcy5zZWNvbmRhcnlGb250Q29sb3IpLHcoZnVuY3Rpb24oZSx0LGEpe2UlZD09MCYmKHIuZmlsbFJlY3QoYSwwLDEscyksci5maWxsVGV4dCh1KHQsYyksYStyLnBhcmFtcy5sYWJlbFBhZGRpbmcqci5waXhlbFJhdGlvLHMpKX0pLHRoaXMuc2V0RmlsbFN0eWxlcyh0aGlzLnBhcmFtcy51bmxhYmVsZWROb3RjaENvbG9yKSx3KGZ1bmN0aW9uKGUsdCxhKXtlJWQhPTAmJmUlZiE9MCYmci5maWxsUmVjdChhLDAsMSxsKX0pfX19LHtrZXk6XCJzZXRGaWxsU3R5bGVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZ2V0Q29udGV4dChcIjJkXCIpLmZpbGxTdHlsZT10fSl9fSx7a2V5Olwic2V0Rm9udHNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5nZXRDb250ZXh0KFwiMmRcIikuZm9udD10fSl9fSx7a2V5OlwiZmlsbFJlY3RcIix2YWx1ZTpmdW5jdGlvbihuLGksbyxzKXt2YXIgbD10aGlzO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBhPXQqbC5tYXhDYW52YXNXaWR0aCxyPXt4MTpNYXRoLm1heChuLHQqbC5tYXhDYW52YXNXaWR0aCkseTE6aSx4MjpNYXRoLm1pbihuK28sdCpsLm1heENhbnZhc1dpZHRoK2Uud2lkdGgpLHkyOmkrc307ci54MTxyLngyJiZlLmdldENvbnRleHQoXCIyZFwiKS5maWxsUmVjdChyLngxLWEsci55MSxyLngyLXIueDEsci55Mi1yLnkxKX0pfX0se2tleTpcImZpbGxUZXh0XCIsdmFsdWU6ZnVuY3Rpb24ocixuLGkpe3ZhciBvLHM9MDt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRDb250ZXh0KFwiMmRcIiksYT10LmNhbnZhcy53aWR0aDtuK288c3x8KG48cythJiYobz10Lm1lYXN1cmVUZXh0KHIpLndpZHRoLHQuZmlsbFRleHQocixuLXMsaSkpLHMrPWEpfSl9fSx7a2V5OlwiZGVmYXVsdEZvcm1hdFRpbWVDYWxsYmFja1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMTxlLzYwKXt2YXIgYT1wYXJzZUludChlLzYwLDEwKTtyZXR1cm4gZT0oZT1wYXJzZUludChlJTYwLDEwKSk8MTA/XCIwXCIrZTplLFwiXCIuY29uY2F0KGEsXCI6XCIpLmNvbmNhdChlKX1yZXR1cm4gTWF0aC5yb3VuZCgxZTMqZSkvMWUzfX0se2tleTpcImRlZmF1bHRUaW1lSW50ZXJ2YWxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gMjU8PWU/MToyNTw9NSplPzU6MjU8PTE1KmU/MTU6NjAqTWF0aC5jZWlsKC41L2UpfX0se2tleTpcImRlZmF1bHRQcmltYXJ5TGFiZWxJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiAyNTw9ZT8xMDoyNTw9NSplPzY6NH19LHtrZXk6XCJkZWZhdWx0U2Vjb25kYXJ5TGFiZWxJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiAyNTw9ZT81OjJ9fV0pLHJ9KCk7dC5kZWZhdWx0PWk7dmFyIG89ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuX29uU2Nyb2xsPWZ1bmN0aW9uKCl7YS53cmFwcGVyJiZhLmRyYXdlci53cmFwcGVyJiYoYS53cmFwcGVyLnNjcm9sbExlZnQ9YS5kcmF3ZXIud3JhcHBlci5zY3JvbGxMZWZ0KX0sdGhpcy5fb25SZWRyYXc9ZnVuY3Rpb24oKXtyZXR1cm4gYS5yZW5kZXIoKX0sdGhpcy5fb25SZWFkeT1mdW5jdGlvbigpe3ZhciBlPWEud2F2ZXN1cmZlcjthLmRyYXdlcj1lLmRyYXdlcixhLnBpeGVsUmF0aW89ZS5kcmF3ZXIucGFyYW1zLnBpeGVsUmF0aW8sYS5tYXhDYW52YXNXaWR0aD1lLmRyYXdlci5tYXhDYW52YXNXaWR0aHx8ZS5kcmF3ZXIud2lkdGgsYS5tYXhDYW52YXNFbGVtZW50V2lkdGg9ZS5kcmF3ZXIubWF4Q2FudmFzRWxlbWVudFdpZHRofHxNYXRoLnJvdW5kKGEubWF4Q2FudmFzV2lkdGgvYS5waXhlbFJhdGlvKSxlLmRyYXdlci53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixhLl9vblNjcm9sbCksZS5vbihcInJlZHJhd1wiLGEuX29uUmVkcmF3KSxlLm9uKFwiem9vbVwiLGEuX29uWm9vbSksYS5yZW5kZXIoKX0sdGhpcy5fb25XcmFwcGVyQ2xpY2s9ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciB0PVwib2Zmc2V0WFwiaW4gZT9lLm9mZnNldFg6ZS5sYXllclg7YS5maXJlRXZlbnQoXCJjbGlja1wiLHQvYS53cmFwcGVyLnNjcm9sbFdpZHRofHwwKX19O2UuZXhwb3J0cz10LmRlZmF1bHR9XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdmVzdXJmZXIudGltZWxpbmUubWluLmpzLm1hcCIsIi8qIVxuICogd2F2ZXN1cmZlci5qcyAyLjEuMCAoTW9uIE9jdCAwMSAyMDE4IDExOjM0OjQ5IEdNVCswMjAwIChDZW50cmFsIEV1cm9wZWFuIFN1bW1lciBUaW1lKSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rYXRzcGF1Z2gvd2F2ZXN1cmZlci5qc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlXG4gKi9cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiV2F2ZVN1cmZlclwiLFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuV2F2ZVN1cmZlcj10KCk6ZS5XYXZlU3VyZmVyPXQoKX0od2luZG93LGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3ZhciBuPXt9O2Z1bmN0aW9uIGkoZSl7aWYobltlXSlyZXR1cm4gbltlXS5leHBvcnRzO3ZhciB0PW5bZV09e2k6ZSxsOiExLGV4cG9ydHM6e319O3JldHVybiByW2VdLmNhbGwodC5leHBvcnRzLHQsdC5leHBvcnRzLGkpLHQubD0hMCx0LmV4cG9ydHN9cmV0dXJuIGkubT1yLGkuYz1uLGkuZD1mdW5jdGlvbihlLHQscil7aS5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0saS5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGkudD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9aSh0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGkucihyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIG4gaW4gdClpLmQocixuLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsbikpO3JldHVybiByfSxpLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIGkuZCh0LFwiYVwiLHQpLHR9LGkubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0saS5wPVwiXCIsaShpLnM9NCl9KFtmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJhamF4XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImdldElkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIm1heFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJtaW5cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiT2JzZXJ2ZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZXh0ZW5kXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInN0eWxlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJmcmFtZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWJvdW5jZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJwcmV2ZW50Q2xpY2tcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fX0pO3ZhciBuPXAocig1KSksaT1wKHIoNikpLGE9cChyKDcpKSxzPXAocig4KSksbz1wKHIoMSkpLHU9cChyKDkpKSxsPXAocigxMCkpLGM9cChyKDIpKSxoPXAocigxMSkpLGY9cChyKDEyKSksZD1wKHIoMTMpKTtmdW5jdGlvbiBwKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5oYW5kbGVycz1udWxsfXZhciB0LHIsbjtyZXR1cm4gdD1lLChyPVt7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXM7dGhpcy5oYW5kbGVyc3x8KHRoaXMuaGFuZGxlcnM9e30pO3ZhciBuPXRoaXMuaGFuZGxlcnNbZV07cmV0dXJuIG58fChuPXRoaXMuaGFuZGxlcnNbZV09W10pLG4ucHVzaCh0KSx7bmFtZTplLGNhbGxiYWNrOnQsdW46ZnVuY3Rpb24oZSx0KXtyZXR1cm4gci51bihlLHQpfX19fSx7a2V5OlwidW5cIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKHRoaXMuaGFuZGxlcnMpe3ZhciByLG49dGhpcy5oYW5kbGVyc1tlXTtpZihuKWlmKHQpZm9yKHI9bi5sZW5ndGgtMTswPD1yO3ItLSluW3JdPT10JiZuLnNwbGljZShyLDEpO2Vsc2Ugbi5sZW5ndGg9MH19fSx7a2V5OlwidW5BbGxcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaGFuZGxlcnM9bnVsbH19LHtrZXk6XCJvbmNlXCIsdmFsdWU6ZnVuY3Rpb24oaSxhKXt2YXIgcz10aGlzO3JldHVybiB0aGlzLm9uKGksZnVuY3Rpb24gZSgpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KHQpLG49MDtuPHQ7bisrKXJbbl09YXJndW1lbnRzW25dO2EuYXBwbHkocyxyKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cy51bihpLGUpfSwwKX0pfX0se2tleTpcImZpcmVFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KDE8dD90LTE6MCksbj0xO248dDtuKyspcltuLTFdPWFyZ3VtZW50c1tuXTtpZih0aGlzLmhhbmRsZXJzKXt2YXIgaT10aGlzLmhhbmRsZXJzW2VdO2kmJmkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmFwcGx5KHZvaWQgMCxyKX0pfX19XSkmJmkodC5wcm90b3R5cGUsciksbiYmaSh0LG4pLGV9KCk7dC5kZWZhdWx0PW4sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49KHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHNldFRpbWVvdXQoZSwxZTMvNjApfSkuYmluZCh3aW5kb3cpO3QuZGVmYXVsdD1uLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSl7dmFyIG49T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTp7fTtuLmdldHx8bi5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixuKTp0W3JdPWVbcl19cmV0dXJuIHQuZGVmYXVsdD1lLHR9fShyKDApKTtmdW5jdGlvbiBpKGUpe3JldHVybihpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBhKGUsdCxyKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1pKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIG8oZSl7cmV0dXJuKG89T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIHUoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fWZ1bmN0aW9uIGwoZSx0LHIpe3JldHVybiB0JiZ1KGUucHJvdG90eXBlLHQpLHImJnUoZSxyKSxlfWZ1bmN0aW9uIGMoZSx0KXtyZXR1cm4oYz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9dmFyIGg9XCJwbGF5aW5nXCIsZj1cInBhdXNlZFwiLGQ9XCJmaW5pc2hlZFwiLHA9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gaShlKXt2YXIgdCxyLG47cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxpKSwobj1zKHRoaXMsbyhpKS5jYWxsKHRoaXMpKSkuYXVkaW9Db250ZXh0PW51bGwsbi5vZmZsaW5lQXVkaW9Db250ZXh0PW51bGwsbi5zdGF0ZUJlaGF2aW9ycz0oYSh0PXt9LGgse2luaXQ6ZnVuY3Rpb24oKXt0aGlzLmFkZE9uQXVkaW9Qcm9jZXNzKCl9LGdldFBsYXllZFBlcmNlbnRzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXREdXJhdGlvbigpO3JldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkvZXx8MH0sZ2V0Q3VycmVudFRpbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydFBvc2l0aW9uK3RoaXMuZ2V0UGxheWVkVGltZSgpfX0pLGEodCxmLHtpbml0OmZ1bmN0aW9uKCl7dGhpcy5yZW1vdmVPbkF1ZGlvUHJvY2VzcygpfSxnZXRQbGF5ZWRQZXJjZW50czpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0RHVyYXRpb24oKTtyZXR1cm4gdGhpcy5nZXRDdXJyZW50VGltZSgpL2V8fDB9LGdldEN1cnJlbnRUaW1lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnRQb3NpdGlvbn19KSxhKHQsZCx7aW5pdDpmdW5jdGlvbigpe3RoaXMucmVtb3ZlT25BdWRpb1Byb2Nlc3MoKSx0aGlzLmZpcmVFdmVudChcImZpbmlzaFwiKX0sZ2V0UGxheWVkUGVyY2VudHM6ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0Q3VycmVudFRpbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREdXJhdGlvbigpfX0pLHQpLG4ucGFyYW1zPWUsbi5hYz1lLmF1ZGlvQ29udGV4dHx8bi5nZXRBdWRpb0NvbnRleHQoKSxuLmxhc3RQbGF5PW4uYWMuY3VycmVudFRpbWUsbi5zdGFydFBvc2l0aW9uPTAsbi5zY2hlZHVsZWRQYXVzZT1udWxsLG4uc3RhdGVzPShhKHI9e30saCxPYmplY3QuY3JlYXRlKG4uc3RhdGVCZWhhdmlvcnNbaF0pKSxhKHIsZixPYmplY3QuY3JlYXRlKG4uc3RhdGVCZWhhdmlvcnNbZl0pKSxhKHIsZCxPYmplY3QuY3JlYXRlKG4uc3RhdGVCZWhhdmlvcnNbZF0pKSxyKSxuLmFuYWx5c2VyPW51bGwsbi5idWZmZXI9bnVsbCxuLmZpbHRlcnM9W10sbi5nYWluTm9kZT1udWxsLG4ubWVyZ2VkUGVha3M9bnVsbCxuLm9mZmxpbmVBYz1udWxsLG4ucGVha3M9bnVsbCxuLnBsYXliYWNrUmF0ZT0xLG4uYW5hbHlzZXI9bnVsbCxuLnNjcmlwdE5vZGU9bnVsbCxuLnNvdXJjZT1udWxsLG4uc3BsaXRQZWFrcz1bXSxuLnN0YXRlPW51bGwsbi5leHBsaWNpdER1cmF0aW9uPW51bGwsbn1yZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJmMoZSx0KX0oaSxuLk9ic2VydmVyKSxsKGksW3trZXk6XCJzdXBwb3J0c1dlYkF1ZGlvXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hKCF3aW5kb3cuQXVkaW9Db250ZXh0JiYhd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCl9fSx7a2V5OlwiZ2V0QXVkaW9Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHR8fCh3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dD1uZXcod2luZG93LkF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkpLHdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0fX0se2tleTpcImdldE9mZmxpbmVBdWRpb0NvbnRleHRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gd2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0fHwod2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0PW5ldyh3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQpKDEsMixlKSksd2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0fX1dKSxsKGksW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKSx0aGlzLmNyZWF0ZVNjcmlwdE5vZGUoKSx0aGlzLmNyZWF0ZUFuYWx5c2VyTm9kZSgpLHRoaXMuc2V0U3RhdGUoZiksdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wYXJhbXMuYXVkaW9SYXRlKSx0aGlzLnNldExlbmd0aCgwKX19LHtrZXk6XCJkaXNjb25uZWN0RmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5maWx0ZXJzJiYodGhpcy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSYmZS5kaXNjb25uZWN0KCl9KSx0aGlzLmZpbHRlcnM9bnVsbCx0aGlzLmFuYWx5c2VyLmNvbm5lY3QodGhpcy5nYWluTm9kZSkpfX0se2tleTpcInNldFN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5zdGF0ZSE9PXRoaXMuc3RhdGVzW2VdJiYodGhpcy5zdGF0ZT10aGlzLnN0YXRlc1tlXSx0aGlzLnN0YXRlLmluaXQuY2FsbCh0aGlzKSl9fSx7a2V5Olwic2V0RmlsdGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTt0aGlzLnNldEZpbHRlcnModCl9fSx7a2V5Olwic2V0RmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuZGlzY29ubmVjdEZpbHRlcnMoKSxlJiZlLmxlbmd0aCYmKHRoaXMuZmlsdGVycz1lLHRoaXMuYW5hbHlzZXIuZGlzY29ubmVjdCgpLGUucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY29ubmVjdCh0KSx0fSx0aGlzLmFuYWx5c2VyKS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpKX19LHtrZXk6XCJjcmVhdGVTY3JpcHROb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBhcmFtcy5hdWRpb1NjcmlwdFByb2Nlc3Nvcj90aGlzLnNjcmlwdE5vZGU9dGhpcy5wYXJhbXMuYXVkaW9TY3JpcHRQcm9jZXNzb3I6dGhpcy5hYy5jcmVhdGVTY3JpcHRQcm9jZXNzb3I/dGhpcy5zY3JpcHROb2RlPXRoaXMuYWMuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKGkuc2NyaXB0QnVmZmVyU2l6ZSk6dGhpcy5zY3JpcHROb2RlPXRoaXMuYWMuY3JlYXRlSmF2YVNjcmlwdE5vZGUoaS5zY3JpcHRCdWZmZXJTaXplKSx0aGlzLnNjcmlwdE5vZGUuY29ubmVjdCh0aGlzLmFjLmRlc3RpbmF0aW9uKX19LHtrZXk6XCJhZGRPbkF1ZGlvUHJvY2Vzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnNjcmlwdE5vZGUub25hdWRpb3Byb2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZT10LmdldEN1cnJlbnRUaW1lKCk7ZT49dC5nZXREdXJhdGlvbigpPyh0LnNldFN0YXRlKGQpLHQuZmlyZUV2ZW50KFwicGF1c2VcIikpOmU+PXQuc2NoZWR1bGVkUGF1c2U/dC5wYXVzZSgpOnQuc3RhdGU9PT10LnN0YXRlc1toXSYmdC5maXJlRXZlbnQoXCJhdWRpb3Byb2Nlc3NcIixlKX19fSx7a2V5OlwicmVtb3ZlT25BdWRpb1Byb2Nlc3NcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2Vzcz1udWxsfX0se2tleTpcImNyZWF0ZUFuYWx5c2VyTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hbmFseXNlcj10aGlzLmFjLmNyZWF0ZUFuYWx5c2VyKCksdGhpcy5hbmFseXNlci5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpfX0se2tleTpcImNyZWF0ZVZvbHVtZU5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYWMuY3JlYXRlR2Fpbj90aGlzLmdhaW5Ob2RlPXRoaXMuYWMuY3JlYXRlR2FpbigpOnRoaXMuZ2Fpbk5vZGU9dGhpcy5hYy5jcmVhdGVHYWluTm9kZSgpLHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmFjLmRlc3RpbmF0aW9uKX19LHtrZXk6XCJzZXRTaW5rSWRcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlKXt2YXIgdD1uZXcgd2luZG93LkF1ZGlvO2lmKCF0LnNldFNpbmtJZClyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic2V0U2lua0lkIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyXCIpKTt0LmF1dG9wbGF5PSEwO3ZhciByPXRoaXMuYWMuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO3JldHVybiB0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoKSx0aGlzLmdhaW5Ob2RlLmNvbm5lY3QociksdC5zcmNPYmplY3Q9ci5zdHJlYW0sdC5zZXRTaW5rSWQoZSl9cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGV2aWNlSWQ6IFwiK2UpKX19LHtrZXk6XCJzZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoZSx0aGlzLmFjLmN1cnJlbnRUaW1lKX19LHtrZXk6XCJnZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWV9fSx7a2V5OlwiZGVjb2RlQXJyYXlCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7dGhpcy5vZmZsaW5lQWN8fCh0aGlzLm9mZmxpbmVBYz10aGlzLmdldE9mZmxpbmVBdWRpb0NvbnRleHQodGhpcy5hYyYmdGhpcy5hYy5zYW1wbGVSYXRlP3RoaXMuYWMuc2FtcGxlUmF0ZTo0NDEwMCkpLHRoaXMub2ZmbGluZUFjLmRlY29kZUF1ZGlvRGF0YShlLGZ1bmN0aW9uKGUpe3JldHVybiB0KGUpfSxyKX19LHtrZXk6XCJzZXRQZWFrc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5leHBsaWNpdER1cmF0aW9uPXQsdGhpcy5wZWFrcz1lfX0se2tleTpcInNldExlbmd0aFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCF0aGlzLm1lcmdlZFBlYWtzfHxlIT0yKnRoaXMubWVyZ2VkUGVha3MubGVuZ3RoLTErMil7dGhpcy5zcGxpdFBlYWtzPVtdLHRoaXMubWVyZ2VkUGVha3M9W107dmFyIHQscj10aGlzLmJ1ZmZlcj90aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOjE7Zm9yKHQ9MDt0PHI7dCsrKXRoaXMuc3BsaXRQZWFrc1t0XT1bXSx0aGlzLnNwbGl0UGVha3NbdF1bMiooZS0xKV09MCx0aGlzLnNwbGl0UGVha3NbdF1bMiooZS0xKSsxXT0wO3RoaXMubWVyZ2VkUGVha3NbMiooZS0xKV09MCx0aGlzLm1lcmdlZFBlYWtzWzIqKGUtMSkrMV09MH19fSx7a2V5OlwiZ2V0UGVha3NcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7aWYodGhpcy5wZWFrcylyZXR1cm4gdGhpcy5wZWFrcztpZih0PXR8fDAscj1yfHxlLTEsdGhpcy5zZXRMZW5ndGgoZSksIXRoaXMuYnVmZmVyLmxlbmd0aCl7dmFyIG49dGhpcy5jcmVhdGVCdWZmZXIoMSw0MDk2LHRoaXMuc2FtcGxlUmF0ZSk7dGhpcy5idWZmZXI9bi5idWZmZXJ9dmFyIGksYT10aGlzLmJ1ZmZlci5sZW5ndGgvZSxzPX5+KGEvMTApfHwxLG89dGhpcy5idWZmZXIubnVtYmVyT2ZDaGFubmVscztmb3IoaT0wO2k8bztpKyspe3ZhciB1PXRoaXMuc3BsaXRQZWFrc1tpXSxsPXRoaXMuYnVmZmVyLmdldENoYW5uZWxEYXRhKGkpLGM9dm9pZCAwO2ZvcihjPXQ7Yzw9cjtjKyspe3ZhciBoPX5+KGMqYSksZj1+fihoK2EpLGQ9MCxwPTAsdj12b2lkIDA7Zm9yKHY9aDt2PGY7dis9cyl7dmFyIHk9bFt2XTtwPHkmJihwPXkpLHk8ZCYmKGQ9eSl9dVsyKmNdPXAsdVsyKmMrMV09ZCwoMD09aXx8cD50aGlzLm1lcmdlZFBlYWtzWzIqY10pJiYodGhpcy5tZXJnZWRQZWFrc1syKmNdPXApLCgwPT1pfHxkPHRoaXMubWVyZ2VkUGVha3NbMipjKzFdKSYmKHRoaXMubWVyZ2VkUGVha3NbMipjKzFdPWQpfX1yZXR1cm4gdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVscz90aGlzLnNwbGl0UGVha3M6dGhpcy5tZXJnZWRQZWFrc319LHtrZXk6XCJnZXRQbGF5ZWRQZXJjZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuZ2V0UGxheWVkUGVyY2VudHMuY2FsbCh0aGlzKX19LHtrZXk6XCJkaXNjb25uZWN0U291cmNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNvdXJjZSYmdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaXNQYXVzZWQoKXx8dGhpcy5wYXVzZSgpLHRoaXMudW5BbGwoKSx0aGlzLmJ1ZmZlcj1udWxsLHRoaXMuZGlzY29ubmVjdEZpbHRlcnMoKSx0aGlzLmRpc2Nvbm5lY3RTb3VyY2UoKSx0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoKSx0aGlzLnNjcmlwdE5vZGUuZGlzY29ubmVjdCgpLHRoaXMuYW5hbHlzZXIuZGlzY29ubmVjdCgpLHRoaXMucGFyYW1zLmNsb3NlQXVkaW9Db250ZXh0JiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5hYy5jbG9zZSYmXCJjbG9zZWRcIiE9dGhpcy5hYy5zdGF0ZSYmdGhpcy5hYy5jbG9zZSgpLHRoaXMuYWM9bnVsbCx0aGlzLnBhcmFtcy5hdWRpb0NvbnRleHQ/dGhpcy5wYXJhbXMuYXVkaW9Db250ZXh0PW51bGw6d2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHQ9bnVsbCx3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQ9bnVsbCl9fSx7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc3RhcnRQb3NpdGlvbj0wLHRoaXMubGFzdFBsYXk9dGhpcy5hYy5jdXJyZW50VGltZSx0aGlzLmJ1ZmZlcj1lLHRoaXMuY3JlYXRlU291cmNlKCl9fSx7a2V5OlwiY3JlYXRlU291cmNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmRpc2Nvbm5lY3RTb3VyY2UoKSx0aGlzLnNvdXJjZT10aGlzLmFjLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpLHRoaXMuc291cmNlLnN0YXJ0PXRoaXMuc291cmNlLnN0YXJ0fHx0aGlzLnNvdXJjZS5ub3RlR3JhaW5Pbix0aGlzLnNvdXJjZS5zdG9wPXRoaXMuc291cmNlLnN0b3B8fHRoaXMuc291cmNlLm5vdGVPZmYsdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLHRoaXMuYWMuY3VycmVudFRpbWUpLHRoaXMuc291cmNlLmJ1ZmZlcj10aGlzLmJ1ZmZlcix0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpfX0se2tleTpcImlzUGF1c2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZSE9PXRoaXMuc3RhdGVzW2hdfX0se2tleTpcImdldER1cmF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWZmZXI/dGhpcy5idWZmZXIuZHVyYXRpb246dGhpcy5leHBsaWNpdER1cmF0aW9uP3RoaXMuZXhwbGljaXREdXJhdGlvbjowfX0se2tleTpcInNlZWtUb1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5idWZmZXIpcmV0dXJuKHRoaXMuc2NoZWR1bGVkUGF1c2U9bnVsbCk9PWUmJihlPXRoaXMuZ2V0Q3VycmVudFRpbWUoKSk+PXRoaXMuZ2V0RHVyYXRpb24oKSYmKGU9MCksbnVsbD09dCYmKHQ9dGhpcy5nZXREdXJhdGlvbigpKSx0aGlzLnN0YXJ0UG9zaXRpb249ZSx0aGlzLmxhc3RQbGF5PXRoaXMuYWMuY3VycmVudFRpbWUsdGhpcy5zdGF0ZT09PXRoaXMuc3RhdGVzW2RdJiZ0aGlzLnNldFN0YXRlKGYpLHtzdGFydDplLGVuZDp0fX19LHtrZXk6XCJnZXRQbGF5ZWRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5hYy5jdXJyZW50VGltZS10aGlzLmxhc3RQbGF5KSp0aGlzLnBsYXliYWNrUmF0ZX19LHtrZXk6XCJwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmJ1ZmZlcil7dGhpcy5jcmVhdGVTb3VyY2UoKTt2YXIgcj10aGlzLnNlZWtUbyhlLHQpO2U9ci5zdGFydCx0PXIuZW5kLHRoaXMuc2NoZWR1bGVkUGF1c2U9dCx0aGlzLnNvdXJjZS5zdGFydCgwLGUsdC1lKSxcInN1c3BlbmRlZFwiPT10aGlzLmFjLnN0YXRlJiZ0aGlzLmFjLnJlc3VtZSYmdGhpcy5hYy5yZXN1bWUoKSx0aGlzLnNldFN0YXRlKGgpLHRoaXMuZmlyZUV2ZW50KFwicGxheVwiKX19fSx7a2V5OlwicGF1c2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2NoZWR1bGVkUGF1c2U9bnVsbCx0aGlzLnN0YXJ0UG9zaXRpb24rPXRoaXMuZ2V0UGxheWVkVGltZSgpLHRoaXMuc291cmNlJiZ0aGlzLnNvdXJjZS5zdG9wKDApLHRoaXMuc2V0U3RhdGUoZiksdGhpcy5maXJlRXZlbnQoXCJwYXVzZVwiKX19LHtrZXk6XCJnZXRDdXJyZW50VGltZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuZ2V0Q3VycmVudFRpbWUuY2FsbCh0aGlzKX19LHtrZXk6XCJnZXRQbGF5YmFja1JhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBsYXliYWNrUmF0ZX19LHtrZXk6XCJzZXRQbGF5YmFja1JhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXtlPWV8fDEsdGhpcy5pc1BhdXNlZCgpP3RoaXMucGxheWJhY2tSYXRlPWU6KHRoaXMucGF1c2UoKSx0aGlzLnBsYXliYWNrUmF0ZT1lLHRoaXMucGxheSgpKX19XSksaX0oKTsodC5kZWZhdWx0PXApLnNjcmlwdEJ1ZmZlclNpemU9MjU2LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBpPWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSl7dmFyIG49T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTp7fTtuLmdldHx8bi5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixuKTp0W3JdPWVbcl19cmV0dXJuIHQuZGVmYXVsdD1lLHR9fShyKDApKSxhPW4ocigxNCkpLHM9bihyKDMpKSxvPW4ocigxNikpLHU9bihyKDE3KSk7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gbChlKXtyZXR1cm4obD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09bCh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9kKGUpOnR9ZnVuY3Rpb24gaChlKXtyZXR1cm4oaD1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gZihlLHQpe3JldHVybihmPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX1mdW5jdGlvbiBkKGUpe2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiBlfWZ1bmN0aW9uIHAoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHYoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fWZ1bmN0aW9uIHkoZSx0LHIpe3JldHVybiB0JiZ2KGUucHJvdG90eXBlLHQpLHImJnYoZSxyKSxlfXZhciBtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSl7dmFyIHQ7aWYocCh0aGlzLG4pLCh0PWModGhpcyxoKG4pLmNhbGwodGhpcykpKS5kZWZhdWx0UGFyYW1zPXthdWRpb0NvbnRleHQ6bnVsbCxhdWRpb1JhdGU6MSxhdXRvQ2VudGVyOiEwLGJhY2tlbmQ6XCJXZWJBdWRpb1wiLGJhckhlaWdodDoxLGJhckdhcDpudWxsLGNvbnRhaW5lcjpudWxsLGN1cnNvckNvbG9yOlwiIzMzM1wiLGN1cnNvcldpZHRoOjEsZHJhZ1NlbGVjdGlvbjohMCxmaWxsUGFyZW50OiEwLGZvcmNlRGVjb2RlOiExLGhlaWdodDoxMjgsaGlkZVNjcm9sbGJhcjohMSxpbnRlcmFjdDohMCxsb29wU2VsZWN0aW9uOiEwLG1heENhbnZhc1dpZHRoOjRlMyxtZWRpYUNvbnRhaW5lcjpudWxsLG1lZGlhQ29udHJvbHM6ITEsbWVkaWFUeXBlOlwiYXVkaW9cIixtaW5QeFBlclNlYzoyMCxub3JtYWxpemU6ITEscGFydGlhbFJlbmRlcjohMSxwaXhlbFJhdGlvOndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHxzY3JlZW4uZGV2aWNlWERQSS9zY3JlZW4ubG9naWNhbFhEUEkscGx1Z2luczpbXSxwcm9ncmVzc0NvbG9yOlwiIzU1NVwiLHJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveTohMCxyZW5kZXJlcjphLmRlZmF1bHQscmVzcG9uc2l2ZTohMSxzY3JvbGxQYXJlbnQ6ITEsc2tpcExlbmd0aDoyLHNwbGl0Q2hhbm5lbHM6ITEsd2F2ZUNvbG9yOlwiIzk5OVwiLHhocjp7fX0sdC5iYWNrZW5kcz17TWVkaWFFbGVtZW50Om8uZGVmYXVsdCxXZWJBdWRpbzpzLmRlZmF1bHR9LHQudXRpbD1pLHQucGFyYW1zPWkuZXh0ZW5kKHt9LHQuZGVmYXVsdFBhcmFtcyxlKSx0LmNvbnRhaW5lcj1cInN0cmluZ1wiPT10eXBlb2YgZS5jb250YWluZXI/ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0LnBhcmFtcy5jb250YWluZXIpOnQucGFyYW1zLmNvbnRhaW5lciwhdC5jb250YWluZXIpdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kXCIpO2lmKG51bGw9PXQucGFyYW1zLm1lZGlhQ29udGFpbmVyP3QubWVkaWFDb250YWluZXI9dC5jb250YWluZXI6XCJzdHJpbmdcIj09dHlwZW9mIHQucGFyYW1zLm1lZGlhQ29udGFpbmVyP3QubWVkaWFDb250YWluZXI9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0LnBhcmFtcy5tZWRpYUNvbnRhaW5lcik6dC5tZWRpYUNvbnRhaW5lcj10LnBhcmFtcy5tZWRpYUNvbnRhaW5lciwhdC5tZWRpYUNvbnRhaW5lcil0aHJvdyBuZXcgRXJyb3IoXCJNZWRpYSBDb250YWluZXIgZWxlbWVudCBub3QgZm91bmRcIik7aWYodC5wYXJhbXMubWF4Q2FudmFzV2lkdGg8PTEpdGhyb3cgbmV3IEVycm9yKFwibWF4Q2FudmFzV2lkdGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKTtpZih0LnBhcmFtcy5tYXhDYW52YXNXaWR0aCUyPT0xKXRocm93IG5ldyBFcnJvcihcIm1heENhbnZhc1dpZHRoIG11c3QgYmUgYW4gZXZlbiBudW1iZXJcIik7aWYodC5zYXZlZFZvbHVtZT0wLHQuaXNNdXRlZD0hMSx0LnRtcEV2ZW50cz1bXSx0LmN1cnJlbnRBamF4PW51bGwsdC5hcnJheWJ1ZmZlcj1udWxsLHQuZHJhd2VyPW51bGwsdC5iYWNrZW5kPW51bGwsdC5wZWFrQ2FjaGU9bnVsbCxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LnBhcmFtcy5yZW5kZXJlcil0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXJlciBwYXJhbWV0ZXIgaXMgaW52YWxpZFwiKTt0LkRyYXdlcj10LnBhcmFtcy5yZW5kZXJlcix0LkJhY2tlbmQ9dC5iYWNrZW5kc1t0LnBhcmFtcy5iYWNrZW5kXSx0LmluaXRpYWxpc2VkUGx1Z2luTGlzdD17fSx0LmlzRGVzdHJveWVkPSExLHQuaXNSZWFkeT0hMTt2YXIgcj0wO3JldHVybiB0Ll9vblJlc2l6ZT1pLmRlYm91bmNlKGZ1bmN0aW9uKCl7cj09dC5kcmF3ZXIud3JhcHBlci5jbGllbnRXaWR0aHx8dC5wYXJhbXMuc2Nyb2xsUGFyZW50fHwocj10LmRyYXdlci53cmFwcGVyLmNsaWVudFdpZHRoLHQuZHJhd2VyLmZpcmVFdmVudChcInJlZHJhd1wiKSl9LFwibnVtYmVyXCI9PXR5cGVvZiB0LnBhcmFtcy5yZXNwb25zaXZlP3QucGFyYW1zLnJlc3BvbnNpdmU6MTAwKSxjKHQsZChkKHQpKSl9cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZmKGUsdCl9KG4saS5PYnNlcnZlcikseShuLG51bGwsW3trZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gbmV3IG4oZSkuaW5pdCgpfX1dKSx5KG4sW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWdpc3RlclBsdWdpbnModGhpcy5wYXJhbXMucGx1Z2lucyksdGhpcy5jcmVhdGVEcmF3ZXIoKSx0aGlzLmNyZWF0ZUJhY2tlbmQoKSx0aGlzLmNyZWF0ZVBlYWtDYWNoZSgpLHRoaXN9fSx7a2V5OlwicmVnaXN0ZXJQbHVnaW5zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFkZFBsdWdpbihlKX0pLGUuZm9yRWFjaChmdW5jdGlvbihlKXtlLmRlZmVySW5pdHx8dC5pbml0UGx1Z2luKGUubmFtZSl9KSx0aGlzLmZpcmVFdmVudChcInBsdWdpbnMtcmVnaXN0ZXJlZFwiLGUpLHRoaXN9fSx7a2V5OlwiYWRkUGx1Z2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dGhpcztpZighdC5uYW1lKXRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBkb2VzIG5vdCBoYXZlIGEgbmFtZSFcIik7aWYoIXQuaW5zdGFuY2UpdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdCh0Lm5hbWUsXCIgZG9lcyBub3QgaGF2ZSBhbiBpbnN0YW5jZSBwcm9wZXJ0eSFcIikpO3Quc3RhdGljUHJvcHMmJk9iamVjdC5rZXlzKHQuc3RhdGljUHJvcHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cltlXT10LnN0YXRpY1Byb3BzW2VdfSk7dmFyIG49dC5pbnN0YW5jZTtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaS5PYnNlcnZlci5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24oZSl7bi5wcm90b3R5cGVbZV09aS5PYnNlcnZlci5wcm90b3R5cGVbZV19KSx0aGlzW3QubmFtZV09bmV3IG4odC5wYXJhbXN8fHt9LHRoaXMpLHRoaXMuZmlyZUV2ZW50KFwicGx1Z2luLWFkZGVkXCIsdC5uYW1lKSx0aGlzfX0se2tleTpcImluaXRQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbihlKXtpZighdGhpc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHlldCFcIikpO3JldHVybiB0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtlXSYmdGhpcy5kZXN0cm95UGx1Z2luKGUpLHRoaXNbZV0uaW5pdCgpLHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W2VdPSEwLHRoaXMuZmlyZUV2ZW50KFwicGx1Z2luLWluaXRpYWxpc2VkXCIsZSksdGhpc319LHtrZXk6XCJkZXN0cm95UGx1Z2luXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIXRoaXNbZV0pdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChlLFwiIGhhcyBub3QgYmVlbiBhZGRlZCB5ZXQgYW5kIGNhbm5vdCBiZSBkZXN0cm95ZWQhXCIpKTtpZighdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbZV0pdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChlLFwiIGlzIG5vdCBhY3RpdmUgYW5kIGNhbm5vdCBiZSBkZXN0cm95ZWQhXCIpKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2VdLmRlc3Ryb3kpdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChlLFwiIGRvZXMgbm90IGhhdmUgYSBkZXN0cm95IGZ1bmN0aW9uIVwiKSk7cmV0dXJuIHRoaXNbZV0uZGVzdHJveSgpLGRlbGV0ZSB0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtlXSx0aGlzLmZpcmVFdmVudChcInBsdWdpbi1kZXN0cm95ZWRcIixlKSx0aGlzfX0se2tleTpcImRlc3Ryb3lBbGxQbHVnaW5zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO09iamVjdC5rZXlzKHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmRlc3Ryb3lQbHVnaW4oZSl9KX19LHtrZXk6XCJjcmVhdGVEcmF3ZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciByPXRoaXM7dGhpcy5kcmF3ZXI9bmV3IHRoaXMuRHJhd2VyKHRoaXMuY29udGFpbmVyLHRoaXMucGFyYW1zKSx0aGlzLmRyYXdlci5pbml0KCksdGhpcy5maXJlRXZlbnQoXCJkcmF3ZXItY3JlYXRlZFwiLHRoaXMuZHJhd2VyKSwhMSE9PXRoaXMucGFyYW1zLnJlc3BvbnNpdmUmJih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMuX29uUmVzaXplLCEwKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsdGhpcy5fb25SZXNpemUsITApKSx0aGlzLmRyYXdlci5vbihcInJlZHJhd1wiLGZ1bmN0aW9uKCl7ci5kcmF3QnVmZmVyKCksci5kcmF3ZXIucHJvZ3Jlc3Moci5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpfSksdGhpcy5kcmF3ZXIub24oXCJjbGlja1wiLGZ1bmN0aW9uKGUsdCl7c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiByLnNlZWtUbyh0KX0sMCl9KSx0aGlzLmRyYXdlci5vbihcInNjcm9sbFwiLGZ1bmN0aW9uKGUpe3IucGFyYW1zLnBhcnRpYWxSZW5kZXImJnIuZHJhd0J1ZmZlcigpLHIuZmlyZUV2ZW50KFwic2Nyb2xsXCIsZSl9KX19LHtrZXk6XCJjcmVhdGVCYWNrZW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYmFja2VuZCYmdGhpcy5iYWNrZW5kLmRlc3Ryb3koKSxcIkF1ZGlvRWxlbWVudFwiPT10aGlzLnBhcmFtcy5iYWNrZW5kJiYodGhpcy5wYXJhbXMuYmFja2VuZD1cIk1lZGlhRWxlbWVudFwiKSxcIldlYkF1ZGlvXCIhPXRoaXMucGFyYW1zLmJhY2tlbmR8fHRoaXMuQmFja2VuZC5wcm90b3R5cGUuc3VwcG9ydHNXZWJBdWRpby5jYWxsKG51bGwpfHwodGhpcy5wYXJhbXMuYmFja2VuZD1cIk1lZGlhRWxlbWVudFwiKSx0aGlzLmJhY2tlbmQ9bmV3IHRoaXMuQmFja2VuZCh0aGlzLnBhcmFtcyksdGhpcy5iYWNrZW5kLmluaXQoKSx0aGlzLmZpcmVFdmVudChcImJhY2tlbmQtY3JlYXRlZFwiLHRoaXMuYmFja2VuZCksdGhpcy5iYWNrZW5kLm9uKFwiZmluaXNoXCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5maXJlRXZlbnQoXCJmaW5pc2hcIil9KSx0aGlzLmJhY2tlbmQub24oXCJwbGF5XCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5maXJlRXZlbnQoXCJwbGF5XCIpfSksdGhpcy5iYWNrZW5kLm9uKFwicGF1c2VcIixmdW5jdGlvbigpe3JldHVybiB0LmZpcmVFdmVudChcInBhdXNlXCIpfSksdGhpcy5iYWNrZW5kLm9uKFwiYXVkaW9wcm9jZXNzXCIsZnVuY3Rpb24oZSl7dC5kcmF3ZXIucHJvZ3Jlc3ModC5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpLHQuZmlyZUV2ZW50KFwiYXVkaW9wcm9jZXNzXCIsZSl9KX19LHtrZXk6XCJjcmVhdGVQZWFrQ2FjaGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyYW1zLnBhcnRpYWxSZW5kZXImJih0aGlzLnBlYWtDYWNoZT1uZXcgdS5kZWZhdWx0KX19LHtrZXk6XCJnZXREdXJhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5nZXREdXJhdGlvbigpfX0se2tleTpcImdldEN1cnJlbnRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmdldEN1cnJlbnRUaW1lKCl9fSx7a2V5Olwic2V0Q3VycmVudFRpbWVcIix2YWx1ZTpmdW5jdGlvbihlKXtlPj10aGlzLmdldER1cmF0aW9uKCk/dGhpcy5zZWVrVG8oMSk6dGhpcy5zZWVrVG8oZS90aGlzLmdldER1cmF0aW9uKCkpfX0se2tleTpcInBsYXlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZmlyZUV2ZW50KFwiaW50ZXJhY3Rpb25cIixmdW5jdGlvbigpe3JldHVybiByLnBsYXkoZSx0KX0pLHRoaXMuYmFja2VuZC5wbGF5KGUsdCl9fSx7a2V5OlwicGF1c2VcIix2YWx1ZTpmdW5jdGlvbigpe2lmKCF0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKSlyZXR1cm4gdGhpcy5iYWNrZW5kLnBhdXNlKCl9fSx7a2V5OlwicGxheVBhdXNlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCk/dGhpcy5wbGF5KCk6dGhpcy5wYXVzZSgpfX0se2tleTpcImlzUGxheWluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuYmFja2VuZC5pc1BhdXNlZCgpfX0se2tleTpcInNraXBCYWNrd2FyZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc2tpcCgtZXx8LXRoaXMucGFyYW1zLnNraXBMZW5ndGgpfX0se2tleTpcInNraXBGb3J3YXJkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5za2lwKGV8fHRoaXMucGFyYW1zLnNraXBMZW5ndGgpfX0se2tleTpcInNraXBcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldER1cmF0aW9uKCl8fDEscj10aGlzLmdldEN1cnJlbnRUaW1lKCl8fDA7cj1NYXRoLm1heCgwLE1hdGgubWluKHQscisoZXx8MCkpKSx0aGlzLnNlZWtBbmRDZW50ZXIoci90KX19LHtrZXk6XCJzZWVrQW5kQ2VudGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5zZWVrVG8oZSksdGhpcy5kcmF3ZXIucmVjZW50ZXIoZSl9fSx7a2V5Olwic2Vla1RvXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZihcIm51bWJlclwiIT10eXBlb2YgZXx8IWlzRmluaXRlKGUpfHxlPDB8fDE8ZSlyZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgd2F2ZXN1cmZlci5zZWVrVG8sIHBhcmFtZXRlciBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSFcIik7dGhpcy5maXJlRXZlbnQoXCJpbnRlcmFjdGlvblwiLGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2Vla1RvKGUpfSk7dmFyIHI9dGhpcy5iYWNrZW5kLmlzUGF1c2VkKCk7cnx8dGhpcy5iYWNrZW5kLnBhdXNlKCk7dmFyIG49dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50O3RoaXMucGFyYW1zLnNjcm9sbFBhcmVudD0hMSx0aGlzLmJhY2tlbmQuc2Vla1RvKGUqdGhpcy5nZXREdXJhdGlvbigpKSx0aGlzLmRyYXdlci5wcm9ncmVzcyhlKSxyfHx0aGlzLmJhY2tlbmQucGxheSgpLHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudD1uLHRoaXMuZmlyZUV2ZW50KFwic2Vla1wiLGUpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGF1c2UoKSx0aGlzLnNlZWtUbygwKSx0aGlzLmRyYXdlci5wcm9ncmVzcygwKX19LHtrZXk6XCJzZXRTaW5rSWRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5iYWNrZW5kLnNldFNpbmtJZChlKX19LHtrZXk6XCJzZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmJhY2tlbmQuc2V0Vm9sdW1lKGUpLHRoaXMuZmlyZUV2ZW50KFwidm9sdW1lXCIsZSl9fSx7a2V5OlwiZ2V0Vm9sdW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmdldFZvbHVtZSgpfX0se2tleTpcInNldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYmFja2VuZC5zZXRQbGF5YmFja1JhdGUoZSl9fSx7a2V5OlwiZ2V0UGxheWJhY2tSYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmdldFBsYXliYWNrUmF0ZSgpfX0se2tleTpcInRvZ2dsZU11dGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2V0TXV0ZSghdGhpcy5pc011dGVkKX19LHtrZXk6XCJzZXRNdXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZSE9PXRoaXMuaXNNdXRlZCYmKGU/KHRoaXMuc2F2ZWRWb2x1bWU9dGhpcy5iYWNrZW5kLmdldFZvbHVtZSgpLHRoaXMuYmFja2VuZC5zZXRWb2x1bWUoMCksdGhpcy5pc011dGVkPSEwLHRoaXMuZmlyZUV2ZW50KFwidm9sdW1lXCIsMCkpOih0aGlzLmJhY2tlbmQuc2V0Vm9sdW1lKHRoaXMuc2F2ZWRWb2x1bWUpLHRoaXMuaXNNdXRlZD0hMSx0aGlzLmZpcmVFdmVudChcInZvbHVtZVwiLHRoaXMuc2F2ZWRWb2x1bWUpKSksdGhpcy5maXJlRXZlbnQoXCJtdXRlXCIsdGhpcy5pc011dGVkKX19LHtrZXk6XCJnZXRNdXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc011dGVkfX0se2tleTpcImlzUmVhZHlcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUmVhZHl9fSx7a2V5OlwiZ2V0RmlsdGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5maWx0ZXJzfHxbXX19LHtrZXk6XCJ0b2dnbGVTY3JvbGxcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyYW1zLnNjcm9sbFBhcmVudD0hdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50LHRoaXMuZHJhd0J1ZmZlcigpfX0se2tleTpcInRvZ2dsZUludGVyYWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBhcmFtcy5pbnRlcmFjdD0hdGhpcy5wYXJhbXMuaW50ZXJhY3R9fSx7a2V5OlwiZ2V0V2F2ZUNvbG9yXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJhbXMud2F2ZUNvbG9yfX0se2tleTpcInNldFdhdmVDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGFyYW1zLndhdmVDb2xvcj1lLHRoaXMuZHJhd0J1ZmZlcigpfX0se2tleTpcImdldFByb2dyZXNzQ29sb3JcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yfX0se2tleTpcInNldFByb2dyZXNzQ29sb3JcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yPWUsdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwiZ2V0Q3Vyc29yQ29sb3JcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtcy5jdXJzb3JDb2xvcn19LHtrZXk6XCJzZXRDdXJzb3JDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGFyYW1zLmN1cnNvckNvbG9yPWUsdGhpcy5kcmF3ZXIudXBkYXRlQ3Vyc29yKCl9fSx7a2V5OlwiZ2V0SGVpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJhbXMuaGVpZ2h0fX0se2tleTpcInNldEhlaWdodFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGFyYW1zLmhlaWdodD1lLHRoaXMuZHJhd2VyLnNldEhlaWdodChlKnRoaXMucGFyYW1zLnBpeGVsUmF0aW8pLHRoaXMuZHJhd0J1ZmZlcigpfX0se2tleTpcImRyYXdCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9TWF0aC5yb3VuZCh0aGlzLmdldER1cmF0aW9uKCkqdGhpcy5wYXJhbXMubWluUHhQZXJTZWMqdGhpcy5wYXJhbXMucGl4ZWxSYXRpbykscj10aGlzLmRyYXdlci5nZXRXaWR0aCgpLG49dCxpPXRoaXMuZHJhd2VyLmdldFNjcm9sbFgoKSxhPU1hdGgubWF4KGkrcixuKTtpZih0aGlzLnBhcmFtcy5maWxsUGFyZW50JiYoIXRoaXMucGFyYW1zLnNjcm9sbFBhcmVudHx8dDxyKSYmKGk9MCxhPW49ciksdGhpcy5wYXJhbXMucGFydGlhbFJlbmRlcil7dmFyIHMsbz10aGlzLnBlYWtDYWNoZS5hZGRSYW5nZVRvUGVha0NhY2hlKG4saSxhKTtmb3Iocz0wO3M8by5sZW5ndGg7cysrKWU9dGhpcy5iYWNrZW5kLmdldFBlYWtzKG4sb1tzXVswXSxvW3NdWzFdKSx0aGlzLmRyYXdlci5kcmF3UGVha3MoZSxuLG9bc11bMF0sb1tzXVsxXSl9ZWxzZSBlPXRoaXMuYmFja2VuZC5nZXRQZWFrcyhuLGksYSksdGhpcy5kcmF3ZXIuZHJhd1BlYWtzKGUsbixpLGEpO3RoaXMuZmlyZUV2ZW50KFwicmVkcmF3XCIsZSxuKX19LHtrZXk6XCJ6b29tXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PWU/KHRoaXMucGFyYW1zLm1pblB4UGVyU2VjPWUsITApOih0aGlzLnBhcmFtcy5taW5QeFBlclNlYz10aGlzLmRlZmF1bHRQYXJhbXMubWluUHhQZXJTZWMsITEpLHRoaXMuZHJhd0J1ZmZlcigpLHRoaXMuZHJhd2VyLnByb2dyZXNzKHRoaXMuYmFja2VuZC5nZXRQbGF5ZWRQZXJjZW50cygpKSx0aGlzLmRyYXdlci5yZWNlbnRlcih0aGlzLmdldEN1cnJlbnRUaW1lKCkvdGhpcy5nZXREdXJhdGlvbigpKSx0aGlzLmZpcmVFdmVudChcInpvb21cIixlKX19LHtrZXk6XCJsb2FkQXJyYXlCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuZGVjb2RlQXJyYXlCdWZmZXIoZSxmdW5jdGlvbihlKXt0LmlzRGVzdHJveWVkfHx0LmxvYWREZWNvZGVkQnVmZmVyKGUpfSl9fSx7a2V5OlwibG9hZERlY29kZWRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmJhY2tlbmQubG9hZChlKSx0aGlzLmRyYXdCdWZmZXIoKSx0aGlzLmZpcmVFdmVudChcInJlYWR5XCIpLHRoaXMuaXNSZWFkeT0hMH19LHtrZXk6XCJsb2FkQmxvYlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj1uZXcgRmlsZVJlYWRlcjtyLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uUHJvZ3Jlc3MoZSl9KSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQubG9hZEFycmF5QnVmZmVyKGUudGFyZ2V0LnJlc3VsdCl9KSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZmlyZUV2ZW50KFwiZXJyb3JcIixcIkVycm9yIHJlYWRpbmcgZmlsZVwiKX0pLHIucmVhZEFzQXJyYXlCdWZmZXIoZSksdGhpcy5lbXB0eSgpfX0se2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXtpZih0aGlzLmVtcHR5KCkscil7dmFyIGk9e1wiUHJlbG9hZCBpcyBub3QgJ2F1dG8nLCAnbm9uZScgb3IgJ21ldGFkYXRhJ1wiOi0xPT09W1wiYXV0b1wiLFwibWV0YWRhdGFcIixcIm5vbmVcIl0uaW5kZXhPZihyKSxcIlBlYWtzIGFyZSBub3QgcHJvdmlkZWRcIjohdCxcIkJhY2tlbmQgaXMgbm90IG9mIHR5cGUgTWVkaWFFbGVtZW50XCI6XCJNZWRpYUVsZW1lbnRcIiE9PXRoaXMucGFyYW1zLmJhY2tlbmQsXCJVcmwgaXMgbm90IG9mIHR5cGUgc3RyaW5nXCI6XCJzdHJpbmdcIiE9dHlwZW9mIGV9LGE9T2JqZWN0LmtleXMoaSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBpW2VdfSk7YS5sZW5ndGgmJihjb25zb2xlLndhcm4oXCJQcmVsb2FkIHBhcmFtZXRlciBvZiB3YXZlc3VyZmVyLmxvYWQgd2lsbCBiZSBpZ25vcmVkIGJlY2F1c2U6XFxuXFx0LSBcIithLmpvaW4oXCJcXG5cXHQtIFwiKSkscj1udWxsKX1zd2l0Y2godGhpcy5wYXJhbXMuYmFja2VuZCl7Y2FzZVwiV2ViQXVkaW9cIjpyZXR1cm4gdGhpcy5sb2FkQnVmZmVyKGUsdCxuKTtjYXNlXCJNZWRpYUVsZW1lbnRcIjpyZXR1cm4gdGhpcy5sb2FkTWVkaWFFbGVtZW50KGUsdCxyLG4pfX19LHtrZXk6XCJsb2FkQnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXRoaXMsaT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmbi50bXBFdmVudHMucHVzaChuLm9uY2UoXCJyZWFkeVwiLGUpKSxuLmdldEFycmF5QnVmZmVyKHQsZnVuY3Rpb24oZSl7cmV0dXJuIG4ubG9hZEFycmF5QnVmZmVyKGUpfSl9O2lmKCFlKXJldHVybiBpKCk7dGhpcy5iYWNrZW5kLnNldFBlYWtzKGUsciksdGhpcy5kcmF3QnVmZmVyKCksdGhpcy50bXBFdmVudHMucHVzaCh0aGlzLm9uY2UoXCJpbnRlcmFjdGlvblwiLGkpKX19LHtrZXk6XCJsb2FkTWVkaWFFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9dGhpcyxhPWU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdGhpcy5iYWNrZW5kLmxvYWQoYSx0aGlzLm1lZGlhQ29udGFpbmVyLHQscik7ZWxzZXt2YXIgcz1lO3RoaXMuYmFja2VuZC5sb2FkRWx0KHMsdCksYT1zLnNyY310aGlzLnRtcEV2ZW50cy5wdXNoKHRoaXMuYmFja2VuZC5vbmNlKFwiY2FucGxheVwiLGZ1bmN0aW9uKCl7aS5kcmF3QnVmZmVyKCksaS5maXJlRXZlbnQoXCJyZWFkeVwiKSxpLmlzUmVhZHk9ITB9KSx0aGlzLmJhY2tlbmQub25jZShcImVycm9yXCIsZnVuY3Rpb24oZSl7cmV0dXJuIGkuZmlyZUV2ZW50KFwiZXJyb3JcIixlKX0pKSx0JiZ0aGlzLmJhY2tlbmQuc2V0UGVha3ModCxuKSx0JiYhdGhpcy5wYXJhbXMuZm9yY2VEZWNvZGV8fCF0aGlzLmJhY2tlbmQuc3VwcG9ydHNXZWJBdWRpbygpfHx0aGlzLmdldEFycmF5QnVmZmVyKGEsZnVuY3Rpb24oZSl7aS5kZWNvZGVBcnJheUJ1ZmZlcihlLGZ1bmN0aW9uKGUpe2kuYmFja2VuZC5idWZmZXI9ZSxpLmJhY2tlbmQuc2V0UGVha3MobnVsbCksaS5kcmF3QnVmZmVyKCksaS5maXJlRXZlbnQoXCJ3YXZlZm9ybS1yZWFkeVwiKX0pfSl9fSx7a2V5OlwiZGVjb2RlQXJyYXlCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBuPXRoaXM7dGhpcy5hcnJheWJ1ZmZlcj10LHRoaXMuYmFja2VuZC5kZWNvZGVBcnJheUJ1ZmZlcih0LGZ1bmN0aW9uKGUpe24uaXNEZXN0cm95ZWR8fG4uYXJyYXlidWZmZXIhPXR8fChyKGUpLG4uYXJyYXlidWZmZXI9bnVsbCl9LGZ1bmN0aW9uKCl7cmV0dXJuIG4uZmlyZUV2ZW50KFwiZXJyb3JcIixcIkVycm9yIGRlY29kaW5nIGF1ZGlvYnVmZmVyXCIpfSl9fSx7a2V5OlwiZ2V0QXJyYXlCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlLHIpe3ZhciBuPXRoaXMsdD1pLmFqYXgoe3VybDplLHJlc3BvbnNlVHlwZTpcImFycmF5YnVmZmVyXCIseGhyOnRoaXMucGFyYW1zLnhocn0pO3JldHVybiB0aGlzLmN1cnJlbnRBamF4PXQsdGhpcy50bXBFdmVudHMucHVzaCh0Lm9uKFwicHJvZ3Jlc3NcIixmdW5jdGlvbihlKXtuLm9uUHJvZ3Jlc3MoZSl9KSx0Lm9uKFwic3VjY2Vzc1wiLGZ1bmN0aW9uKGUsdCl7cihlKSxuLmN1cnJlbnRBamF4PW51bGx9KSx0Lm9uKFwiZXJyb3JcIixmdW5jdGlvbihlKXtuLmZpcmVFdmVudChcImVycm9yXCIsXCJYSFIgZXJyb3I6IFwiK2UudGFyZ2V0LnN0YXR1c1RleHQpLG4uY3VycmVudEFqYXg9bnVsbH0pKSx0fX0se2tleTpcIm9uUHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdDt0PWUubGVuZ3RoQ29tcHV0YWJsZT9lLmxvYWRlZC9lLnRvdGFsOmUubG9hZGVkLyhlLmxvYWRlZCsxZTYpLHRoaXMuZmlyZUV2ZW50KFwibG9hZGluZ1wiLE1hdGgucm91bmQoMTAwKnQpLGUudGFyZ2V0KX19LHtrZXk6XCJleHBvcnRQQ01cIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXtlPWV8fDEwMjQsbj1ufHwwLHQ9dHx8MWU0LHI9cnx8ITE7dmFyIGk9dGhpcy5iYWNrZW5kLmdldFBlYWtzKGUsbiksYT1bXS5tYXAuY2FsbChpLGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLnJvdW5kKGUqdCkvdH0pLHM9SlNPTi5zdHJpbmdpZnkoYSk7cmV0dXJuIHJ8fHdpbmRvdy5vcGVuKFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgsXCIrZW5jb2RlVVJJQ29tcG9uZW50KHMpKSxzfX0se2tleTpcImV4cG9ydEltYWdlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZXx8KGU9XCJpbWFnZS9wbmdcIiksdHx8KHQ9MSksdGhpcy5kcmF3ZXIuZ2V0SW1hZ2UoZSx0KX19LHtrZXk6XCJjYW5jZWxBamF4XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmN1cnJlbnRBamF4JiYodGhpcy5jdXJyZW50QWpheC54aHIuYWJvcnQoKSx0aGlzLmN1cnJlbnRBamF4PW51bGwpfX0se2tleTpcImNsZWFyVG1wRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnRtcEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnVuKCl9KX19LHtrZXk6XCJlbXB0eVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5iYWNrZW5kLmlzUGF1c2VkKCl8fCh0aGlzLnN0b3AoKSx0aGlzLmJhY2tlbmQuZGlzY29ubmVjdFNvdXJjZSgpKSx0aGlzLmlzUmVhZHk9ITEsdGhpcy5jYW5jZWxBamF4KCksdGhpcy5jbGVhclRtcEV2ZW50cygpLHRoaXMuZHJhd2VyLnByb2dyZXNzKDApLHRoaXMuZHJhd2VyLnNldFdpZHRoKDApLHRoaXMuZHJhd2VyLmRyYXdQZWFrcyh7bGVuZ3RoOnRoaXMuZHJhd2VyLmdldFdpZHRoKCl9LDApfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGVzdHJveUFsbFBsdWdpbnMoKSx0aGlzLmZpcmVFdmVudChcImRlc3Ryb3lcIiksdGhpcy5jYW5jZWxBamF4KCksdGhpcy5jbGVhclRtcEV2ZW50cygpLHRoaXMudW5BbGwoKSwhMSE9PXRoaXMucGFyYW1zLnJlc3BvbnNpdmUmJih3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMuX29uUmVzaXplLCEwKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsdGhpcy5fb25SZXNpemUsITApKSx0aGlzLmJhY2tlbmQuZGVzdHJveSgpLHRoaXMuZHJhd2VyLmRlc3Ryb3koKSx0aGlzLmlzRGVzdHJveWVkPSEwLHRoaXMuaXNSZWFkeT0hMSx0aGlzLmFycmF5YnVmZmVyPW51bGx9fV0pLG59KCk7KHQuZGVmYXVsdD1tKS5WRVJTSU9OPVwiMi4xLjBcIixtLnV0aWw9aSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBpLmRlZmF1bHQscj1uZXcgWE1MSHR0cFJlcXVlc3Qsbj0hMTtyLm9wZW4oZS5tZXRob2R8fFwiR0VUXCIsZS51cmwsITApLHIucmVzcG9uc2VUeXBlPWUucmVzcG9uc2VUeXBlfHxcImpzb25cIixlLnhociYmKGUueGhyLnJlcXVlc3RIZWFkZXJzJiZlLnhoci5yZXF1ZXN0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3Iuc2V0UmVxdWVzdEhlYWRlcihlLmtleSxlLnZhbHVlKX0pLGUueGhyLndpdGhDcmVkZW50aWFscyYmKHIud2l0aENyZWRlbnRpYWxzPSEwKSk7cmV0dXJuIHIuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsZnVuY3Rpb24oZSl7dC5maXJlRXZlbnQoXCJwcm9ncmVzc1wiLGUpLGUubGVuZ3RoQ29tcHV0YWJsZSYmZS5sb2FkZWQ9PWUudG90YWwmJihuPSEwKX0pLHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbihlKXtufHx0LmZpcmVFdmVudChcInByb2dyZXNzXCIsZSksdC5maXJlRXZlbnQoXCJsb2FkXCIsZSksMjAwPT1yLnN0YXR1c3x8MjA2PT1yLnN0YXR1cz90LmZpcmVFdmVudChcInN1Y2Nlc3NcIixyLnJlc3BvbnNlLGUpOnQuZmlyZUV2ZW50KFwiZXJyb3JcIixlKX0pLHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQuZmlyZUV2ZW50KFwiZXJyb3JcIixlKX0pLHIuc2VuZCgpLHQueGhyPXIsdH07dmFyIG4saT0obj1yKDEpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07ZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbigpe3JldHVyblwid2F2ZXN1cmZlcl9cIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDMyKS5zdWJzdHJpbmcoMil9LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24odCl7dmFyIHI9LTEvMDtyZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPnImJihyPXRbZV0pfSkscn0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbih0KXt2YXIgcj1OdW1iZXIoMS8wKTtyZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPHImJihyPXRbZV0pfSkscn0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbihyKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheSgxPGU/ZS0xOjApLG49MTtuPGU7bisrKXRbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JbZV09dFtlXX0pfSkscn0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbih0LHIpe3JldHVybiBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3Quc3R5bGVbZV0hPT1yW2VdJiYodC5zdHlsZVtlXT1yW2VdKX0pLHR9LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuKDAsaS5kZWZhdWx0KShmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KHZvaWQgMCx0KX0pfX07dmFyIG4saT0obj1yKDIpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07ZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKHQscixuKXt2YXIgaSxhLHMsbyx1O2Z1bmN0aW9uIGwoKXt2YXIgZT1EYXRlLm5vdygpLW87ZTxyJiYwPD1lP2k9c2V0VGltZW91dChsLHItZSk6KGk9bnVsbCxufHwodT10LmFwcGx5KHMsYSkscz1hPW51bGwpKX1udWxsPT1yJiYocj0xMDApO3ZhciBlPWZ1bmN0aW9uKCl7cz10aGlzLGE9YXJndW1lbnRzLG89RGF0ZS5ub3coKTt2YXIgZT1uJiYhaTtyZXR1cm4gaXx8KGk9c2V0VGltZW91dChsLHIpKSxlJiYodT10LmFwcGx5KHMsYSkscz1hPW51bGwpLHV9O3JldHVybiBlLmNsZWFyPWZ1bmN0aW9uKCl7aSYmKGNsZWFyVGltZW91dChpKSxpPW51bGwpfSxlLmZsdXNoPWZ1bmN0aW9uKCl7aSYmKHU9dC5hcHBseShzLGEpLHM9YT1udWxsLGNsZWFyVGltZW91dChpKSxpPW51bGwpfSxlfXIuZGVib3VuY2U9cixlLmV4cG9ydHM9cn0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSxkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLG4sITApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbihlKXtkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLG4sITApfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixhPShuPXIoMTUpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0sZj1mdW5jdGlvbihlKXt7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikpe3ZhciBuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUscik6e307bi5nZXR8fG4uc2V0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsbik6dFtyXT1lW3JdfXJldHVybiB0LmRlZmF1bHQ9ZSx0fX0ocigwKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4oaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09aSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXJldHVybiBlO3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0oZSk6dH1mdW5jdGlvbiB1KGUpe3JldHVybih1PU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBsKGUsdCl7cmV0dXJuKGw9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfXZhciBjPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSx0KXt2YXIgcjtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLG4pLChyPW8odGhpcyx1KG4pLmNhbGwodGhpcyxlLHQpKSkubWF4Q2FudmFzV2lkdGg9dC5tYXhDYW52YXNXaWR0aCxyLm1heENhbnZhc0VsZW1lbnRXaWR0aD1NYXRoLnJvdW5kKHQubWF4Q2FudmFzV2lkdGgvdC5waXhlbFJhdGlvKSxyLmhhc1Byb2dyZXNzQ2FudmFzPXQud2F2ZUNvbG9yIT10LnByb2dyZXNzQ29sb3Isci5oYWxmUGl4ZWw9LjUvdC5waXhlbFJhdGlvLHIuY2FudmFzZXM9W10sci5wcm9ncmVzc1dhdmU9bnVsbCxyfXZhciB0LHIsaTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJmwoZSx0KX0obixhLmRlZmF1bHQpLHQ9biwocj1be2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3JlYXRlV3JhcHBlcigpLHRoaXMuY3JlYXRlRWxlbWVudHMoKX19LHtrZXk6XCJjcmVhdGVFbGVtZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9ncmVzc1dhdmU9dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3R5bGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIndhdmVcIikse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix6SW5kZXg6MyxsZWZ0OjAsdG9wOjAsYm90dG9tOjAsb3ZlcmZsb3c6XCJoaWRkZW5cIix3aWR0aDpcIjBcIixkaXNwbGF5Olwibm9uZVwiLGJveFNpemluZzpcImJvcmRlci1ib3hcIixib3JkZXJSaWdodFN0eWxlOlwic29saWRcIixwb2ludGVyRXZlbnRzOlwibm9uZVwifSkpLHRoaXMuYWRkQ2FudmFzKCksdGhpcy51cGRhdGVDdXJzb3IoKX19LHtrZXk6XCJ1cGRhdGVDdXJzb3JcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUse2JvcmRlclJpZ2h0V2lkdGg6dGhpcy5wYXJhbXMuY3Vyc29yV2lkdGgrXCJweFwiLGJvcmRlclJpZ2h0Q29sb3I6dGhpcy5wYXJhbXMuY3Vyc29yQ29sb3J9KX19LHtrZXk6XCJ1cGRhdGVTaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIG49dGhpcyxlPU1hdGgucm91bmQodGhpcy53aWR0aC90aGlzLnBhcmFtcy5waXhlbFJhdGlvKSx0PU1hdGguY2VpbChlL3RoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoKTt0aGlzLmNhbnZhc2VzLmxlbmd0aDx0Oyl0aGlzLmFkZENhbnZhcygpO2Zvcig7dGhpcy5jYW52YXNlcy5sZW5ndGg+dDspdGhpcy5yZW1vdmVDYW52YXMoKTt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSx0KXt2YXIgcj1uLm1heENhbnZhc1dpZHRoKzIqTWF0aC5jZWlsKG4ucGFyYW1zLnBpeGVsUmF0aW8vMik7dD09bi5jYW52YXNlcy5sZW5ndGgtMSYmKHI9bi53aWR0aC1uLm1heENhbnZhc1dpZHRoKihuLmNhbnZhc2VzLmxlbmd0aC0xKSksbi51cGRhdGVEaW1lbnNpb25zKGUscixuLmhlaWdodCksbi5jbGVhcldhdmVGb3JFbnRyeShlKX0pfX0se2tleTpcImFkZENhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9e30sdD10aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aCp0aGlzLmNhbnZhc2VzLmxlbmd0aDtlLndhdmU9dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3R5bGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHpJbmRleDoyLGxlZnQ6dCtcInB4XCIsdG9wOjAsYm90dG9tOjAsaGVpZ2h0OlwiMTAwJVwiLHBvaW50ZXJFdmVudHM6XCJub25lXCJ9KSksZS53YXZlQ3R4PWUud2F2ZS5nZXRDb250ZXh0KFwiMmRcIiksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmKGUucHJvZ3Jlc3M9dGhpcy5wcm9ncmVzc1dhdmUuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHtwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDp0K1wicHhcIix0b3A6MCxib3R0b206MCxoZWlnaHQ6XCIxMDAlXCJ9KSksZS5wcm9ncmVzc0N0eD1lLnByb2dyZXNzLmdldENvbnRleHQoXCIyZFwiKSksdGhpcy5jYW52YXNlcy5wdXNoKGUpfX0se2tleTpcInJlbW92ZUNhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jYW52YXNlcy5wb3AoKTtlLndhdmUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlLndhdmUpLHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMmJmUucHJvZ3Jlc3MucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlLnByb2dyZXNzKX19LHtrZXk6XCJ1cGRhdGVEaW1lbnNpb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPU1hdGgucm91bmQodC90aGlzLnBhcmFtcy5waXhlbFJhdGlvKSxpPU1hdGgucm91bmQodGhpcy53aWR0aC90aGlzLnBhcmFtcy5waXhlbFJhdGlvKTtlLnN0YXJ0PWUud2F2ZUN0eC5jYW52YXMub2Zmc2V0TGVmdC9pfHwwLGUuZW5kPWUuc3RhcnQrbi9pLGUud2F2ZUN0eC5jYW52YXMud2lkdGg9dCxlLndhdmVDdHguY2FudmFzLmhlaWdodD1yLHRoaXMuc3R5bGUoZS53YXZlQ3R4LmNhbnZhcyx7d2lkdGg6bitcInB4XCJ9KSx0aGlzLnN0eWxlKHRoaXMucHJvZ3Jlc3NXYXZlLHtkaXNwbGF5OlwiYmxvY2tcIn0pLHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMmJihlLnByb2dyZXNzQ3R4LmNhbnZhcy53aWR0aD10LGUucHJvZ3Jlc3NDdHguY2FudmFzLmhlaWdodD1yLHRoaXMuc3R5bGUoZS5wcm9ncmVzc0N0eC5jYW52YXMse3dpZHRoOm4rXCJweFwifSkpfX0se2tleTpcImNsZWFyV2F2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2xlYXJXYXZlRm9yRW50cnkoZSl9KX19LHtrZXk6XCJjbGVhcldhdmVGb3JFbnRyeVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Uud2F2ZUN0eC5jbGVhclJlY3QoMCwwLGUud2F2ZUN0eC5jYW52YXMud2lkdGgsZS53YXZlQ3R4LmNhbnZhcy5oZWlnaHQpLHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMmJmUucHJvZ3Jlc3NDdHguY2xlYXJSZWN0KDAsMCxlLnByb2dyZXNzQ3R4LmNhbnZhcy53aWR0aCxlLnByb2dyZXNzQ3R4LmNhbnZhcy5oZWlnaHQpfX0se2tleTpcImRyYXdCYXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHYseSl7dmFyIG09dGhpcztyZXR1cm4gdGhpcy5wcmVwYXJlRHJhdyhlLHQsdix5LGZ1bmN0aW9uKGUpe3ZhciB0PWUuYWJzbWF4LHI9ZS5oYXNNaW5WYWxzLG49KGUuaGVpZ2h0LGUub2Zmc2V0WSksaT1lLmhhbGZILGE9ZS5wZWFrcztpZih2b2lkIDAhPT12KXt2YXIgcyxvPXI/MjoxLHU9YS5sZW5ndGgvbyxsPW0ucGFyYW1zLmJhcldpZHRoKm0ucGFyYW1zLnBpeGVsUmF0aW8sYz1sKyhudWxsPT09bS5wYXJhbXMuYmFyR2FwP01hdGgubWF4KG0ucGFyYW1zLnBpeGVsUmF0aW8sfn4obC8yKSk6TWF0aC5tYXgobS5wYXJhbXMucGl4ZWxSYXRpbyxtLnBhcmFtcy5iYXJHYXAqbS5wYXJhbXMucGl4ZWxSYXRpbykpLGg9dS9tLndpZHRoLGY9eTtmb3Iocz12O3M8ZjtzKz1jKXt2YXIgZD1hW01hdGguZmxvb3IocypoKm8pXXx8MCxwPU1hdGgucm91bmQoZC90KmkpO20uZmlsbFJlY3QocyttLmhhbGZQaXhlbCxpLXArbixsK20uaGFsZlBpeGVsLDIqcCl9fX0pfX0se2tleTpcImRyYXdXYXZlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGwsYyl7dmFyIGg9dGhpcztyZXR1cm4gdGhpcy5wcmVwYXJlRHJhdyhlLHQsbCxjLGZ1bmN0aW9uKGUpe3ZhciB0PWUuYWJzbWF4LHI9ZS5oYXNNaW5WYWxzLG49KGUuaGVpZ2h0LGUub2Zmc2V0WSksaT1lLmhhbGZILGE9ZS5wZWFrcztpZighcil7dmFyIHMsbz1bXSx1PWEubGVuZ3RoO2ZvcihzPTA7czx1O3MrKylvWzIqc109YVtzXSxvWzIqcysxXT0tYVtzXTthPW99dm9pZCAwIT09bCYmaC5kcmF3TGluZShhLHQsaSxuLGwsYyksaC5maWxsUmVjdCgwLGkrbi1oLmhhbGZQaXhlbCxoLndpZHRoLGguaGFsZlBpeGVsKX0pfX0se2tleTpcImRyYXdMaW5lXCIsdmFsdWU6ZnVuY3Rpb24odCxyLG4saSxhLHMpe3ZhciBvPXRoaXM7dGhpcy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe28uc2V0RmlsbFN0eWxlcyhlKSxvLmRyYXdMaW5lVG9Db250ZXh0KGUsZS53YXZlQ3R4LHQscixuLGksYSxzKSxvLmRyYXdMaW5lVG9Db250ZXh0KGUsZS5wcm9ncmVzc0N0eCx0LHIsbixpLGEscyl9KX19LHtrZXk6XCJkcmF3TGluZVRvQ29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4saSxhLHMsbyl7aWYodCl7dmFyIHU9ci5sZW5ndGgvMixsPXRoaXMucGFyYW1zLmZpbGxQYXJlbnQmJnRoaXMud2lkdGghPXU/dGhpcy53aWR0aC91OjEsYz1NYXRoLnJvdW5kKHUqZS5zdGFydCksaD1NYXRoLnJvdW5kKHUqZS5lbmQpKzE7aWYoIShvPGN8fGg8cykpe3ZhciBmLGQscD1NYXRoLm1pbihjLHMpLHY9TWF0aC5tYXgoaCxvKTtmb3IodC5iZWdpblBhdGgoKSx0Lm1vdmVUbygocC1jKSpsK3RoaXMuaGFsZlBpeGVsLGkrYSksZj1wO2Y8djtmKyspe3ZhciB5PXJbMipmXXx8MCxtPU1hdGgucm91bmQoeS9uKmkpO3QubGluZVRvKChmLWMpKmwrdGhpcy5oYWxmUGl4ZWwsaS1tK2EpfWZvcihkPXYtMTtwPD1kO2QtLSl7dmFyIGI9clsyKmQrMV18fDAsZz1NYXRoLnJvdW5kKGIvbippKTt0LmxpbmVUbygoZC1jKSpsK3RoaXMuaGFsZlBpeGVsLGktZythKX10LmNsb3NlUGF0aCgpLHQuZmlsbCgpfX19fSx7a2V5OlwiZmlsbFJlY3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXt2YXIgaSxhPU1hdGguZmxvb3IoZS90aGlzLm1heENhbnZhc1dpZHRoKSxzPU1hdGgubWluKE1hdGguY2VpbCgoZStyKS90aGlzLm1heENhbnZhc1dpZHRoKSsxLHRoaXMuY2FudmFzZXMubGVuZ3RoKTtmb3IoaT1hO2k8cztpKyspe3ZhciBvPXRoaXMuY2FudmFzZXNbaV0sdT1pKnRoaXMubWF4Q2FudmFzV2lkdGgsbD17eDE6TWF0aC5tYXgoZSxpKnRoaXMubWF4Q2FudmFzV2lkdGgpLHkxOnQseDI6TWF0aC5taW4oZStyLGkqdGhpcy5tYXhDYW52YXNXaWR0aCtvLndhdmVDdHguY2FudmFzLndpZHRoKSx5Mjp0K259O2wueDE8bC54MiYmKHRoaXMuc2V0RmlsbFN0eWxlcyhvKSx0aGlzLmZpbGxSZWN0VG9Db250ZXh0KG8ud2F2ZUN0eCxsLngxLXUsbC55MSxsLngyLWwueDEsbC55Mi1sLnkxKSx0aGlzLmZpbGxSZWN0VG9Db250ZXh0KG8ucHJvZ3Jlc3NDdHgsbC54MS11LGwueTEsbC54Mi1sLngxLGwueTItbC55MSkpfX19LHtrZXk6XCJwcmVwYXJlRHJhd1wiLHZhbHVlOmZ1bmN0aW9uKHMsbyx1LGwsYyl7dmFyIGg9dGhpcztyZXR1cm4gZi5mcmFtZShmdW5jdGlvbigpe2lmKHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgZT1zO2lmKGgucGFyYW1zLnNwbGl0Q2hhbm5lbHMpcmV0dXJuIGguc2V0SGVpZ2h0KGUubGVuZ3RoKmgucGFyYW1zLmhlaWdodCpoLnBhcmFtcy5waXhlbFJhdGlvKSxlLmZvckVhY2goZnVuY3Rpb24oZSx0KXtyZXR1cm4gaC5wcmVwYXJlRHJhdyhlLHQsdSxsLGMpfSk7cz1lWzBdfXZhciB0PTEvaC5wYXJhbXMuYmFySGVpZ2h0O2lmKGgucGFyYW1zLm5vcm1hbGl6ZSl7dmFyIHI9Zi5tYXgocyksbj1mLm1pbihzKTt0PXI8LW4/LW46cn12YXIgaT1bXS5zb21lLmNhbGwocyxmdW5jdGlvbihlKXtyZXR1cm4gZTwwfSksYT1oLnBhcmFtcy5oZWlnaHQqaC5wYXJhbXMucGl4ZWxSYXRpbztyZXR1cm4gYyh7YWJzbWF4OnQsaGFzTWluVmFsczppLGhlaWdodDphLG9mZnNldFk6YSpvfHwwLGhhbGZIOmEvMixwZWFrczpzfSl9KSgpfX0se2tleTpcImZpbGxSZWN0VG9Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbixpKXtlJiZlLmZpbGxSZWN0KHQscixuLGkpfX0se2tleTpcInNldEZpbGxTdHlsZXNcIix2YWx1ZTpmdW5jdGlvbihlKXtlLndhdmVDdHguZmlsbFN0eWxlPXRoaXMucGFyYW1zLndhdmVDb2xvcix0aGlzLmhhc1Byb2dyZXNzQ2FudmFzJiYoZS5wcm9ncmVzc0N0eC5maWxsU3R5bGU9dGhpcy5wYXJhbXMucHJvZ3Jlc3NDb2xvcil9fSx7a2V5OlwiZ2V0SW1hZ2VcIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBlPXRoaXMuY2FudmFzZXMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLndhdmUudG9EYXRhVVJMKHQscil9KTtyZXR1cm4gMTxlLmxlbmd0aD9lOmVbMF19fSx7a2V5OlwidXBkYXRlUHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnN0eWxlKHRoaXMucHJvZ3Jlc3NXYXZlLHt3aWR0aDplK1wicHhcIn0pfX1dKSYmcyh0LnByb3RvdHlwZSxyKSxpJiZzKHQsaSksbn0oKTt0LmRlZmF1bHQ9YyxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgYT1mdW5jdGlvbihlKXt7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikpe3ZhciBuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUscik6e307bi5nZXR8fG4uc2V0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsbik6dFtyXT1lW3JdfXJldHVybiB0LmRlZmF1bHQ9ZSx0fX0ocigwKSk7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09bih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXJldHVybiBlO3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0oZSk6dH1mdW5jdGlvbiB1KGUpe3JldHVybih1PU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBsKGUsdCl7cmV0dXJuKGw9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfXZhciBpPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSx0KXt2YXIgcjtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLG4pLChyPW8odGhpcyx1KG4pLmNhbGwodGhpcykpKS5jb250YWluZXI9ZSxyLnBhcmFtcz10LHIud2lkdGg9MCxyLmhlaWdodD10LmhlaWdodCpyLnBhcmFtcy5waXhlbFJhdGlvLHIubGFzdFBvcz0wLHIud3JhcHBlcj1udWxsLHJ9dmFyIHQscixpO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbChlLHQpfShuLGEuT2JzZXJ2ZXIpLHQ9biwocj1be2tleTpcInN0eWxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYS5zdHlsZShlLHQpfX0se2tleTpcImNyZWF0ZVdyYXBwZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMud3JhcHBlcj10aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwid2F2ZVwiKSksdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIse2Rpc3BsYXk6XCJibG9ja1wiLHBvc2l0aW9uOlwicmVsYXRpdmVcIix1c2VyU2VsZWN0Olwibm9uZVwiLHdlYmtpdFVzZXJTZWxlY3Q6XCJub25lXCIsaGVpZ2h0OnRoaXMucGFyYW1zLmhlaWdodCtcInB4XCJ9KSwodGhpcy5wYXJhbXMuZmlsbFBhcmVudHx8dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50KSYmdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIse3dpZHRoOlwiMTAwJVwiLG92ZXJmbG93WDp0aGlzLnBhcmFtcy5oaWRlU2Nyb2xsYmFyP1wiaGlkZGVuXCI6XCJhdXRvXCIsb3ZlcmZsb3dZOlwiaGlkZGVuXCJ9KSx0aGlzLnNldHVwV3JhcHBlckV2ZW50cygpfX0se2tleTpcImhhbmRsZUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXshdCYmZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciByLG49ZS50YXJnZXRUb3VjaGVzP2UudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYOmUuY2xpZW50WCxpPXRoaXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxhPXRoaXMud2lkdGgscz10aGlzLmdldFdpZHRoKCk7cmV0dXJuIXRoaXMucGFyYW1zLmZpbGxQYXJlbnQmJmE8cz8xPChyPShuLWkubGVmdCkqKHRoaXMucGFyYW1zLnBpeGVsUmF0aW8vYSl8fDApJiYocj0xKTpyPShuLWkubGVmdCt0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdCkvdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRofHwwLHJ9fSx7a2V5Olwic2V0dXBXcmFwcGVyRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgbj10aGlzO3RoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbihlKXt2YXIgdD1uLndyYXBwZXIub2Zmc2V0SGVpZ2h0LW4ud3JhcHBlci5jbGllbnRIZWlnaHQ7aWYoMCE9dCl7dmFyIHI9bi53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKGUuY2xpZW50WT49ci5ib3R0b20tdClyZXR1cm59bi5wYXJhbXMuaW50ZXJhY3QmJm4uZmlyZUV2ZW50KFwiY2xpY2tcIixlLG4uaGFuZGxlRXZlbnQoZSkpfSksdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixmdW5jdGlvbihlKXtyZXR1cm4gbi5maXJlRXZlbnQoXCJzY3JvbGxcIixlKX0pfX0se2tleTpcImRyYXdQZWFrc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe3RoaXMuc2V0V2lkdGgodCl8fHRoaXMuY2xlYXJXYXZlKCksdGhpcy5wYXJhbXMuYmFyV2lkdGg/dGhpcy5kcmF3QmFycyhlLDAscixuKTp0aGlzLmRyYXdXYXZlKGUsMCxyLG4pfX0se2tleTpcInJlc2V0U2Nyb2xsXCIsdmFsdWU6ZnVuY3Rpb24oKXtudWxsIT09dGhpcy53cmFwcGVyJiYodGhpcy53cmFwcGVyLnNjcm9sbExlZnQ9MCl9fSx7a2V5OlwicmVjZW50ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGgqZTt0aGlzLnJlY2VudGVyT25Qb3NpdGlvbih0LCEwKX19LHtrZXk6XCJyZWNlbnRlck9uUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMud3JhcHBlci5zY3JvbGxMZWZ0LG49fn4odGhpcy53cmFwcGVyLmNsaWVudFdpZHRoLzIpLGk9dGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoLXRoaXMud3JhcHBlci5jbGllbnRXaWR0aCxhPWUtbixzPWEtcjtpZigwIT1pKXtpZighdCYmLW48PXMmJnM8bil7YT1yKyhzPU1hdGgubWF4KC01LE1hdGgubWluKDUscykpKX0oYT1NYXRoLm1heCgwLE1hdGgubWluKGksYSkpKSE9ciYmKHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0PWEpfX19LHtrZXk6XCJnZXRTY3JvbGxYXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnBhcmFtcy5waXhlbFJhdGlvLHQ9TWF0aC5yb3VuZCh0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdCplKTtpZih0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpe3ZhciByPX5+KHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCplLXRoaXMuZ2V0V2lkdGgoKSk7dD1NYXRoLm1pbihyLE1hdGgubWF4KDAsdCkpfXJldHVybiB0fX0se2tleTpcImdldFdpZHRoXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCp0aGlzLnBhcmFtcy5waXhlbFJhdGlvKX19LHtrZXk6XCJzZXRXaWR0aFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLndpZHRoIT1lJiYodGhpcy53aWR0aD1lLHRoaXMucGFyYW1zLmZpbGxQYXJlbnR8fHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudD90aGlzLnN0eWxlKHRoaXMud3JhcHBlcix7d2lkdGg6XCJcIn0pOnRoaXMuc3R5bGUodGhpcy53cmFwcGVyLHt3aWR0aDp+fih0aGlzLndpZHRoL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pK1wicHhcIn0pLHRoaXMudXBkYXRlU2l6ZSgpLCEwKX19LHtrZXk6XCJzZXRIZWlnaHRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSE9dGhpcy5oZWlnaHQmJih0aGlzLmhlaWdodD1lLHRoaXMuc3R5bGUodGhpcy53cmFwcGVyLHtoZWlnaHQ6fn4odGhpcy5oZWlnaHQvdGhpcy5wYXJhbXMucGl4ZWxSYXRpbykrXCJweFwifSksdGhpcy51cGRhdGVTaXplKCksITApfX0se2tleTpcInByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MS90aGlzLnBhcmFtcy5waXhlbFJhdGlvLHI9TWF0aC5yb3VuZChlKnRoaXMud2lkdGgpKnQ7aWYocjx0aGlzLmxhc3RQb3N8fHItdGhpcy5sYXN0UG9zPj10KXtpZih0aGlzLmxhc3RQb3M9cix0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQmJnRoaXMucGFyYW1zLmF1dG9DZW50ZXIpe3ZhciBuPX5+KHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCplKTt0aGlzLnJlY2VudGVyT25Qb3NpdGlvbihuKX10aGlzLnVwZGF0ZVByb2dyZXNzKHIpfX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnVuQWxsKCksdGhpcy53cmFwcGVyJiYodGhpcy53cmFwcGVyLnBhcmVudE5vZGU9PXRoaXMuY29udGFpbmVyJiZ0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpLHRoaXMud3JhcHBlcj1udWxsKX19LHtrZXk6XCJ1cGRhdGVDdXJzb3JcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJ1cGRhdGVTaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwiZHJhd0JhcnNcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXt9fSx7a2V5OlwiZHJhd1dhdmVcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXt9fSx7a2V5OlwiY2xlYXJXYXZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwidXBkYXRlUHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt9fV0pJiZzKHQucHJvdG90eXBlLHIpLGkmJnModCxpKSxufSgpO3QuZGVmYXVsdD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGE9KG49cigzKSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59OyFmdW5jdGlvbihlKXt7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybjt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpKXt2YXIgbj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOnt9O24uZ2V0fHxuLnNldD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4pOnRbcl09ZVtyXX10LmRlZmF1bHQ9ZX19KHIoMCkpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuKGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHMoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PWkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZnVuY3Rpb24oZSl7aWYodm9pZCAwIT09ZSlyZXR1cm4gZTt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIil9KGUpOnR9ZnVuY3Rpb24gdShlLHQscil7cmV0dXJuKHU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1mdW5jdGlvbihlLHQpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiZudWxsIT09KGU9bChlKSk7KTtyZXR1cm4gZX0oZSx0KTtpZihuKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7cmV0dXJuIGkuZ2V0P2kuZ2V0LmNhbGwocik6aS52YWx1ZX19KShlLHQscnx8ZSl9ZnVuY3Rpb24gbChlKXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gYyhlLHQpe3JldHVybihjPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX12YXIgaD1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKGUpe3ZhciB0O3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbiksKHQ9byh0aGlzLGwobikuY2FsbCh0aGlzLGUpKSkucGFyYW1zPWUsdC5tZWRpYT17Y3VycmVudFRpbWU6MCxkdXJhdGlvbjowLHBhdXNlZDohMCxwbGF5YmFja1JhdGU6MSxwbGF5OmZ1bmN0aW9uKCl7fSxwYXVzZTpmdW5jdGlvbigpe30sdm9sdW1lOjB9LHQubWVkaWFUeXBlPWUubWVkaWFUeXBlLnRvTG93ZXJDYXNlKCksdC5lbGVtZW50UG9zaXRpb249ZS5lbGVtZW50UG9zaXRpb24sdC5wZWFrcz1udWxsLHQucGxheWJhY2tSYXRlPTEsdC52b2x1bWU9MSx0LmJ1ZmZlcj1udWxsLHQub25QbGF5RW5kPW51bGwsdH12YXIgdCxyLGk7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZjKGUsdCl9KG4sYS5kZWZhdWx0KSx0PW4sKHI9W3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBhcmFtcy5hdWRpb1JhdGUpLHRoaXMuY3JlYXRlVGltZXIoKX19LHtrZXk6XCJjcmVhdGVUaW1lclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLm9uKFwicGxheVwiLGZ1bmN0aW9uIGUoKXt0LmlzUGF1c2VkKCl8fCh0LmZpcmVFdmVudChcImF1ZGlvcHJvY2Vzc1wiLHQuZ2V0Q3VycmVudFRpbWUoKSksKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGUpKX0pLHRoaXMub24oXCJwYXVzZVwiLGZ1bmN0aW9uKCl7dC5maXJlRXZlbnQoXCJhdWRpb3Byb2Nlc3NcIix0LmdldEN1cnJlbnRUaW1lKCkpfSl9fSx7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tZWRpYVR5cGUpO2kuY29udHJvbHM9dGhpcy5wYXJhbXMubWVkaWFDb250cm9scyxpLmF1dG9wbGF5PXRoaXMucGFyYW1zLmF1dG9wbGF5fHwhMSxpLnByZWxvYWQ9bnVsbD09bj9cImF1dG9cIjpuLGkuc3JjPWUsaS5zdHlsZS53aWR0aD1cIjEwMCVcIjt2YXIgYT10LnF1ZXJ5U2VsZWN0b3IodGhpcy5tZWRpYVR5cGUpO2EmJnQucmVtb3ZlQ2hpbGQoYSksdC5hcHBlbmRDaGlsZChpKSx0aGlzLl9sb2FkKGkscil9fSx7a2V5OlwibG9hZEVsdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7ZS5jb250cm9scz10aGlzLnBhcmFtcy5tZWRpYUNvbnRyb2xzLGUuYXV0b3BsYXk9dGhpcy5wYXJhbXMuYXV0b3BsYXl8fCExLHRoaXMuX2xvYWQoZSx0KX19LHtrZXk6XCJfbG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmxvYWQmJmUubG9hZCgpLGUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcImVycm9yXCIsXCJFcnJvciBsb2FkaW5nIG1lZGlhIGVsZW1lbnRcIil9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcImNhbnBsYXlcIil9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLGZ1bmN0aW9uKCl7ci5maXJlRXZlbnQoXCJmaW5pc2hcIil9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcInBsYXlcIil9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLGZ1bmN0aW9uKCl7ci5maXJlRXZlbnQoXCJwYXVzZVwiKX0pLHRoaXMubWVkaWE9ZSx0aGlzLnBlYWtzPXQsdGhpcy5vblBsYXlFbmQ9bnVsbCx0aGlzLmJ1ZmZlcj1udWxsLHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGxheWJhY2tSYXRlKSx0aGlzLnNldFZvbHVtZSh0aGlzLnZvbHVtZSl9fSx7a2V5OlwiaXNQYXVzZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLm1lZGlhfHx0aGlzLm1lZGlhLnBhdXNlZH19LHtrZXk6XCJnZXREdXJhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5leHBsaWNpdER1cmF0aW9uKXJldHVybiB0aGlzLmV4cGxpY2l0RHVyYXRpb247dmFyIGU9KHRoaXMuYnVmZmVyfHx0aGlzLm1lZGlhKS5kdXJhdGlvbjtyZXR1cm4gMS8wPD1lJiYoZT10aGlzLm1lZGlhLnNlZWthYmxlLmVuZCgwKSksZX19LHtrZXk6XCJnZXRDdXJyZW50VGltZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWVkaWEmJnRoaXMubWVkaWEuY3VycmVudFRpbWV9fSx7a2V5OlwiZ2V0UGxheWVkUGVyY2VudHNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkvdGhpcy5nZXREdXJhdGlvbigpfHwwfX0se2tleTpcImdldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlfHx0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZX19LHtrZXk6XCJzZXRQbGF5YmFja1JhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnBsYXliYWNrUmF0ZT1lfHwxLHRoaXMubWVkaWEucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlfX0se2tleTpcInNlZWtUb1wiLHZhbHVlOmZ1bmN0aW9uKGUpe251bGwhPWUmJih0aGlzLm1lZGlhLmN1cnJlbnRUaW1lPWUpLHRoaXMuY2xlYXJQbGF5RW5kKCl9fSx7a2V5OlwicGxheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5zZWVrVG8oZSk7dmFyIHI9dGhpcy5tZWRpYS5wbGF5KCk7cmV0dXJuIHQmJnRoaXMuc2V0UGxheUVuZCh0KSxyfX0se2tleTpcInBhdXNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gdGhpcy5tZWRpYSYmKGU9dGhpcy5tZWRpYS5wYXVzZSgpKSx0aGlzLmNsZWFyUGxheUVuZCgpLGV9fSx7a2V5Olwic2V0UGxheUVuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPXRoaXM7dGhpcy5fb25QbGF5RW5kPWZ1bmN0aW9uKGUpe3Q8PWUmJihyLnBhdXNlKCksci5zZWVrVG8odCkpfSx0aGlzLm9uKFwiYXVkaW9wcm9jZXNzXCIsdGhpcy5fb25QbGF5RW5kKX19LHtrZXk6XCJjbGVhclBsYXlFbmRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX29uUGxheUVuZCYmKHRoaXMudW4oXCJhdWRpb3Byb2Nlc3NcIix0aGlzLl9vblBsYXlFbmQpLHRoaXMuX29uUGxheUVuZD1udWxsKX19LHtrZXk6XCJnZXRQZWFrc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdGhpcy5idWZmZXI/dShsKG4ucHJvdG90eXBlKSxcImdldFBlYWtzXCIsdGhpcykuY2FsbCh0aGlzLGUsdCxyKTp0aGlzLnBlYWtzfHxbXX19LHtrZXk6XCJzZXRTaW5rSWRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT90aGlzLm1lZGlhLnNldFNpbmtJZD90aGlzLm1lZGlhLnNldFNpbmtJZChlKTpQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzZXRTaW5rSWQgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXJcIikpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGV2aWNlSWQ6IFwiK2UpKX19LHtrZXk6XCJnZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZvbHVtZXx8dGhpcy5tZWRpYS52b2x1bWV9fSx7a2V5Olwic2V0Vm9sdW1lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy52b2x1bWU9ZSx0aGlzLm1lZGlhLnZvbHVtZT10aGlzLnZvbHVtZX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBhdXNlKCksdGhpcy51bkFsbCgpLHRoaXMucGFyYW1zLnJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveSYmdGhpcy5tZWRpYSYmdGhpcy5tZWRpYS5wYXJlbnROb2RlJiZ0aGlzLm1lZGlhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tZWRpYSksdGhpcy5tZWRpYT1udWxsfX1dKSYmcyh0LnByb3RvdHlwZSxyKSxpJiZzKHQsaSksbn0oKTt0LmRlZmF1bHQ9aCxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuY2xlYXJQZWFrQ2FjaGUoKX12YXIgdCxyLG47cmV0dXJuIHQ9ZSwocj1be2tleTpcImNsZWFyUGVha0NhY2hlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBlYWtDYWNoZVJhbmdlcz1bXSx0aGlzLnBlYWtDYWNoZUxlbmd0aD0tMX19LHtrZXk6XCJhZGRSYW5nZVRvUGVha0NhY2hlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe2UhPXRoaXMucGVha0NhY2hlTGVuZ3RoJiYodGhpcy5jbGVhclBlYWtDYWNoZSgpLHRoaXMucGVha0NhY2hlTGVuZ3RoPWUpO2Zvcih2YXIgbj1bXSxpPTA7aTx0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGgmJnRoaXMucGVha0NhY2hlUmFuZ2VzW2ldPHQ7KWkrKztmb3IoaSUyPT0wJiZuLnB1c2godCk7aTx0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGgmJnRoaXMucGVha0NhY2hlUmFuZ2VzW2ldPD1yOyluLnB1c2godGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV0pLGkrKztpJTI9PTAmJm4ucHVzaChyKSxuPW4uZmlsdGVyKGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gMD09dD9lIT1yW3QrMV06dD09ci5sZW5ndGgtMT9lIT1yW3QtMV06ZSE9clt0LTFdJiZlIT1yW3QrMV19KSx0aGlzLnBlYWtDYWNoZVJhbmdlcz10aGlzLnBlYWtDYWNoZVJhbmdlcy5jb25jYXQobiksdGhpcy5wZWFrQ2FjaGVSYW5nZXM9dGhpcy5wZWFrQ2FjaGVSYW5nZXMuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBlLXR9KS5maWx0ZXIoZnVuY3Rpb24oZSx0LHIpe3JldHVybiAwPT10P2UhPXJbdCsxXTp0PT1yLmxlbmd0aC0xP2UhPXJbdC0xXTplIT1yW3QtMV0mJmUhPXJbdCsxXX0pO3ZhciBhPVtdO2ZvcihpPTA7aTxuLmxlbmd0aDtpKz0yKWEucHVzaChbbltpXSxuW2krMV1dKTtyZXR1cm4gYX19LHtrZXk6XCJnZXRDYWNoZVJhbmdlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD1bXTtmb3IoZT0wO2U8dGhpcy5wZWFrQ2FjaGVSYW5nZXMubGVuZ3RoO2UrPTIpdC5wdXNoKFt0aGlzLnBlYWtDYWNoZVJhbmdlc1tlXSx0aGlzLnBlYWtDYWNoZVJhbmdlc1tlKzFdXSk7cmV0dXJuIHR9fV0pJiZpKHQucHJvdG90eXBlLHIpLG4mJmkodCxuKSxlfSgpO3QuZGVmYXVsdD1uLGUuZXhwb3J0cz10LmRlZmF1bHR9XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdmVzdXJmZXIubWluLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGliXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbi8vIGluaXRpYWwgc3RhdGVcbmNvbnN0IGluaXRpYWwgPSB7XG5cdG51bWJlcjogMFxufTtcblxuLy8gYWN0aW9uXG5jb25zdCBzZXQgPSBudW1iZXIgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCAnY291bnRlcicsIHtudW1iZXJ9KTtcbmNvbnN0IGluY3IgPSAoKSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsICdjb3VudGVyJywge251bWJlcjogc3RhdGUuY291bnRlci5udW1iZXIgKyAxfSk7XG5jb25zdCBkZWNyID0gKCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCAnY291bnRlcicsIHtudW1iZXI6IHN0YXRlLmNvdW50ZXIubnVtYmVyIC0gMX0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aW5pdGlhbCxcblx0c2V0LFxuXHRpbmNyLFxuXHRkZWNyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqLCBhcnJ9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuLy8gbmFtZXNwYWNlcz1cbmNvbnN0IGNvdW50ZXIgPSByZXF1aXJlKCcuL2NvdW50ZXInKTtcbmNvbnN0IG1pZGlNYXAgPSByZXF1aXJlKCcuL21pZGktbWFwJyk7XG5cbi8vIGluaXRpYWxcbmNvbnN0IGluaXRpYWwgPSB7XG5cdG1vZGU6IDAsXG5cdHN0dDogZmFsc2UsXG5cdHN0dE1pYzogZmFsc2UsXG5cdHF1ZXJ5OiAnJyxcblx0c2Vzc2lvbjoge1xuXHRcdHNhbXBsZTogJ2Fzc2V0cy9MYXRpbkV0aG5vRWxla3Ryb0dyb292ZS5tcDMnLFxuXHRcdHBsYXlpbmc6IGZhbHNlLFxuXHRcdGZvY3VzZWQ6IFswLCAwXSxcblx0XHRwYWRzOiB7fVxuXHR9XG59O1xuXG4vLyBhY3Rpb25zXG5jb25zdCBzZXQgPSAoa2V5LCB2YWx1ZSkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBrZXksIHZhbHVlKTtcbmNvbnN0IHRvZ2dsZSA9IGtleSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIGtleSwgIW9iai5zdWIoc3RhdGUsIGtleSkpO1xuY29uc3QgYXJyVG9nZ2xlID0gKGtleSwgdmFsdWUpID0+IHN0YXRlID0+XG5cdG9iai5wYXRjaChzdGF0ZSwga2V5LFxuXHRcdGFyci50b2dnbGUob2JqLnN1YihzdGF0ZSwga2V5KSwgdmFsdWUpXG5cdCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbml0aWFsLFxuXHQvLyBuYW1lc3BhY2VzXG5cdG1pZGlNYXAsXG5cdC8vIGFjdGlvbnNcblx0c2V0LFxuXHR0b2dnbGUsXG5cdGFyclRvZ2dsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG4vLyB1dGlsXG5jb25zdCB7b2JqLCBhcnJ9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3QgYXJyTW9kID0gKGEsIHAsIHYpID0+IFtdLmNvbmNhdChcblx0YS5zbGljZSgwLCBwWzBdKSxcblx0W3AubGVuZ3RoID09PSAxID8gdiA6IGFyck1vZChhW3BbMF1dLCBwLnNsaWNlKDEpLCB2KV0sXG5cdGEuc2xpY2UocFswXSArIDEpXG4pO1xuXG5jb25zdCBpbml0aWFsID0ge1xuXHRkZXZpY2VzOiB7XG5cdFx0aW5wdXRzOiBbXSxcblx0XHRvdXRwdXRzOiBbXVxuXHR9LFxuXHRzZXR0aW5nczoge1xuXHRcdG1pZGlSb3V0ZVRvQWN0aXZlOiB0cnVlXG5cdH0sXG5cdGNsb2NrOiB7XG5cdFx0aW46IFtdLFxuXHRcdG91dDogW11cblx0fSxcblx0ZGF0YToge1xuXHRcdGluOiBbXSxcblx0XHRvdXQ6IFtdXG5cdH0sXG5cdHBpdGNoOiAwLFxuXHRjaGFubmVsczoge1xuXHR9LFxuXHRtYXA6IFtcblx0XHRbJ2NvbnRyb2xsZXInLCAyMCwgWydpbnN0cnVtZW50JywgJ3ZjZicsICdjdXRvZmYnXV0sXG5cdFx0Wydjb250cm9sbGVyJywgMjEsIFsnaW5zdHJ1bWVudCcsICd2Y2YnLCAncmVzb25hbmNlJ11dLFxuXHRcdFsnY29udHJvbGxlcicsIDIyLCBbJ3N0dWRpbycsICdicG0nXSwgNjAsIDIwMCwgMF0sXG5cdFx0Wydjb250cm9sbGVyJywgMjMsIFsnc3R1ZGlvJywgJ3ZvbHVtZSddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNCwgWydpbnN0cnVtZW50JywgJ2VnJywgJ2F0dGFjayddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNSwgWydpbnN0cnVtZW50JywgJ2VnJywgJ2RlY2F5J11dLFxuXHRcdFsnY29udHJvbGxlcicsIDI2LCBbJ2luc3RydW1lbnQnLCAnZWcnLCAnc3VzdGFpbiddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNywgWydpbnN0cnVtZW50JywgJ2VnJywgJ3JlbGVhc2UnXV1cblx0XVxufTtcblxuY29uc3QgY29ubmVjdCA9IGRldmljZXMgPT5cblx0c3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCAnbWlkaU1hcCcsIHtcblx0XHRkZXZpY2VzLFxuXHRcdGRhdGE6IHtcblx0XHRcdC4uLnN0YXRlLm1pZGlNYXAuZGF0YSxcblx0XHRcdGluOiBzdGF0ZS5taWRpTWFwLmRhdGEuaW4uaW5kZXhPZihkZXZpY2VzLmlucHV0cy5maW5kSW5kZXgoZGV2ID0+IGRldi5uYW1lLm1hdGNoKC9NUEttaW5pMi8pKSkgPT09IC0xXG5cdFx0XHRcdD8gYXJyLmFkZChzdGF0ZS5taWRpTWFwLmRhdGEuaW4sIGRldmljZXMuaW5wdXRzLmZpbmRJbmRleChkZXYgPT4gZGV2Lm5hbWUubWF0Y2goL01QS21pbmkyLykpKVxuXHRcdFx0XHQ6IHN0YXRlLm1pZGlNYXAuZGF0YS5pblxuXHRcdH1cblx0fSk7XG5cbmNvbnN0IHRvZ2dsZUNsb2NrID0gKGluT3V0LCBpbmRleCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ21pZGlNYXAnLCAnY2xvY2snLCBpbk91dF0sXG5cdGFyci50b2dnbGUob2JqLnN1YihzdGF0ZSwgWydtaWRpTWFwJywgJ2Nsb2NrJ10pW2luT3V0XSwgaW5kZXgpXG4pO1xuXG5jb25zdCB0b2dnbGVEYXRhID0gKGluT3V0LCBpbmRleCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ21pZGlNYXAnLCAnZGF0YScsIGluT3V0XSxcblx0YXJyLnRvZ2dsZShvYmouc3ViKHN0YXRlLCBbJ21pZGlNYXAnLCAnZGF0YScsIGluT3V0XSksIGluZGV4KVxuKTtcblxuY29uc3Qgbm90ZU9uID0gKGRldmljZSA9IDAsIGNoYW5uZWwsIG5vdGUsIHZlbG9jaXR5ID0gMCkgPT4gc3RhdGUgPT4gY2hhbm5lbCAhPT0gdW5kZWZpbmVkID8gKFxuXHQvLyBjb25zb2xlLmxvZyhzdGF0ZS5taWRpTWFwLmNoYW5uZWxzLCBvYmouc3ViKHN0YXRlLCBbJ21pZGlNYXAnLCAnY2hhbm5lbHMnLCBjaGFubmVsLCBub3RlXSksIGNoYW5uZWwsIG5vdGUsIHZlbG9jaXR5KSxcblx0dmVsb2NpdHkgIT09IDBcblx0XHQ/IG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJywgZGV2aWNlLCBjaGFubmVsLCBub3RlXSwgdmVsb2NpdHkpXG5cdFx0OiBvYmoucGF0Y2goc3RhdGUsIFsnbWlkaU1hcCcsICdjaGFubmVscycsIGRldmljZV0sIHtcblx0XHRcdFtjaGFubmVsXTogb2JqLmZpbHRlcihcblx0XHRcdFx0b2JqLnN1YihzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJywgZGV2aWNlLCBjaGFubmVsXSkgfHwge30sXG5cdFx0XHRcdChrZXksIHZhbHVlKSA9PiBrZXkgIT09IG5vdGUpXG5cdFx0fSlcblx0KSA6IHN0YXRlO1xuXG5jb25zdCBwYW5pYyA9ICgpID0+IHN0YXRlID0+XG5cdG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJ10sIHt9KTtcblxuY29uc3QgbW9kaWZ5ID0gKHAsIHYpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJ10sIHtcblx0bWFwOiBhcnJNb2Qoc3RhdGUubWlkaU1hcC5tYXAsIHAsIHYpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGluaXRpYWwsXG5cdGNvbm5lY3QsXG5cdHRvZ2dsZUNsb2NrLFxuXHR0b2dnbGVEYXRhLFxuXHRub3RlT24sXG5cdHBhbmljLFxuXHRtb2RpZnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGxpYlxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5cbi8vIGlibG9relxuY29uc3QgdmRvbSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG5jb25zdCB7b2JqLCBhcnJ9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuLy8gYXBwXG5jb25zdCBhcHAgPSByZXF1aXJlKCcuL3V0aWwvYXBwJyk7XG5sZXQgYWN0aW9ucyA9IGFwcC5hZGFwdChyZXF1aXJlKCcuL2FjdGlvbnMnKSk7XG5sZXQgdWkgPSByZXF1aXJlKCcuL3VpJyk7XG5sZXQgYWN0aW9ucyQ7XG5jb25zdCBzdGF0ZSQgPSBuZXcgUnguQmVoYXZpb3JTdWJqZWN0KCk7XG4vLyBzZXJ2aWNlc1xuLy8gd2F2ZXN1cmZlclxubGV0IHdhdmVzdXJmZXIgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3dhdmVzdXJmZXIuanMnKTtcbi8vIHNhbXBsZXMgLSBhdWRpb2NvbW1vbnNcbmxldCBzYW1wbGVzID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9zYW1wbGVzLmpzJyk7XG5hY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnc2FtcGxlcycsIHNhbXBsZXMuYWN0aW9ucyk7XG4vLyBwYWRzXG5sZXQgcGFkcyA9IHJlcXVpcmUoJy4vc2VydmljZXMvcGFkcy5qcycpO1xuYWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3BhZHMnLCBwYWRzLmFjdGlvbnMpO1xuLy8gbWlkaVxubGV0IG1pZGkgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21pZGkuanMnKTtcbmFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdtaWRpJywgbWlkaS5hY3Rpb25zKTtcbi8vIHN0dCAtIHNwZWFjaCB0byB0ZXh0XG5sZXQgc3R0ID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9zdHQuanMnKTtcbi8vIGNvbnRyb2xcbmxldCBjb250cm9sID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9jb250cm9sLmpzJyk7XG5hY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnY29udHJvbCcsIGNvbnRyb2wuYWN0aW9ucyk7XG5cbi8vIGhvdCByZWxvYWRpbmdcbmlmIChtb2R1bGUuaG90KSB7XG5cdC8vIGFjdGlvbnNcblx0YWN0aW9ucyQgPSAkLmZyb21FdmVudFBhdHRlcm4oXG4gICAgaCA9PiBtb2R1bGUuaG90LmFjY2VwdChcIi4vYWN0aW9uc1wiLCBoKVxuXHQpLmZsYXRNYXAoKCkgPT4ge1xuXHRcdGFjdGlvbnMgPSBhcHAuYWRhcHQocmVxdWlyZSgnLi9hY3Rpb25zJykpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdwYWRzJywgcGFkcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnc2FtcGxlcycsIHNhbXBsZXMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ21pZGknLCBtaWRpLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdjb250cm9sJywgY29udHJvbC5hY3Rpb25zKTtcblx0XHRyZXR1cm4gYWN0aW9ucy5zdHJlYW0uc3RhcnRXaXRoKHN0YXRlID0+IHN0YXRlKTtcblx0fSkubWVyZ2UoYWN0aW9ucy5zdHJlYW0pO1xuXHQvLyB1aVxuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vdWlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dWkgPSByZXF1aXJlKCcuL3VpJyk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG5cdC8vIHNlcnZpY2VzXG5cdC8vIHdhdmVzdXJmZXJcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NlcnZpY2VzL3dhdmVzdXJmZXIuanNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0d2F2ZXN1cmZlci51bmhvb2soKTtcblx0XHR3YXZlc3VyZmVyID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy93YXZlc3VyZmVyLmpzJyk7XG5cdFx0d2F2ZXN1cmZlci5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcblx0Ly8gc2FtcGxlc1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vc2VydmljZXMvc2FtcGxlcy5qc1wiLCBmdW5jdGlvbigpIHtcblx0XHRzYW1wbGVzLnVuaG9vaygpO1xuXHRcdHNhbXBsZXMgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3NhbXBsZXMuanMnKTtcblx0XHRhY3Rpb25zID0gYXBwLmFkYXB0KHJlcXVpcmUoJy4vYWN0aW9ucycpKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAncGFkcycsIHBhZHMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3NhbXBsZXMnLCBzYW1wbGVzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdtaWRpJywgbWlkaS5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnY29udHJvbCcsIGNvbnRyb2wuYWN0aW9ucyk7XG5cdFx0c2FtcGxlcy5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcblx0Ly8gcGFkc1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vc2VydmljZXMvcGFkcy5qc1wiLCBmdW5jdGlvbigpIHtcblx0XHRwYWRzLnVuaG9vaygpO1xuXHRcdHBhZHMgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3BhZHMuanMnKTtcblx0XHRhY3Rpb25zID0gYXBwLmFkYXB0KHJlcXVpcmUoJy4vYWN0aW9ucycpKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAncGFkcycsIHBhZHMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3NhbXBsZXMnLCBzYW1wbGVzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdtaWRpJywgbWlkaS5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnY29udHJvbCcsIGNvbnRyb2wuYWN0aW9ucyk7XG5cdFx0cGFkcy5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcblx0Ly8gbWlkaVxuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vc2VydmljZXMvbWlkaS5qc1wiLCBmdW5jdGlvbigpIHtcblx0XHRtaWRpLnVuaG9vaygpO1xuXHRcdG1pZGkgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21pZGkuanMnKTtcblx0XHRhY3Rpb25zID0gYXBwLmFkYXB0KHJlcXVpcmUoJy4vYWN0aW9ucycpKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAncGFkcycsIHBhZHMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3NhbXBsZXMnLCBzYW1wbGVzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdtaWRpJywgbWlkaS5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnY29udHJvbCcsIGNvbnRyb2wuYWN0aW9ucyk7XG5cdFx0bWlkaS5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcblx0Ly8gc3R0XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9zZXJ2aWNlcy9zdHQuanNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0c3R0LnVuaG9vaygpO1xuXHRcdHN0dCA9IHJlcXVpcmUoJy4vc2VydmljZXMvc3R0LmpzJyk7XG5cdFx0c3R0Lmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xuXHQvLyBjb250cm9sXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9zZXJ2aWNlcy9jb250cm9sLmpzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGNvbnRyb2wudW5ob29rKCk7XG5cdFx0Y29udHJvbCA9IHJlcXVpcmUoJy4vc2VydmljZXMvY29udHJvbC5qcycpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYWRhcHQocmVxdWlyZSgnLi9hY3Rpb25zJykpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdwYWRzJywgcGFkcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnc2FtcGxlcycsIHNhbXBsZXMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ21pZGknLCBtaWRpLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdjb250cm9sJywgY29udHJvbC5hY3Rpb25zKTtcblx0XHRjb250cm9sLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xufSBlbHNlIHtcblx0YWN0aW9ucyQgPSBhY3Rpb25zLnN0cmVhbTtcbn1cblxuLy8gYWN0aW9ucyAtPiBzdGF0ZVxuYWN0aW9ucyRcblx0Lm1hcChhY3Rpb24gPT4gKFxuXHRcdGFjdGlvbi5wYXRoICYmIGNvbnNvbGUubG9nKGFjdGlvbi5wYXRoLmpvaW4oJy4nKSwgYWN0aW9uLnBheWxvYWQpLFxuXHRcdGNvbnNvbGUubG9nKGFjdGlvbiksXG5cdFx0YWN0aW9uXG5cdCkpXG5cdC5zdGFydFdpdGgoKCkgPT4gYWN0aW9ucy5pbml0aWFsKVxuXHQuc2Nhbigoc3RhdGUsIGNoYW5nZSkgPT4gY2hhbmdlKHN0YXRlKSwge30pXG5cdC5tYXAoc3RhdGUgPT4gKGNvbnNvbGUubG9nKHN0YXRlKSwgc3RhdGUpKVxuXHQuc3Vic2NyaWJlKHN0YXRlID0+IHN0YXRlJC5vbk5leHQoc3RhdGUpKTtcblxuLy8gc3RhdGUgLT4gdWlcbmNvbnN0IHVpJCA9IHN0YXRlJC5tYXAoc3RhdGUgPT4gdWkoe3N0YXRlLCBhY3Rpb25zfSkpO1xudmRvbS5wYXRjaFN0cmVhbSh1aSQsICcjdWknKTtcblxud2F2ZXN1cmZlci5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcbnNhbXBsZXMuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5wYWRzLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xubWlkaS5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcbnN0dC5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcbmNvbnRyb2wuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cbi8vIGxpdmVyZWxvYWQgaW1wbC5cbmlmIChtb2R1bGUuaG90KSB7XG5cdGRvY3VtZW50LndyaXRlKGA8c2NyaXB0IHNyYz1cImh0dHA6Ly8keyhsb2NhdGlvbi5ob3N0IHx8ICdsb2NhbGhvc3QnKS5zcGxpdCgnOicpWzBdfWAgK1xuXHRgOjM1NzI5L2xpdmVyZWxvYWQuanM/c25pcHZlcj0xXCI+PC9zY3JpcHQ+YCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCBnYW1lcGFkID0gcmVxdWlyZSgnLi4vdXRpbC9nYW1lcGFkJyk7XG5cbmxldCBhY3Rpb25zID0ge1xuXHRpbml0aWFsOiB7fVxufTtcblxuY29uc3QgcGxheSA9IHVybCA9PiB7XG5cdGxldCBhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0FVRElPJyk7XG5cdGFuLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCB0cnVlKTtcblx0YW4uc3JjID0gdXJsO1xufTtcblxuY29uc3Qga2V5TWFwID0gW1xuXHRbJzcnLCAnOCcsICc5JywgJzAnXSxcblx0Wyd1JywgJ2knLCAnbycsICdwJ10sXG5cdFsnaicsICdrJywgJ2wnLCAnOyddLFxuXHRbJ20nLCAnLCcsICcuJywgJy8nXVxuXTtcblxuY29uc3QgZ2V0SW5kZXggPSBrZXkgPT4ga2V5TWFwLnJlZHVjZShcblx0KHAxLCBjb2xzLCByb3cpID0+IHAxLnJvdyA9PT0gLTEgPyBjb2xzLnJlZHVjZShcblx0XHQocDIsIG1hcEtleSwgY29sKSA9PiBrZXkgPT09IG1hcEtleVxuXHRcdFx0PyAoe3JvdywgY29sfSlcblx0XHRcdDogcDIsXG5cdFx0cDFcblx0KSA6IHAxLFxuXHR7cm93OiAtMSwgY29sOiAtMX1cbik7XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblxuXHRnYW1lcGFkLmNoYW5nZXMoKVxuXHRcdC5tYXAocGFkcyA9PiAoY29uc29sZS5sb2coe3BhZHN9KSwgcGFkcykpXG5cdFx0LndpdGhMYXRlc3RGcm9tKHN0YXRlJCwgKHBhZHMsIHN0YXRlKSA9PiAoe3BhZHMsIHN0YXRlfSkpXG5cdFx0LnN1YnNjcmliZSgoe3BhZHMsIHN0YXRlfSkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2cocGFkc1swXSk7XG5cdFx0XHRpZiAocGFkc1swXSkge1xuXHRcdFx0XHRpZiAocGFkc1swXS5heGVzWzFdID09PSAtMSkgYWN0aW9ucy5zYW1wbGVzLnByZXYoKTtcblx0XHRcdFx0Ly8gaWYgKHBhZHNbMF0uYXhlc1swXSA+IDApIGFjdGlvbnMubW92ZSgncmlnaHQnKTtcblx0XHRcdFx0aWYgKHBhZHNbMF0uYXhlc1sxXSA9PT0gMSkgYWN0aW9ucy5zYW1wbGVzLm5leHQoKTtcblx0XHRcdFx0Ly8gaWYgKHBhZHNbMF0uYXhlc1swXSA8IDApIGFjdGlvbnMubW92ZSgnbGVmdCcpO1xuXHRcdFx0XHRpZiAocGFkc1swXS5idXR0b25zWzhdLnByZXNzZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRpZiAoc3RhdGUuc2FtcGxlcy5saXN0W3N0YXRlLnNhbXBsZXMuaW5kZXhdKSBwbGF5KHN0YXRlLnNhbXBsZXMubGlzdFtzdGF0ZS5zYW1wbGVzLmluZGV4XS5zb3VuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhZHNbMF0uYnV0dG9uc1szXS5wcmVzc2VkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0bGV0IHNhbXBsZSA9IHN0YXRlLnNhbXBsZXMubGlzdFtzdGF0ZS5zYW1wbGVzLmluZGV4XTtcblx0XHRcdFx0XHRpZiAoc2FtcGxlKSBhY3Rpb25zLnBhZHMubG9hZChzYW1wbGUuaWQsIHNhbXBsZS5zb3VuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhZHNbMF0uYnV0dG9uc1swXS5wcmVzc2VkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0YWN0aW9ucy5zZXQoJ3N0dE1pYycsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYWRzWzBdLmJ1dHRvbnNbMV0ucHJlc3NlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGFjdGlvbnMuc2V0KCdtb2RlJywgMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhZHNbMF0uYnV0dG9uc1syXS5wcmVzc2VkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0YWN0aW9ucy5zZXQoJ21vZGUnLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdCQuZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicpXG5cdFx0LmZpbHRlcihldiA9PiBbJ2lucHV0JywgJ3RleHRhcmVhJ10uaW5kZXhPZihldi50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpXG5cdFx0LnN1YnNjcmliZShldiA9PiB7XG5cdFx0XHRsZXQgcG9zID0gZ2V0SW5kZXgoZXYua2V5KTtcblx0XHRcdGNvbnNvbGUubG9nKGV2LmtleSwgZXYudGFyZ2V0LCBwb3MpO1xuXHRcdFx0aWYgKHBvcy5yb3cgIT09IC0xKSB7XG5cdFx0XHRcdGFjdGlvbnMubWlkaS50cmlnZ2VyKHBvcy5yb3csIHBvcy5jb2wpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdHVuaG9vayA9ICgpID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViLmRpc3Bvc2UoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0YWN0aW9ucyxcblx0aG9vayxcblx0dW5ob29rOiAoKSA9PiB1bmhvb2soKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGxpYlxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5cbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3QgbWlkaSA9IHJlcXVpcmUoJy4uL3V0aWwvbWlkaScpO1xuY29uc3QgcG9ja2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9wb2NrZXQnKTtcbmNvbnN0IGEgPSByZXF1aXJlKCcuLi91dGlsL2F1ZGlvJyk7XG5jb25zdCBzYW1wbGVyID0gcmVxdWlyZSgnLi4vdXRpbC9hdWRpby9zb3VyY2VzL3NhbXBsZXInKTtcblxuY29uc3QgZ2V0SWRzID0gKGlucHV0cywgaW5kZXhlcykgPT4gaW5wdXRzXG5cdC5tYXAoaW5wID0+IGlucC5pZClcblx0LmZpbHRlcigoaWQsIGkpID0+IGluZGV4ZXMuaW5kZXhPZihpKSA+IC0xKTtcblxuY29uc3QgdHJpZ2dlciA9IChyb3csIGNvbCkgPT4gc3RhdGUgPT4ge1xuXHRsZXQgc2FtcGxlSWQgPSBvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2xdKTtcblx0aWYgKHNhbXBsZUlkKSB7XG5cdFx0bGV0IGluc3QgPSBzYW1wbGVyLmNsb25lKHBvY2tldC5nZXQoXG5cdFx0XHRbJ3NhbXBsZUJhbmsnLCBzYW1wbGVJZF1cblx0XHQpKTtcblx0XHRpbnN0ID0gYS5jb25uZWN0KGluc3QsIGEuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0YS5zdGFydChpbnN0KTtcblx0fVxuXHRyZXR1cm4gc3RhdGU7XG59O1xuXG5sZXQgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge30sXG5cdHRyaWdnZXJcbn07XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblxuXHRjb25zdCB7ZGV2aWNlcyQsIG1zZyR9ID0gbWlkaS5pbml0KCk7XG5cblx0Ly8gbWlkaSBkZXZpY2UgYWNjZXNzXG5cdHN1YnMucHVzaChcblx0XHRkZXZpY2VzJC5zdWJzY3JpYmUoZGF0YSA9PiBhY3Rpb25zLm1pZGlNYXAuY29ubmVjdChkYXRhKSlcblx0KTtcblxuXHRjb25zdCBwYXJzZWRNaWRpTXNnJCA9IG1zZyRcblx0XHQubWFwKHJhdyA9PiAoe21zZzogbWlkaS5wYXJzZU1pZGlNc2cocmF3Lm1zZyksIHJhd30pKVxuXHRcdC8vIC5tYXAoZGF0YSA9PiAoY29uc29sZS5sb2coZGF0YSksIGRhdGEpKVxuXHRcdC5zaGFyZSgpO1xuXG5cdC8vIG1pZGkgbWVzc2FnZXNcblx0c3Vicy5wdXNoKFxuXHRcdHBhcnNlZE1pZGlNc2ckXG5cdFx0XHQubWFwKG1pZGlEYXRhID0+IChjb25zb2xlLmxvZyh7bWlkaURhdGF9KSwgbWlkaURhdGEpKVxuXHRcdFx0Ly8gLmZpbHRlcigoe21zZ30pID0+IFsnbm90ZU9uJywgJ25vdGVPZmYnXS5pbmRleE9mKG1zZy5zdGF0ZSkgPiAtMSlcblx0XHRcdC5maWx0ZXIoKHttc2d9KSA9PlxuXHRcdFx0XHRtc2cuc3RhdGUgPT09ICdjb250cm9sbGVyJyB8fCBtc2cuc3RhdGUgPT09ICdub3RlT24nXG5cdFx0XHQpXG5cdFx0XHQud2l0aExhdGVzdEZyb20oc3RhdGUkLCAobWlkaURhdGEsIHN0YXRlKSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgbWlkaURhdGEsIHtzdGF0ZX0pKSlcblx0XHRcdC8vIC5maWx0ZXIoKHtyYXcsIHN0YXRlfSkgPT4gKFxuXHRcdFx0Ly8gXHQvLyBjb25zb2xlLmxvZyhyYXcuaW5wdXQuaWQsIHN0YXRlLm1pZGlNYXAuZGV2aWNlcy5pbnB1dHMsIHN0YXRlLm1pZGlNYXAuZGF0YS5pbiksXG5cdFx0XHQvLyBcdGdldElkcyhzdGF0ZS5taWRpTWFwLmRldmljZXMuaW5wdXRzLCBzdGF0ZS5taWRpTWFwLmRhdGEuaW4pLmluZGV4T2YoXG5cdFx0XHQvLyBcdFx0cmF3LmlucHV0LmlkXG5cdFx0XHQvLyBcdCkgPiAtMVxuXHRcdFx0Ly8gKSlcblx0XHRcdC5zdWJzY3JpYmUoKHtyYXcsIG1zZywgc3RhdGV9KSA9PiB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKHN0YXRlLm1pZGlNYXAuZGV2aWNlcy5pbnB1dHMsIHJhdy5pbnB1dCk7XG5cdFx0XHRcdC8vIHRyYWt0b3Jcblx0XHRcdFx0aWYgKG1zZy5jaGFubmVsID09PSAxMyAmJiBtc2cuc3RhdGUgPT09ICdjb250cm9sbGVyJyAmJiBtc2cudmFsdWUgPT09IDEpIHtcblx0XHRcdFx0XHRpZiAobXNnLmNvbnRyb2xsZXIgPj0gMTAgJiYgbXNnLmNvbnRyb2xsZXIgPD0gMjYpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNvbCA9IChtc2cuY29udHJvbGxlciAtIDEwKSAlIDQ7XG5cdFx0XHRcdFx0XHRjb25zdCByb3cgPSAoKG1zZy5jb250cm9sbGVyIC0gMTAgLSBjb2wpIC8gNCk7XG5cdFx0XHRcdFx0XHRsZXQgc2FtcGxlSWQgPSBvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2xdKTtcblx0XHRcdFx0XHRcdC8vIGxldCBpbnN0O1xuXHRcdFx0XHRcdFx0c3dpdGNoIChzdGF0ZS5tb2RlKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0XHR0cmlnZ2VyKHJvdywgY29sKShzdGF0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRcdFx0XHRhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbXG5cdFx0XHRcdFx0XHRcdFx0XHRyb3csIGNvbFxuXHRcdFx0XHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobXNnLmNvbnRyb2xsZXIgPj0gMzcgJiYgbXNnLmNvbnRyb2xsZXIgPD0gMzkpIHtcblx0XHRcdFx0XHRcdGFjdGlvbnMuc2V0KCdtb2RlJywgbXNnLmNvbnRyb2xsZXIgLSAzNyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtc2cuY2hhbm5lbCA9PT0gMTAgJiYgbXNnLnN0YXRlID09PSAnbm90ZU9uJykge1xuXHRcdFx0XHRcdGNvbnN0IGNvbCA9IChtc2cubm90ZS5udW1iZXIgLSA2MCkgJSA0O1xuXHRcdFx0XHRcdGNvbnN0IHJvdyA9IChtc2cubm90ZS5udW1iZXIgLSA2MCAtIGNvbCkgLyA0ICtcblx0XHRcdFx0XHRcdCgoKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAvIDQgJSAyID09PSAxKVxuXHRcdFx0XHRcdFx0XHQ/IC0xIDogMSk7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAvIDQsIChtc2cubm90ZS5udW1iZXIgLSA2MCAtIGNvbCkgJSAyLCByb3csIGNvbCk7XG5cdFx0XHRcdFx0c3dpdGNoIChzdGF0ZS5tb2RlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdHRyaWdnZXIocm93LCBjb2wpKHN0YXRlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdGFjdGlvbnMuc2V0KFsncGFkcycsICdmb2N1c2VkJ10sIFtcblx0XHRcdFx0XHRcdFx0XHRyb3csIGNvbFxuXHRcdFx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0KTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCB7b2JqLCBmbn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3QgcG9ja2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9wb2NrZXQnKTtcbmNvbnN0IGZpbGUgPSByZXF1aXJlKCcuLi91dGlsL2ZpbGUnKTtcbmNvbnN0IHtjb250ZXh0fSA9IHJlcXVpcmUoJy4uL3V0aWwvYXVkaW8nKTtcbmNvbnN0IHNhbXBsZXIgPSByZXF1aXJlKCcuLi91dGlsL2F1ZGlvL3NvdXJjZXMvc2FtcGxlcicpO1xuXG5jb25zdCBsb2FkID0gKGlkLCB1cmwpID0+ICQuZnJvbVByb21pc2UoZmV0Y2godXJsLnJlcGxhY2UoJ2h0dHA6Ly8nLCAnLy8nKSlcblx0LnRoZW4ocmVzID0+IHJlcy5hcnJheUJ1ZmZlcigpKSlcblx0LmNvbmNhdE1hcChidWZmZXIgPT4gJC5mcm9tQ2FsbGJhY2soY29udGV4dC5kZWNvZGVBdWRpb0RhdGEsIGNvbnRleHQpKGJ1ZmZlcikpXG5cdC5tYXAoYnVmZmVyID0+ICh7XG5cdFx0aWQsXG5cdFx0bm9kZTogc2FtcGxlci5jcmVhdGUodXJsLCBidWZmZXIpXG5cdH0pKVxuXHQubWFwKHNhbXBsZSA9PiAoXG5cdFx0cG9ja2V0LnB1dChbJ3NhbXBsZUJhbmsnLCBzYW1wbGUuaWRdLCBzYW1wbGUubm9kZSksXG5cdFx0c3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgLi4uc3RhdGUucGFkcy5mb2N1c2VkXSwgc2FtcGxlLmlkKVxuXHQpKTtcblxuY29uc3QgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge1xuXHRcdGZvY3VzZWQ6IFswLCAwXSxcblx0XHRtYXA6IHt9XG5cdH0sXG5cdGxvYWRcbn07XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3QgcG9ja2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9wb2NrZXQnKTtcblxuY29uc3QgdXJsID0gYGh0dHBzOi8vbTIuYXVkaW9jb21tb25zLm9yZy9hcGkvYXVkaW9jbGlwc2A7XG5cbmNvbnN0IHNlYXJjaCA9ICh7cGF0dGVybiwgc291cmNlID0gJ2ZyZWVzb3VuZCd9KSA9PlxuXHRyZXF1ZXN0LmdldChgJHt1cmx9L3NlYXJjaGApXG5cdFx0LnF1ZXJ5KHtwYXR0ZXJuLCBzb3VyY2V9KVxuXHRcdC50aGVuKHJlcyA9PiByZXMuYm9keS5yZXN1bHRzKVxuXHRcdC50aGVuKHJlc3VsdHMgPT4gKGNvbnNvbGUubG9nKHJlc3VsdHMpLCByZXN1bHRzKSlcblx0XHQudGhlbihyZXN1bHRzID0+IHJlc3VsdHNbMF0ubWVtYmVycy5tYXAoXG5cdFx0XHRtID0+ICh7XG5cdFx0XHRcdGlkOiBtLmNvbnRlbnRbJ0BpZCddLFxuXHRcdFx0XHRuYW1lOiBtLmNvbnRlbnQudGl0bGUsXG5cdFx0XHRcdGF1dGhvcjogbS5jb250ZW50LmF1dGhvci5yZXBsYWNlKCdmcmVlc291bmQtdXNlcnM6JywgJycpLFxuXHRcdFx0XHRzb3VuZDogbS5jb250ZW50LmF2YWlsYWJsZUFzWzBdLmxvY2F0b3IsXG5cdFx0XHRcdGltYWdlOiBtLmNvbnRlbnQuaW1hZ2VzWzBdLmxvY2F0b3IsXG5cdFx0XHRcdGxpY2Vuc2U6IG0uY29udGVudC5saWNlbnNlLFxuXHRcdFx0XHRkdXJhdGlvbjogbS5jb250ZW50LmR1cmF0aW9uXG5cdFx0XHR9KVxuXHRcdCkpXG5cdFx0LnRoZW4obGlzdCA9PiAoXG5cdFx0XHRzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIFsnc2FtcGxlcyddLCB7bGlzdH0pXG5cdFx0KSk7XG5cbmNvbnN0IG5leHQgPSAoKSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIFsnc2FtcGxlcyddLCB7XG5cdGluZGV4OiBzdGF0ZS5zYW1wbGVzLmluZGV4IDwgc3RhdGUuc2FtcGxlcy5saXN0Lmxlbmd0aCAtIDFcblx0XHQ/IHN0YXRlLnNhbXBsZXMuaW5kZXggKyAxXG5cdFx0OiBzdGF0ZS5zYW1wbGVzLmluZGV4XG59KTtcblxuY29uc3QgcHJldiA9ICgpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydzYW1wbGVzJ10sIHtcblx0aW5kZXg6IHN0YXRlLnNhbXBsZXMuaW5kZXggPiAwID8gc3RhdGUuc2FtcGxlcy5pbmRleCAtIDEgOiBzdGF0ZS5zYW1wbGVzLmluZGV4XG59KTtcblxuY29uc3QgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge1xuXHRcdGxpc3Q6IFtdLFxuXHRcdGluZGV4OiAwXG5cdH0sXG5cdHNlYXJjaCxcblx0bmV4dCxcblx0cHJldlxufTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcblxuY29uc3QgU3BlZWNoU0RLID0gd2luZG93LlNwZWVjaFNESztcblxuY29uc3Qgc3Vic2NyaXB0aW9uS2V5ID0gJ2M2MzA1N2UxMjE5NDQxNDg5YzFiNDMxMzI2ODVjNGI4JztcbmNvbnN0IHJlZ2lvbiA9ICd3ZXN0dXMnO1xuY29uc3QgdXJsID0gYGh0dHBzOi8vJHtyZWdpb259LmFwaS5jb2duaXRpdmUubWljcm9zb2Z0LmNvbS9zdHMvdjEuMC9pc3N1ZVRva2VuYDtcblxuY29uc3QgaW5pdCA9IHRva2VuID0+IHtcblx0bGV0IHNwZWVjaENvbmZpZyA9IFNwZWVjaFNESy5TcGVlY2hDb25maWcuZnJvbUF1dGhvcml6YXRpb25Ub2tlbih0b2tlbiwgcmVnaW9uKTtcblx0c3BlZWNoQ29uZmlnLnNwZWVjaFJlY29nbml0aW9uTGFuZ3VhZ2UgPSBcImVuLUdCXCI7XG5cdGxldCBhdWRpb0NvbmZpZyA9IFNwZWVjaFNESy5BdWRpb0NvbmZpZy5mcm9tRGVmYXVsdE1pY3JvcGhvbmVJbnB1dCgpO1xuXHRsZXQgcmVjb2duaXplciA9IG5ldyBTcGVlY2hTREsuU3BlZWNoUmVjb2duaXplcihzcGVlY2hDb25maWcsIGF1ZGlvQ29uZmlnKTtcblx0cmV0dXJuIHJlY29nbml6ZXI7XG59O1xuXG5jb25zdCByZWNvZ25pemUgPSByZWNvZ25pemVyID0+XG5cdCQuZnJvbUNhbGxiYWNrKHJlY29nbml6ZXIucmVjb2duaXplT25jZUFzeW5jLCByZWNvZ25pemVyKSgpXG5cdC5tYXAocmVzID0+IChjb25zb2xlLmxvZyhyZXMpLCByZXMpKTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXG5cdHJlcXVlc3Rcblx0XHQucG9zdCh1cmwpXG5cdFx0LnNldCh7XG5cdFx0XHQnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRcdFx0J09jcC1BcGltLVN1YnNjcmlwdGlvbi1LZXknOiBzdWJzY3JpcHRpb25LZXlcblx0XHR9KVxuXHRcdC50aGVuKHJlcyA9PiBhY3Rpb25zLnNldCgnc3R0JywgcmVzLnRleHQpKTtcblxuXHRzdGF0ZSQuZGlzdGluY3RVbnRpbENoYW5nZWQoc3RhdGUgPT4gc3RhdGUuc3R0ICsgJyAnICsgc3RhdGUuc3R0TWljKVxuXHRcdC5maWx0ZXIoc3RhdGUgPT4gc3RhdGUuc3R0ICYmIHN0YXRlLnN0dE1pYylcblx0XHQubWFwKHN0YXRlID0+IGluaXQoc3RhdGUuc3R0KSlcblx0XHQuZmxhdE1hcChyZWNvZ25pemUpXG5cdFx0LnN1YnNjcmliZShyZXMgPT4ge1xuXHRcdFx0bGV0IHF1ZXJ5ID0gcmVzLnByaXZUZXh0LnJlcGxhY2UoL1xcLiQvLCAnJyk7XG5cdFx0XHRhY3Rpb25zLnNldCgncXVlcnknLCBxdWVyeSk7XG5cdFx0XHRhY3Rpb25zLnNhbXBsZXMuc2VhcmNoKHtwYXR0ZXJuOiBxdWVyeX0pO1xuXHRcdFx0YWN0aW9ucy5zZXQoJ3N0dE1pYycsIGZhbHNlKTtcblx0XHR9KTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCBXYXZlU3VyZmVyID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5qcycpO1xuLy8gd2luZG93LldhdmVTdXJmZXIgPSBXYXZlU3VyZmVyO1xuY29uc3QgVGltZWxpbmVQbHVnaW4gPSByZXF1aXJlKCd3YXZlc3VyZmVyLmpzL2Rpc3QvcGx1Z2luL3dhdmVzdXJmZXIudGltZWxpbmUubWluLmpzJyk7XG5jb25zdCBSZWdpb25zUGx1Z2luID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMubWluLmpzJyk7XG4vLyByZXF1aXJlKCd3YXZlc3VyZmVyL3BsdWdpbi93YXZlc3VyZmVyLnRpbWVsaW5lLmpzJyk7XG4vLyBXYXZlU3VyZmVyID0gd2luZG93LldhdmVTdXJmZXI7XG5cbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHBvY2tldCA9IHJlcXVpcmUoJy4uL3V0aWwvcG9ja2V0Jyk7XG5cbmNvbnN0IGluaXQgPSBjb250YWluZXIgPT4ge1xuXHRjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cdGxldCB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUoe1xuXHRcdGNvbnRhaW5lcjogJyN3YXZlZm9ybScsXG5cdFx0d2F2ZUNvbG9yOiAnI2NkZScsXG5cdFx0cHJvZ3Jlc3NDb2xvcjogJyM3ODknLFxuXHRcdHBsdWdpbnM6IFtcblx0XHRcdFRpbWVsaW5lUGx1Z2luLmNyZWF0ZSh7XG5cdFx0XHRcdGNvbnRhaW5lcjogJyN3YXZlLXRpbWVsaW5lJ1xuXHRcdFx0XHQvLyBkZWZlckluaXQ6IHRydWUgLy8gc3RvcCB0aGUgcGx1Z2luIGZyb20gaW5pdGlhbGlzaW5nIGltbWVkaWF0ZWx5XG5cdFx0XHR9KSxcblx0XHRcdFJlZ2lvbnNQbHVnaW4uY3JlYXRlKHtcblx0XHRcdFx0Ly8gcGx1Z2luIG9wdGlvbnMgLi4uXG5cdFx0XHR9KVxuXHRcdF1cblx0fSk7XG5cdC8vIHdhdmVzdXJmZXIubG9hZCgnYXNzZXRzL0xhdGluRXRobm9FbGVrdHJvR3Jvb3ZlLm1wMycpO1xuXHRyZXR1cm4gd2F2ZXN1cmZlcjtcbn07XG5cbmNvbnN0IGxvYWQgPSAoe3dhdmVzdXJmZXIsIHNhbXBsZX0pID0+IHtcblx0Y29uc29sZS5sb2cod2F2ZXN1cmZlciwgc2FtcGxlLCBwb2NrZXQpO1xuXHRpZiAoc2FtcGxlWzBdID09PSAndXJsJykgd2F2ZXN1cmZlci5sb2FkKHNhbXBsZVsxXSk7XG5cdGVsc2UgaWYgKHNhbXBsZVsxXSlcblx0XHR3YXZlc3VyZmVyLmxvYWREZWNvZGVkQnVmZmVyKFxuXHRcdFx0cG9ja2V0LmdldChbJ3NhbXBsZUJhbmsnLCBzYW1wbGVbMV1dKS5vdXRwdXQuYnVmZmVyXG5cdFx0KTtcblx0cmV0dXJuIHdhdmVzdXJmZXI7XG59O1xuXG5sZXQgdW5ob29rID0gKCkgPT4ge307XG5jb25zdCBob29rID0gKHtzdGF0ZSQsIGFjdGlvbnN9KSA9PiB7XG5cdGxldCBzdWJzID0gW107XG5cblx0bGV0IHdhdmVzdXJmZXIkID0gJC5pbnRlcnZhbCgxMDApXG5cdFx0Lm1hcCgoKSA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd2F2ZWZvcm0nKSlcblx0XHQuZGlzdGluY3RVbnRpbENoYW5nZWQoZWwgPT4gZWwpXG5cdFx0LmZpbHRlcihlbCA9PiBlbClcblx0XHQubWFwKGluaXQpO1xuXG5cdGxldCBzYW1wbGVDaGFuZ2UkID0gc3RhdGUkXG5cdFx0LmRpc3RpbmN0VW50aWxDaGFuZ2VkKHN0YXRlID0+XG5cdFx0XHRzdGF0ZS5wYWRzLmZvY3VzZWQudG9TdHJpbmcoKSArXG5cdFx0XHRcdCcgJyArIG9iai5zdWIoc3RhdGUucGFkcywgWydtYXAnLCAuLi5zdGF0ZS5wYWRzLmZvY3VzZWRdKVxuXHRcdClcblx0XHQubWFwKHN0YXRlID0+IChbJ2lkJywgb2JqLnN1YihzdGF0ZS5wYWRzLm1hcCwgc3RhdGUucGFkcy5mb2N1c2VkKV0pKVxuXHRcdC5zdGFydFdpdGgoKFsndXJsJywgJ2Fzc2V0cy9MYXRpbkV0aG5vRWxla3Ryb0dyb292ZS5tcDMnXSkpO1xuXG5cdHdhdmVzdXJmZXIkXG5cdFx0LmZsYXRNYXAod2F2ZXN1cmZlciA9PlxuXHRcdFx0JC5tZXJnZShcblx0XHRcdFx0c2FtcGxlQ2hhbmdlJFxuXHRcdFx0XHRcdC5tYXAoc2FtcGxlID0+IHdhdmVzdXJmZXIgPT4gbG9hZCh7d2F2ZXN1cmZlciwgc2FtcGxlfSkpLFxuXHRcdFx0XHRzdGF0ZSRcblx0XHRcdFx0XHQuZGlzdGluY3RVbnRpbENoYW5nZWQoc3RhdGUgPT4gc3RhdGUuc2Vzc2lvbi5wbGF5aW5nKVxuXHRcdFx0XHRcdC5tYXAoc3RhdGUgPT4gd2F2ZXN1cmZlciA9PiAod2F2ZXN1cmZlci5wbGF5UGF1c2UoKSwgd2F2ZXN1cmZlcikpXG5cdFx0XHQpXG5cdFx0XHQuc2Nhbigod2F2ZXN1cmZlciwgcmVkdWNlcikgPT4gcmVkdWNlcih3YXZlc3VyZmVyKSwgd2F2ZXN1cmZlcilcblx0XHQpXG5cdFx0LnN1YnNjcmliZShkYXRhID0+IHt9KTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0c2VjdGlvbiwgc3BhbiwgYSwgZGl2LCBwcmUsIGltZywgaSxcblx0Zm9ybSwgaW5wdXQsIGJ1dHRvbiwgbGFiZWwsIHNlbGVjdCwgb3B0aW9uLFxuXHR1bCwgbGksIHRhYmxlLCB0Ym9keSwgdGhlYWQsIHRyLCB0ZCwgdGhcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5jb25zdCBmb3JtVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybScpO1xuXG5jb25zdCBwbGF5ID0gdXJsID0+IHtcblx0bGV0IGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQVVESU8nKTtcblx0YW4uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIHRydWUpO1xuXHRhbi5zcmMgPSB1cmw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7c3RhdGUsIGFjdGlvbnN9KSA9PiBzZWN0aW9uKCcjYm9hcmQnLCBbXS5jb25jYXQoXG5cdGZvcm0oJyNib2FyZC1zZWFyY2gnLCB7XG5cdFx0b246IHtcblx0XHRcdHN1Ym1pdDogZXYgPT4ge1xuXHRcdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRsZXQgZGF0YSA9IGZvcm1VdGlsLnRvRGF0YShldi50YXJnZXQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhkYXRhKTtcblx0XHRcdFx0YWN0aW9ucy5zYW1wbGVzLnNlYXJjaChkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIFtcblx0XHRpbnB1dChgI2JvYXJkLXNlYXJjaC1wYXR0ZXJuW25hbWU9XCJwYXR0ZXJuXCJdW3BsYWNlaG9sZGVyPVwiUXVlcnlcIl1gLCB7XG5cdFx0XHRhdHRyczoge1xuXHRcdFx0XHR2YWx1ZTogc3RhdGUucXVlcnlcblx0XHRcdH1cblx0XHR9KSxcblx0XHRzZWxlY3QoYFtuYW1lPVwic291cmNlXCJdYCwgWydmcmVlc291bmQnLCAnamFtZW5kbycsICdldXJvcGVhbmEnXS5tYXAoXG5cdFx0XHRzID0+IG9wdGlvbihgW3ZhbHVlPVwiJHtzfVwiXWAsIHMpXG5cdFx0KSksXG5cdFx0YnV0dG9uKCdTZWFyY2gnKVxuXHRdKSxcblx0KHN0YXRlLnNhbXBsZXMubGlzdC5sZW5ndGggPiAwKSA/IHRhYmxlKCcjYm9hcmQtc2FtcGxlc1t3aWR0aD1cIjEwMCVcIl1bY2VsbHNwYWNpbmc9NF1bY2VsbHBhZGRpbmc9MF0nLCBbXG5cdFx0dGhlYWQodHIoW1xuXHRcdFx0dGgoJ1t3aWR0aD1cIjYwJVwiXScsICdTYW1wbGUnKSxcblx0XHRcdHRoKCdBdXRob3InKSxcblx0XHRcdHRoKCdEdXJhdGlvbicpLFxuXHRcdFx0dGgoJ0xpY2Vuc2UnKSxcblx0XHRcdHRoKCdQbGF5JyksXG5cdFx0XHR0aCgnTG9hZCcpXG5cdFx0XSkpLFxuXHRcdHRib2R5KHN0YXRlLnNhbXBsZXMubGlzdC5tYXAoKHNhbXBsZSwgaW5kZXgpID0+XG5cdFx0XHR0cih7XG5cdFx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdFx0c2VsZWN0ZWQ6IGluZGV4ID09PSBzdGF0ZS5zYW1wbGVzLmluZGV4XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtcblx0XHRcdFx0dGQoW1xuXHRcdFx0XHRcdGltZyhgW3NyYz1cIiR7c2FtcGxlLmltYWdlfVwiXWApLFxuXHRcdFx0XHRcdHNwYW4oc2FtcGxlLm5hbWUpXG5cdFx0XHRcdF0pLFxuXHRcdFx0XHR0ZChzYW1wbGUuYXV0aG9yKSxcblx0XHRcdFx0dGQoYCR7KHNhbXBsZS5kdXJhdGlvbiAvIDEwMDApLnRvRml4ZWQoMil9IHNgKSxcblx0XHRcdFx0dGQoYShgW3RhcmdldD1cIl9ibGFua1wiXVtocmVmPVwiJHtzYW1wbGUubGljZW5zZX1cIl1gLFxuXHRcdFx0XHRcdHNhbXBsZS5saWNlbnNlLnJlcGxhY2UoJ2h0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnLycsICcnKSkpLFxuXHRcdFx0XHR0ZChbXG5cdFx0XHRcdFx0YnV0dG9uKHtcblx0XHRcdFx0XHRcdG9uOiB7XG5cdFx0XHRcdFx0XHRcdGNsaWNrOiAoKSA9PiBwbGF5KHNhbXBsZS5zb3VuZClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBpKCcuZmEuZmEtcGxheScpKVxuXHRcdFx0XHRdKSxcblx0XHRcdFx0dGQoW1xuXHRcdFx0XHRcdGJ1dHRvbih7XG5cdFx0XHRcdFx0XHRvbjoge1xuXHRcdFx0XHRcdFx0XHRjbGljazogZXYgPT4gYWN0aW9ucy5wYWRzLmxvYWQoc2FtcGxlLmlkLCBzYW1wbGUuc291bmQpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgaSgnLmZhLmZhLXBsdXMnKSlcblx0XHRcdFx0XSlcblx0XHRcdF0pXG5cdFx0KSlcblx0XSkgOiBbXVxuKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0c2VjdGlvbiwgYnV0dG9uLCBzcGFuLCBoZWFkZXIsIGgxLFxuXHR1bCwgbGksIGlcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7c3RhdGUsIGFjdGlvbnN9KSA9PiBoZWFkZXIoW1xuXHR1bCgnLmxlZnQnLCBbXG5cdFx0bGkoYnV0dG9uKHtcblx0XHRcdG9uOiB7XG5cdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnNldCgnc3R0TWljJywgdHJ1ZSlcblx0XHRcdH0sXG5cdFx0XHRjbGFzczoge1xuXHRcdFx0XHRzZWxlY3RlZDogc3RhdGUuc3R0TWljXG5cdFx0XHR9XG5cdFx0fSwgaSgnLmZhLmZhLXZvbHVtZS1jb250cm9sLXBob25lJykpKVxuXHRdKSxcblx0aDEoJ3hBbXBsUicpLFxuXHR1bCgnLnJpZ2h0JywgW1xuXHRcdGxpKGJ1dHRvbih7XG5cdFx0XHRvbjoge1xuXHRcdFx0XHRjbGljazogKCkgPT4gYWN0aW9ucy5zZXQoJ21vZGUnLCAwKVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdHNlbGVjdGVkOiBzdGF0ZS5tb2RlID09PSAwXG5cdFx0XHR9XG5cdFx0fSwgaSgnLmZhLmZhLWVkaXQnKSkpLFxuXHRcdGxpKGJ1dHRvbih7XG5cdFx0XHRvbjoge1xuXHRcdFx0XHRjbGljazogKCkgPT4gYWN0aW9ucy5zZXQoJ21vZGUnLCAxKVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdHNlbGVjdGVkOiBzdGF0ZS5tb2RlID09PSAxXG5cdFx0XHR9XG5cdFx0fSwgaSgnLmZhLmZhLW11c2ljJykpKVxuXHRdKVxuXSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGRvbVxuY29uc3Qge1xuXHRoMSwgYSwgZGl2LCBpLFxuXHRzZWN0aW9uLCBidXR0b24sIHNwYW5cbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuLy8gY29tcG9uZW50c1xuY29uc3QgaGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXInKTtcbmNvbnN0IGJvYXJkID0gcmVxdWlyZSgnLi9ib2FyZCcpO1xuY29uc3QgcGFkcyA9IHJlcXVpcmUoJy4vcGFkcycpO1xuLy8gY29uc3QgY291bnRlciA9IHJlcXVpcmUoJy4vY291bnRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7c3RhdGUsIGFjdGlvbnN9KSA9PiBzZWN0aW9uKCcjdWknLCBbXG5cdGhlYWRlcih7c3RhdGUsIGFjdGlvbnN9KSxcblx0c2VjdGlvbignLndhdmVmb3JtJywgW1xuXHRcdGRpdignI3dhdmUtdGltZWxpbmUnKSxcblx0XHRkaXYoJyN3YXZlZm9ybScpLFxuXHRcdGJ1dHRvbih7XG5cdFx0XHRvbjoge1xuXHRcdFx0XHRjbGljazogKCkgPT4gYWN0aW9ucy50b2dnbGUoWydzZXNzaW9uJywgJ3BsYXlpbmcnXSlcblx0XHRcdH1cblx0XHR9LCBpKGAuZmEuZmEtJHtzdGF0ZS5zZXNzaW9uLnBsYXlpbmcgPyAncGF1c2UnIDogJ3BsYXknfWApKVxuXHRdKSxcblx0Ym9hcmQoe3N0YXRlLCBhY3Rpb25zfSksXG5cdHBhZHMoe3N0YXRlLCBhY3Rpb25zfSlcbl0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG5cdHNlY3Rpb24sIHNwYW4sIGEsIGRpdiwgcHJlLCBpbWcsIGksXG5cdGZvcm0sIGlucHV0LCBidXR0b24sIGxhYmVsLFxuXHR1bCwgbGksIHRhYmxlLCB0Ym9keSwgdGhlYWQsIHRyLCB0ZCwgdGhcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7c3RhdGUsIGFjdGlvbnN9KSA9PiBzZWN0aW9uKCcjcGFkcycsXG5cdGRpdignLnJvd3MnLCBBcnJheSg0KS5maWxsKHt9KS5tYXAoKGEsIHJvdykgPT5cblx0XHRkaXYoJy5jb2xzJywgQXJyYXkoNCkuZmlsbCh7fSkubWFwKChhLCBjb2wpID0+XG5cdFx0XHRidXR0b24oJy5wYWQnLCB7XG5cdFx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdFx0Zm9jdXNlZDogc3RhdGUubW9kZSA9PT0gMCAmJiBzdGF0ZS5wYWRzLmZvY3VzZWRbMF0gPT09IHJvdyAmJiBzdGF0ZS5wYWRzLmZvY3VzZWRbMV0gPT09IGNvbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRvbjoge1xuXHRcdFx0XHRcdGZvY3VzOiAoKSA9PiBhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbcm93LCBjb2xdKSxcblx0XHRcdFx0XHRjbGljazogKCkgPT4gc3RhdGUubW9kZSA9PT0gMSAmJiBhY3Rpb25zLm1pZGkudHJpZ2dlcihyb3csIGNvbClcblx0XHRcdFx0XHRcdHx8IHN0YXRlLm1vZGUgPT09IDAgJiYgYWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW3JvdywgY29sXSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHQpKVxuXHQpKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3Qge2Fyciwgb2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IG9ic2VydmUgPSBzb3VyY2UgPT4gKHNvdXJjZSBpbnN0YW5jZW9mIFJ4Lk9ic2VydmFibGUpXG4gID8gc291cmNlXG4gIDogKHNvdXJjZS50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgPyBSeC5PYnNlcnZhYmxlLmZyb21Qcm9taXNlKHNvdXJjZSlcbiAgICA6IFJ4Lk9ic2VydmFibGUuanVzdChzb3VyY2UpO1xuXG5jb25zdCBhZGFwdCA9IChvLCBwID0gW10pID0+IE9iamVjdC5rZXlzKG8pLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnaW5pdGlhbCcpLnJlZHVjZSgobzIsIGtleSkgPT4gT2JqZWN0LmFzc2lnbih7fSwgbzIsXG5cdChvW2tleV0gaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgb2JqLmtleVZhbHVlKGtleSwgZnVuY3Rpb24oKSB7XG5cdFx0b2JzZXJ2ZShcblx0XHRcdG9ba2V5XS5hcHBseShudWxsLCBBcnJheS5mcm9tKGFyZ3VtZW50cykpXG5cdFx0KS5zdWJzY3JpYmUocmVzcCA9PiBvMi5zdHJlYW0ub25OZXh0KE9iamVjdC5hc3NpZ24ocmVzcCwge1xuXHRcdFx0cGF0aDogW10uY29uY2F0KHAsIGtleSksXG5cdFx0XHRwYXlsb2FkOiBBcnJheS5mcm9tKGFyZ3VtZW50cylcblx0XHR9KSkpO1xuXHR9KSB8fCAob1trZXldIGluc3RhbmNlb2YgT2JqZWN0KSAmJiAoKCkgPT4ge1xuXHRcdGxldCBvMyA9IGFkYXB0KG9ba2V5XSwgW10uY29uY2F0KHAsIGtleSkpO1xuXHRcdG8zLnN0cmVhbS5zdWJzY3JpYmUocmVzcCA9PiBvMi5zdHJlYW0ub25OZXh0KHJlc3ApKTtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRpbml0aWFsOiBPYmplY3QuYXNzaWduKHt9LCBvMi5pbml0aWFsLCBvYmoua2V5VmFsdWUoa2V5LCBvMy5pbml0aWFsKSlcblx0XHR9LCBvYmoua2V5VmFsdWUoa2V5LCBvMykpO1xuXHR9KSgpIHx8IG9iai5rZXlWYWx1ZShrZXksIG9ba2V5XSlcbiksIHtzdHJlYW06IG5ldyBSeC5TdWJqZWN0KCksIGluaXRpYWw6IG8uaW5pdGlhbCB8fCB7fX0pO1xuXG5jb25zdCBhdHRhY2ggPSAodHJlZSwgcGF0aCwgbm9kZSkgPT4gW2FkYXB0KG5vZGUsIHBhdGgpXS5tYXAoYWRhcHRlZE5vZGUgPT4gKFxuXHRhZGFwdGVkTm9kZS5zdHJlYW0uc3Vic2NyaWJlKHJlc3AgPT4gdHJlZS5zdHJlYW0ub25OZXh0KHJlc3ApKSxcblx0T2JqZWN0LmFzc2lnbih7fSwgb2JqLnBhdGNoKHRyZWUsIHBhdGgsIGFkYXB0ZWROb2RlKSwge1xuXHRcdGluaXRpYWw6IG9iai5wYXRjaCh0cmVlLmluaXRpYWwsIHBhdGgsIGFkYXB0ZWROb2RlLmluaXRpYWwpXG5cdH0pXG4pKS5wb3AoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFkYXB0LFxuXHRhdHRhY2hcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCB7Y29udGV4dCwgY3JlYXRlOiBfY3JlYXRlLCBzZXQsIGNoYWluLCBkdXJhdGlvbiwgY2hEYXRhLCBzY2hlZHVsZX0gPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmNvbnN0IGNyZWF0ZSA9IHByZWZzID0+IFt7XG5cdHByZWZzOiBPYmplY3QuYXNzaWduKHtcblx0XHR2b2x1bWU6IDAuNDEsXG5cdFx0YXR0YWNrOiAwLjMxLFxuXHRcdGRlY2F5OiAwLjE2LFxuXHRcdHN1c3RhaW46IDAuOCxcblx0XHRyZWxlYXNlOiAwLjIxXG5cdH0sIHByZWZzKSxcblx0dGhyb3VnaDogX2NyZWF0ZSgnZ2FpbicpXG59XS5tYXAobiA9PiAoXG5cdHNldChuLnRocm91Z2guZ2FpbiwgJ3ZhbHVlJywgMCksXG5cdG5cbikpLnBvcCgpO1xuXG5jb25zdCB1cGRhdGUgPSAobiwgcHJlZnMpID0+IChcblx0c2V0KG4sICdwcmVmcycsIE9iamVjdC5hc3NpZ24oe30sIG4ucHJlZnMsIHByZWZzKSksXG5cdG5cbik7XG5cbmNvbnN0IG5vdGVPbiA9IChub2RlLCB2ZWxvY2l0eSwgdGltZSkgPT4ge1xuXHRjb25zdCBub3cgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuXHR0aW1lID0gKHRpbWUgfHwgbm93KSArIDAuMDAwMTtcblxuXHRub2RlLnRocm91Z2guZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XG5cblx0Y29uc3QgY2hhbmdlcyA9IFtdLmNvbmNhdChcblx0XHQvLyBhdHRhY2tcblx0XHQobm9kZS5wcmVmcy5hdHRhY2sgPiAwKVxuXHRcdFx0PyBbWzAsIHRpbWVdLCBbdmVsb2NpdHkgKiBub2RlLnByZWZzLnZvbHVtZSwgbm9kZS5wcmVmcy5hdHRhY2tdXVxuXHRcdFx0OiBbW3ZlbG9jaXR5ICogbm9kZS5wcmVmcy52b2x1bWUsIHRpbWVdXSxcblx0XHQvLyBkZWNheVxuXHRcdChub2RlLnByZWZzLmRlY2F5ID4gMClcblx0XHRcdD8gW1tub2RlLnByZWZzLnN1c3RhaW4gKiB2ZWxvY2l0eSAqIG5vZGUucHJlZnMudm9sdW1lLCBub2RlLnByZWZzLmRlY2F5XV0gOiBbXVxuXHQpLnJlZHVjZSgoYSwgYykgPT4gW1tdLmNvbmNhdChhWzBdLCBjWzBdKSwgW10uY29uY2F0KGFbMV0sIGNbMV0pXSwgW1tdLCBbXV0pO1xuXG5cdHNjaGVkdWxlKG5vZGUudGhyb3VnaCwgJ2dhaW4nLCBjaGFuZ2VzWzBdLCBjaGFuZ2VzWzFdKTtcblx0cmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBub3RlT2ZmID0gKG5vZGUsIHRpbWUpID0+IHtcblx0Y29uc3Qgbm93ID0gY29udGV4dC5jdXJyZW50VGltZTtcblx0dGltZSA9IHRpbWUgfHwgbm93ICsgMC4wMDAxO1xuXG5cdHNldFRpbWVvdXQoKCkgPT4gKFxuXHRcdG5vZGUudGhyb3VnaC5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKSxcblx0XHRub2RlLnRocm91Z2guZ2Fpbi5zZXRWYWx1ZUN1cnZlQXRUaW1lKG5ldyBGbG9hdDMyQXJyYXkoW25vZGUudGhyb3VnaC5nYWluLnZhbHVlLCAwXSksXG5cdFx0XHRcdHRpbWUsIG5vZGUucHJlZnMucmVsZWFzZSA+IDAgJiYgbm9kZS5wcmVmcy5yZWxlYXNlIHx8IDAuMDAwMDEpXG5cdCksICh0aW1lIC0gbm93KSAqIDEwMDApO1xuXHRyZXR1cm4gbm9kZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGUsXG5cdHVwZGF0ZSxcblx0bm90ZU9uLFxuXHRub3RlT2ZmXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqLCBmbn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG5jb25zdCBjb250ZXh0ID0gbmV3IChcblx0d2luZG93LkF1ZGlvQ29udGV4dFxuXHR8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0XG5cdHx8IHdpbmRvdy5tb3pBdWRpb0NvbnRleHRcblx0fHwgd2luZG93Lm9BdWRpb0NvbnRleHRcblx0fHwgd2luZG93Lm1zQXVkaW9Db250ZXh0XG4pKCk7XG5cbmNvbnN0IHNldCA9IChvLCBrLCB2KSA9PiAob1trXSA9IHYpO1xuY29uc3QgaXNTZXQgPSB2ID0+IHYgIT09IHVuZGVmaW5lZDtcbmNvbnN0IGlzR2V0ID0gdiA9PiBpc1NldCh2KSA/IHYgOiBudWxsO1xuXG5jb25zdCBhcHBseSA9IChvMSwgbzIpID0+IE9iamVjdC5rZXlzKG8yKVxuXHQucmVkdWNlKChvLCBrKSA9PiBzZXQobywgaywgbzJba10pLCBvMSk7XG5cbmNvbnN0IGNyZWF0ZSA9ICh0eXBlLCAuLi5hcmdzKSA9PiAoXG5cdC8vIGNvbnNvbGUubG9nKHR5cGUpLFxuXHRvYmouc3dpdGNoKHR5cGUsIHtcblx0XHRvc2NpbGxhdG9yOiAoKSA9PiBjb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoLi4uYXJncyksXG5cdFx0Z2FpbjogKCkgPT4gY29udGV4dC5jcmVhdGVHYWluKC4uLmFyZ3MpLFxuXHRcdGJpcXVhZEZpbHRlcjogKCkgPT4gY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoLi4uYXJncyksXG5cdFx0Y29udm9sdmVyOiAoKSA9PiBjb250ZXh0LmNyZWF0ZUNvbnZvbHZlciguLi5hcmdzKSxcblx0XHRidWZmZXI6ICgpID0+IGNvbnRleHQuY3JlYXRlQnVmZmVyKC4uLmFyZ3MpLFxuXHRcdGJ1ZmZlclNvdXJjZTogKCkgPT4gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoLi4uYXJncylcblx0fSkoKSk7XG5cbmNvbnN0IHVwZGF0ZSA9IChub2RlLCBwcmVmcykgPT4gYXBwbHkobm9kZSwgcHJlZnMpO1xuXG5jb25zdCBjb25uZWN0ID0gKG4xLCBuMikgPT4gKFxuXHQvLyBjb25zb2xlLmxvZyhuMSwgbjIpLFxuXHRuMS5jb25uZWN0KG4yKSxcblx0bjFcbik7XG5jb25zdCBkaXNjb25uZWN0ID0gKG4xLCBuMikgPT4ge1xuXHQvLyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGNvbm5lY3RlZFxuXHR0cnkge1xuXHRcdG4xLmRpc2Nvbm5lY3QobjIpO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRjb25zb2xlLmxvZyhlcnIpO1xuXHR9XG5cdHJldHVybiBuMTtcbn07XG5cbmNvbnN0IGNoYWluID0gKC4uLm5vZGVzKSA9PiAoXG5cdG5vZGVzLmZvckVhY2goKG4sIGkpID0+IGlzU2V0KG5vZGVzW2kgKyAxXSkgJiYgY29ubmVjdChuLCBub2Rlc1tpICsgMV0pKSxcblx0bm9kZXNbMF1cbik7XG5cbmNvbnN0IHVuY2hhaW4gPSAoLi4ubm9kZXMpID0+IChcblx0bm9kZXMuc2xpY2UoKS5yZXZlcnNlKClcblx0XHQuZm9yRWFjaCgobiwgaSkgPT4gaXNTZXQobm9kZXNbaSAtIDFdKSAmJiBkaXNjb25uZWN0KG5vZGVzW2kgLSAxXSwgbikpLFxuXHRub2Rlc1swXVxuKTtcblxuY29uc3QgZHVyYXRpb24gPSBzZWNvbmRzID0+IGNvbnRleHQuc2FtcGxlUmF0ZSAqIHNlY29uZHM7XG5jb25zdCBjaERhdGEgPSAobm9kZSwgLi4uYXJncykgPT4gKFxuXHQvLyBjb25zb2xlLmxvZyhub2RlLCBhcmdzKSxcblx0bm9kZS5nZXRDaGFubmVsRGF0YSguLi5hcmdzKVxuKTtcblxuY29uc3Qgc2NoZWR1bGUgPSAobm9kZSwgcHJlZiwgdmFsdWVzLCB0aW1lcykgPT4gKHZhbHVlcy5sZW5ndGggPT09IDEpXG5cdD8gbm9kZVtwcmVmXS5zZXRWYWx1ZUF0VGltZSh2YWx1ZXNbMF0sIHRpbWVzWzBdKVxuXHQ6IChub2RlW3ByZWZdLnNldFZhbHVlQ3VydmVBdFRpbWUobmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMuc2xpY2UoMCwgMikpLCB0aW1lc1swXSwgdGltZXNbMV0pLFxuXHRcdCh2YWx1ZXMubGVuZ3RoID4gMikgJiYgc2NoZWR1bGUobm9kZSwgcHJlZiwgdmFsdWVzLnNsaWNlKDEpLCBbdGltZXNbMF0gKyB0aW1lc1sxXV0uY29uY2F0KHRpbWVzLnNsaWNlKDIpKSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y29udGV4dCxcblx0c2V0LFxuXHRpc1NldCxcblx0aXNHZXQsXG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRjb25uZWN0LFxuXHRkaXNjb25uZWN0LFxuXHRjaGFpbixcblx0dW5jaGFpbixcblx0Ly8gdXRpbFxuXHRkdXJhdGlvbixcblx0Y2hEYXRhLFxuXHRzY2hlZHVsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHtjb250ZXh0LCBjcmVhdGU6IF9jcmVhdGUsIHNldCwgY2hhaW4sIGR1cmF0aW9uLCBjaERhdGF9ID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5jb25zdCBjcmVhdGUgPSBwcmVmcyA9PiBbe1xuXHRwcmVmczogT2JqZWN0LmFzc2lnbih7XG5cdFx0dHlwZTogJ3Nhd3Rvb3RoJyxcblx0XHRmcmVxdWVuY3k6IDUsXG5cdFx0Z2FpbjogMTVcblx0fSwgcHJlZnMpLFxuXHRlZmZlY3Q6IF9jcmVhdGUoJ29zY2lsbGF0b3InKSxcblx0b3V0cHV0OiBfY3JlYXRlKCdnYWluJylcbn1dLm1hcChuID0+IChcblx0Y2hhaW4obi5lZmZlY3QsIG4ub3V0cHV0KSxcblx0c2V0KG4uZWZmZWN0LmZyZXF1ZW5jeSwgJ3ZhbHVlJywgbi5wcmVmcy5mcmVxdWVuY3kpLFxuXHRzZXQobi5vdXRwdXQuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy5nYWluKSxcblx0c2V0KG4uZWZmZWN0LCAndHlwZScsIG4ucHJlZnMudHlwZSksXG5cdG5cbikpLnBvcCgpO1xuXG5jb25zdCB1cGRhdGUgPSAobiwgcHJlZnMpID0+IChcblx0c2V0KG4sICdwcmVmcycsIE9iamVjdC5hc3NpZ24oe30sIG4ucHJlZnMsIHByZWZzKSksXG5cdHNldChuLmVmZmVjdC5mcmVxdWVuY3ksICd2YWx1ZScsIG4ucHJlZnMuZnJlcXVlbmN5KSxcblx0c2V0KG4ub3V0cHV0LmdhaW4sICd2YWx1ZScsIG4ucHJlZnMuZ2FpbiksXG5cdHNldChuLmVmZmVjdCwgJ3R5cGUnLCBuLnByZWZzLnR5cGUpLFxuXHRuXG4pO1xuXG5jb25zdCBzdGFydCA9IChuLCAuLi5hcmdzKSA9PiAoXG5cdG4uZWZmZWN0LnN0YXJ0KCksXG5cdG5cbik7XG5cbi8vIGNvbnN0IGNsb25lID0gbiA9PiBjcmVhdGUobnVsbCwgbi5vdXRwdXQuYnVmZmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRzdGFydFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHtjb250ZXh0LCBjcmVhdGU6IF9jcmVhdGUsIHNldCwgY2hhaW4sIGR1cmF0aW9uLCBjaERhdGF9ID0gcmVxdWlyZSgnLi4vY29yZScpO1xuLy8gY29uc3Qge2NvbnRleHR9ID0gY29yZTtcblxuY29uc3QgYnVpbGRJbXB1bHNlID0gKHtzZWNvbmRzLCBkZWNheX0pID0+IHtcblx0bGV0IGltcHVsc2UgPSBfY3JlYXRlKCdidWZmZXInLCAyLCBkdXJhdGlvbihzZWNvbmRzKSwgY29udGV4dC5zYW1wbGVSYXRlKTtcblx0bGV0IGNoYW5uZWxEYXRhID0gW1xuXHRcdGNoRGF0YShpbXB1bHNlLCAwKSxcblx0XHRjaERhdGEoaW1wdWxzZSwgMSlcblx0XTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkdXJhdGlvbihzZWNvbmRzKTsgaSsrKSB7XG5cdFx0Y2hhbm5lbERhdGFbMF1baV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBpIC8gZHVyYXRpb24oc2Vjb25kcyksIGRlY2F5KTtcblx0XHRjaGFubmVsRGF0YVsxXVtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIGkgLyBkdXJhdGlvbihzZWNvbmRzKSwgZGVjYXkpO1xuXHR9XG5cdHJldHVybiBpbXB1bHNlO1xufTtcblxuY29uc3QgY3JlYXRlID0gcHJlZnMgPT4gW3tcblx0cHJlZnM6IE9iamVjdC5hc3NpZ24oe3NlY29uZHM6IDMsIGRlY2F5OiAyLCB3ZXQ6IDAsIGRyeTogMX0sIHByZWZzKSxcblx0aW5wdXQ6IF9jcmVhdGUoJ2dhaW4nKSxcblx0b3V0cHV0OiBfY3JlYXRlKCdnYWluJyksXG5cdGVmZmVjdDogX2NyZWF0ZSgnY29udm9sdmVyJyksXG5cdHdldDogX2NyZWF0ZSgnZ2FpbicpLFxuXHRkcnk6IF9jcmVhdGUoJ2dhaW4nKVxufV0ubWFwKG4gPT4gKFxuXHRjaGFpbihuLmlucHV0LCBuLmRyeSwgbi5vdXRwdXQpLFxuXHRjaGFpbihuLmlucHV0LCBuLmVmZmVjdCwgbi53ZXQsIG4ub3V0cHV0KSxcblx0c2V0KG4uZHJ5LmdhaW4sICd2YWx1ZScsIG4ucHJlZnMuZHJ5KSxcblx0c2V0KG4ud2V0LmdhaW4sICd2YWx1ZScsIG4ucHJlZnMud2V0KSxcblx0c2V0KG4uZWZmZWN0LCAnYnVmZmVyJywgYnVpbGRJbXB1bHNlKG4ucHJlZnMpKSxcblx0blxuKVxuXHQvLyBuXG5cblx0Lypcblx0bi5pbnB1dC5jb25uZWN0KG4uZWZmZWN0KTtcblx0bi5lZmZlY3QuY29ubmVjdChuLndldCk7XG5cdG4ud2V0LmNvbm5lY3Qobi5vdXRwdXQpO1xuXG5cdG4uaW5wdXQuY29ubmVjdChuLmRyeSk7XG5cdG4uZHJ5LmNvbm5lY3Qobi5vdXRwdXQpO1xuXHQqL1xuXHQvKlxuXHRuLmRyeS5nYWluLnZhbHVlID0gbi5wcmVmcy5kcnk7XG5cdG4ud2V0LmdhaW4udmFsdWUgPSBuLnByZWZzLndldDtcblx0bi5lZmZlY3QuYnVmZmVyID0gYnVpbGRJbXB1bHNlKG4ucHJlZnMpO1xuXHQqL1xuXHQvLyBzZXQobi53ZXQuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy53ZXQpLFxuXHQvLyBzZXQobi5lZmZlY3QsICdidWZmZXInLCBidWlsZEltcHVsc2Uobi5wcmVmcykpLFxuXHQvLyByZXR1cm4gbjtcbikucG9wKCk7XG5cbmNvbnN0IHVwZGF0ZSA9IChuLCBwcmVmcykgPT4gKFxuLy9cdGNvbnNvbGUubG9nKHByZWZzLCBuLnByZWZzKSxcblx0KG4ucHJlZnMuc2Vjb25kcyAhPT0gcHJlZnMuc2Vjb25kcyB8fCBuLnByZWZzLmRlY2F5ICE9PSBwcmVmcy5kZWNheSlcblx0XHQmJiBzZXQobi5lZmZlY3QsICdidWZmZXInLCBidWlsZEltcHVsc2Uobi5wcmVmcykpLFxuXHQobi5wcmVmcy5kcnkgIT09IHByZWZzLmRyeSlcblx0XHQmJiBzZXQobi5kcnkuZ2FpbiwgJ3ZhbHVlJywgcHJlZnMuZHJ5KSxcblx0KG4ucHJlZnMud2V0ICE9PSBwcmVmcy53ZXQpXG5cdFx0JiYgc2V0KG4ud2V0LmdhaW4sICd2YWx1ZScsIHByZWZzLndldCksXG5cdHNldChuLCAncHJlZnMnLCBPYmplY3QuYXNzaWduKHt9LCBuLnByZWZzLCBwcmVmcykpLFxuXHRuXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlLFxuXHR1cGRhdGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IHtcblx0Y29udGV4dCwgc2V0LCBpc1NldCwgaXNHZXQsXG5cdHNjaGVkdWxlOiBfc2NoZWR1bGUsXG5cdGNyZWF0ZTogX2NyZWF0ZSxcblx0Y29ubmVjdDogX2Nvbm5lY3QsIGRpc2Nvbm5lY3Q6IF9kaXNjb25uZWN0XG59ID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbmNvbnN0IHJldmVyYiA9IHJlcXVpcmUoJy4vZWZmZWN0cy9yZXZlcmInKTtcbmNvbnN0IGxmbyA9IHJlcXVpcmUoJy4vZWZmZWN0cy9sZm8nKTtcbmNvbnN0IGFkc3IgPSByZXF1aXJlKCcuL2NvbnRyb2xzL2Fkc3InKTtcblxuY29uc3QgY3JlYXRlID0gKHR5cGUsIHByZWZzID0ge30sIGN0eCA9IGNvbnRleHQpID0+IE9iamVjdC5hc3NpZ24oe30sXG5cdG9iai5zd2l0Y2godHlwZSwge1xuXHRcdHZjbzogKCkgPT4gKHtvdXRwdXQ6IF9jcmVhdGUoJ29zY2lsbGF0b3InKX0pLFxuXHRcdHZjYTogKCkgPT4gKHt0aHJvdWdoOiBfY3JlYXRlKCdnYWluJyl9KSxcblx0XHR2Y2Y6ICgpID0+ICh7dGhyb3VnaDogX2NyZWF0ZSgnYmlxdWFkRmlsdGVyJyl9KSxcblx0XHRsZm86ICgpID0+IGxmby5jcmVhdGUocHJlZnMpLFxuXHRcdHJldmVyYjogKCkgPT4gcmV2ZXJiLmNyZWF0ZShwcmVmcyksXG5cdFx0YWRzcjogKCkgPT4gYWRzci5jcmVhdGUocHJlZnMpXG5cdH0pKCksXG5cdHt0eXBlLCBvdXQ6IFtdfVxuKTtcblxuY29uc3QgY3V0b2ZmVG9GcmVxID0gY3V0b2ZmID0+IHtcblx0Y29uc3QgbWluVmFsdWUgPSA0MDtcblx0Y29uc3QgbWF4VmFsdWUgPSBjb250ZXh0LnNhbXBsZVJhdGUgLyAyO1xuXHQvLyBMb2dhcml0aG0gKGJhc2UgMikgdG8gY29tcHV0ZSBob3cgbWFueSBvY3RhdmVzIGZhbGwgaW4gdGhlIHJhbmdlLlxuXHR2YXIgbnVtYmVyT2ZPY3RhdmVzID0gTWF0aC5sb2cobWF4VmFsdWUgLyBtaW5WYWx1ZSkgLyBNYXRoLkxOMjtcblx0Ly8gQ29tcHV0ZSBhIG11bHRpcGxpZXIgZnJvbSAwIHRvIDEgYmFzZWQgb24gYW4gZXhwb25lbnRpYWwgc2NhbGUuXG5cdHZhciBtdWx0aXBsaWVyID0gTWF0aC5wb3coMiwgbnVtYmVyT2ZPY3RhdmVzICogKGN1dG9mZiAtIDEuMCkpO1xuXHQvLyBHZXQgYmFjayB0byB0aGUgZnJlcXVlbmN5IHZhbHVlIGJldHdlZW4gbWluIGFuZCBtYXguXG5cdHJldHVybiBtYXhWYWx1ZSAqIG11bHRpcGxpZXI7XG59O1xuXG5jb25zdCB1cGRhdGUgPSAobm9kZSwgcHJlZnMpID0+IG9iai5zd2l0Y2gobm9kZS50eXBlLCB7XG5cdHZjbzogKCkgPT4gKFxuXHRcdGlzU2V0KHByZWZzLnR5cGUpICYmIHNldChub2RlLm91dHB1dCwgJ3R5cGUnLCBwcmVmcy50eXBlKSxcblx0XHRpc1NldChwcmVmcy5mcmVxKSAmJiBzZXQobm9kZS5vdXRwdXQuZnJlcXVlbmN5LCAndmFsdWUnLCBwcmVmcy5mcmVxKSxcblx0XHRpc1NldChwcmVmcy5kZXR1bmUpICYmIHNldChub2RlLm91dHB1dC5kZXR1bmUsICd2YWx1ZScsIHByZWZzLmRldHVuZSksXG5cdFx0T2JqZWN0LmFzc2lnbihub2RlLCB7cHJlZnN9KVxuXHQpLFxuXHR2Y2E6ICgpID0+IChcblx0XHRpc1NldChwcmVmcy5nYWluKSAmJiBzZXQobm9kZS50aHJvdWdoLmdhaW4sICd2YWx1ZScsIHByZWZzLmdhaW4pLFxuXHRcdE9iamVjdC5hc3NpZ24obm9kZSwge3ByZWZzfSlcblx0KSxcblx0dmNmOiAoKSA9PiAoXG5cdFx0aXNTZXQocHJlZnMudHlwZSkgJiYgc2V0KG5vZGUudGhyb3VnaCwgJ3R5cGUnLCBwcmVmcy50eXBlKSxcblx0XHRpc1NldChwcmVmcy5jdXRvZmYpXG5cdFx0XHQmJiBfc2NoZWR1bGUobm9kZS50aHJvdWdoLCAnZnJlcXVlbmN5JywgW2N1dG9mZlRvRnJlcShwcmVmcy5jdXRvZmYpXSwgW2NvbnRleHQuY3VycmVudFRpbWUgKyAwLjAwMDFdKSxcblx0XHRcdC8vIHNldChub2RlLnRocm91Z2guZnJlcXVlbmN5LCAndmFsdWUnLCBjdXRvZmZUb0ZyZXEocHJlZnMuY3V0b2ZmKSksXG5cdFx0aXNTZXQocHJlZnMucmVzb25hbmNlKVxuXHRcdFx0JiYgX3NjaGVkdWxlKG5vZGUudGhyb3VnaCwgJ1EnLCBbcHJlZnMucmVzb25hbmNlICogMzBdLCBbY29udGV4dC5jdXJyZW50VGltZSArIDAuMDAwMV0pLFxuXHRcdE9iamVjdC5hc3NpZ24obm9kZSwge3ByZWZzfSlcblx0KSxcblx0cmV2ZXJiOiAoKSA9PiByZXZlcmIudXBkYXRlKG5vZGUsIHByZWZzKSxcblx0YWRzcjogKCkgPT4gYWRzci51cGRhdGUobm9kZSwgcHJlZnMpLFxuXHRsZm86ICgpID0+IGxmby51cGRhdGUobm9kZSwgcHJlZnMpXG59KSgpO1xuXG5jb25zdCBjb25uZWN0ID0gKG5vZGUxLCBub2RlMikgPT4gIShub2RlMS5vdXQgJiYgbm9kZTEub3V0LmluZGV4T2Yobm9kZTIpID4gLTEpXG5cdD8gKF9jb25uZWN0KFxuXHRcdFx0Ly8gaW5wdXRcblx0XHRcdGlzR2V0KG5vZGUxLm91dHB1dClcblx0XHRcdHx8IGlzR2V0KG5vZGUxLnRocm91Z2gpXG5cdFx0XHR8fCBpc1NldChub2RlMS5jb25uZWN0KSAmJiBub2RlMSxcblx0XHRcdC8vIG91dHB1dFxuXHRcdFx0KG5vZGUyIGluc3RhbmNlb2YgQXVkaW9QYXJhbSkgJiYgbm9kZTJcblx0XHRcdHx8IGlzR2V0KG5vZGUyLmlucHV0KVxuXHRcdFx0fHwgaXNHZXQobm9kZTIudGhyb3VnaClcblx0XHRcdHx8IG5vZGUyXG5cdFx0KSxcblx0XHRPYmplY3QuYXNzaWduKHt9LCBub2RlMSwge1xuXHRcdFx0b3V0OiBbXS5jb25jYXQobm9kZTEub3V0IHx8IFtdLCBbbm9kZTJdKVxuXHRcdH0pKVxuXHQ6IG5vZGUxO1xuXG5jb25zdCBkaXNjb25uZWN0ID0gKG5vZGUxLCBub2RlMikgPT4gKFxuXHQvLyAoY29uc29sZS5sb2coJ2Rpc3Njb25uZWN0aW5nJywgbm9kZTEsIG5vZGUyKSksXG5cdChub2RlMS5vdXQuaW5kZXhPZihub2RlMikgPiAtMSlcblx0PyAoX2Rpc2Nvbm5lY3QoXG5cdFx0XHQvLyBpbnB1dFxuXHRcdFx0aXNHZXQobm9kZTEub3V0cHV0KVxuXHRcdFx0fHwgaXNHZXQobm9kZTEudGhyb3VnaClcblx0XHRcdHx8IGlzU2V0KG5vZGUxLmNvbm5lY3QpICYmIG5vZGUxLFxuXHRcdFx0Ly8gb3V0cHV0XG5cdFx0XHQobm9kZTIgaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSAmJiBub2RlMlxuXHRcdFx0fHwgaXNHZXQobm9kZTIuaW5wdXQpXG5cdFx0XHR8fCBpc0dldChub2RlMi50aHJvdWdoKVxuXHRcdFx0fHwgbm9kZTJcblx0XHQpLFxuXHRcdE9iamVjdC5hc3NpZ24oe30sIG5vZGUxLCB7XG5cdFx0XHRvdXQ6IFtdLmNvbmNhdChcblx0XHRcdFx0bm9kZTEub3V0LnNsaWNlKDAsIG5vZGUxLm91dC5pbmRleE9mKG5vZGUyKSksXG5cdFx0XHRcdG5vZGUxLm91dC5zbGljZShub2RlMS5vdXQuaW5kZXhPZihub2RlMikgKyAxKVxuXHRcdFx0KVxuXHRcdH0pKVxuXHQ6ICh0eXBlb2Ygbm9kZTIgPT09ICd1bmRlZmluZWQnKVxuXHRcdD8gbm9kZTEub3V0LnJlZHVjZSgobm9kZTEsIHByZXZOb2RlKSA9PiBkaXNjb25uZWN0KG5vZGUxLCBwcmV2Tm9kZSksIG5vZGUxKVxuXHRcdDogbm9kZTFcbik7XG5cbmNvbnN0IHJlcm91dGUgPSAobm9kZTEsIG5vZGUyKSA9PiAobm9kZTEub3V0ICYmIG5vZGUxLm91dC5pbmRleE9mKG5vZGUyKSA9PT0gLTEpXG5cdD8gY29ubmVjdChkaXNjb25uZWN0KG5vZGUxKSwgbm9kZTIpXG5cdDogbm9kZTE7XG5cbmNvbnN0IGNoYWluID0gKC4uLm5vZGVzKSA9PiAoXG5cdG5vZGVzLmZvckVhY2goKG4sIGkpID0+IGlzU2V0KG5baSArIDFdKSAmJiBjb25uZWN0KG4sIG5vZGVzW2kgKyAxXSkpLFxuXHRub2Rlc1swXVxuKTtcblxuY29uc3QgdW5jaGFpbiA9ICguLi5ub2RlcykgPT4gKFxuXHRub2Rlcy5zbGljZSgpLnJldmVyc2UoKVxuXHRcdC5mb3JFYWNoKChuLCBpKSA9PiBpc1NldChuW2kgLSAxXSkgJiYgZGlzY29ubmVjdChub2Rlc1tpIC0gMV0sIG4pKSxcblx0bm9kZXNbMF1cbik7XG5cbmNvbnN0IHN0YXJ0ID0gKG5vZGUsIC4uLmFyZ3MpID0+IChub2RlLnR5cGUgPT09ICdsZm8nICYmIGxmby5zdGFydChub2RlLCAuLi5hcmdzKSB8fCBub2RlLm91dHB1dC5zdGFydCguLi5hcmdzKSwgbm9kZSk7XG5cbmNvbnN0IHN0b3AgPSAobm9kZSwgLi4uYXJncykgPT4gKG5vZGUub3V0cHV0LnN0b3AoLi4uYXJncyksIG5vZGUpO1xuXG5jb25zdCBzY2hlZHVsZSA9IChub2RlLCBwcmVmLCB2YWx1ZXMsIHRpbWVzKSA9PiAodmFsdWVzLmxlbmd0aCA9PT0gMSlcblx0PyBub2RlLnRocm91Z2hbcHJlZl0uc2V0VmFsdWVBdFRpbWUodmFsdWVzWzBdLCB0aW1lc1swXSlcblx0OiAobm9kZS50aHJvdWdoW3ByZWZdLnNldFZhbHVlQ3VydmVBdFRpbWUobmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMuc2xpY2UoMCwgMikpLCB0aW1lc1swXSwgdGltZXNbMV0pLFxuXHRcdCh2YWx1ZXMubGVuZ3RoID4gMikgJiYgc2NoZWR1bGUobm9kZSwgcHJlZiwgdmFsdWVzLnNsaWNlKDEpLCBbdGltZXNbMF0gKyB0aW1lc1sxXV0uY29uY2F0KHRpbWVzLnNsaWNlKDIpKSkpO1xuXG5jb25zdCBub3RlVG9GcmVxdWVuY3kgPSBmdW5jdGlvbihub3RlKSB7XG5cdHZhciBub3RlcyA9IFsnQScsICdBIycsICdCJywgJ0MnLCAnQyMnLCAnRCcsICdEIycsICdFJywgJ0YnLCAnRiMnLCAnRycsICdHIyddO1xuXHR2YXIga2V5TnVtYmVyO1xuXHR2YXIgb2N0YXZlO1xuXG5cdGlmIChub3RlLmxlbmd0aCA9PT0gMykge1xuXHRcdG9jdGF2ZSA9IG5vdGUuY2hhckF0KDIpO1xuXHR9IGVsc2Uge1xuXHRcdG9jdGF2ZSA9IG5vdGUuY2hhckF0KDEpO1xuXHR9XG5cblx0a2V5TnVtYmVyID0gbm90ZXMuaW5kZXhPZihub3RlLnNsaWNlKDAsIC0xKSk7XG5cblx0aWYgKGtleU51bWJlciA8IDMpIHtcblx0XHRrZXlOdW1iZXIgPSBrZXlOdW1iZXIgKyAxMiArICgob2N0YXZlIC0gMSkgKiAxMikgKyAxO1xuXHR9IGVsc2Uge1xuXHRcdGtleU51bWJlciA9IGtleU51bWJlciArICgob2N0YXZlIC0gMSkgKiAxMikgKyAxO1xuXHR9XG5cblx0cmV0dXJuIDQ0MCAqIE1hdGgucG93KDIsIChrZXlOdW1iZXIgLSA0OSkgLyAxMik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y29udGV4dCxcblx0Y3JlYXRlLFxuXHR1cGRhdGUsXG5cdHNjaGVkdWxlLFxuXHRjb25uZWN0LFxuXHRkaXNjb25uZWN0LFxuXHRyZXJvdXRlLFxuXHRjaGFpbixcblx0dW5jaGFpbixcblx0bm90ZVRvRnJlcXVlbmN5LFxuXHRzdGFydCxcblx0c3RvcCxcblx0dmNvOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCd2Y28nLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0dmNmOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCd2Y2YnLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0bGZvOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCdsZm8nLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0dmNhOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCd2Y2EnLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0YWRzcjogcHJlZnMgPT4gY3JlYXRlKCdhZHNyJywgcHJlZnMsIGNvbnRleHQpLFxuXHRub3RlT246IGFkc3Iubm90ZU9uLFxuXHRub3RlT2ZmOiBhZHNyLm5vdGVPZmZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCB7Y29udGV4dCwgY3JlYXRlOiBfY3JlYXRlLCBzZXQsIGNoYWluLCBkdXJhdGlvbiwgY2hEYXRhfSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuY29uc3QgY3JlYXRlID0gKGZpbGUsIGJ1ZmZlcikgPT4gW3tcblx0b3V0cHV0OiBfY3JlYXRlKCdidWZmZXJTb3VyY2UnKVxufV0ubWFwKG4gPT4gKFxuXHQoIWJ1ZmZlcilcblx0XHQ/IGZldGNoKGZpbGUpXG5cdFx0XHQudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG5cdFx0XHQudGhlbihidWZmZXIgPT4gY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYnVmZmVyLFxuXHRcdFx0XHRidWZmZXIgPT4gc2V0KG4ub3V0cHV0LCAnYnVmZmVyJywgYnVmZmVyKVxuXHRcdFx0KSlcblx0XHQ6IHNldChuLm91dHB1dCwgJ2J1ZmZlcicsIGJ1ZmZlciksXG5cdFx0bikpLnBvcCgpO1xuXG5jb25zdCB1cGRhdGUgPSAoKSA9PiB7XG5cbn07XG5cbmNvbnN0IGNsb25lID0gbiA9PiBjcmVhdGUobnVsbCwgbi5vdXRwdXQuYnVmZmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRjbG9uZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5jb25zdCBmaWxlU2F2ZXIgPSByZXF1aXJlKCdmaWxlLXNhdmVyJyk7XG5jb25zdCBqc1ppcCA9IHJlcXVpcmUoXCJqc3ppcFwiKTtcbmNvbnN0IHtmbiwgb2JqfSA9IHJlcXVpcmUoXCJpYmxva3otZGF0YVwiKTtcblxuY29uc3QgbG9hZCA9IChmaWxlLCByZWFkQXMgPSAndGV4dCcpID0+ICQuY3JlYXRlKHN0cmVhbSA9PiB7XG5cdGNvbnN0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ZnIub25sb2FkID0gZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBjb25zb2xlLmxvZyhyZWFkQXMsIGV2LnRhcmdldC5yZXN1bHQpO1xuXHRcdHN0cmVhbS5vbk5leHQoXG5cdFx0XHRyZWFkQXMgPT09ICdqc29uJ1xuXHRcdFx0XHQ/IEpTT04ucGFyc2UoZXYudGFyZ2V0LnJlc3VsdClcblx0XHRcdFx0OiBldi50YXJnZXQucmVzdWx0XG5cdFx0KTtcblx0XHRzdHJlYW0ub25Db21wbGV0ZWQoKTtcblx0fTtcblx0Ly8gY29uc29sZS5sb2coZmlsZSwgcmVhZEFzKTtcblx0KCh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpXG5cdFx0PyAkLmZyb21Qcm9taXNlKGZldGNoKGZpbGUpKS5mbGF0TWFwKHJlcyA9PiByZXMuYmxvYigpKVxuXHRcdDogJC5qdXN0KGZpbGUpKVxuXHRcdC5zdWJzY3JpYmUoZiA9PiBmbi5zd2l0Y2gocmVhZEFzLCB7XG5cdFx0XHRhcnJheUJ1ZmZlcjogZiA9PiBmci5yZWFkQXNBcnJheUJ1ZmZlcihmKSxcblx0XHRcdGRlZmF1bHQ6IGYgPT4gZnIucmVhZEFzVGV4dChmKVxuXHRcdH0pKGYpKTtcbn0pO1xuXG5jb25zdCBsb2FkWmlwID0gZmlsZSA9PiBsb2FkKGZpbGUsICdhcnJheUJ1ZmZlcicpXG5cdC5mbGF0TWFwKGRhdGEgPT4gJC5mcm9tUHJvbWlzZShqc1ppcC5sb2FkQXN5bmMoZGF0YSkpKVxuXHQuZmxhdE1hcCh6ZiA9PiAkLmNvbmNhdChcblx0XHRPYmplY3Qua2V5cyh6Zi5maWxlcylcblx0XHRcdC5maWx0ZXIoayA9PiAhemYuZmlsZXNba10uZGlyKVxuXHRcdFx0Ly8gLm1hcChrID0+IChjb25zb2xlLmxvZyhrKSwgaykpXG5cdFx0XHQubWFwKGsgPT4gJC5mcm9tUHJvbWlzZSh6Zi5maWxlc1trXS5hc3luYygnYXJyYXlidWZmZXInKSkubWFwKHYgPT4gKHtrLCB2fSkpKVxuXHRcdCkucmVkdWNlKChvLCB7aywgdn0pID0+IG9iai5wYXRjaChvLCBrLCB2KSwge30pXG5cdCk7XG5cbmNvbnN0IHNhdmUgPSAoZmlsZU5hbWUsIGNvbnRlbnQpID0+IGZpbGVTYXZlci5zYXZlQXMoXG5cdG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShjb250ZW50KV0sIHt0eXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD11dGYtOFwifSksXG5cdGZpbGVOYW1lXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bG9hZCxcblx0bG9hZFppcCxcblx0c2F2ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5cbmNvbnN0IGFycmlmeSA9IG8gPT4gbyBpbnN0YW5jZW9mIE9iamVjdFxuICA/ICEobyBpbnN0YW5jZW9mIEFycmF5KSAmJiBrZXlzKG8pLmZpbHRlcihrID0+IGsubWF0Y2goL14tP1swLTkuXSskLykpLmxlbmd0aCA9PT0ga2V5cyhvKS5sZW5ndGhcbiAgICA/IGtleXMobykubWFwKGsgPT4gYXJyaWZ5KG9ba10pKVxuICAgIDoga2V5cyhvKS5yZWR1Y2UoKG8yLCBrKSA9PiBvYmoucGF0Y2gobzIsIGssIGFycmlmeShvW2tdKSksIHt9KVxuICA6IG87XG5cbmNvbnN0IHRvRGF0YSA9IGZvcm0gPT4gYXJyaWZ5KEFycmF5LmZyb20oZm9ybS5lbGVtZW50cylcbiAgLy8gLm1hcChlbCA9PiAoY29uc29sZS5sb2coZWwubmFtZSksIGVsKSlcbiAgLmZpbHRlcihlbCA9PiBlbC5uYW1lICE9PSB1bmRlZmluZWQgJiYgZWwubmFtZSAhPT0gJycpXG4gIC5yZWR1Y2UoKG8sIGVsKSA9PiBvYmoucGF0Y2gobywgZWwubmFtZS5zcGxpdCgnLicpLFxuICAgIGVsLnR5cGUgJiYgZWwudHlwZSA9PT0gJ251bWJlcidcbiAgICAgID8gTnVtYmVyKGVsLnZhbHVlKVxuICAgICAgOiBlbC52YWx1ZVxuICApLCB7fSkpO1xuXG5jb25zdCBjbGVhciA9IGZvcm0gPT4gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICAuZm9yRWFjaChlbCA9PiAoZWwudmFsdWUgPSBudWxsKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR0b0RhdGEsXG5cdGNsZWFyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG5jb25zdCBwYXJzZVBhZCA9IHBhZCA9PiBwYWQgJiYgKHtcblx0YXhlczogcGFkLmF4ZXMsXG5cdGJ1dHRvbnM6IHBhZC5idXR0b25zLm1hcChidXR0b24gPT4gKHtcblx0XHRwcmVzc2VkOiBidXR0b24ucHJlc3NlZCxcblx0XHR2YWx1ZTogYnV0dG9uLnZhbHVlXG5cdH0pKSxcblx0Y29ubmVjdGVkOiBwYWQuY29ubmVjdGVkLFxuXHRpZDogcGFkLmlkLFxuXHRpbmRleDogcGFkLmluZGV4LFxuXHRtYXBwaW5nOiBwYWQubWFwcGluZyxcblx0dGltZXN0YW1wOiBwYWQudGltZXN0YW1wXG59KSB8fCBwYWQ7XG5cbmNvbnN0IGxpc3QgPSAoKSA9PiBBcnJheS5mcm9tKG5hdmlnYXRvci5nZXRHYW1lcGFkcygpIHx8IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpIHx8IFtdKVxuXHQubWFwKHBhcnNlUGFkKTtcblxuY29uc3QgY2hhbmdlcyA9ICgpID0+IHRpbWUuZnJhbWUoKVxuXHQubWFwKGxpc3QpXG5cdC5kaXN0aW5jdFVudGlsQ2hhbmdlZChwYWRzID0+IHBhZHMpXG5cdC8vXHRwYWRzLnJlZHVjZSgociwgcGFkKSA9PiAhcGFkICYmIHIgfHwgKHIgKyAocGFkLmF4ZXMgfHwgJycpICsgKHBhZC5idXR0b25zIHx8ICcnKSksICcnKSlcblx0LnNoYXJlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRsaXN0LFxuXHRjaGFuZ2VzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3Qga2V5cyA9IFsnQycsICdDIycsICdEJywgJ0QjJywgJ0UnLCAnRicsICdGIycsICdHJywgJ0cjJywgJ0EnLCAnQSMnLCAnQiddO1xuXG5jb25zdCBudW1iZXJUb05vdGUgPSBudW1iZXIgPT4gKHtcblx0a2V5OiBrZXlzW251bWJlciAlIDEyXSxcblx0b2N0YXZlOiBwYXJzZUludCgobnVtYmVyIC0gbnVtYmVyICUgMTIpIC8gMTIsIDEwKSAtIDEsXG5cdG51bWJlclxufSk7XG5cbmNvbnN0IG5vdGVUb051bWJlciA9IG5vdGUgPT4gKFxuXHRrZXlzLmluZGV4T2Yobm90ZS5yZXBsYWNlKC9bMC05XSsvLCAnJykpICtcblx0KHBhcnNlSW50KG5vdGUucmVwbGFjZSgvW0EtWiNiXSsvLCAnJyksIDEwKSArIDEpICogMTJcbik7XG5cbmNvbnN0IHBhcnNlTWlkaU1zZyA9IGV2ZW50ID0+IHtcblx0Ly8gTWFzayBvZmYgdGhlIGxvd2VyIG5pYmJsZSAoTUlESSBjaGFubmVsLCB3aGljaCB3ZSBkb24ndCBjYXJlIGFib3V0KVxuXG5cdGNvbnN0IHN0YXR1cyA9IGV2ZW50LmRhdGFbMF0gJiAweGYwO1xuXHRjb25zdCBiaW5hcnkgPSBldmVudC5kYXRhWzBdLnRvU3RyaW5nKDIpO1xuXHRjb25zdCBjaGFubmVsID0gZXZlbnQuZGF0YVswXSAtIHN0YXR1cyArIDE7XG5cdGxldCBtc2cgPSB7fTtcblxuXHRzd2l0Y2ggKGJpbmFyeS5zbGljZSgwLCA0KSkge1xuXHRcdC8vIG5vdGVvZmZcblx0XHRjYXNlIFwiMTAwMFwiOlxuXHRcdFx0bXNnID0ge1xuXHRcdFx0XHRzdGF0ZTogJ25vdGVPZmYnLFxuXHRcdFx0XHRub3RlOiBudW1iZXJUb05vdGUoZXZlbnQuZGF0YVsxXSlcblx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHQvLyBub3Rlb25cblx0XHRjYXNlIFwiMTAwMVwiOlxuXHRcdFx0bXNnID0gKGV2ZW50LmRhdGFbMl0gIT09IDApIC8vIGlmIHZlbG9jaXR5ICE9IDAsIHRoaXMgaXMgYSBub3RlLW9uIG1lc3NhZ2Vcblx0XHRcdFx0PyB7XG5cdFx0XHRcdFx0c3RhdGU6ICdub3RlT24nLFxuXHRcdFx0XHRcdG5vdGU6IG51bWJlclRvTm90ZShldmVudC5kYXRhWzFdKSxcblx0XHRcdFx0XHR2ZWxvY2l0eTogcGFyc2VGbG9hdCgoZXZlbnQuZGF0YVsyXSAvIDEyNykudG9GaXhlZCgyKSlcblx0XHRcdFx0fVxuXHRcdFx0XHQ6IHsgLy8gaWYgdmVsb2NpdHkgPT0gMCwgZmFsbCB0aHJ1OiBpdCdzIGEgbm90ZS1vZmYuXHRNSURJJ3Mgd2VpcmQsIHlhJ2xsLlxuXHRcdFx0XHRcdHN0YXRlOiAnbm90ZU9mZicsXG5cdFx0XHRcdFx0bm90ZTogbnVtYmVyVG9Ob3RlKGV2ZW50LmRhdGFbMV0pXG5cdFx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHQvLyBwaXRjaCB3aGVlbFxuXHRcdGNhc2UgXCIxMTEwXCI6XG5cdFx0XHRtc2cgPSB7XG5cdFx0XHRcdHN0YXRlOiAncGl0Y2hCZW5kJyxcblx0XHRcdFx0cGl0Y2hWYWx1ZTogKGV2ZW50LmRhdGFbMl0gPT09IDY0KSA/IDAgOiBwYXJzZUZsb2F0KChldmVudC5kYXRhWzJdIC8gNjMuNSAtIDEpLnRvRml4ZWQoMikpXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdFx0Ly8gY29udHJvbGxlclxuXHRcdGNhc2UgXCIxMDExXCI6XG5cdFx0XHRtc2cgPSB7XG5cdFx0XHRcdHN0YXRlOiBcImNvbnRyb2xsZXJcIixcblx0XHRcdFx0Y29udHJvbGxlcjogZXZlbnQuZGF0YVsxXSxcblx0XHRcdFx0dmFsdWU6IHBhcnNlRmxvYXQoKGV2ZW50LmRhdGFbMl0gLyAxMjcpLnRvRml4ZWQoMikpXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIjExMDBcIjpcblx0XHRcdG1zZyA9IHtcblx0XHRcdFx0c3RhdGU6IFwiYmFua1NlbGVjdFwiLFxuXHRcdFx0XHRiYW5rOiBldmVudC5kYXRhWzFdXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdG1zZyA9IHtcblx0XHRcdFx0c3RhdGU6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbXNnLCB7XG5cdFx0YmluYXJ5LFxuXHRcdHN0YXR1cyxcblx0XHRjaGFubmVsLFxuXHRcdGRhdGE6IGV2ZW50LmRhdGFcblx0fSk7XG59O1xuLy9cbi8vIGNvbnN0IGhvb2tVcE1JRElJbnB1dCA9IG1pZGlBY2Nlc3MgPT4ge1xuLy8gXHR2YXIgaGF2ZUF0TGVhc3RPbmVEZXZpY2UgPSBmYWxzZTtcbi8vIFx0dmFyIGlucHV0cyA9IG1pZGlBY2Nlc3MuaW5wdXRzLnZhbHVlcygpO1xuLy8gXHRmb3IgKHZhciBpbnB1dCA9IGlucHV0cy5uZXh0KCk7IGlucHV0ICYmICFpbnB1dC5kb25lOyBpbnB1dCA9IGlucHV0cy5uZXh0KCkpIHtcbi8vIFx0XHRpbnB1dC52YWx1ZS5vbm1pZGltZXNzYWdlID0gTUlESU1lc3NhZ2VFdmVudEhhbmRsZXI7XG4vLyBcdFx0aGF2ZUF0TGVhc3RPbmVEZXZpY2UgPSB0cnVlO1xuLy8gXHR9XG4vLyB9O1xuLy9cbi8vIGNvbnN0IG9uTUlESUluaXQgPSBtaWRpID0+IHtcbi8vIFx0aG9va1VwTUlESUlucHV0KG1pZGkpO1xuLy8gXHRtaWRpLm9uc3RhdGVjaGFuZ2UgPSBob29rVXBNSURJSW5wdXQ7XG4vLyB9O1xuLy9cbi8vIGNvbnN0IG9uTUlESVJlamVjdCA9IGVyciA9PlxuLy8gXHRjb25zb2xlLmxvZyhlcnIsICdUaGUgTUlESSBzeXN0ZW0gZmFpbGVkIHRvIHN0YXJ0LicpO1xuLy9cbi8vIChuYXZpZ2F0b3IucmVxdWVzdE1JRElBY2Nlc3MpXG4vLyBcdFx0JiYgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCkudGhlbihvbk1JRElJbml0LCBvbk1JRElSZWplY3QpO1xuXG5jb25zdCBwYXJzZUFjY2VzcyA9IGFjY2VzcyA9PiB7XG5cdGxldCBpbnB1dHMgPSBbXTtcblx0bGV0IG91dHB1dHMgPSBbXTtcblxuXHQvLyBjb25zb2xlLmxvZyhhY2Nlc3MpO1xuXG5cdGFjY2Vzcy5pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dHMucHVzaChpbnB1dCkpO1xuXHRhY2Nlc3Mub3V0cHV0cy5mb3JFYWNoKG91dHB1dCA9PiBvdXRwdXRzLnB1c2gob3V0cHV0KSk7XG5cdHJldHVybiB7YWNjZXNzLCBpbnB1dHMsIG91dHB1dHN9O1xufTtcblxuY29uc3QgaW5pdCA9ICgpID0+IHtcblx0Y29uc3QgZGV2aWNlcyQgPSBuZXcgUnguU3ViamVjdCgpO1xuXHQkLmZyb21Qcm9taXNlKG5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2VzcygpKVxuXHRcdC5mbGF0TWFwKGFjY2VzcyA9PiAkLmNyZWF0ZShzdHJlYW0gPT4ge1xuXHRcdFx0YWNjZXNzLm9uc3RhdGVjaGFuZ2UgPSBjb25uZWN0aW9uID0+IHN0cmVhbS5vbk5leHQoY29ubmVjdGlvbi5jdXJyZW50VGFyZ2V0KTtcblx0XHR9KS5zdGFydFdpdGgoYWNjZXNzKSlcblx0XHQubWFwKHBhcnNlQWNjZXNzKVxuXHRcdC8vIC5tYXAoZGF0YSA9PiAoY29uc29sZS5sb2coJ21pZGkgYWNjZXNzJywgZGF0YSksIGRhdGEpKVxuXHRcdC5zdWJzY3JpYmUoZGV2aWNlID0+IGRldmljZXMkLm9uTmV4dChkZXZpY2UpKTtcblx0XHQvLyAuc2hhcmUoKTtcblxuXHRjb25zdCBtc2ckID0gbmV3IFJ4LlN1YmplY3QoKTtcblx0ZGV2aWNlcyQuZmxhdE1hcChcblx0XHQoe2FjY2VzcywgaW5wdXRzfSkgPT4gaW5wdXRzLnJlZHVjZShcblx0XHRcdFx0KG1zZ1N0cmVhbSwgaW5wdXQpID0+IG1zZ1N0cmVhbS5tZXJnZShcblx0XHRcdFx0XHQkLmZyb21FdmVudFBhdHRlcm4oaCA9PiB7XG5cdFx0XHRcdFx0XHRpbnB1dC5vbm1pZGltZXNzYWdlID0gaDtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5tYXAobXNnID0+ICh7YWNjZXNzLCBpbnB1dCwgbXNnfSkpXG5cdFx0XHRcdCksICQuZW1wdHkoKVxuXHRcdFx0KVxuXHQpLnN1YnNjcmliZShtc2cgPT4gbXNnJC5vbk5leHQobXNnKSk7XG5cblx0cmV0dXJuIHtcblx0XHRkZXZpY2VzJCxcblx0XHRtc2ckXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aW5pdCxcblx0bnVtYmVyVG9Ob3RlLFxuXHRub3RlVG9OdW1iZXIsXG5cdHBhcnNlTWlkaU1zZ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmxldCBwb2NrZXQ7XG5cbmxldCByZWR1Y2VycyQgPSBuZXcgUnguU3ViamVjdCgpO1xubGV0IHBvY2tldCQgPSBuZXcgUnguQmVoYXZpb3JTdWJqZWN0KHt9KTtcblxucmVkdWNlcnMkXG5cdC5zY2FuKChwb2NrZXQsIHJlZHVjZSkgPT4gcmVkdWNlKHBvY2tldCksIHt9KVxuXHQuc3Vic2NyaWJlKHBvY2tldCA9PiBwb2NrZXQkLm9uTmV4dChwb2NrZXQpKTtcblxucG9ja2V0JC5zdWJzY3JpYmUoX3BvY2tldCA9PiB7XG5cdC8vIGNvbnNvbGUubG9nKHtwb2NrZXR9KTtcblx0cG9ja2V0ID0gX3BvY2tldDtcbn0pO1xuXG5jb25zdCBwdXQgPSAocGF0aCwgdmFsKSA9PiByZWR1Y2VycyQub25OZXh0KHBvY2tldCA9PiBvYmoucGF0Y2gocG9ja2V0LCBwYXRoLCB2YWwpKTtcbmNvbnN0IGdldCA9IHBhdGggPT4gb2JqLnN1Yihwb2NrZXQsIHBhdGgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cHV0LFxuXHRnZXQsXG5cdHJlZHVjZXJzJCxcblx0c3RyZWFtOiBwb2NrZXQkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3QgcmFmID0gcmVxdWlyZSgncmFmJyk7XG5cbmNvbnN0IHRpY2sgPSBjYiA9PiByYWYoZnVuY3Rpb24oZHQpIHtcblx0Y2IoZHQpO1xuXHR0aWNrKGNiKTtcbn0pO1xuXG5jb25zdCBmcmFtZSA9ICgpID0+ICQuY3JlYXRlKFxuXHRvYnMgPT4gdGljayhkdCA9PiBvYnMub25OZXh0KGR0KSlcbilcblx0LmZpbHRlcihkdCA9PiBkdCAhPT0gMClcblx0LnNoYXJlKCk7XG5cbmNvbnN0IGxvb3AgPSAoc3RhdGUkLCBub2RlKSA9PiBmcmFtZShub2RlKS53aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIChkdCwgc3RhdGUpID0+ICh7ZHQsIHN0YXRlfSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0ZnJhbWUsXG5cdGxvb3Bcbn07XG4iXX0=
