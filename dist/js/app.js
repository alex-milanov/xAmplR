(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0; i < l; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

},{}],2:[function(require,module,exports){
"use strict";

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

var base64 = require('base64-js');
var ieee754 = require('ieee754');
var isArray = require('isarray');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":1,"ieee754":28,"isarray":32}],4:[function(require,module,exports){
'use strict';

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],5:[function(require,module,exports){
(function (Buffer){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":31}],6:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;

  if (!this._events) this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events || !this._events[type]) return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;

  if (!this._events) return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
(function (global){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (a, b) {
  if ("function" == typeof define && define.amd) define([], b);else if ("undefined" != typeof exports) b();else {
    b(), a.FileSaver = { exports: {} }.exports;
  }
})(undefined, function () {
  "use strict";
  function b(a, b) {
    return "undefined" == typeof b ? b = { autoBom: !1 } : "object" != (typeof b === "undefined" ? "undefined" : _typeof(b)) && (console.warn("Depricated: Expected third argument to be a object"), b = { autoBom: !b }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], { type: a.type }) : a;
  }function c(b, c, d) {
    var e = new XMLHttpRequest();e.open("GET", b), e.responseType = "blob", e.onload = function () {
      a(e.response, c, d);
    }, e.onerror = function () {
      console.error("could not download file");
    }, e.send();
  }function d(a) {
    var b = new XMLHttpRequest();return b.open("HEAD", a, !1), b.send(), 200 <= b.status && 299 >= b.status;
  }function e(a) {
    try {
      a.dispatchEvent(new MouseEvent("click"));
    } catch (c) {
      var b = document.createEvent("MouseEvents");b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
    }
  }var f = function () {
    try {
      return Function("return this")() || (42, eval)("this");
    } catch (a) {
      return "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.window === window ? window : "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self ? self : "object" == (typeof global === "undefined" ? "undefined" : _typeof(global)) && global.global === global ? global : this;
    }
  }(),
      a = f.saveAs || "object" != (typeof window === "undefined" ? "undefined" : _typeof(window)) || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype ? function (b, g, h) {
    var i = f.URL || f.webkitURL,
        j = document.createElement("a");g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
      i.revokeObjectURL(j.href);
    }, 4E4), setTimeout(function () {
      e(j);
    }, 0));
  } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
    if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
      var i = document.createElement("a");i.href = f, i.target = "_blank", setTimeout(function () {
        e(i);
      });
    }
  } : function (a, b, d, e) {
    if (e = e || open("", "_blank"), e && (e.document.title = e.document.body.innerText = "downloading..."), "string" == typeof a) return c(a, b, d);var g = "application/octet-stream" === a.type,
        h = /constructor/i.test(f.HTMLElement) || f.safari,
        i = /CriOS\/[\d]+/.test(navigator.userAgent);if ((i || g && h) && "object" == (typeof FileReader === "undefined" ? "undefined" : _typeof(FileReader))) {
      var j = new FileReader();j.onloadend = function () {
        var a = j.result;a = i ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), e ? e.location.href = a : location = a, e = null;
      }, j.readAsDataURL(a);
    } else {
      var k = f.URL || f.webkitURL,
          l = k.createObjectURL(a);e ? e.location = l : location.href = l, e = null, setTimeout(function () {
        k.revokeObjectURL(l);
      }, 4E4);
    }
  };f.saveAs = a.saveAs = a, "undefined" != typeof module && (module.exports = a);
});



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
module.exports=[
	"a",
	"abbr",
	"address",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"bdi",
	"bdo",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"cite",
	"code",
	"col",
	"colgroup",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"div",
	"dl",
	"dt",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"img",
	"input",
	"ins",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"main",
	"map",
	"mark",
	"math",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"nav",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"picture",
	"pre",
	"progress",
	"q",
	"rb",
	"rp",
	"rt",
	"rtc",
	"ruby",
	"s",
	"samp",
	"script",
	"section",
	"select",
	"slot",
	"small",
	"source",
	"span",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"svg",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"u",
	"ul",
	"var",
	"video",
	"wbr"
]

},{}],9:[function(require,module,exports){
'use strict';

module.exports = require('./html-tags.json');

},{"./html-tags.json":8}],10:[function(require,module,exports){
'use strict';

module.exports = {
	obj: require('./lib/obj'),
	arr: require('./lib/arr'),
	str: require('./lib/str'),
	fn: require('./lib/fn')
};

},{"./lib/arr":11,"./lib/fn":12,"./lib/obj":13,"./lib/str":14}],11:[function(require,module,exports){
'use strict';

var add = function add(arr, item) {
	return [].concat(arr, [item]);
};

var remove = function remove(arr, item) {
	return arr.indexOf(item) > -1 ? [].concat(arr.slice(0, arr.indexOf(item)), arr.slice(arr.indexOf(item) + 1)) : arr;
};

var toggle = function toggle(arr, item) {
	return arr.indexOf(item) > -1 ? remove(arr, item) : add(arr, item);
};

module.exports = {
	add: add,
	remove: remove,
	toggle: toggle
};

},{}],12:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var obj = require('./obj');

// (((a, b, …, n) → o), (o → p), …, (x → y), (y → z)) → ((a, b, …, n) → z)
var pipe = function pipe(a) {
	for (var _len = arguments.length, fns = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		fns[_key - 1] = arguments[_key];
	}

	return function () {
		return fns.reduce(function (res, fn) {
			return fn(res);
		}, a.apply(undefined, arguments));
	};
};

// ((y → z), (x → y), …, (o → p), ((a, b, …, n) → o)) → ((a, b, …, n) → z)
var compose = function compose() {
	for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		fns[_key2] = arguments[_key2];
	}

	return pipe.apply(undefined, [fns.slice(-1).pop()].concat(_toConsumableArray(fns.reverse().slice(1))));
};

// switch for backwards compatibility
module.exports = {
	compose: compose,
	pipe: pipe,
	switch: obj.switch
};

},{"./obj":13}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var keyValue = function keyValue(k, v) {
	var o = {};
	o[k] = v;
	return o;
};

var clone = function clone(o) {
	return _extends(Object.create(Object.getPrototypeOf(o) || {}), o);
};

var sub = function sub(o, p) {
	return p instanceof Array ? typeof o[p[0]] !== 'undefined' && p.length > 1 ? sub(o[p[0]], p.slice(1)) : o[p[0]] : o[p];
};

var patch = function patch(o, k, v) {
	return _extends(clone(o), k instanceof Array ? keyValue(k[0], k.length > 1 ? patch(o[k[0]] || {}, k.slice(1), v) : _typeof(o[k[0]]) === 'object' && o[k[0]].constructor === Object && _extends(clone(o[k[0]]), v) || v) : keyValue(k, _typeof(o[k]) === 'object' && o[k].constructor === Object && _extends(clone(o[k]), v) || v));
};

var reduce = function reduce(o, reduceFn, initial) {
	return Object.keys(o).reduce(function (accumulator, key, index) {
		return reduceFn(accumulator, key, o[key], index, o);
	}, typeof initial === 'undefined' ? o[Object.keys(o)[0]] // to confirm with the array reduce spec in this case the firts property is used
	: initial);
};

var map = function map(o, mapFn) {
	return reduce(o, function (o2, key, value, index) {
		return patch(o2, key, mapFn(key, value, index, o));
	}, {});
};

var filter = function filter(o, filterFn) {
	return reduce(o, function (o2, key, value, index) {
		return filterFn(key, value, index, o) ? patch(o2, key, value) : o2;
	}, {});
};

var traverse = function traverse(tree, fn) {
	return Object.keys(tree).reduce(function (o, k) {
		return patch(o, k, _typeof(tree[k]) === 'object' && tree[k].constructor === Object ? traverse(tree[k], fn) : fn(tree[k], k));
	}, {});
};

var chainCall = function chainCall(o, chain) {
	return chain.reduce(function (o, link) {
		return typeof link[1] === 'undefined' ? o[link[0]]() : o[link[0]](link[1]);
	}, o);
};

var _switch = function _switch(value, cases) {
	return sub(cases, value) && sub(cases, value)['default'] || sub(cases, value) || value instanceof Array && value.length > 1 && _switch(value.slice(0, value.length - 1), cases) || cases['default'] || false;
};

module.exports = {
	keyValue: keyValue,
	clone: clone,
	sub: sub,
	patch: patch,
	reduce: reduce,
	map: map,
	filter: filter,
	traverse: traverse,
	chainCall: chainCall,
	switch: _switch
};

},{}],14:[function(require,module,exports){
'use strict';

var capitalize = function capitalize(chunk) {
	return chunk.charAt(0).toUpperCase() + chunk.slice(1);
};

var toCamelCase = function toCamelCase(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	return str.split(glue).map(function (chunk, i) {
		return i === 0 ? chunk : capitalize(chunk);
	}).join('');
};

var fromCamelCase = function fromCamelCase(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	return str.replace(/([A-Z])/g, ' $1').split(' ').map(function (chunk) {
		return chunk.toLowerCase();
	}).join(glue);
};

var singularToPlural = function singularToPlural(str) {
	return str.replace(/y$/, 'ie').concat('s');
};

var pluralToSingular = function pluralToSingular(str) {
	return str.replace(/ies$/, 'y').replace(/s$/, '');
};

var toDocumentId = function toDocumentId(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Id';
	var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
	return prefix.concat(pluralToSingular(toCamelCase(str, glue)), suffix);
};

module.exports = {
	capitalize: capitalize,
	toCamelCase: toCamelCase,
	fromCamelCase: fromCamelCase,
	singularToPlural: singularToPlural,
	pluralToSingular: pluralToSingular,
	toDocumentId: toDocumentId
};

},{}],15:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var snabbdom = require('snabbdom');
var h = require('snabbdom/h').default;

var _require = require('iblokz-data'),
    obj = _require.obj;

var htmlTags = require('html-tags');

var attrs = require('./util/attrs');

var patch = snabbdom.init([// Init patch function with choosen modules
require('snabbdom/modules/class').default, // makes it easy to toggle classes
require('snabbdom/modules/props').default, // for setting properties on DOM elements
require('snabbdom/modules/attributes').default, // for setting properties on DOM elements
require('snabbdom/modules/style').default, // handles styling on elements with support for animations
require('snabbdom/modules/eventlisteners').default // attaches event listeners
]);

var patchStream = function patchStream(stream, dom) {
	dom = typeof dom === 'string' ? document.querySelector(dom) : dom;
	stream.scan(function (vnode, newVnode) {
		return patch(vnode, newVnode);
	}, dom).subscribe();
};

var hyperHelpers = htmlTags.reduce(function (o, tag) {
	o[tag] = function () {
		var _this = this;

		return [Array.from(arguments)].map(attrs.process).map(function (args) {
			return (
				// is the first argument a selector
				args[0] && typeof args[0] === 'string' && args[0].match(/^(\.|#)[a-zA-Z\-_0-9]+/ig) ? [].concat(tag + args[0], args.slice(1)) : [tag].concat(args)
			);
		}).map(function (args) {
			return h.apply(_this, args);
		}).pop();
	};
	return o;
}, {});

module.exports = _extends({
	h: h,
	patch: patch,
	patchStream: patchStream
}, hyperHelpers);

},{"./util/attrs":27,"html-tags":9,"iblokz-data":10,"snabbdom":24,"snabbdom/h":16,"snabbdom/modules/attributes":19,"snabbdom/modules/class":20,"snabbdom/modules/eventlisteners":21,"snabbdom/modules/props":22,"snabbdom/modules/style":23}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {},
        children,
        text,
        i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        } else if (is.primitive(c)) {
            text = c;
        } else if (c && c.sel) {
            children = [c];
        }
    } else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        } else if (is.primitive(b)) {
            text = b;
        } else if (b && b.sel) {
            children = [b];
        } else {
            data = b;
        }
    }
    if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i])) children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i]);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' && (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;


},{"./is":18,"./vnode":26}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
exports.htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment
};
exports.default = exports.htmlDomApi;


},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;


},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", "truespeed", "typemustmatch", "visible"];
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
var booleanAttrsDict = Object.create(null);
for (var i = 0, len = booleanAttrs.length; i < len; i++) {
    booleanAttrsDict[booleanAttrs[i]] = true;
}
function updateAttrs(oldVnode, vnode) {
    var key,
        elm = vnode.elm,
        oldAttrs = oldVnode.data.attrs,
        attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs) return;
    if (oldAttrs === attrs) return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (booleanAttrsDict[key]) {
                if (cur) {
                    elm.setAttribute(key, "");
                } else {
                    elm.removeAttribute(key);
                }
            } else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                } else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                } else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                } else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;


},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur,
        name,
        elm = vnode.elm,
        oldClass = oldVnode.data.class,
        klass = vnode.data.class;
    if (!oldClass && !klass) return;
    if (oldClass === klass) return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;


},{}],21:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    } else if ((typeof handler === "undefined" ? "undefined" : _typeof(handler)) === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            } else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        } else {
            // call multiple handlers
            for (var i = 0; i < handler.length; i++) {
                invokeHandler(handler[i]);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type,
        on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) {
        invokeHandler(on[name], vnode, event);
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on,
        oldListener = oldVnode.listener,
        oldElm = oldVnode.elm,
        on = vnode && vnode.data.on,
        elm = vnode && vnode.elm,
        name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                oldElm.removeEventListener(name, oldListener, false);
            }
        } else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                elm.addEventListener(name, listener, false);
            }
        } else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    elm.addEventListener(name, listener, false);
                }
            }
        }
    }
}
exports.eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
exports.default = exports.eventListenersModule;


},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key,
        cur,
        old,
        elm = vnode.elm,
        oldProps = oldVnode.data.props,
        props = vnode.data.props;
    if (!oldProps && !props) return;
    if (oldProps === props) return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;


},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var raf = typeof window !== 'undefined' && window.requestAnimationFrame || setTimeout;
var nextFrame = function nextFrame(fn) {
    raf(function () {
        raf(fn);
    });
};
function setNextFrame(obj, prop, val) {
    nextFrame(function () {
        obj[prop] = val;
    });
}
function updateStyle(oldVnode, vnode) {
    var cur,
        name,
        elm = vnode.elm,
        oldStyle = oldVnode.data.style,
        style = vnode.data.style;
    if (!oldStyle && !style) return;
    if (oldStyle === style) return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            } else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        } else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            } else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style,
        name,
        elm = vnode.elm,
        s = vnode.data.style;
    if (!s || !(style = s.destroy)) return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    var name,
        elm = vnode.elm,
        i = 0,
        compStyle,
        style = s.remove,
        amount = 0,
        applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1) amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm) --amount;
        if (amount === 0) rm();
    });
}
exports.styleModule = {
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;


},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
var htmldomapi_1 = require("./htmldomapi");
function isUndef(s) {
    return s === undefined;
}
function isDef(s) {
    return s !== undefined;
}
var emptyNode = vnode_1.default('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i,
        map = {},
        key,
        ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined) map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
var h_1 = require("./h");
exports.h = h_1.h;
var thunk_1 = require("./thunk");
exports.thunk = thunk_1.thunk;
function init(modules, domApi) {
    var i,
        j,
        cbs = {};
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i,
            data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children,
            sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        } else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag) : api.createElement(tag);
            if (hash < dot) elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, vnode);
            }if (is.array(children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            } else if (is.primitive(vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create) i.create(emptyNode, vnode);
                if (i.insert) insertedVnodeQueue.push(vnode);
            }
        } else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i,
            j,
            data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](vnode);
            }if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0,
                listeners = void 0,
                rm = void 0,
                ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1) {
                        cbs.remove[i_1](ch, rm);
                    }if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    } else {
                        rm();
                    }
                } else {
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0,
            newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            } else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            } else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                } else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    } else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx > oldEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode) return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i) {
                cbs.update[i](oldVnode, vnode);
            }i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        } else if (oldVnode.text !== vnode.text) {
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i) {
            cbs.pre[i]();
        }if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        } else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i) {
            cbs.post[i]();
        }return vnode;
    };
}
exports.init = init;


},{"./h":16,"./htmldomapi":17,"./is":18,"./thunk":25,"./vnode":26}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = require("./h");
function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i,
        old = oldVnode.data,
        cur = thunk.data;
    var oldArgs = old.args,
        args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
exports.thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return h_1.h(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
exports.default = exports.thunk;


},{"./h":16}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;


},{}],27:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('iblokz-data'),
    obj = _require.obj;

var strParse = function strParse(s) {
	return s.match(/^[0-9]+$/) ? parseInt(s, 10) : s.match(/^[0-9.]+$/) ? parseFloat(s) : s === 'true' ? true : s === 'false' ? false : s;
};

var process = function process(args) {
	var newArgs = args.slice();

	var selector = newArgs[0] && typeof newArgs[0] === 'string' && newArgs[0] || '';
	if (selector !== '') newArgs = newArgs.slice(1);

	var attrRegExp = /\[[a-z\-0-9]+=("[^"]+"|'[^']+'|[0-9.]+|true|false|[^\]^=^"^']+)\]/ig;

	var attrs = selector && selector.match(attrRegExp);
	selector = selector.replace(attrRegExp, '');

	attrs = attrs && attrs.map && attrs.map(function (c) {
		return c.replace(/[[\]("|')]/g, '').split('=');
	}).reduce(function (o, attr) {
		return obj.patch(o, attr[0], strParse(attr[1]));
	}, {}) || {};

	if (attrs && Object.keys(attrs).length > 0) {
		if (!newArgs[0] || newArgs[0] && _typeof(newArgs[0]) === 'object' && !(newArgs[0] instanceof Array)) {
			attrs = _extends({}, newArgs[0] && newArgs[0].attrs || {}, attrs);
			newArgs[0] = _extends({}, newArgs[0] || {}, { attrs: attrs });
		} else {
			newArgs = [{ attrs: attrs }].concat(newArgs);
		}
	}

	if (selector !== '') newArgs = [selector].concat(newArgs);

	// console.log(args, newArgs);
	return newArgs;
};

module.exports = {
	strParse: strParse,
	process: process
};

},{"iblokz-data":10}],28:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],29:[function(require,module,exports){
(function (global){
'use strict';

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function scheduleDrain() {
      element.data = called = ++called % 2;
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function scheduleDrain() {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function scheduleDrain() {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function scheduleDrain() {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
'use strict';

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],31:[function(require,module,exports){
'use strict';

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],32:[function(require,module,exports){
'use strict';

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],33:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

// public method for encoding
exports.encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0,
        len = input.length,
        remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }

    return output.join("");
};

// public method for decoding
exports.decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0,
        resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
    } else {
        output = new Array(totalLength | 0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }
    }

    return output;
};

},{"./support":62,"./utils":64}],34:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker: function getContentWorker() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker: function getCompressedWorker() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":38,"./stream/Crc32Probe":57,"./stream/DataLengthProbe":58,"./stream/DataWorker":59}],35:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function compressWorker(compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker: function uncompressWorker() {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":39,"./stream/GenericWorker":60}],36:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
    } else {
        return crc32str(crc | 0, input, input.length, 0);
    }
};

},{"./utils":64}],37:[function(require,module,exports){
'use strict';

exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],38:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)

var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":105}],39:[function(require,module,exports){
'use strict';

var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function (data) {
        self.push({
            data: data,
            meta: self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":60,"./utils":64,"pako":89}],40:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function decToHex(dec, bytes) {
    var hex = "",
        i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0) & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
        compression = streamInfo['compression'],
        useCustomEncoding = encodeFileName !== utf8.utf8encode,
        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
        comment = file.comment,
        encodedComment = utils.transformTo("string", encodeFileName(comment)),
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
        useUTF8ForComment = utfEncodedComment.length !== comment.length,
        dosTime,
        dosDate,
        extraFields = "",
        unicodePathExtraField = "",
        unicodeCommentExtraField = "",
        dir = file.dir,
        date = file.date;

    var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }

    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if (platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
        // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
        // Version
        decToHex(1, 1) +
        // NameCRC32
        decToHex(crc32(encodedFileName), 4) +
        // UnicodeName
        utfEncodedFileName;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x70" +
        // size
        decToHex(unicodePathExtraField.length, 2) +
        // content
        unicodePathExtraField;
    }

    if (useUTF8ForComment) {

        unicodeCommentExtraField =
        // Version
        decToHex(1, 1) +
        // CommentCRC32
        decToHex(crc32(encodedComment), 4) +
        // UnicodeName
        utfEncodedComment;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x63" +
        // size
        decToHex(unicodeCommentExtraField.length, 2) +
        // content
        unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);

    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
    // version made by (00: DOS)
    decToHex(versionMadeBy, 2) +
    // file header (common to file and central directory)
    header +
    // file comment length
    decToHex(encodedComment.length, 2) +
    // disk number start
    "\x00\x00" +
    // internal file attributes TODO
    "\x00\x00" +
    // external file attributes
    decToHex(extFileAttr, 4) +
    // relative offset of local header
    decToHex(offset, 4) +
    // file name
    encodedFileName +
    // extra field
    extraFields +
    // file comment
    encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
    // number of this disk
    "\x00\x00" +
    // number of the disk with the start of the central directory
    "\x00\x00" +
    // total number of entries in the central directory on this disk
    decToHex(entriesCount, 2) +
    // total number of entries in the central directory
    decToHex(entriesCount, 2) +
    // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) +
    // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) +
    // .ZIP file comment length
    decToHex(encodedComment.length, 2) +
    // .ZIP file comment
    encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function generateDataDescriptors(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
    // crc-32                          4 bytes
    decToHex(streamInfo['crc32'], 4) +
    // compressed size                 4 bytes
    decToHex(streamInfo['compressedSize'], 4) +
    // uncompressed size               4 bytes
    decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};

/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;

    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if (this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data: chunk.data,
            meta: {
                currentFile: this.currentFile,
                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data: generateDataDescriptors(streamInfo),
            meta: { percent: 100 }
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data: this.dirRecords[i],
            meta: { percent: 100 }
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data: dirEnd,
        meta: { percent: 100 }
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if (self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for (var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch (e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":36,"../signature":55,"../stream/GenericWorker":60,"../utf8":63,"../utils":64}],41:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function getCompression(fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir,
                date = file.date;

            file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                name: relativePath,
                dir: dir,
                date: date,
                comment: file.comment || "",
                unixPermissions: file.unixPermissions,
                dosPermissions: file.dosPermissions
            }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":35,"./ZipFileWorker":40}],42:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */

function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if (!(this instanceof JSZip)) {
        return new JSZip();
    }

    if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function () {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.5";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":37,"./external":38,"./load":43,"./object":47,"./support":62}],43:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        }).on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        }).resume();
    });
}

module.exports = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions: input.unixPermissions,
                dosPermissions: input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":38,"./nodejsUtils":46,"./stream/Crc32Probe":57,"./utf8":63,"./utils":64,"./zipEntries":65}],44:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function (chunk) {
        self.push({
            data: chunk,
            meta: {
                percent: 0
            }
        });
    }).on("error", function (e) {
        if (self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    }).on("end", function () {
        if (self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if (!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":60,"../utils":64}],45:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if (updateCb) {
            updateCb(meta);
        }
    }).on("error", function (e) {
        self.emit('error', e);
    }).on("end", function () {
        self.push(null);
    });
}

NodejsStreamOutputAdapter.prototype._read = function () {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":64,"readable-stream":48}],46:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode: typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function newBufferFrom(data, encoding) {
        // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`
        // in nodejs v4 (< v.4.5). It's not the expected implementation (and
        // has a different signature).
        // see https://github.com/nodejs/node/issues/8053
        // A condition on nodejs' version won't solve the issue as we don't
        // control the Buffer polyfills that may or may not be used.
        return new Buffer(data, encoding);
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function allocBuffer(size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            return new Buffer(size);
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer: function isBuffer(b) {
        return Buffer.isBuffer(b);
    },

    isStream: function isStream(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
};

}).call(this,require("buffer").Buffer)

},{"buffer":3}],47:[function(require,module,exports){
'use strict';

var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");

/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function fileAdd(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;

    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && o.unixPermissions & 0x4000) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && o.dosPermissions & 0x0010) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }

    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?
     return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function parentFolder(path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function forceTrailingSlash(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function folderAdd(name, createFolders) {
    createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function load() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function forEach(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) {
                // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function filter(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) {
                // the file matches the function
                result.push(entry);
            }
        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function file(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            } else {
                // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        } else {
            // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function folder(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function (relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function remove(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function (relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function generate(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function generateInternalStream(options) {
        var worker,
            opts = {};
        try {
            opts = utils.extend(options || {}, {
                streamFiles: false,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: 'application/zip',
                encodeFileName: utf8.utf8encode
            });

            opts.type = opts.type.toLowerCase();
            opts.compression = opts.compression.toUpperCase();

            // "binarystring" is prefered but the internals use "string".
            if (opts.type === "binarystring") {
                opts.type = "string";
            }

            if (!opts.type) {
                throw new Error("No output type specified.");
            }

            utils.checkSupport(opts.type);

            // accept nodejs `process.platform`
            if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
                opts.platform = "UNIX";
            }
            if (opts.platform === 'win32') {
                opts.platform = "DOS";
            }

            var comment = opts.comment || this.comment || "";
            worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
            worker = new GenericWorker("error");
            worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function generateAsync(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function generateNodeStream(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":34,"./defaults":37,"./generate":41,"./nodejs/NodejsStreamInputAdapter":44,"./nodejsUtils":46,"./stream/GenericWorker":60,"./stream/StreamHelper":61,"./utf8":63,"./utils":64,"./zipObject":67}],48:[function(require,module,exports){
"use strict";

/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":125}],49:[function(require,module,exports){
'use strict';

var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 0xFF;
    }
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function (i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":64,"./DataReader":50}],50:[function(require,module,exports){
'use strict';

var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function checkOffset(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function checkIndex(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function setIndex(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function skip(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function byteAt(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function readInt(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function readString(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function readData(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function lastIndexOfSignature(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function readAndCheckSignature(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function readDate() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
        (dostime >> 21 & 0x0f) - 1, // month
        dostime >> 16 & 0x1f, // day
        dostime >> 11 & 0x1f, // hour
        dostime >> 5 & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":64}],51:[function(require,module,exports){
'use strict';

var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":64,"./Uint8ArrayReader":53}],52:[function(require,module,exports){
'use strict';

var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function (i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function (sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function (size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":64,"./DataReader":50}],53:[function(require,module,exports){
'use strict';

var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":64,"./ArrayReader":49}],54:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":62,"../utils":64,"./ArrayReader":49,"./NodeBufferReader":51,"./StringReader":52,"./Uint8ArrayReader":53}],55:[function(require,module,exports){
'use strict';

exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],56:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":64,"./GenericWorker":60}],57:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
  GenericWorker.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
  this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":36,"../utils":64,"./GenericWorker":60}],58:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;

},{"../utils":64,"./GenericWorker":60}],59:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if (!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function () {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function () {

    if (this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null,
        nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch (this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
                break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
                break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
                break;
        }
        this.index = nextIndex;
        return this.push({
            data: data,
            meta: {
                percent: this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":64,"./GenericWorker":60}],60:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */

function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data': [],
        'end': [],
        'error': []
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push: function push(chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end: function end() {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error: function error(e) {
        if (this.isFinished) {
            return false;
        }

        if (this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if (this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on: function on(name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp: function cleanUp() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit: function emit(name, arg) {
        if (this._listeners[name]) {
            for (var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe: function pipe(next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious: function registerPrevious(previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous = previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause: function pause() {
        if (this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if (this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume: function resume() {
        if (!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if (this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if (this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush: function flush() {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk: function processChunk(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo: function withStreamInfo(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo: function mergeStreamInfo() {
        for (var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function lock() {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString: function toString() {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],61:[function(require,module,exports){
(function (Buffer){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch (e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch (type) {
        case "blob":
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
            return base64.encode(content);
        default:
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat(type, dataArray) {
    var i,
        index = 0,
        res = null,
        totalLength = 0;
    for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch (type) {
        case "string":
            return dataArray.join("");
        case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for (i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '" + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function _accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper.on('data', function (data, meta) {
            dataArray.push(data);
            if (updateCallback) {
                updateCallback(meta);
            }
        }).on('error', function (err) {
            dataArray = [];
            reject(err);
        }).on('end', function () {
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        }).resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
            break;
        case "base64":
            internalType = "string";
            break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate: function accumulate(updateCb) {
        return _accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on: function on(evt, fn) {
        var self = this;

        if (evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume: function resume() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause: function pause() {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream: function toNodejsStream(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
    }
};

module.exports = StreamHelper;

}).call(this,require("buffer").Buffer)

},{"../base64":33,"../external":38,"../nodejs/NodejsStreamOutputAdapter":45,"../support":62,"../utils":64,"./ConvertWorker":56,"./GenericWorker":60,"buffer":3}],62:[function(require,module,exports){
(function (Buffer){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
} else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    } catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        } catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch (e) {
    exports.nodestream = false;
}

}).call(this,require("buffer").Buffer)

},{"buffer":3,"readable-stream":48}],63:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function string2buf(str) {
    var buf,
        c,
        c2,
        m_pos,
        i,
        str_len = str.length,
        buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function utf8border(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) {
        max = buf.length;
    }

    // go back from last position, until start of sequence found
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
    }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) {
        return max;
    }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) {
        return max;
    }

    return pos + _utf8len[buf[pos]] > max ? pos : max;
};

// convert array to string
var buf2string = function buf2string(buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) {
            utf16buf[out++] = c;continue;
        }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
        }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;continue;
        }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};

// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};

/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if (this.leftOver && this.leftOver.length) {
        this.push({
            data: exports.utf8decode(this.leftOver),
            meta: {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":46,"./stream/GenericWorker":60,"./support":62,"./utils":64}],64:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('core-js/library/fn/set-immediate');
var external = require("./external");

/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
        result = new Uint8Array(str.length);
    } else {
        result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function (part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    } catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        } catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function stringifyByChunk(array, type, chunk) {
        var result = [],
            k = 0,
            len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function stringifyByChar(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        }()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;

/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function array(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function uint8array(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function nodebuffer(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function arraybuffer(input) {
        return new Uint8Array(input).buffer;
    },
    "uint8array": function uint8array(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function string(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function array(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function uint8array(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function uint8array(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function (outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function (input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function (type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function (str) {
    var res = '',
        code,
        i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function (callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function Obj() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function () {
    var result = {},
        i,
        attr;
    for (i = 0; i < arguments.length; i++) {
        // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function (data) {

        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function (e) {
                    resolve(e.target.result);
                };
                reader.onerror = function (e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function (data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            } else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":33,"./external":38,"./nodejsUtils":46,"./support":62,"core-js/library/fn/set-immediate":68}],65:[function(require,module,exports){
'use strict';

var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function checkSignature(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function isSignature(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function readBlockEndOfCentral() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function readLocalFiles() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function readCentralDir() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function readEndOfCentral() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();

        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function prepareReader(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function load(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":54,"./signature":55,"./support":62,"./utf8":63,"./utils":64,"./zipEntry":66}],66:[function(require,module,exports){
'use strict';

var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function findCompression(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function isEncrypted() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function useUTF8() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function readLocalPart(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) {
            // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function readCentralPart(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function processAttributes() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if (madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function parseZIP64ExtraField(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function readExtraFields(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function handleUTF8() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":34,"./compressions":35,"./crc32":36,"./reader/readerFor":54,"./support":62,"./utf8":63,"./utils":64}],67:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function ZipObject(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function internalStream(type) {
        var result = null,
            outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function async(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function nodeStream(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function _compressWorker(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if (!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker: function _decompressWorker() {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function removedFn() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for (var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":34,"./stream/DataWorker":59,"./stream/GenericWorker":60,"./stream/StreamHelper":61,"./utf8":63}],68:[function(require,module,exports){
'use strict';

require('../modules/web.immediate');
module.exports = require('../modules/_core').setImmediate;

},{"../modules/_core":72,"../modules/web.immediate":88}],69:[function(require,module,exports){
'use strict';

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],70:[function(require,module,exports){
'use strict';

var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":83}],71:[function(require,module,exports){
"use strict";

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],72:[function(require,module,exports){
'use strict';

var core = module.exports = { version: '2.3.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],73:[function(require,module,exports){
'use strict';

// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":69}],74:[function(require,module,exports){
'use strict';

// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_fails":77}],75:[function(require,module,exports){
'use strict';

var isObject = require('./_is-object'),
    document = require('./_global').document
// in old IE typeof document.createElement is 'object'
,
    is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":78,"./_is-object":83}],76:[function(require,module,exports){
'use strict';

var global = require('./_global'),
    core = require('./_core'),
    ctx = require('./_ctx'),
    hide = require('./_hide'),
    PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      IS_WRAP = type & $export.W,
      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
      expProto = exports[PROTOTYPE],
      target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
      key,
      own,
      out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
          }return new C(a, b, c);
        }return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
      // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

},{"./_core":72,"./_ctx":73,"./_global":78,"./_hide":79}],77:[function(require,module,exports){
"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],78:[function(require,module,exports){
'use strict';

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],79:[function(require,module,exports){
'use strict';

var dP = require('./_object-dp'),
    createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":74,"./_object-dp":84,"./_property-desc":85}],80:[function(require,module,exports){
'use strict';

module.exports = require('./_global').document && document.documentElement;

},{"./_global":78}],81:[function(require,module,exports){
'use strict';

module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_descriptors":74,"./_dom-create":75,"./_fails":77}],82:[function(require,module,exports){
"use strict";

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
                  var un = that === undefined;
                  switch (args.length) {
                                    case 0:
                                                      return un ? fn() : fn.call(that);
                                    case 1:
                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
                                    case 2:
                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                    case 3:
                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                    case 4:
                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                  }return fn.apply(that, args);
};

},{}],83:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

},{}],84:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object'),
    IE8_DOM_DEFINE = require('./_ie8-dom-define'),
    toPrimitive = require('./_to-primitive'),
    dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":70,"./_descriptors":74,"./_ie8-dom-define":81,"./_to-primitive":87}],85:[function(require,module,exports){
"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],86:[function(require,module,exports){
'use strict';

var ctx = require('./_ctx'),
    invoke = require('./_invoke'),
    html = require('./_html'),
    cel = require('./_dom-create'),
    global = require('./_global'),
    process = global.process,
    setTask = global.setImmediate,
    clearTask = global.clearImmediate,
    MessageChannel = global.MessageChannel,
    counter = 0,
    queue = {},
    ONREADYSTATECHANGE = 'onreadystatechange',
    defer,
    channel,
    port;
var run = function run() {
  var id = +this;
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [],
        i = 1;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }queue[++counter] = function () {
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    };
    // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":71,"./_ctx":73,"./_dom-create":75,"./_global":78,"./_html":80,"./_invoke":82}],87:[function(require,module,exports){
'use strict';

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":83}],88:[function(require,module,exports){
'use strict';

var $export = require('./_export'),
    $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":76,"./_task":86}],89:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign = require('./lib/utils/common').assign;

var deflate = require('./lib/deflate');
var inflate = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":90,"./lib/inflate":91,"./lib/utils/common":92,"./lib/zlib/constants":95}],90:[function(require,module,exports){
'use strict';

var zlib_deflate = require('./zlib/deflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY = 0;

var Z_DEFLATED = 8;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }

  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":92,"./utils/strings":93,"./zlib/deflate":97,"./zlib/messages":102,"./zlib/zstream":104}],91:[function(require,module,exports){
'use strict';

var zlib_inflate = require('./zlib/inflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var c = require('./zlib/constants');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');
var GZheader = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }

  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

},{"./utils/common":92,"./utils/strings":93,"./zlib/constants":95,"./zlib/gzheader":98,"./zlib/inflate":100,"./zlib/messages":102,"./zlib/zstream":104}],92:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};

// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
};

// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],93:[function(require,module,exports){
// String encode/decode helpers
'use strict';

var utils = require('./common');

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}

// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};

// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};

// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;continue;
    }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

},{"./common":92}],94:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

},{}],95:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,

  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],96:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

},{}],97:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');
var trees = require('./trees');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var msg = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;

var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/* The deflate compression method */
var Z_DEFLATED = 8;

/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS = 256;
/* number of literal bytes 0..255 */
var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES = 30;
/* number of distance codes */
var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length; /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match; /* matched string */
  var len; /* length of current match */
  var best_len = s.prev_length; /* best match length so far */
  var nice_match = s.nice_match; /* stop if match long enough */
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head; /* head of the hash chain */
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head; /* head of hash chain */
  var bflush; /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {

          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush; /* set if current block must be flushed */
  var prev; /* byte at distance one to match */
  var scan, strend; /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0; /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0; /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;

        s.status = BUSY_STATE;
        putShortMSB(s, header);

        /* Save the adler32 of the preset dictionary: */
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }
        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  }

  //#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  //#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":92,"./adler32":94,"./crc32":96,"./messages":102,"./trees":103}],98:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}

module.exports = GZheader;

},{}],99:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js

var BAD = 30; /* got a data error -- remain here until reset */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in; /* local strm.input */
  var last; /* have enough input while in < last */
  var _out; /* local strm.output */
  var beg; /* inflate()'s initial strm.output */
  var end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  var dmax; /* maximum distance from zlib header */
  //#endif
  var wsize; /* window size or zero if not using window */
  var whave; /* valid bytes in the window */
  var wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window; /* allocated sliding window, if wsize != 0 */
  var hold; /* local strm.hold */
  var bits; /* local strm.bits */
  var lcode; /* local strm.lencode */
  var dcode; /* local strm.distcode */
  var lmask; /* mask for first level of length codes */
  var dmask; /* mask for first level of distance codes */
  var here; /* retrieved table entry */
  var op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  var len; /* match length, unused bytes */
  var dist; /* match distance */
  var from; /* where to copy match from */
  var from_source;

  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],100:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var inflate_fast = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED = 8;

/* STATES ====================================================================*/
/* ===========================================================================*/

var HEAD = 1; /* i: waiting for magic header */
var FLAGS = 2; /* i: waiting for method and flags (gzip) */
var TIME = 3; /* i: waiting for modification time (gzip) */
var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
var EXLEN = 5; /* i: waiting for extra length (gzip) */
var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
var NAME = 7; /* i: waiting for end of file name (gzip) */
var COMMENT = 8; /* i: waiting for end of comment (gzip) */
var HCRC = 9; /* i: waiting for header crc (gzip) */
var DICTID = 10; /* i: waiting for dictionary check value */
var DICT = 11; /* waiting for inflateSetDictionary() call */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
var STORED = 14; /* i: waiting for stored size (length and complement) */
var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
var COPY = 16; /* i/o: waiting for input or output to copy stored block */
var TABLE = 17; /* i: waiting for dynamic block table lengths */
var LENLENS = 18; /* i: waiting for code length code lengths */
var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
var LEN_ = 20; /* i: same as LEN below, but only first time in */
var LEN = 21; /* i: waiting for length/lit/eob code */
var LENEXT = 22; /* i: waiting for length extra bits */
var DIST = 23; /* i: waiting for distance code */
var DISTEXT = 24; /* i: waiting for distance extra bits */
var MATCH = 25; /* o: waiting for output space to copy string */
var LIT = 26; /* o: waiting for output space to write literal */
var CHECK = 27; /* i: waiting for 32-bit check value */
var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
var DONE = 29; /* finished check, done -- remain here until reset */
var BAD = 30; /* got a data error -- remain here until reset */
var MEM = 31; /* got an inflate() memory error -- remain here until reset */
var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib) */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null /*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers
  var next; /* next input INDEX */
  var put; /* next output INDEX */
  var have, left; /* available input and output */
  var hold; /* bit buffer */
  var bits; /* bits in bit buffer */
  var _in, _out; /* save starting available input and output */
  var copy; /* number of stored or match bytes to copy */
  var from; /* where to copy match bytes from */
  var from_source;
  var here = 0; /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len; /* length to copy for repeats, bits to drop */
  var ret; /* return code */
  var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0; /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff) << /*BITS(8)*/8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f) !== /*BITS(4)*/Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f) + /*BITS(4)*/8;
        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(state.head.extra, input, next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03) {/*BITS(2)*/case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f) + /*BITS(5)*/257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f) + /*BITS(5)*/1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f) + /*BITS(4)*/4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
      return Z_STREAM_ERROR;
    }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":92,"./adler32":94,"./crc32":96,"./inffast":99,"./inftrees":101}],101:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

var lext = [/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];

var dbase = [/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];

var dext = [/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  var len = 0; /* a code's length in bits */
  var sym = 0; /* index of code symbols */
  var min = 0,
      max = 0; /* minimum and maximum code lengths */
  var root = 0; /* number of index bits for root table */
  var curr = 0; /* number of index bits for current table */
  var drop = 0; /* code bits to drop for sub-table */
  var left = 0; /* number of prefix codes available */
  var used = 0; /* code entries in table used */
  var huff = 0; /* Huffman code */
  var incr; /* for incrementing code, index */
  var fill; /* index for replicating entries */
  var low; /* low bits for current root entry */
  var mask; /* mask for low root bits */
  var next; /* next available space in table */
  var base = null; /* base value table to use */
  var base_index = 0;
  //  var shoextra;    /* extra bits table to use */
  var end; /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work; /* dummy value--not used */
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":92}],102:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary', /* Z_NEED_DICT       2  */
  1: 'stream end', /* Z_STREAM_END      1  */
  0: '', /* Z_OK              0  */
  '-1': 'file error', /* Z_ERRNO         (-1) */
  '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error', /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],103:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/

//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY = 0;
var Z_TEXT = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/*============================================================================*/

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits = /* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

var extra_dbits = /* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

var extra_blbits = /* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h; /* heap index */
  var n, m; /* iterate over the tree elements */
  var bits; /* bit length */
  var xbits; /* extra bits */
  var f; /* frequency */
  var overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0; /* running code value */
  var bits; /* bit index */
  var n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n; /* iterates over tree elements */
  var bits; /* bit counter */
  var length; /* length value */
  var code; /* code value */
  var dist; /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}

/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }

  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s); /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  //  while (len--) {
  //    put_byte(s, *buf++);
  //  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}

// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist; /* distance of matched string */
  var lc; /* match length or unmatched char (if dist == 0) */
  var lx = 0; /* running index in l_buf */
  var code; /* the code to send */
  var extra; /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");
    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m; /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {

      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}

var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s) {

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}

/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  var max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility

  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif

  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":92}],104:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],105:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":29}],106:[function(require,module,exports){
(function (process){
"use strict";

// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(undefined);



}).call(this,require('_process'))

},{"_process":108}],107:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

}).call(this,require('_process'))

},{"_process":108}],108:[function(require,module,exports){
'use strict';

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],109:[function(require,module,exports){
(function (global){
'use strict';

var now = require('performance-now'),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
module.exports.cancel = function () {
  caf.apply(root, arguments);
};
module.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":106}],110:[function(require,module,exports){
'use strict';

module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":111}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":113,"./_stream_writable":115,"core-util-is":5,"inherits":30,"process-nextick-args":107}],112:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":114,"core-util-is":5,"inherits":30}],113:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":111,"./internal/streams/BufferList":116,"./internal/streams/destroy":117,"./internal/streams/stream":118,"_process":108,"core-util-is":5,"events":6,"inherits":30,"isarray":32,"process-nextick-args":107,"safe-buffer":124,"string_decoder/":126,"util":2}],114:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":111,"core-util-is":5,"inherits":30}],115:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":111,"./internal/streams/destroy":117,"./internal/streams/stream":118,"_process":108,"core-util-is":5,"inherits":30,"process-nextick-args":107,"safe-buffer":124,"util-deprecate":133}],116:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

},{"safe-buffer":124,"util":2}],117:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

},{"process-nextick-args":107}],118:[function(require,module,exports){
'use strict';

module.exports = require('events').EventEmitter;

},{"events":6}],119:[function(require,module,exports){
'use strict';

module.exports = require('./readable').PassThrough;

},{"./readable":120}],120:[function(require,module,exports){
'use strict';

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":111,"./lib/_stream_passthrough.js":112,"./lib/_stream_readable.js":113,"./lib/_stream_transform.js":114,"./lib/_stream_writable.js":115}],121:[function(require,module,exports){
'use strict';

module.exports = require('./readable').Transform;

},{"./readable":120}],122:[function(require,module,exports){
'use strict';

module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":115}],123:[function(require,module,exports){
(function (process,global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.

;(function (undefined) {

  var objectTypes = {
    'function': true,
    'object': true
  };

  function checkGlobal(value) {
    return value && value.Object === Object ? value : null;
  }

  var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : null;
  var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : null;
  var freeGlobal = checkGlobal(freeExports && freeModule && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global);
  var freeSelf = checkGlobal(objectTypes[typeof self === 'undefined' ? 'undefined' : _typeof(self)] && self);
  var freeWindow = checkGlobal(objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window);
  var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;
  var thisGlobal = checkGlobal(objectTypes[_typeof(this)] && this);
  var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();

  var Rx = {
    internals: {},
    config: {
      Promise: root.Promise
    },
    helpers: {}
  };

  // Defaults
  var noop = Rx.helpers.noop = function () {},
      identity = Rx.helpers.identity = function (x) {
    return x;
  },
      defaultNow = Rx.helpers.defaultNow = Date.now,
      defaultComparer = Rx.helpers.defaultComparer = function (x, y) {
    return isEqual(x, y);
  },
      defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) {
    return x > y ? 1 : x < y ? -1 : 0;
  },
      defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) {
    return x.toString();
  },
      defaultError = Rx.helpers.defaultError = function (err) {
    throw err;
  },
      isPromise = Rx.helpers.isPromise = function (p) {
    return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
  },
      isFunction = Rx.helpers.isFunction = function () {

    var isFn = function isFn(value) {
      return typeof value == 'function' || false;
    };

    // fallback for older versions of Chrome and Safari
    if (isFn(/x/)) {
      isFn = function isFn(value) {
        return typeof value == 'function' && toString.call(value) == '[object Function]';
      };
    }

    return isFn;
  }();

  function cloneArray(arr) {
    for (var a = [], i = 0, len = arr.length; i < len; i++) {
      a.push(arr[i]);
    }return a;
  }

  var errorObj = { e: {} };

  function tryCatcherGen(tryCatchTarget) {
    return function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    };
  }

  var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {
    if (!isFunction(fn)) {
      throw new TypeError('fn must be a function');
    }
    return tryCatcherGen(fn);
  };

  function thrower(e) {
    throw e;
  }

  Rx.config.longStackSupport = false;
  var hasStacks = false,
      stacks = tryCatch(function () {
    throw new Error();
  })();
  hasStacks = !!stacks.e && !!stacks.e.stack;

  // All code after this point will be filtered from stack traces reported by RxJS
  var rStartingLine = captureLine(),
      rFileName;

  var STACK_JUMP_SEPARATOR = 'From previous event:';

  function makeStackTraceLong(error, observable) {
    // If possible, transform the error stack trace by removing Node and RxJS
    // cruft, then concatenating with the stack trace of `observable`.
    if (hasStacks && observable.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
      var stacks = [];
      for (var o = observable; !!o; o = o.source) {
        if (o.stack) {
          stacks.unshift(o.stack);
        }
      }
      stacks.unshift(error.stack);

      var concatedStacks = stacks.join('\n' + STACK_JUMP_SEPARATOR + '\n');
      error.stack = filterStackString(concatedStacks);
    }
  }

  function filterStackString(stackString) {
    var lines = stackString.split('\n'),
        desiredLines = [];
    for (var i = 0, len = lines.length; i < len; i++) {
      var line = lines[i];

      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
        desiredLines.push(line);
      }
    }
    return desiredLines.join('\n');
  }

  function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    if (!fileNameAndLineNumber) {
      return false;
    }
    var fileName = fileNameAndLineNumber[0],
        lineNumber = fileNameAndLineNumber[1];

    return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
  }

  function isNodeFrame(stackLine) {
    return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
  }

  function captureLine() {
    if (!hasStacks) {
      return;
    }

    try {
      throw new Error();
    } catch (e) {
      var lines = e.stack.split('\n');
      var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];
      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
      if (!fileNameAndLineNumber) {
        return;
      }

      rFileName = fileNameAndLineNumber[0];
      return fileNameAndLineNumber[1];
    }
  }

  function getFileNameAndLineNumber(stackLine) {
    // Named functions: 'at functionName (filename:lineNumber:columnNumber)'
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
      return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: 'at filename:lineNumber:columnNumber'
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
      return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: 'function@filename:lineNumber or @filename:lineNumber'
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
      return [attempt3[1], Number(attempt3[2])];
    }
  }

  var EmptyError = Rx.EmptyError = function () {
    this.message = 'Sequence contains no elements.';
    Error.call(this);
  };
  EmptyError.prototype = Object.create(Error.prototype);
  EmptyError.prototype.name = 'EmptyError';

  var ObjectDisposedError = Rx.ObjectDisposedError = function () {
    this.message = 'Object has been disposed';
    Error.call(this);
  };
  ObjectDisposedError.prototype = Object.create(Error.prototype);
  ObjectDisposedError.prototype.name = 'ObjectDisposedError';

  var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function () {
    this.message = 'Argument out of range';
    Error.call(this);
  };
  ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);
  ArgumentOutOfRangeError.prototype.name = 'ArgumentOutOfRangeError';

  var NotSupportedError = Rx.NotSupportedError = function (message) {
    this.message = message || 'This operation is not supported';
    Error.call(this);
  };
  NotSupportedError.prototype = Object.create(Error.prototype);
  NotSupportedError.prototype.name = 'NotSupportedError';

  var NotImplementedError = Rx.NotImplementedError = function (message) {
    this.message = message || 'This operation is not implemented';
    Error.call(this);
  };
  NotImplementedError.prototype = Object.create(Error.prototype);
  NotImplementedError.prototype.name = 'NotImplementedError';

  var notImplemented = Rx.helpers.notImplemented = function () {
    throw new NotImplementedError();
  };

  var notSupported = Rx.helpers.notSupported = function () {
    throw new NotSupportedError();
  };

  // Shim in iterator support
  var $iterator$ = typeof Symbol === 'function' && Symbol.iterator || '_es6shim_iterator_';
  // Bug for mozilla version
  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };

  var isIterable = Rx.helpers.isIterable = function (o) {
    return o && o[$iterator$] !== undefined;
  };

  var isArrayLike = Rx.helpers.isArrayLike = function (o) {
    return o && o.length !== undefined;
  };

  Rx.helpers.iterator = $iterator$;

  var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {
    if (typeof thisArg === 'undefined') {
      return func;
    }
    switch (argCount) {
      case 0:
        return function () {
          return func.call(thisArg);
        };
      case 1:
        return function (arg) {
          return func.call(thisArg, arg);
        };
      case 2:
        return function (value, index) {
          return func.call(thisArg, value, index);
        };
      case 3:
        return function (value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
    }

    return function () {
      return func.apply(thisArg, arguments);
    };
  };

  /** Used to determine if values are of the language type Object */
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
      dontEnumsLength = dontEnums.length;

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  var objectProto = Object.prototype,
      hasOwnProperty = objectProto.hasOwnProperty,
      objToString = objectProto.toString,
      MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

  var keys = Object.keys || function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
        dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [],
          prop,
          i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }();

  function equalObjects(object, other, equalFunc, isLoose, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength !== othLength && !isLoose) {
      return false;
    }
    var index = objLength,
        key;
    while (index--) {
      key = objProps[index];
      if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var skipCtor = isLoose;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key],
          result;

      if (!(result === undefined ? equalFunc(objValue, othValue, isLoose, stackA, stackB) : result)) {
        return false;
      }
      skipCtor || (skipCtor = key === 'constructor');
    }
    if (!skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor !== othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }

  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        return +object === +other;

      case errorTag:
        return object.name === other.name && object.message === other.message;

      case numberTag:
        return object !== +object ? other !== +other : object === +other;

      case regexpTag:
      case stringTag:
        return object === other + '';
    }
    return false;
  }

  var isObject = Rx.internals.isObject = function (value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return !!value && (type === 'object' || type === 'function');
  };

  function isObjectLike(value) {
    return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
  }

  function isLength(value) {
    return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
  }

  var isHostObject = function () {
    try {
      Object({ 'toString': 0 } + '');
    } catch (e) {
      return function () {
        return false;
      };
    }
    return function (value) {
      return typeof value.toString !== 'function' && typeof (value + '') === 'string';
    };
  }();

  function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
  }

  var isArray = Array.isArray || function (value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) === arrayTag;
  };

  function arraySome(array, predicate) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  function equalArrays(array, other, equalFunc, isLoose, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength !== othLength && !(isLoose && othLength > arrLength)) {
      return false;
    }
    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index],
          result;

      if (result !== undefined) {
        if (result) {
          continue;
        }
        return false;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (isLoose) {
        if (!arraySome(other, function (othValue) {
          return arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB);
        })) {
          return false;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB))) {
        return false;
      }
    }
    return true;
  }

  function baseIsEqualDeep(object, other, equalFunc, isLoose, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;

    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag === argsTag) {
        objTag = objectTag;
      } else if (objTag !== objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag === argsTag) {
        othTag = objectTag;
      }
    }
    var objIsObj = objTag === objectTag && !isHostObject(object),
        othIsObj = othTag === objectTag && !isHostObject(other),
        isSameTag = objTag === othTag;

    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    if (!isLoose) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, isLoose, stackA, stackB);
      }
    }
    if (!isSameTag) {
      return false;
    }
    // Assume cyclic values are equal.
    // For more information on detecting circular references see https://es5.github.io/#JO.
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] === object) {
        return stackB[length] === other;
      }
    }
    // Add `object` and `other` to the stack of traversed objects.
    stackA.push(object);
    stackB.push(other);

    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, isLoose, stackA, stackB);

    stackA.pop();
    stackB.pop();

    return result;
  }

  function baseIsEqual(value, other, isLoose, stackA, stackB) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, isLoose, stackA, stackB);
  }

  var isEqual = Rx.internals.isEqual = function (value, other) {
    return baseIsEqual(value, other);
  };

  var hasProp = {}.hasOwnProperty,
      slice = Array.prototype.slice;

  var inherits = Rx.internals.inherits = function (child, parent) {
    function __() {
      this.constructor = child;
    }
    __.prototype = parent.prototype;
    child.prototype = new __();
  };

  var addProperties = Rx.internals.addProperties = function (obj) {
    for (var sources = [], i = 1, len = arguments.length; i < len; i++) {
      sources.push(arguments[i]);
    }
    for (var idx = 0, ln = sources.length; idx < ln; idx++) {
      var source = sources[idx];
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  };

  // Rx Utils
  var addRef = Rx.internals.addRef = function (xs, r) {
    return new AnonymousObservable(function (observer) {
      return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));
    });
  };

  function arrayInitialize(count, factory) {
    var a = new Array(count);
    for (var i = 0; i < count; i++) {
      a[i] = factory();
    }
    return a;
  }

  function IndexedItem(id, value) {
    this.id = id;
    this.value = value;
  }

  IndexedItem.prototype.compareTo = function (other) {
    var c = this.value.compareTo(other.value);
    c === 0 && (c = this.id - other.id);
    return c;
  };

  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {
    this.items = new Array(capacity);
    this.length = 0;
  };

  var priorityProto = PriorityQueue.prototype;
  priorityProto.isHigherPriority = function (left, right) {
    return this.items[left].compareTo(this.items[right]) < 0;
  };

  priorityProto.percolate = function (index) {
    if (index >= this.length || index < 0) {
      return;
    }
    var parent = index - 1 >> 1;
    if (parent < 0 || parent === index) {
      return;
    }
    if (this.isHigherPriority(index, parent)) {
      var temp = this.items[index];
      this.items[index] = this.items[parent];
      this.items[parent] = temp;
      this.percolate(parent);
    }
  };

  priorityProto.heapify = function (index) {
    +index || (index = 0);
    if (index >= this.length || index < 0) {
      return;
    }
    var left = 2 * index + 1,
        right = 2 * index + 2,
        first = index;
    if (left < this.length && this.isHigherPriority(left, first)) {
      first = left;
    }
    if (right < this.length && this.isHigherPriority(right, first)) {
      first = right;
    }
    if (first !== index) {
      var temp = this.items[index];
      this.items[index] = this.items[first];
      this.items[first] = temp;
      this.heapify(first);
    }
  };

  priorityProto.peek = function () {
    return this.items[0].value;
  };

  priorityProto.removeAt = function (index) {
    this.items[index] = this.items[--this.length];
    this.items[this.length] = undefined;
    this.heapify();
  };

  priorityProto.dequeue = function () {
    var result = this.peek();
    this.removeAt(0);
    return result;
  };

  priorityProto.enqueue = function (item) {
    var index = this.length++;
    this.items[index] = new IndexedItem(PriorityQueue.count++, item);
    this.percolate(index);
  };

  priorityProto.remove = function (item) {
    for (var i = 0; i < this.length; i++) {
      if (this.items[i].value === item) {
        this.removeAt(i);
        return true;
      }
    }
    return false;
  };
  PriorityQueue.count = 0;

  /**
   * Represents a group of disposable resources that are disposed together.
   * @constructor
   */
  var CompositeDisposable = Rx.CompositeDisposable = function () {
    var args = [],
        i,
        len;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      len = arguments.length;
      args = new Array(len);
      for (i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    this.disposables = args;
    this.isDisposed = false;
    this.length = args.length;
  };

  var CompositeDisposablePrototype = CompositeDisposable.prototype;

  /**
   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
   * @param {Mixed} item Disposable to add.
   */
  CompositeDisposablePrototype.add = function (item) {
    if (this.isDisposed) {
      item.dispose();
    } else {
      this.disposables.push(item);
      this.length++;
    }
  };

  /**
   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
   * @param {Mixed} item Disposable to remove.
   * @returns {Boolean} true if found; false otherwise.
   */
  CompositeDisposablePrototype.remove = function (item) {
    var shouldDispose = false;
    if (!this.isDisposed) {
      var idx = this.disposables.indexOf(item);
      if (idx !== -1) {
        shouldDispose = true;
        this.disposables.splice(idx, 1);
        this.length--;
        item.dispose();
      }
    }
    return shouldDispose;
  };

  /**
   *  Disposes all disposables in the group and removes them from the group.
   */
  CompositeDisposablePrototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var len = this.disposables.length,
          currentDisposables = new Array(len);
      for (var i = 0; i < len; i++) {
        currentDisposables[i] = this.disposables[i];
      }
      this.disposables = [];
      this.length = 0;

      for (i = 0; i < len; i++) {
        currentDisposables[i].dispose();
      }
    }
  };

  /**
   * Provides a set of static methods for creating Disposables.
   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
   */
  var Disposable = Rx.Disposable = function (action) {
    this.isDisposed = false;
    this.action = action || noop;
  };

  /** Performs the task of cleaning up resources. */
  Disposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.action();
      this.isDisposed = true;
    }
  };

  /**
   * Creates a disposable object that invokes the specified action when disposed.
   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
   * @return {Disposable} The disposable object that runs the given action upon disposal.
   */
  var disposableCreate = Disposable.create = function (action) {
    return new Disposable(action);
  };

  /**
   * Gets the disposable that does nothing when disposed.
   */
  var disposableEmpty = Disposable.empty = { dispose: noop };

  /**
   * Validates whether the given object is a disposable
   * @param {Object} Object to test whether it has a dispose method
   * @returns {Boolean} true if a disposable object, else false.
   */
  var isDisposable = Disposable.isDisposable = function (d) {
    return d && isFunction(d.dispose);
  };

  var checkDisposed = Disposable.checkDisposed = function (disposable) {
    if (disposable.isDisposed) {
      throw new ObjectDisposedError();
    }
  };

  var disposableFixup = Disposable._fixup = function (result) {
    return isDisposable(result) ? result : disposableEmpty;
  };

  // Single assignment
  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function () {
    this.isDisposed = false;
    this.current = null;
  };
  SingleAssignmentDisposable.prototype.getDisposable = function () {
    return this.current;
  };
  SingleAssignmentDisposable.prototype.setDisposable = function (value) {
    if (this.current) {
      throw new Error('Disposable has already been assigned');
    }
    var shouldDispose = this.isDisposed;
    !shouldDispose && (this.current = value);
    shouldDispose && value && value.dispose();
  };
  SingleAssignmentDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old = this.current;
      this.current = null;
      old && old.dispose();
    }
  };

  // Multiple assignment disposable
  var SerialDisposable = Rx.SerialDisposable = function () {
    this.isDisposed = false;
    this.current = null;
  };
  SerialDisposable.prototype.getDisposable = function () {
    return this.current;
  };
  SerialDisposable.prototype.setDisposable = function (value) {
    var shouldDispose = this.isDisposed;
    if (!shouldDispose) {
      var old = this.current;
      this.current = value;
    }
    old && old.dispose();
    shouldDispose && value && value.dispose();
  };
  SerialDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old = this.current;
      this.current = null;
    }
    old && old.dispose();
  };

  var BinaryDisposable = Rx.BinaryDisposable = function (first, second) {
    this._first = first;
    this._second = second;
    this.isDisposed = false;
  };

  BinaryDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old1 = this._first;
      this._first = null;
      old1 && old1.dispose();
      var old2 = this._second;
      this._second = null;
      old2 && old2.dispose();
    }
  };

  var NAryDisposable = Rx.NAryDisposable = function (disposables) {
    this._disposables = disposables;
    this.isDisposed = false;
  };

  NAryDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      for (var i = 0, len = this._disposables.length; i < len; i++) {
        this._disposables[i].dispose();
      }
      this._disposables.length = 0;
    }
  };

  /**
   * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
   */
  var RefCountDisposable = Rx.RefCountDisposable = function () {

    function InnerDisposable(disposable) {
      this.disposable = disposable;
      this.disposable.count++;
      this.isInnerDisposed = false;
    }

    InnerDisposable.prototype.dispose = function () {
      if (!this.disposable.isDisposed && !this.isInnerDisposed) {
        this.isInnerDisposed = true;
        this.disposable.count--;
        if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
          this.disposable.isDisposed = true;
          this.disposable.underlyingDisposable.dispose();
        }
      }
    };

    /**
     * Initializes a new instance of the RefCountDisposable with the specified disposable.
     * @constructor
     * @param {Disposable} disposable Underlying disposable.
      */
    function RefCountDisposable(disposable) {
      this.underlyingDisposable = disposable;
      this.isDisposed = false;
      this.isPrimaryDisposed = false;
      this.count = 0;
    }

    /**
     * Disposes the underlying disposable only when all dependent disposables have been disposed
     */
    RefCountDisposable.prototype.dispose = function () {
      if (!this.isDisposed && !this.isPrimaryDisposed) {
        this.isPrimaryDisposed = true;
        if (this.count === 0) {
          this.isDisposed = true;
          this.underlyingDisposable.dispose();
        }
      }
    };

    /**
     * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
     * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.
     */
    RefCountDisposable.prototype.getDisposable = function () {
      return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
    };

    return RefCountDisposable;
  }();

  function ScheduledDisposable(scheduler, disposable) {
    this.scheduler = scheduler;
    this.disposable = disposable;
    this.isDisposed = false;
  }

  function scheduleItem(s, self) {
    if (!self.isDisposed) {
      self.isDisposed = true;
      self.disposable.dispose();
    }
  }

  ScheduledDisposable.prototype.dispose = function () {
    this.scheduler.schedule(this, scheduleItem);
  };

  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
    this.scheduler = scheduler;
    this.state = state;
    this.action = action;
    this.dueTime = dueTime;
    this.comparer = comparer || defaultSubComparer;
    this.disposable = new SingleAssignmentDisposable();
  };

  ScheduledItem.prototype.invoke = function () {
    this.disposable.setDisposable(this.invokeCore());
  };

  ScheduledItem.prototype.compareTo = function (other) {
    return this.comparer(this.dueTime, other.dueTime);
  };

  ScheduledItem.prototype.isCancelled = function () {
    return this.disposable.isDisposed;
  };

  ScheduledItem.prototype.invokeCore = function () {
    return disposableFixup(this.action(this.scheduler, this.state));
  };

  /** Provides a set of static properties to access commonly used schedulers. */
  var Scheduler = Rx.Scheduler = function () {

    function Scheduler() {}

    /** Determines whether the given object is a scheduler */
    Scheduler.isScheduler = function (s) {
      return s instanceof Scheduler;
    };

    var schedulerProto = Scheduler.prototype;

    /**
    * Schedules an action to be executed.
    * @param state State passed to the action to be executed.
    * @param {Function} action Action to be executed.
    * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
    */
    schedulerProto.schedule = function (state, action) {
      throw new NotImplementedError();
    };

    /**
     * Schedules an action to be executed after dueTime.
     * @param state State passed to the action to be executed.
     * @param {Function} action Action to be executed.
     * @param {Number} dueTime Relative time after which to execute the action.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleFuture = function (state, dueTime, action) {
      var dt = dueTime;
      dt instanceof Date && (dt = dt - this.now());
      dt = Scheduler.normalize(dt);

      if (dt === 0) {
        return this.schedule(state, action);
      }

      return this._scheduleFuture(state, dt, action);
    };

    schedulerProto._scheduleFuture = function (state, dueTime, action) {
      throw new NotImplementedError();
    };

    /** Gets the current time according to the local machine's system clock. */
    Scheduler.now = defaultNow;

    /** Gets the current time according to the local machine's system clock. */
    Scheduler.prototype.now = defaultNow;

    /**
     * Normalizes the specified TimeSpan value to a positive value.
     * @param {Number} timeSpan The time span value to normalize.
     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0
     */
    Scheduler.normalize = function (timeSpan) {
      timeSpan < 0 && (timeSpan = 0);
      return timeSpan;
    };

    return Scheduler;
  }();

  var normalizeTime = Scheduler.normalize,
      isScheduler = Scheduler.isScheduler;

  (function (schedulerProto) {

    function invokeRecImmediate(scheduler, pair) {
      var state = pair[0],
          action = pair[1],
          group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2) {
        var isAdded = false,
            isDone = false;

        var d = scheduler.schedule(state2, scheduleWork);
        if (!isDone) {
          group.add(d);
          isAdded = true;
        }

        function scheduleWork(_, state3) {
          if (isAdded) {
            group.remove(d);
          } else {
            isDone = true;
          }
          action(state3, innerAction);
          return disposableEmpty;
        }
      }
    }

    function invokeRecDate(scheduler, pair) {
      var state = pair[0],
          action = pair[1],
          group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2, dueTime1) {
        var isAdded = false,
            isDone = false;

        var d = scheduler.scheduleFuture(state2, dueTime1, scheduleWork);
        if (!isDone) {
          group.add(d);
          isAdded = true;
        }

        function scheduleWork(_, state3) {
          if (isAdded) {
            group.remove(d);
          } else {
            isDone = true;
          }
          action(state3, innerAction);
          return disposableEmpty;
        }
      }
    }

    /**
     * Schedules an action to be executed recursively.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleRecursive = function (state, action) {
      return this.schedule([state, action], invokeRecImmediate);
    };

    /**
     * Schedules an action to be executed recursively after a specified relative or absolute due time.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
     * @param {Number | Date} dueTime Relative or absolute time after which to execute the action for the first time.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleRecursiveFuture = function (state, dueTime, action) {
      return this.scheduleFuture([state, action], dueTime, invokeRecDate);
    };
  })(Scheduler.prototype);

  (function (schedulerProto) {

    /**
     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
     * @param {Mixed} state Initial state passed to the action upon the first iteration.
     * @param {Number} period Period for running the work periodically.
     * @param {Function} action Action to be executed, potentially updating the state.
     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
     */
    schedulerProto.schedulePeriodic = function (state, period, action) {
      if (typeof root.setInterval === 'undefined') {
        throw new NotSupportedError();
      }
      period = normalizeTime(period);
      var s = state,
          id = root.setInterval(function () {
        s = action(s);
      }, period);
      return disposableCreate(function () {
        root.clearInterval(id);
      });
    };
  })(Scheduler.prototype);

  (function (schedulerProto) {
    /**
     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.
     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.
     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.
     */
    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {
      return new CatchScheduler(this, handler);
    };
  })(Scheduler.prototype);

  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = function () {
    function createTick(self) {
      return function tick(command, recurse) {
        recurse(0, self._period);
        var state = tryCatch(self._action)(self._state);
        if (state === errorObj) {
          self._cancel.dispose();
          thrower(state.e);
        }
        self._state = state;
      };
    }

    function SchedulePeriodicRecursive(scheduler, state, period, action) {
      this._scheduler = scheduler;
      this._state = state;
      this._period = period;
      this._action = action;
    }

    SchedulePeriodicRecursive.prototype.start = function () {
      var d = new SingleAssignmentDisposable();
      this._cancel = d;
      d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));

      return d;
    };

    return SchedulePeriodicRecursive;
  }();

  /** Gets a scheduler that schedules work immediately on the current thread. */
  var ImmediateScheduler = function (__super__) {
    inherits(ImmediateScheduler, __super__);
    function ImmediateScheduler() {
      __super__.call(this);
    }

    ImmediateScheduler.prototype.schedule = function (state, action) {
      return disposableFixup(action(this, state));
    };

    return ImmediateScheduler;
  }(Scheduler);

  var immediateScheduler = Scheduler.immediate = new ImmediateScheduler();

  /**
   * Gets a scheduler that schedules work as soon as possible on the current thread.
   */
  var CurrentThreadScheduler = function (__super__) {
    var queue;

    function runTrampoline() {
      while (queue.length > 0) {
        var item = queue.dequeue();
        !item.isCancelled() && item.invoke();
      }
    }

    inherits(CurrentThreadScheduler, __super__);
    function CurrentThreadScheduler() {
      __super__.call(this);
    }

    CurrentThreadScheduler.prototype.schedule = function (state, action) {
      var si = new ScheduledItem(this, state, action, this.now());

      if (!queue) {
        queue = new PriorityQueue(4);
        queue.enqueue(si);

        var result = tryCatch(runTrampoline)();
        queue = null;
        if (result === errorObj) {
          thrower(result.e);
        }
      } else {
        queue.enqueue(si);
      }
      return si.disposable;
    };

    CurrentThreadScheduler.prototype.scheduleRequired = function () {
      return !queue;
    };

    return CurrentThreadScheduler;
  }(Scheduler);

  var currentThreadScheduler = Scheduler.currentThread = new CurrentThreadScheduler();

  var scheduleMethod, clearMethod;

  var localTimer = function () {
    var localSetTimeout,
        localClearTimeout = noop;
    if (!!root.setTimeout) {
      localSetTimeout = root.setTimeout;
      localClearTimeout = root.clearTimeout;
    } else if (!!root.WScript) {
      localSetTimeout = function localSetTimeout(fn, time) {
        root.WScript.Sleep(time);
        fn();
      };
    } else {
      throw new NotSupportedError();
    }

    return {
      setTimeout: localSetTimeout,
      clearTimeout: localClearTimeout
    };
  }();
  var localSetTimeout = localTimer.setTimeout,
      localClearTimeout = localTimer.clearTimeout;

  (function () {

    var nextHandle = 1,
        tasksByHandle = {},
        currentlyRunning = false;

    clearMethod = function clearMethod(handle) {
      delete tasksByHandle[handle];
    };

    function runTask(handle) {
      if (currentlyRunning) {
        localSetTimeout(function () {
          runTask(handle);
        }, 0);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunning = true;
          var result = tryCatch(task)();
          clearMethod(handle);
          currentlyRunning = false;
          if (result === errorObj) {
            thrower(result.e);
          }
        }
      }
    }

    var reNative = new RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');

    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;

    function postMessageSupported() {
      // Ensure not in a worker
      if (!root.postMessage || root.importScripts) {
        return false;
      }
      var isAsync = false,
          oldHandler = root.onmessage;
      // Test for async
      root.onmessage = function () {
        isAsync = true;
      };
      root.postMessage('', '*');
      root.onmessage = oldHandler;

      return isAsync;
    }

    // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout
    if (isFunction(setImmediate)) {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        setImmediate(function () {
          runTask(id);
        });

        return id;
      };
    } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        process.nextTick(function () {
          runTask(id);
        });

        return id;
      };
    } else if (postMessageSupported()) {
      var MSG_PREFIX = 'ms.rx.schedule' + Math.random();

      var onGlobalPostMessage = function onGlobalPostMessage(event) {
        // Only if we're a match to avoid any other global events
        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
          runTask(event.data.substring(MSG_PREFIX.length));
        }
      };

      root.addEventListener('message', onGlobalPostMessage, false);

      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        root.postMessage(MSG_PREFIX + id, '*');
        return id;
      };
    } else if (!!root.MessageChannel) {
      var channel = new root.MessageChannel();

      channel.port1.onmessage = function (e) {
        runTask(e.data);
      };

      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        channel.port2.postMessage(id);
        return id;
      };
    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {

      scheduleMethod = function scheduleMethod(action) {
        var scriptElement = root.document.createElement('script');
        var id = nextHandle++;
        tasksByHandle[id] = action;

        scriptElement.onreadystatechange = function () {
          runTask(id);
          scriptElement.onreadystatechange = null;
          scriptElement.parentNode.removeChild(scriptElement);
          scriptElement = null;
        };
        root.document.documentElement.appendChild(scriptElement);
        return id;
      };
    } else {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        localSetTimeout(function () {
          runTask(id);
        }, 0);

        return id;
      };
    }
  })();

  /**
   * Gets a scheduler that schedules work via a timed callback based upon platform.
   */
  var DefaultScheduler = function (__super__) {
    inherits(DefaultScheduler, __super__);
    function DefaultScheduler() {
      __super__.call(this);
    }

    function scheduleAction(disposable, action, scheduler, state) {
      return function schedule() {
        disposable.setDisposable(Disposable._fixup(action(scheduler, state)));
      };
    }

    function ClearDisposable(id) {
      this._id = id;
      this.isDisposed = false;
    }

    ClearDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        clearMethod(this._id);
      }
    };

    function LocalClearDisposable(id) {
      this._id = id;
      this.isDisposed = false;
    }

    LocalClearDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        localClearTimeout(this._id);
      }
    };

    DefaultScheduler.prototype.schedule = function (state, action) {
      var disposable = new SingleAssignmentDisposable(),
          id = scheduleMethod(scheduleAction(disposable, action, this, state));
      return new BinaryDisposable(disposable, new ClearDisposable(id));
    };

    DefaultScheduler.prototype._scheduleFuture = function (state, dueTime, action) {
      if (dueTime === 0) {
        return this.schedule(state, action);
      }
      var disposable = new SingleAssignmentDisposable(),
          id = localSetTimeout(scheduleAction(disposable, action, this, state), dueTime);
      return new BinaryDisposable(disposable, new LocalClearDisposable(id));
    };

    function scheduleLongRunning(state, action, disposable) {
      return function () {
        action(state, disposable);
      };
    }

    DefaultScheduler.prototype.scheduleLongRunning = function (state, action) {
      var disposable = disposableCreate(noop);
      scheduleMethod(scheduleLongRunning(state, action, disposable));
      return disposable;
    };

    return DefaultScheduler;
  }(Scheduler);

  var defaultScheduler = Scheduler['default'] = Scheduler.async = new DefaultScheduler();

  var CatchScheduler = function (__super__) {
    inherits(CatchScheduler, __super__);

    function CatchScheduler(scheduler, handler) {
      this._scheduler = scheduler;
      this._handler = handler;
      this._recursiveOriginal = null;
      this._recursiveWrapper = null;
      __super__.call(this);
    }

    CatchScheduler.prototype.schedule = function (state, action) {
      return this._scheduler.schedule(state, this._wrap(action));
    };

    CatchScheduler.prototype._scheduleFuture = function (state, dueTime, action) {
      return this._scheduler.schedule(state, dueTime, this._wrap(action));
    };

    CatchScheduler.prototype.now = function () {
      return this._scheduler.now();
    };

    CatchScheduler.prototype._clone = function (scheduler) {
      return new CatchScheduler(scheduler, this._handler);
    };

    CatchScheduler.prototype._wrap = function (action) {
      var parent = this;
      return function (self, state) {
        var res = tryCatch(action)(parent._getRecursiveWrapper(self), state);
        if (res === errorObj) {
          if (!parent._handler(res.e)) {
            thrower(res.e);
          }
          return disposableEmpty;
        }
        return disposableFixup(res);
      };
    };

    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {
      if (this._recursiveOriginal !== scheduler) {
        this._recursiveOriginal = scheduler;
        var wrapper = this._clone(scheduler);
        wrapper._recursiveOriginal = scheduler;
        wrapper._recursiveWrapper = wrapper;
        this._recursiveWrapper = wrapper;
      }
      return this._recursiveWrapper;
    };

    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {
      var self = this,
          failed = false,
          d = new SingleAssignmentDisposable();

      d.setDisposable(this._scheduler.schedulePeriodic(state, period, function (state1) {
        if (failed) {
          return null;
        }
        var res = tryCatch(action)(state1);
        if (res === errorObj) {
          failed = true;
          if (!self._handler(res.e)) {
            thrower(res.e);
          }
          d.dispose();
          return null;
        }
        return res;
      }));

      return d;
    };

    return CatchScheduler;
  }(Scheduler);

  /**
   *  Represents a notification to an observer.
   */
  var Notification = Rx.Notification = function () {
    function Notification() {}

    Notification.prototype._accept = function (onNext, onError, onCompleted) {
      throw new NotImplementedError();
    };

    Notification.prototype._acceptObserver = function (onNext, onError, onCompleted) {
      throw new NotImplementedError();
    };

    /**
     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.
     * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification on..
     * @param {Function} onError Function to invoke for an OnError notification.
     * @param {Function} onCompleted Function to invoke for an OnCompleted notification.
     * @returns {Any} Result produced by the observation.
     */
    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
      return observerOrOnNext && (typeof observerOrOnNext === 'undefined' ? 'undefined' : _typeof(observerOrOnNext)) === 'object' ? this._acceptObserver(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
    };

    /**
     * Returns an observable sequence with a single notification.
     *
     * @memberOf Notifications
     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.
     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.
     */
    Notification.prototype.toObservable = function (scheduler) {
      var self = this;
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function (o) {
        return scheduler.schedule(self, function (_, notification) {
          notification._acceptObserver(o);
          notification.kind === 'N' && o.onCompleted();
        });
      });
    };

    return Notification;
  }();

  var OnNextNotification = function (__super__) {
    inherits(OnNextNotification, __super__);
    function OnNextNotification(value) {
      this.value = value;
      this.kind = 'N';
    }

    OnNextNotification.prototype._accept = function (onNext) {
      return onNext(this.value);
    };

    OnNextNotification.prototype._acceptObserver = function (o) {
      return o.onNext(this.value);
    };

    OnNextNotification.prototype.toString = function () {
      return 'OnNext(' + this.value + ')';
    };

    return OnNextNotification;
  }(Notification);

  var OnErrorNotification = function (__super__) {
    inherits(OnErrorNotification, __super__);
    function OnErrorNotification(error) {
      this.error = error;
      this.kind = 'E';
    }

    OnErrorNotification.prototype._accept = function (onNext, onError) {
      return onError(this.error);
    };

    OnErrorNotification.prototype._acceptObserver = function (o) {
      return o.onError(this.error);
    };

    OnErrorNotification.prototype.toString = function () {
      return 'OnError(' + this.error + ')';
    };

    return OnErrorNotification;
  }(Notification);

  var OnCompletedNotification = function (__super__) {
    inherits(OnCompletedNotification, __super__);
    function OnCompletedNotification() {
      this.kind = 'C';
    }

    OnCompletedNotification.prototype._accept = function (onNext, onError, onCompleted) {
      return onCompleted();
    };

    OnCompletedNotification.prototype._acceptObserver = function (o) {
      return o.onCompleted();
    };

    OnCompletedNotification.prototype.toString = function () {
      return 'OnCompleted()';
    };

    return OnCompletedNotification;
  }(Notification);

  /**
   * Creates an object that represents an OnNext notification to an observer.
   * @param {Any} value The value contained in the notification.
   * @returns {Notification} The OnNext notification containing the value.
   */
  var notificationCreateOnNext = Notification.createOnNext = function (value) {
    return new OnNextNotification(value);
  };

  /**
   * Creates an object that represents an OnError notification to an observer.
   * @param {Any} error The exception contained in the notification.
   * @returns {Notification} The OnError notification containing the exception.
   */
  var notificationCreateOnError = Notification.createOnError = function (error) {
    return new OnErrorNotification(error);
  };

  /**
   * Creates an object that represents an OnCompleted notification to an observer.
   * @returns {Notification} The OnCompleted notification.
   */
  var notificationCreateOnCompleted = Notification.createOnCompleted = function () {
    return new OnCompletedNotification();
  };

  /**
   * Supports push-style iteration over an observable sequence.
   */
  var Observer = Rx.Observer = function () {};

  /**
   *  Creates a notification callback from an observer.
   * @returns The action that forwards its input notification to the underlying observer.
   */
  Observer.prototype.toNotifier = function () {
    var observer = this;
    return function (n) {
      return n.accept(observer);
    };
  };

  /**
   *  Hides the identity of an observer.
   * @returns An observer that hides the identity of the specified observer.
   */
  Observer.prototype.asObserver = function () {
    var self = this;
    return new AnonymousObserver(function (x) {
      self.onNext(x);
    }, function (err) {
      self.onError(err);
    }, function () {
      self.onCompleted();
    });
  };

  /**
   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
   *  If a violation is detected, an Error is thrown from the offending observer method call.
   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
   */
  Observer.prototype.checked = function () {
    return new CheckedObserver(this);
  };

  /**
   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.
   * @param {Function} [onNext] Observer's OnNext action implementation.
   * @param {Function} [onError] Observer's OnError action implementation.
   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.
   * @returns {Observer} The observer object implemented using the given actions.
   */
  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {
    onNext || (onNext = noop);
    onError || (onError = defaultError);
    onCompleted || (onCompleted = noop);
    return new AnonymousObserver(onNext, onError, onCompleted);
  };

  /**
   *  Creates an observer from a notification callback.
   * @param {Function} handler Action that handles a notification.
   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.
   */
  Observer.fromNotifier = function (handler, thisArg) {
    var cb = bindCallback(handler, thisArg, 1);
    return new AnonymousObserver(function (x) {
      return cb(notificationCreateOnNext(x));
    }, function (e) {
      return cb(notificationCreateOnError(e));
    }, function () {
      return cb(notificationCreateOnCompleted());
    });
  };

  /**
   * Schedules the invocation of observer methods on the given scheduler.
   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.
   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.
   */
  Observer.prototype.notifyOn = function (scheduler) {
    return new ObserveOnObserver(scheduler, this);
  };

  Observer.prototype.makeSafe = function (disposable) {
    return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
  };

  /**
   * Abstract base class for implementations of the Observer class.
   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.
   */
  var AbstractObserver = Rx.internals.AbstractObserver = function (__super__) {
    inherits(AbstractObserver, __super__);

    /**
     * Creates a new observer in a non-stopped state.
     */
    function AbstractObserver() {
      this.isStopped = false;
    }

    // Must be implemented by other observers
    AbstractObserver.prototype.next = notImplemented;
    AbstractObserver.prototype.error = notImplemented;
    AbstractObserver.prototype.completed = notImplemented;

    /**
     * Notifies the observer of a new element in the sequence.
     * @param {Any} value Next element in the sequence.
     */
    AbstractObserver.prototype.onNext = function (value) {
      !this.isStopped && this.next(value);
    };

    /**
     * Notifies the observer that an exception has occurred.
     * @param {Any} error The error that has occurred.
     */
    AbstractObserver.prototype.onError = function (error) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.error(error);
      }
    };

    /**
     * Notifies the observer of the end of the sequence.
     */
    AbstractObserver.prototype.onCompleted = function () {
      if (!this.isStopped) {
        this.isStopped = true;
        this.completed();
      }
    };

    /**
     * Disposes the observer, causing it to transition to the stopped state.
     */
    AbstractObserver.prototype.dispose = function () {
      this.isStopped = true;
    };

    AbstractObserver.prototype.fail = function (e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.error(e);
        return true;
      }

      return false;
    };

    return AbstractObserver;
  }(Observer);

  /**
   * Class to create an Observer instance from delegate-based implementations of the on* methods.
   */
  var AnonymousObserver = Rx.AnonymousObserver = function (__super__) {
    inherits(AnonymousObserver, __super__);

    /**
     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
     * @param {Any} onNext Observer's OnNext action implementation.
     * @param {Any} onError Observer's OnError action implementation.
     * @param {Any} onCompleted Observer's OnCompleted action implementation.
     */
    function AnonymousObserver(onNext, onError, onCompleted) {
      __super__.call(this);
      this._onNext = onNext;
      this._onError = onError;
      this._onCompleted = onCompleted;
    }

    /**
     * Calls the onNext action.
     * @param {Any} value Next element in the sequence.
     */
    AnonymousObserver.prototype.next = function (value) {
      this._onNext(value);
    };

    /**
     * Calls the onError action.
     * @param {Any} error The error that has occurred.
     */
    AnonymousObserver.prototype.error = function (error) {
      this._onError(error);
    };

    /**
     *  Calls the onCompleted action.
     */
    AnonymousObserver.prototype.completed = function () {
      this._onCompleted();
    };

    return AnonymousObserver;
  }(AbstractObserver);

  var CheckedObserver = function (__super__) {
    inherits(CheckedObserver, __super__);

    function CheckedObserver(observer) {
      __super__.call(this);
      this._observer = observer;
      this._state = 0; // 0 - idle, 1 - busy, 2 - done
    }

    var CheckedObserverPrototype = CheckedObserver.prototype;

    CheckedObserverPrototype.onNext = function (value) {
      this.checkAccess();
      var res = tryCatch(this._observer.onNext).call(this._observer, value);
      this._state = 0;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.onError = function (err) {
      this.checkAccess();
      var res = tryCatch(this._observer.onError).call(this._observer, err);
      this._state = 2;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.onCompleted = function () {
      this.checkAccess();
      var res = tryCatch(this._observer.onCompleted).call(this._observer);
      this._state = 2;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.checkAccess = function () {
      if (this._state === 1) {
        throw new Error('Re-entrancy detected');
      }
      if (this._state === 2) {
        throw new Error('Observer completed');
      }
      if (this._state === 0) {
        this._state = 1;
      }
    };

    return CheckedObserver;
  }(Observer);

  var ScheduledObserver = Rx.internals.ScheduledObserver = function (__super__) {
    inherits(ScheduledObserver, __super__);

    function ScheduledObserver(scheduler, observer) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.observer = observer;
      this.isAcquired = false;
      this.hasFaulted = false;
      this.queue = [];
      this.disposable = new SerialDisposable();
    }

    function enqueueNext(observer, x) {
      return function () {
        observer.onNext(x);
      };
    }
    function enqueueError(observer, e) {
      return function () {
        observer.onError(e);
      };
    }
    function enqueueCompleted(observer) {
      return function () {
        observer.onCompleted();
      };
    }

    ScheduledObserver.prototype.next = function (x) {
      this.queue.push(enqueueNext(this.observer, x));
    };

    ScheduledObserver.prototype.error = function (e) {
      this.queue.push(enqueueError(this.observer, e));
    };

    ScheduledObserver.prototype.completed = function () {
      this.queue.push(enqueueCompleted(this.observer));
    };

    function scheduleMethod(state, recurse) {
      var work;
      if (state.queue.length > 0) {
        work = state.queue.shift();
      } else {
        state.isAcquired = false;
        return;
      }
      var res = tryCatch(work)();
      if (res === errorObj) {
        state.queue = [];
        state.hasFaulted = true;
        return thrower(res.e);
      }
      recurse(state);
    }

    ScheduledObserver.prototype.ensureActive = function () {
      var isOwner = false;
      if (!this.hasFaulted && this.queue.length > 0) {
        isOwner = !this.isAcquired;
        this.isAcquired = true;
      }
      isOwner && this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));
    };

    ScheduledObserver.prototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this.disposable.dispose();
    };

    return ScheduledObserver;
  }(AbstractObserver);

  var ObserveOnObserver = function (__super__) {
    inherits(ObserveOnObserver, __super__);

    function ObserveOnObserver(scheduler, observer, cancel) {
      __super__.call(this, scheduler, observer);
      this._cancel = cancel;
    }

    ObserveOnObserver.prototype.next = function (value) {
      __super__.prototype.next.call(this, value);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.error = function (e) {
      __super__.prototype.error.call(this, e);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.completed = function () {
      __super__.prototype.completed.call(this);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this._cancel && this._cancel.dispose();
      this._cancel = null;
    };

    return ObserveOnObserver;
  }(ScheduledObserver);

  var observableProto;

  /**
   * Represents a push-style collection.
   */
  var Observable = Rx.Observable = function () {

    function makeSubscribe(self, subscribe) {
      return function (o) {
        var oldOnError = o.onError;
        o.onError = function (e) {
          makeStackTraceLong(e, self);
          oldOnError.call(o, e);
        };

        return subscribe.call(self, o);
      };
    }

    function Observable() {
      if (Rx.config.longStackSupport && hasStacks) {
        var oldSubscribe = this._subscribe;
        var e = tryCatch(thrower)(new Error()).e;
        this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
        this._subscribe = makeSubscribe(this, oldSubscribe);
      }
    }

    observableProto = Observable.prototype;

    /**
    * Determines whether the given object is an Observable
    * @param {Any} An object to determine whether it is an Observable
    * @returns {Boolean} true if an Observable, else false.
    */
    Observable.isObservable = function (o) {
      return o && isFunction(o.subscribe);
    };

    /**
     *  Subscribes an o to the observable sequence.
     *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.
     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
      return this._subscribe((typeof oOrOnNext === 'undefined' ? 'undefined' : _typeof(oOrOnNext)) === 'object' ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));
    };

    /**
     * Subscribes to the next value in the sequence with an optional "this" argument.
     * @param {Function} onNext The function to invoke on each element in the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnNext = function (onNext, thisArg) {
      return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function (x) {
        onNext.call(thisArg, x);
      } : onNext));
    };

    /**
     * Subscribes to an exceptional condition in the sequence with an optional "this" argument.
     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnError = function (onError, thisArg) {
      return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function (e) {
        onError.call(thisArg, e);
      } : onError));
    };

    /**
     * Subscribes to the next value in the sequence with an optional "this" argument.
     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {
      return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function () {
        onCompleted.call(thisArg);
      } : onCompleted));
    };

    return Observable;
  }();

  var ObservableBase = Rx.ObservableBase = function (__super__) {
    inherits(ObservableBase, __super__);

    function fixSubscriber(subscriber) {
      return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
    }

    function setDisposable(s, state) {
      var ado = state[0],
          self = state[1];
      var sub = tryCatch(self.subscribeCore).call(self, ado);
      if (sub === errorObj && !ado.fail(errorObj.e)) {
        thrower(errorObj.e);
      }
      ado.setDisposable(fixSubscriber(sub));
    }

    function ObservableBase() {
      __super__.call(this);
    }

    ObservableBase.prototype._subscribe = function (o) {
      var ado = new AutoDetachObserver(o),
          state = [ado, this];

      if (currentThreadScheduler.scheduleRequired()) {
        currentThreadScheduler.schedule(state, setDisposable);
      } else {
        setDisposable(null, state);
      }
      return ado;
    };

    ObservableBase.prototype.subscribeCore = notImplemented;

    return ObservableBase;
  }(Observable);

  var FlatMapObservable = Rx.FlatMapObservable = function (__super__) {

    inherits(FlatMapObservable, __super__);

    function FlatMapObservable(source, selector, resultSelector, thisArg) {
      this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
      this.selector = bindCallback(isFunction(selector) ? selector : function () {
        return selector;
      }, thisArg, 3);
      this.source = source;
      __super__.call(this);
    }

    FlatMapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(observer, selector, resultSelector, source) {
      this.i = 0;
      this.selector = selector;
      this.resultSelector = resultSelector;
      this.source = source;
      this.o = observer;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype._wrapResult = function (result, x, i) {
      return this.resultSelector ? result.map(function (y, i2) {
        return this.resultSelector(x, y, i, i2);
      }, this) : result;
    };

    InnerObserver.prototype.next = function (x) {
      var i = this.i++;
      var result = tryCatch(this.selector)(x, i, this.source);
      if (result === errorObj) {
        return this.o.onError(result.e);
      }

      isPromise(result) && (result = observableFromPromise(result));
      (isArrayLike(result) || isIterable(result)) && (result = Observable.from(result));
      this.o.onNext(this._wrapResult(result, x, i));
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return FlatMapObservable;
  }(ObservableBase);

  var Enumerable = Rx.internals.Enumerable = function () {};

  function IsDisposedDisposable(state) {
    this._s = state;
    this.isDisposed = false;
  }

  IsDisposedDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      this._s.isDisposed = true;
    }
  };

  var ConcatEnumerableObservable = function (__super__) {
    inherits(ConcatEnumerableObservable, __super__);
    function ConcatEnumerableObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    function scheduleMethod(state, recurse) {
      if (state.isDisposed) {
        return;
      }
      var currentItem = tryCatch(state.e.next).call(state.e);
      if (currentItem === errorObj) {
        return state.o.onError(currentItem.e);
      }
      if (currentItem.done) {
        return state.o.onCompleted();
      }

      // Check if promise
      var currentValue = currentItem.value;
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));
    }

    ConcatEnumerableObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var state = {
        isDisposed: false,
        o: o,
        subscription: subscription,
        e: this.sources[$iterator$]()
      };

      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);
      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);
    };

    function InnerObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      AbstractObserver.call(this);
    }

    inherits(InnerObserver, AbstractObserver);

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this._recurse(this._state);
    };

    return ConcatEnumerableObservable;
  }(ObservableBase);

  Enumerable.prototype.concat = function () {
    return new ConcatEnumerableObservable(this);
  };

  var CatchErrorObservable = function (__super__) {
    function CatchErrorObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    inherits(CatchErrorObservable, __super__);

    function scheduleMethod(state, recurse) {
      if (state.isDisposed) {
        return;
      }
      var currentItem = tryCatch(state.e.next).call(state.e);
      if (currentItem === errorObj) {
        return state.o.onError(currentItem.e);
      }
      if (currentItem.done) {
        return state.lastError !== null ? state.o.onError(state.lastError) : state.o.onCompleted();
      }

      var currentValue = currentItem.value;
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));
    }

    CatchErrorObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var state = {
        isDisposed: false,
        e: this.sources[$iterator$](),
        subscription: subscription,
        lastError: null,
        o: o
      };

      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);
      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);
    };

    function InnerObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      AbstractObserver.call(this);
    }

    inherits(InnerObserver, AbstractObserver);

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.lastError = e;this._recurse(this._state);
    };
    InnerObserver.prototype.completed = function () {
      this._state.o.onCompleted();
    };

    return CatchErrorObservable;
  }(ObservableBase);

  Enumerable.prototype.catchError = function () {
    return new CatchErrorObservable(this);
  };

  var RepeatEnumerable = function (__super__) {
    inherits(RepeatEnumerable, __super__);
    function RepeatEnumerable(v, c) {
      this.v = v;
      this.c = c == null ? -1 : c;
    }

    RepeatEnumerable.prototype[$iterator$] = function () {
      return new RepeatEnumerator(this);
    };

    function RepeatEnumerator(p) {
      this.v = p.v;
      this.l = p.c;
    }

    RepeatEnumerator.prototype.next = function () {
      if (this.l === 0) {
        return doneEnumerator;
      }
      if (this.l > 0) {
        this.l--;
      }
      return { done: false, value: this.v };
    };

    return RepeatEnumerable;
  }(Enumerable);

  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {
    return new RepeatEnumerable(value, repeatCount);
  };

  var OfEnumerable = function (__super__) {
    inherits(OfEnumerable, __super__);
    function OfEnumerable(s, fn, thisArg) {
      this.s = s;
      this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
    }
    OfEnumerable.prototype[$iterator$] = function () {
      return new OfEnumerator(this);
    };

    function OfEnumerator(p) {
      this.i = -1;
      this.s = p.s;
      this.l = this.s.length;
      this.fn = p.fn;
    }

    OfEnumerator.prototype.next = function () {
      return ++this.i < this.l ? { done: false, value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s) } : doneEnumerator;
    };

    return OfEnumerable;
  }(Enumerable);

  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {
    return new OfEnumerable(source, selector, thisArg);
  };

  var ObserveOnObservable = function (__super__) {
    inherits(ObserveOnObservable, __super__);
    function ObserveOnObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    ObserveOnObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ObserveOnObserver(this._s, o));
    };

    return ObserveOnObservable;
  }(ObservableBase);

  /**
  *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
  *
  *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects
  *  that require to be run on a scheduler, use subscribeOn.
  *
  *  @param {Scheduler} scheduler Scheduler to notify observers on.
  *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.
  */
  observableProto.observeOn = function (scheduler) {
    return new ObserveOnObservable(this, scheduler);
  };

  var SubscribeOnObservable = function (__super__) {
    inherits(SubscribeOnObservable, __super__);
    function SubscribeOnObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    function scheduleMethod(scheduler, state) {
      var source = state[0],
          d = state[1],
          o = state[2];
      d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(o)));
    }

    SubscribeOnObservable.prototype.subscribeCore = function (o) {
      var m = new SingleAssignmentDisposable(),
          d = new SerialDisposable();
      d.setDisposable(m);
      m.setDisposable(this._s.schedule([this.source, d, o], scheduleMethod));
      return d;
    };

    return SubscribeOnObservable;
  }(ObservableBase);

  /**
  *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
  *  see the remarks section for more information on the distinction between subscribeOn and observeOn.
   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer
  *  callbacks on a scheduler, use observeOn.
   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.
  *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
  */
  observableProto.subscribeOn = function (scheduler) {
    return new SubscribeOnObservable(this, scheduler);
  };

  var FromPromiseObservable = function (__super__) {
    inherits(FromPromiseObservable, __super__);
    function FromPromiseObservable(p, s) {
      this._p = p;
      this._s = s;
      __super__.call(this);
    }

    function scheduleNext(s, state) {
      var o = state[0],
          data = state[1];
      o.onNext(data);
      o.onCompleted();
    }

    function scheduleError(s, state) {
      var o = state[0],
          err = state[1];
      o.onError(err);
    }

    FromPromiseObservable.prototype.subscribeCore = function (o) {
      var sad = new SingleAssignmentDisposable(),
          self = this,
          p = this._p;

      if (isFunction(p)) {
        p = tryCatch(p)();
        if (p === errorObj) {
          o.onError(p.e);
          return sad;
        }
      }

      p.then(function (data) {
        sad.setDisposable(self._s.schedule([o, data], scheduleNext));
      }, function (err) {
        sad.setDisposable(self._s.schedule([o, err], scheduleError));
      });

      return sad;
    };

    return FromPromiseObservable;
  }(ObservableBase);

  /**
  * Converts a Promise to an Observable sequence
  * @param {Promise} An ES6 Compliant promise.
  * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.
  */
  var observableFromPromise = Observable.fromPromise = function (promise, scheduler) {
    scheduler || (scheduler = defaultScheduler);
    return new FromPromiseObservable(promise, scheduler);
  };

  /*
   * Converts an existing observable sequence to an ES6 Compatible Promise
   * @example
   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
   *
   * // With config
   * Rx.config.Promise = RSVP.Promise;
   * var promise = Rx.Observable.return(42).toPromise();
   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
   */
  observableProto.toPromise = function (promiseCtor) {
    promiseCtor || (promiseCtor = Rx.config.Promise);
    if (!promiseCtor) {
      throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
    }
    var source = this;
    return new promiseCtor(function (resolve, reject) {
      // No cancellation can be done
      var value;
      source.subscribe(function (v) {
        value = v;
      }, reject, function () {
        resolve(value);
      });
    });
  };

  var ToArrayObservable = function (__super__) {
    inherits(ToArrayObservable, __super__);
    function ToArrayObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    ToArrayObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o) {
      this.o = o;
      this.a = [];
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this.a.push(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.o.onNext(this.a);this.o.onCompleted();
    };

    return ToArrayObservable;
  }(ObservableBase);

  /**
  * Creates an array from an observable sequence.
  * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.
  */
  observableProto.toArray = function () {
    return new ToArrayObservable(this);
  };

  /**
   *  Creates an observable sequence from a specified subscribe method implementation.
   * @example
   *  var res = Rx.Observable.create(function (observer) { return function () { } );
   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );
   *  var res = Rx.Observable.create(function (observer) { } );
   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.
   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.
   */
  Observable.create = function (subscribe, parent) {
    return new AnonymousObservable(subscribe, parent);
  };

  var Defer = function (__super__) {
    inherits(Defer, __super__);
    function Defer(factory) {
      this._f = factory;
      __super__.call(this);
    }

    Defer.prototype.subscribeCore = function (o) {
      var result = tryCatch(this._f)();
      if (result === errorObj) {
        return observableThrow(result.e).subscribe(o);
      }
      isPromise(result) && (result = observableFromPromise(result));
      return result.subscribe(o);
    };

    return Defer;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
   *
   * @example
   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });
   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.
   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
   */
  var observableDefer = Observable.defer = function (observableFactory) {
    return new Defer(observableFactory);
  };

  var EmptyObservable = function (__super__) {
    inherits(EmptyObservable, __super__);
    function EmptyObservable(scheduler) {
      this.scheduler = scheduler;
      __super__.call(this);
    }

    EmptyObservable.prototype.subscribeCore = function (observer) {
      var sink = new EmptySink(observer, this.scheduler);
      return sink.run();
    };

    function EmptySink(observer, scheduler) {
      this.observer = observer;
      this.scheduler = scheduler;
    }

    function scheduleItem(s, state) {
      state.onCompleted();
      return disposableEmpty;
    }

    EmptySink.prototype.run = function () {
      var state = this.observer;
      return this.scheduler === immediateScheduler ? scheduleItem(null, state) : this.scheduler.schedule(state, scheduleItem);
    };

    return EmptyObservable;
  }(ObservableBase);

  var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);

  /**
   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
   *
   * @example
   *  var res = Rx.Observable.empty();
   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);
   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.
   * @returns {Observable} An observable sequence with no elements.
   */
  var observableEmpty = Observable.empty = function (scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);
  };

  var FromObservable = function (__super__) {
    inherits(FromObservable, __super__);
    function FromObservable(iterable, fn, scheduler) {
      this._iterable = iterable;
      this._fn = fn;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function createScheduleMethod(o, it, fn) {
      return function loopRecursive(i, recurse) {
        var next = tryCatch(it.next).call(it);
        if (next === errorObj) {
          return o.onError(next.e);
        }
        if (next.done) {
          return o.onCompleted();
        }

        var result = next.value;

        if (isFunction(fn)) {
          result = tryCatch(fn)(result, i);
          if (result === errorObj) {
            return o.onError(result.e);
          }
        }

        o.onNext(result);
        recurse(i + 1);
      };
    }

    FromObservable.prototype.subscribeCore = function (o) {
      var list = Object(this._iterable),
          it = getIterable(list);

      return this._scheduler.scheduleRecursive(0, createScheduleMethod(o, it, this._fn));
    };

    return FromObservable;
  }(ObservableBase);

  var maxSafeInteger = Math.pow(2, 53) - 1;

  function StringIterable(s) {
    this._s = s;
  }

  StringIterable.prototype[$iterator$] = function () {
    return new StringIterator(this._s);
  };

  function StringIterator(s) {
    this._s = s;
    this._l = s.length;
    this._i = 0;
  }

  StringIterator.prototype[$iterator$] = function () {
    return this;
  };

  StringIterator.prototype.next = function () {
    return this._i < this._l ? { done: false, value: this._s.charAt(this._i++) } : doneEnumerator;
  };

  function ArrayIterable(a) {
    this._a = a;
  }

  ArrayIterable.prototype[$iterator$] = function () {
    return new ArrayIterator(this._a);
  };

  function ArrayIterator(a) {
    this._a = a;
    this._l = toLength(a);
    this._i = 0;
  }

  ArrayIterator.prototype[$iterator$] = function () {
    return this;
  };

  ArrayIterator.prototype.next = function () {
    return this._i < this._l ? { done: false, value: this._a[this._i++] } : doneEnumerator;
  };

  function numberIsFinite(value) {
    return typeof value === 'number' && root.isFinite(value);
  }

  function isNan(n) {
    return n !== n;
  }

  function getIterable(o) {
    var i = o[$iterator$],
        it;
    if (!i && typeof o === 'string') {
      it = new StringIterable(o);
      return it[$iterator$]();
    }
    if (!i && o.length !== undefined) {
      it = new ArrayIterable(o);
      return it[$iterator$]();
    }
    if (!i) {
      throw new TypeError('Object is not iterable');
    }
    return o[$iterator$]();
  }

  function sign(value) {
    var number = +value;
    if (number === 0) {
      return number;
    }
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? -1 : 1;
  }

  function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
      return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
      return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
      return 0;
    }
    if (len > maxSafeInteger) {
      return maxSafeInteger;
    }
    return len;
  }

  /**
  * This method creates a new Observable sequence from an array-like or iterable object.
  * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.
  * @param {Function} [mapFn] Map function to call on every element of the array.
  * @param {Any} [thisArg] The context to use calling the mapFn if provided.
  * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
  */
  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {
    if (iterable == null) {
      throw new Error('iterable cannot be null.');
    }
    if (mapFn && !isFunction(mapFn)) {
      throw new Error('mapFn when provided must be a function');
    }
    if (mapFn) {
      var mapper = bindCallback(mapFn, thisArg, 2);
    }
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromObservable(iterable, mapper, scheduler);
  };

  var FromArrayObservable = function (__super__) {
    inherits(FromArrayObservable, __super__);
    function FromArrayObservable(args, scheduler) {
      this._args = args;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(o, args) {
      var len = args.length;
      return function loopRecursive(i, recurse) {
        if (i < len) {
          o.onNext(args[i]);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    FromArrayObservable.prototype.subscribeCore = function (o) {
      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._args));
    };

    return FromArrayObservable;
  }(ObservableBase);

  /**
  *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.
  * @deprecated use Observable.from or Observable.of
  * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
  * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.
  */
  var observableFromArray = Observable.fromArray = function (array, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromArrayObservable(array, scheduler);
  };

  var GenerateObservable = function (__super__) {
    inherits(GenerateObservable, __super__);
    function GenerateObservable(state, cndFn, itrFn, resFn, s) {
      this._initialState = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }
      var hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (hasResult === errorObj) {
        return state.o.onError(hasResult.e);
      }
      if (hasResult) {
        var result = tryCatch(state.self._resFn)(state.newState);
        if (result === errorObj) {
          return state.o.onError(result.e);
        }
        state.o.onNext(result);
        recurse(state);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        first: true,
        newState: this._initialState
      };
      return this._s.scheduleRecursive(state, scheduleRecursive);
    };

    return GenerateObservable;
  }(ObservableBase);

  /**
   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
   *
   * @example
   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });
   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.
   * @returns {Observable} The generated sequence.
   */
  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);
  };

  function observableOf(scheduler, array) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromArrayObservable(array, scheduler);
  }

  /**
  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
  */
  Observable.of = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return new FromArrayObservable(args, currentThreadScheduler);
  };

  /**
  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
  * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.
  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
  */
  Observable.ofWithScheduler = function (scheduler) {
    var len = arguments.length,
        args = new Array(len - 1);
    for (var i = 1; i < len; i++) {
      args[i - 1] = arguments[i];
    }
    return new FromArrayObservable(args, scheduler);
  };

  /**
   * Creates an Observable sequence from changes to an array using Array.observe.
   * @param {Array} array An array to observe changes.
   * @returns {Observable} An observable sequence containing changes to an array from Array.observe.
   */
  Observable.ofArrayChanges = function (array) {
    if (!Array.isArray(array)) {
      throw new TypeError('Array.observe only accepts arrays.');
    }
    if (typeof Array.observe !== 'function' && typeof Array.unobserve !== 'function') {
      throw new TypeError('Array.observe is not supported on your platform');
    }
    return new AnonymousObservable(function (observer) {
      function observerFn(changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          observer.onNext(changes[i]);
        }
      }

      Array.observe(array, observerFn);

      return function () {
        Array.unobserve(array, observerFn);
      };
    });
  };

  /**
   * Creates an Observable sequence from changes to an object using Object.observe.
   * @param {Object} obj An object to observe changes.
   * @returns {Observable} An observable sequence containing changes to an object from Object.observe.
   */
  Observable.ofObjectChanges = function (obj) {
    if (obj == null) {
      throw new TypeError('object must not be null or undefined.');
    }
    if (typeof Object.observe !== 'function' && typeof Object.unobserve !== 'function') {
      throw new TypeError('Object.observe is not supported on your platform');
    }
    return new AnonymousObservable(function (observer) {
      function observerFn(changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          observer.onNext(changes[i]);
        }
      }

      Object.observe(obj, observerFn);

      return function () {
        Object.unobserve(obj, observerFn);
      };
    });
  };

  var NeverObservable = function (__super__) {
    inherits(NeverObservable, __super__);
    function NeverObservable() {
      __super__.call(this);
    }

    NeverObservable.prototype.subscribeCore = function (observer) {
      return disposableEmpty;
    };

    return NeverObservable;
  }(ObservableBase);

  var NEVER_OBSERVABLE = new NeverObservable();

  /**
   * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
   * @returns {Observable} An observable sequence whose observers will never get called.
   */
  var observableNever = Observable.never = function () {
    return NEVER_OBSERVABLE;
  };

  var PairsObservable = function (__super__) {
    inherits(PairsObservable, __super__);
    function PairsObservable(o, scheduler) {
      this._o = o;
      this._keys = Object.keys(o);
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(o, obj, keys) {
      return function loopRecursive(i, recurse) {
        if (i < keys.length) {
          var key = keys[i];
          o.onNext([key, obj[key]]);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    PairsObservable.prototype.subscribeCore = function (o) {
      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._o, this._keys));
    };

    return PairsObservable;
  }(ObservableBase);

  /**
   * Convert an object into an observable sequence of [key, value] pairs.
   * @param {Object} obj The object to inspect.
   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
   * @returns {Observable} An observable sequence of [key, value] pairs from the object.
   */
  Observable.pairs = function (obj, scheduler) {
    scheduler || (scheduler = currentThreadScheduler);
    return new PairsObservable(obj, scheduler);
  };

  var RangeObservable = function (__super__) {
    inherits(RangeObservable, __super__);
    function RangeObservable(start, count, scheduler) {
      this.start = start;
      this.rangeCount = count;
      this.scheduler = scheduler;
      __super__.call(this);
    }

    function loopRecursive(start, count, o) {
      return function loop(i, recurse) {
        if (i < count) {
          o.onNext(start + i);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    RangeObservable.prototype.subscribeCore = function (o) {
      return this.scheduler.scheduleRecursive(0, loopRecursive(this.start, this.rangeCount, o));
    };

    return RangeObservable;
  }(ObservableBase);

  /**
  *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.
  * @param {Number} start The value of the first integer in the sequence.
  * @param {Number} count The number of sequential integers to generate.
  * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.
  * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.
  */
  Observable.range = function (start, count, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new RangeObservable(start, count, scheduler);
  };

  var RepeatObservable = function (__super__) {
    inherits(RepeatObservable, __super__);
    function RepeatObservable(value, repeatCount, scheduler) {
      this.value = value;
      this.repeatCount = repeatCount == null ? -1 : repeatCount;
      this.scheduler = scheduler;
      __super__.call(this);
    }

    RepeatObservable.prototype.subscribeCore = function (observer) {
      var sink = new RepeatSink(observer, this);
      return sink.run();
    };

    return RepeatObservable;
  }(ObservableBase);

  function RepeatSink(observer, parent) {
    this.observer = observer;
    this.parent = parent;
  }

  RepeatSink.prototype.run = function () {
    var observer = this.observer,
        value = this.parent.value;
    function loopRecursive(i, recurse) {
      if (i === -1 || i > 0) {
        observer.onNext(value);
        i > 0 && i--;
      }
      if (i === 0) {
        return observer.onCompleted();
      }
      recurse(i);
    }

    return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount, loopRecursive);
  };

  /**
   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.
   * @param {Mixed} value Element to repeat.
   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.
   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.
   */
  Observable.repeat = function (value, repeatCount, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new RepeatObservable(value, repeatCount, scheduler);
  };

  var JustObservable = function (__super__) {
    inherits(JustObservable, __super__);
    function JustObservable(value, scheduler) {
      this._value = value;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    JustObservable.prototype.subscribeCore = function (o) {
      var state = [this._value, o];
      return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);
    };

    function scheduleItem(s, state) {
      var value = state[0],
          observer = state[1];
      observer.onNext(value);
      observer.onCompleted();
      return disposableEmpty;
    }

    return JustObservable;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.
   *  There is an alias called 'just' or browsers <IE9.
   * @param {Mixed} value Single element in the resulting observable sequence.
   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} An observable sequence containing the single specified element.
   */
  var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return new JustObservable(value, scheduler);
  };

  var ThrowObservable = function (__super__) {
    inherits(ThrowObservable, __super__);
    function ThrowObservable(error, scheduler) {
      this._error = error;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    ThrowObservable.prototype.subscribeCore = function (o) {
      var state = [this._error, o];
      return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);
    };

    function scheduleItem(s, state) {
      var e = state[0],
          o = state[1];
      o.onError(e);
      return disposableEmpty;
    }

    return ThrowObservable;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.
   *  There is an alias to this method called 'throwError' for browsers <IE9.
   * @param {Mixed} error An object used for the sequence's termination.
   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.
   */
  var observableThrow = Observable['throw'] = function (error, scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return new ThrowObservable(error, scheduler);
  };

  var UsingObservable = function (__super__) {
    inherits(UsingObservable, __super__);
    function UsingObservable(resFn, obsFn) {
      this._resFn = resFn;
      this._obsFn = obsFn;
      __super__.call(this);
    }

    UsingObservable.prototype.subscribeCore = function (o) {
      var disposable = disposableEmpty;
      var resource = tryCatch(this._resFn)();
      if (resource === errorObj) {
        return new BinaryDisposable(observableThrow(resource.e).subscribe(o), disposable);
      }
      resource && (disposable = resource);
      var source = tryCatch(this._obsFn)(resource);
      if (source === errorObj) {
        return new BinaryDisposable(observableThrow(source.e).subscribe(o), disposable);
      }
      return new BinaryDisposable(source.subscribe(o), disposable);
    };

    return UsingObservable;
  }(ObservableBase);

  /**
   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
   * @param {Function} resourceFactory Factory function to obtain a resource object.
   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.
   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.
   */
  Observable.using = function (resourceFactory, observableFactory) {
    return new UsingObservable(resourceFactory, observableFactory);
  };

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @param {Observable} rightSource Second observable sequence or Promise.
   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.
   */
  observableProto.amb = function (rightSource) {
    var leftSource = this;
    return new AnonymousObservable(function (observer) {
      var choice,
          leftChoice = 'L',
          rightChoice = 'R',
          leftSubscription = new SingleAssignmentDisposable(),
          rightSubscription = new SingleAssignmentDisposable();

      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));

      function choiceL() {
        if (!choice) {
          choice = leftChoice;
          rightSubscription.dispose();
        }
      }

      function choiceR() {
        if (!choice) {
          choice = rightChoice;
          leftSubscription.dispose();
        }
      }

      var leftSubscribe = observerCreate(function (left) {
        choiceL();
        choice === leftChoice && observer.onNext(left);
      }, function (e) {
        choiceL();
        choice === leftChoice && observer.onError(e);
      }, function () {
        choiceL();
        choice === leftChoice && observer.onCompleted();
      });
      var rightSubscribe = observerCreate(function (right) {
        choiceR();
        choice === rightChoice && observer.onNext(right);
      }, function (e) {
        choiceR();
        choice === rightChoice && observer.onError(e);
      }, function () {
        choiceR();
        choice === rightChoice && observer.onCompleted();
      });

      leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
      rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));

      return new BinaryDisposable(leftSubscription, rightSubscription);
    });
  };

  function amb(p, c) {
    return p.amb(c);
  }

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
   */
  Observable.amb = function () {
    var acc = observableNever(),
        items;
    if (Array.isArray(arguments[0])) {
      items = arguments[0];
    } else {
      var len = arguments.length;
      items = new Array(items);
      for (var i = 0; i < len; i++) {
        items[i] = arguments[i];
      }
    }
    for (var i = 0, len = items.length; i < len; i++) {
      acc = amb(acc, items[i]);
    }
    return acc;
  };

  var CatchObservable = function (__super__) {
    inherits(CatchObservable, __super__);
    function CatchObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    CatchObservable.prototype.subscribeCore = function (o) {
      var d1 = new SingleAssignmentDisposable(),
          subscription = new SerialDisposable();
      subscription.setDisposable(d1);
      d1.setDisposable(this.source.subscribe(new CatchObserver(o, subscription, this._fn)));
      return subscription;
    };

    return CatchObservable;
  }(ObservableBase);

  var CatchObserver = function (__super__) {
    inherits(CatchObserver, __super__);
    function CatchObserver(o, s, fn) {
      this._o = o;
      this._s = s;
      this._fn = fn;
      __super__.call(this);
    }

    CatchObserver.prototype.next = function (x) {
      this._o.onNext(x);
    };
    CatchObserver.prototype.completed = function () {
      return this._o.onCompleted();
    };
    CatchObserver.prototype.error = function (e) {
      var result = tryCatch(this._fn)(e);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      isPromise(result) && (result = observableFromPromise(result));

      var d = new SingleAssignmentDisposable();
      this._s.setDisposable(d);
      d.setDisposable(result.subscribe(this._o));
    };

    return CatchObserver;
  }(AbstractObserver);

  /**
   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.
   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.
   */
  observableProto['catch'] = function (handlerOrSecond) {
    return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
  };

  /**
   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.
   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
   */
  var observableCatch = Observable['catch'] = function () {
    var items;
    if (Array.isArray(arguments[0])) {
      items = arguments[0];
    } else {
      var len = arguments.length;
      items = new Array(len);
      for (var i = 0; i < len; i++) {
        items[i] = arguments[i];
      }
    }
    return enumerableOf(items).catchError();
  };

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
   * This can be in the form of an argument list of observables or an array.
   *
   * @example
   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.combineLatest = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args[0].unshift(this);
    } else {
      args.unshift(this);
    }
    return combineLatest.apply(this, args);
  };

  function falseFactory() {
    return false;
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var CombineLatestObservable = function (__super__) {
    inherits(CombineLatestObservable, __super__);
    function CombineLatestObservable(params, cb) {
      this._params = params;
      this._cb = cb;
      __super__.call(this);
    }

    CombineLatestObservable.prototype.subscribeCore = function (observer) {
      var len = this._params.length,
          subscriptions = new Array(len);

      var state = {
        hasValue: arrayInitialize(len, falseFactory),
        hasValueAll: false,
        isDone: arrayInitialize(len, falseFactory),
        values: new Array(len)
      };

      for (var i = 0; i < len; i++) {
        var source = this._params[i],
            sad = new SingleAssignmentDisposable();
        subscriptions[i] = sad;
        isPromise(source) && (source = observableFromPromise(source));
        sad.setDisposable(source.subscribe(new CombineLatestObserver(observer, i, this._cb, state)));
      }

      return new NAryDisposable(subscriptions);
    };

    return CombineLatestObservable;
  }(ObservableBase);

  var CombineLatestObserver = function (__super__) {
    inherits(CombineLatestObserver, __super__);
    function CombineLatestObserver(o, i, cb, state) {
      this._o = o;
      this._i = i;
      this._cb = cb;
      this._state = state;
      __super__.call(this);
    }

    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    CombineLatestObserver.prototype.next = function (x) {
      this._state.values[this._i] = x;
      this._state.hasValue[this._i] = true;
      if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.every(identity))) {
        var res = tryCatch(this._cb).apply(null, this._state.values);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._o.onNext(res);
      } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {
        this._o.onCompleted();
      }
    };

    CombineLatestObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    CombineLatestObserver.prototype.completed = function () {
      this._state.isDone[this._i] = true;
      this._state.isDone.every(identity) && this._o.onCompleted();
    };

    return CombineLatestObserver;
  }(AbstractObserver);

  /**
  * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
  *
  * @example
  * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
  * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
  * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  */
  var combineLatest = Observable.combineLatest = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);
    return new CombineLatestObservable(args, resultSelector);
  };

  /**
   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.
   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
   */
  observableProto.concat = function () {
    for (var args = [], i = 0, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    args.unshift(this);
    return observableConcat.apply(null, args);
  };

  var ConcatObserver = function (__super__) {
    inherits(ConcatObserver, __super__);
    function ConcatObserver(s, fn) {
      this._s = s;
      this._fn = fn;
      __super__.call(this);
    }

    ConcatObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
    };
    ConcatObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    ConcatObserver.prototype.completed = function () {
      this._s.i++;this._fn(this._s);
    };

    return ConcatObserver;
  }(AbstractObserver);

  var ConcatObservable = function (__super__) {
    inherits(ConcatObservable, __super__);
    function ConcatObservable(sources) {
      this._sources = sources;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      if (state.disposable.isDisposed) {
        return;
      }
      if (state.i === state.sources.length) {
        return state.o.onCompleted();
      }

      // Check if promise
      var currentValue = state.sources[state.i];
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new ConcatObserver(state, recurse)));
    }

    ConcatObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var disposable = disposableCreate(noop);
      var state = {
        o: o,
        i: 0,
        subscription: subscription,
        disposable: disposable,
        sources: this._sources
      };

      var cancelable = immediateScheduler.scheduleRecursive(state, scheduleRecursive);
      return new NAryDisposable([subscription, disposable, cancelable]);
    };

    return ConcatObservable;
  }(ObservableBase);

  /**
   * Concatenates all the observable sequences.
   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.
   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
   */
  var observableConcat = Observable.concat = function () {
    var args;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      args = new Array(arguments.length);
      for (var i = 0, len = arguments.length; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    return new ConcatObservable(args);
  };

  /**
   * Concatenates an observable sequence of observable sequences.
   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.
   */
  observableProto.concatAll = function () {
    return this.merge(1);
  };

  var MergeObservable = function (__super__) {
    inherits(MergeObservable, __super__);

    function MergeObservable(source, maxConcurrent) {
      this.source = source;
      this.maxConcurrent = maxConcurrent;
      __super__.call(this);
    }

    MergeObservable.prototype.subscribeCore = function (observer) {
      var g = new CompositeDisposable();
      g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
      return g;
    };

    return MergeObservable;
  }(ObservableBase);

  var MergeObserver = function (__super__) {
    function MergeObserver(o, max, g) {
      this.o = o;
      this.max = max;
      this.g = g;
      this.done = false;
      this.q = [];
      this.activeCount = 0;
      __super__.call(this);
    }

    inherits(MergeObserver, __super__);

    MergeObserver.prototype.handleSubscribe = function (xs) {
      var sad = new SingleAssignmentDisposable();
      this.g.add(sad);
      isPromise(xs) && (xs = observableFromPromise(xs));
      sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
    };

    MergeObserver.prototype.next = function (innerSource) {
      if (this.activeCount < this.max) {
        this.activeCount++;
        this.handleSubscribe(innerSource);
      } else {
        this.q.push(innerSource);
      }
    };
    MergeObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    MergeObserver.prototype.completed = function () {
      this.done = true;this.activeCount === 0 && this.o.onCompleted();
    };

    function InnerObserver(parent, sad) {
      this.parent = parent;
      this.sad = sad;
      __super__.call(this);
    }

    inherits(InnerObserver, __super__);

    InnerObserver.prototype.next = function (x) {
      this.parent.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.parent.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.parent.g.remove(this.sad);
      if (this.parent.q.length > 0) {
        this.parent.handleSubscribe(this.parent.q.shift());
      } else {
        this.parent.activeCount--;
        this.parent.done && this.parent.activeCount === 0 && this.parent.o.onCompleted();
      }
    };

    return MergeObserver;
  }(AbstractObserver);

  /**
  * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.
  * Or merges two observable sequences into a single observable sequence.
  * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.
  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
  */
  observableProto.merge = function (maxConcurrentOrOther) {
    return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
  };

  /**
   * Merges all the observable sequences into a single observable sequence.
   * The scheduler is optional and if not specified, the immediate scheduler is used.
   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.
   */
  var observableMerge = Observable.merge = function () {
    var scheduler,
        sources = [],
        i,
        len = arguments.length;
    if (!arguments[0]) {
      scheduler = immediateScheduler;
      for (i = 1; i < len; i++) {
        sources.push(arguments[i]);
      }
    } else if (isScheduler(arguments[0])) {
      scheduler = arguments[0];
      for (i = 1; i < len; i++) {
        sources.push(arguments[i]);
      }
    } else {
      scheduler = immediateScheduler;
      for (i = 0; i < len; i++) {
        sources.push(arguments[i]);
      }
    }
    if (Array.isArray(sources[0])) {
      sources = sources[0];
    }
    return observableOf(scheduler, sources).mergeAll();
  };

  var MergeAllObservable = function (__super__) {
    inherits(MergeAllObservable, __super__);

    function MergeAllObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    MergeAllObservable.prototype.subscribeCore = function (o) {
      var g = new CompositeDisposable(),
          m = new SingleAssignmentDisposable();
      g.add(m);
      m.setDisposable(this.source.subscribe(new MergeAllObserver(o, g)));
      return g;
    };

    return MergeAllObservable;
  }(ObservableBase);

  var MergeAllObserver = function (__super__) {
    function MergeAllObserver(o, g) {
      this.o = o;
      this.g = g;
      this.done = false;
      __super__.call(this);
    }

    inherits(MergeAllObserver, __super__);

    MergeAllObserver.prototype.next = function (innerSource) {
      var sad = new SingleAssignmentDisposable();
      this.g.add(sad);
      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
      sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));
    };

    MergeAllObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    MergeAllObserver.prototype.completed = function () {
      this.done = true;
      this.g.length === 1 && this.o.onCompleted();
    };

    function InnerObserver(parent, sad) {
      this.parent = parent;
      this.sad = sad;
      __super__.call(this);
    }

    inherits(InnerObserver, __super__);

    InnerObserver.prototype.next = function (x) {
      this.parent.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.parent.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.parent.g.remove(this.sad);
      this.parent.done && this.parent.g.length === 1 && this.parent.o.onCompleted();
    };

    return MergeAllObserver;
  }(AbstractObserver);

  /**
  * Merges an observable sequence of observable sequences into an observable sequence.
  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
  */
  observableProto.mergeAll = function () {
    return new MergeAllObservable(this);
  };

  var CompositeError = Rx.CompositeError = function (errors) {
    this.innerErrors = errors;
    this.message = 'This contains multiple errors. Check the innerErrors';
    Error.call(this);
  };
  CompositeError.prototype = Object.create(Error.prototype);
  CompositeError.prototype.name = 'CompositeError';

  var MergeDelayErrorObservable = function (__super__) {
    inherits(MergeDelayErrorObservable, __super__);
    function MergeDelayErrorObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    MergeDelayErrorObservable.prototype.subscribeCore = function (o) {
      var group = new CompositeDisposable(),
          m = new SingleAssignmentDisposable(),
          state = { isStopped: false, errors: [], o: o };

      group.add(m);
      m.setDisposable(this.source.subscribe(new MergeDelayErrorObserver(group, state)));

      return group;
    };

    return MergeDelayErrorObservable;
  }(ObservableBase);

  var MergeDelayErrorObserver = function (__super__) {
    inherits(MergeDelayErrorObserver, __super__);
    function MergeDelayErrorObserver(group, state) {
      this._group = group;
      this._state = state;
      __super__.call(this);
    }

    function setCompletion(o, errors) {
      if (errors.length === 0) {
        o.onCompleted();
      } else if (errors.length === 1) {
        o.onError(errors[0]);
      } else {
        o.onError(new CompositeError(errors));
      }
    }

    MergeDelayErrorObserver.prototype.next = function (x) {
      var inner = new SingleAssignmentDisposable();
      this._group.add(inner);

      // Check for promises support
      isPromise(x) && (x = observableFromPromise(x));
      inner.setDisposable(x.subscribe(new InnerObserver(inner, this._group, this._state)));
    };

    MergeDelayErrorObserver.prototype.error = function (e) {
      this._state.errors.push(e);
      this._state.isStopped = true;
      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    MergeDelayErrorObserver.prototype.completed = function () {
      this._state.isStopped = true;
      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    inherits(InnerObserver, __super__);
    function InnerObserver(inner, group, state) {
      this._inner = inner;
      this._group = group;
      this._state = state;
      __super__.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.errors.push(e);
      this._group.remove(this._inner);
      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };
    InnerObserver.prototype.completed = function () {
      this._group.remove(this._inner);
      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    return MergeDelayErrorObserver;
  }(AbstractObserver);

  /**
  * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
  * receive all successfully emitted items from all of the source Observables without being interrupted by
  * an error notification from one of them.
  *
  * This behaves like Observable.prototype.mergeAll except that if any of the merged Observables notify of an
  * error via the Observer's onError, mergeDelayError will refrain from propagating that
  * error notification until all of the merged Observables have finished emitting items.
  * @param {Array | Arguments} args Arguments or an array to merge.
  * @returns {Observable} an Observable that emits all of the items emitted by the Observables emitted by the Observable
  */
  Observable.mergeDelayError = function () {
    var args;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      var len = arguments.length;
      args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    var source = observableOf(null, args);
    return new MergeDelayErrorObservable(source);
  };

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.
   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
   */
  observableProto.onErrorResumeNext = function (second) {
    if (!second) {
      throw new Error('Second observable is required');
    }
    return onErrorResumeNext([this, second]);
  };

  var OnErrorResumeNextObservable = function (__super__) {
    inherits(OnErrorResumeNextObservable, __super__);
    function OnErrorResumeNextObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    function scheduleMethod(state, recurse) {
      if (state.pos < state.sources.length) {
        var current = state.sources[state.pos++];
        isPromise(current) && (current = observableFromPromise(current));
        var d = new SingleAssignmentDisposable();
        state.subscription.setDisposable(d);
        d.setDisposable(current.subscribe(new OnErrorResumeNextObserver(state, recurse)));
      } else {
        state.o.onCompleted();
      }
    }

    OnErrorResumeNextObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable(),
          state = { pos: 0, subscription: subscription, o: o, sources: this.sources },
          cancellable = immediateScheduler.scheduleRecursive(state, scheduleMethod);

      return new BinaryDisposable(subscription, cancellable);
    };

    return OnErrorResumeNextObservable;
  }(ObservableBase);

  var OnErrorResumeNextObserver = function (__super__) {
    inherits(OnErrorResumeNextObserver, __super__);
    function OnErrorResumeNextObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      __super__.call(this);
    }

    OnErrorResumeNextObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    OnErrorResumeNextObserver.prototype.error = function () {
      this._recurse(this._state);
    };
    OnErrorResumeNextObserver.prototype.completed = function () {
      this._recurse(this._state);
    };

    return OnErrorResumeNextObserver;
  }(AbstractObserver);

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
   */
  var onErrorResumeNext = Observable.onErrorResumeNext = function () {
    var sources = [];
    if (Array.isArray(arguments[0])) {
      sources = arguments[0];
    } else {
      var len = arguments.length;
      sources = new Array(len);
      for (var i = 0; i < len; i++) {
        sources[i] = arguments[i];
      }
    }
    return new OnErrorResumeNextObservable(sources);
  };

  var SkipUntilObservable = function (__super__) {
    inherits(SkipUntilObservable, __super__);

    function SkipUntilObservable(source, other) {
      this._s = source;
      this._o = isPromise(other) ? observableFromPromise(other) : other;
      this._open = false;
      __super__.call(this);
    }

    SkipUntilObservable.prototype.subscribeCore = function (o) {
      var leftSubscription = new SingleAssignmentDisposable();
      leftSubscription.setDisposable(this._s.subscribe(new SkipUntilSourceObserver(o, this)));

      isPromise(this._o) && (this._o = observableFromPromise(this._o));

      var rightSubscription = new SingleAssignmentDisposable();
      rightSubscription.setDisposable(this._o.subscribe(new SkipUntilOtherObserver(o, this, rightSubscription)));

      return new BinaryDisposable(leftSubscription, rightSubscription);
    };

    return SkipUntilObservable;
  }(ObservableBase);

  var SkipUntilSourceObserver = function (__super__) {
    inherits(SkipUntilSourceObserver, __super__);
    function SkipUntilSourceObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipUntilSourceObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };

    SkipUntilSourceObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    SkipUntilSourceObserver.prototype.onCompleted = function () {
      this._p._open && this._o.onCompleted();
    };

    return SkipUntilSourceObserver;
  }(AbstractObserver);

  var SkipUntilOtherObserver = function (__super__) {
    inherits(SkipUntilOtherObserver, __super__);
    function SkipUntilOtherObserver(o, p, r) {
      this._o = o;
      this._p = p;
      this._r = r;
      __super__.call(this);
    }

    SkipUntilOtherObserver.prototype.next = function () {
      this._p._open = true;
      this._r.dispose();
    };

    SkipUntilOtherObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    SkipUntilOtherObserver.prototype.onCompleted = function () {
      this._r.dispose();
    };

    return SkipUntilOtherObserver;
  }(AbstractObserver);

  /**
   * Returns the values from the source observable sequence only after the other observable sequence produces a value.
   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.
   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.
   */
  observableProto.skipUntil = function (other) {
    return new SkipUntilObservable(this, other);
  };

  var SwitchObservable = function (__super__) {
    inherits(SwitchObservable, __super__);
    function SwitchObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    SwitchObservable.prototype.subscribeCore = function (o) {
      var inner = new SerialDisposable(),
          s = this.source.subscribe(new SwitchObserver(o, inner));
      return new BinaryDisposable(s, inner);
    };

    inherits(SwitchObserver, AbstractObserver);
    function SwitchObserver(o, inner) {
      this.o = o;
      this.inner = inner;
      this.stopped = false;
      this.latest = 0;
      this.hasLatest = false;
      AbstractObserver.call(this);
    }

    SwitchObserver.prototype.next = function (innerSource) {
      var d = new SingleAssignmentDisposable(),
          id = ++this.latest;
      this.hasLatest = true;
      this.inner.setDisposable(d);
      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
      d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
    };

    SwitchObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    SwitchObserver.prototype.completed = function () {
      this.stopped = true;
      !this.hasLatest && this.o.onCompleted();
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(parent, id) {
      this.parent = parent;
      this.id = id;
      AbstractObserver.call(this);
    }
    InnerObserver.prototype.next = function (x) {
      this.parent.latest === this.id && this.parent.o.onNext(x);
    };

    InnerObserver.prototype.error = function (e) {
      this.parent.latest === this.id && this.parent.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      if (this.parent.latest === this.id) {
        this.parent.hasLatest = false;
        this.parent.stopped && this.parent.o.onCompleted();
      }
    };

    return SwitchObservable;
  }(ObservableBase);

  /**
  * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
  * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
  */
  observableProto['switch'] = observableProto.switchLatest = function () {
    return new SwitchObservable(this);
  };

  var TakeUntilObservable = function (__super__) {
    inherits(TakeUntilObservable, __super__);

    function TakeUntilObservable(source, other) {
      this.source = source;
      this.other = isPromise(other) ? observableFromPromise(other) : other;
      __super__.call(this);
    }

    TakeUntilObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this.source.subscribe(o), this.other.subscribe(new TakeUntilObserver(o)));
    };

    return TakeUntilObservable;
  }(ObservableBase);

  var TakeUntilObserver = function (__super__) {
    inherits(TakeUntilObserver, __super__);
    function TakeUntilObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    TakeUntilObserver.prototype.next = function () {
      this._o.onCompleted();
    };

    TakeUntilObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    TakeUntilObserver.prototype.onCompleted = noop;

    return TakeUntilObserver;
  }(AbstractObserver);

  /**
   * Returns the values from the source observable sequence until the other observable sequence produces a value.
   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.
   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
   */
  observableProto.takeUntil = function (other) {
    return new TakeUntilObservable(this, other);
  };

  function falseFactory() {
    return false;
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var WithLatestFromObservable = function (__super__) {
    inherits(WithLatestFromObservable, __super__);
    function WithLatestFromObservable(source, sources, resultSelector) {
      this._s = source;
      this._ss = sources;
      this._cb = resultSelector;
      __super__.call(this);
    }

    WithLatestFromObservable.prototype.subscribeCore = function (o) {
      var len = this._ss.length;
      var state = {
        hasValue: arrayInitialize(len, falseFactory),
        hasValueAll: false,
        values: new Array(len)
      };

      var n = this._ss.length,
          subscriptions = new Array(n + 1);
      for (var i = 0; i < n; i++) {
        var other = this._ss[i],
            sad = new SingleAssignmentDisposable();
        isPromise(other) && (other = observableFromPromise(other));
        sad.setDisposable(other.subscribe(new WithLatestFromOtherObserver(o, i, state)));
        subscriptions[i] = sad;
      }

      var outerSad = new SingleAssignmentDisposable();
      outerSad.setDisposable(this._s.subscribe(new WithLatestFromSourceObserver(o, this._cb, state)));
      subscriptions[n] = outerSad;

      return new NAryDisposable(subscriptions);
    };

    return WithLatestFromObservable;
  }(ObservableBase);

  var WithLatestFromOtherObserver = function (__super__) {
    inherits(WithLatestFromOtherObserver, __super__);
    function WithLatestFromOtherObserver(o, i, state) {
      this._o = o;
      this._i = i;
      this._state = state;
      __super__.call(this);
    }

    WithLatestFromOtherObserver.prototype.next = function (x) {
      this._state.values[this._i] = x;
      this._state.hasValue[this._i] = true;
      this._state.hasValueAll = this._state.hasValue.every(identity);
    };

    WithLatestFromOtherObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    WithLatestFromOtherObserver.prototype.completed = noop;

    return WithLatestFromOtherObserver;
  }(AbstractObserver);

  var WithLatestFromSourceObserver = function (__super__) {
    inherits(WithLatestFromSourceObserver, __super__);
    function WithLatestFromSourceObserver(o, cb, state) {
      this._o = o;
      this._cb = cb;
      this._state = state;
      __super__.call(this);
    }

    WithLatestFromSourceObserver.prototype.next = function (x) {
      var allValues = [x].concat(this._state.values);
      if (!this._state.hasValueAll) {
        return;
      }
      var res = tryCatch(this._cb).apply(null, allValues);
      if (res === errorObj) {
        return this._o.onError(res.e);
      }
      this._o.onNext(res);
    };

    WithLatestFromSourceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    WithLatestFromSourceObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return WithLatestFromSourceObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.withLatestFrom = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);

    return new WithLatestFromObservable(this, args, resultSelector);
  };

  function falseFactory() {
    return false;
  }
  function emptyArrayFactory() {
    return [];
  }

  var ZipObservable = function (__super__) {
    inherits(ZipObservable, __super__);
    function ZipObservable(sources, resultSelector) {
      this._s = sources;
      this._cb = resultSelector;
      __super__.call(this);
    }

    ZipObservable.prototype.subscribeCore = function (observer) {
      var n = this._s.length,
          subscriptions = new Array(n),
          done = arrayInitialize(n, falseFactory),
          q = arrayInitialize(n, emptyArrayFactory);

      for (var i = 0; i < n; i++) {
        var source = this._s[i],
            sad = new SingleAssignmentDisposable();
        subscriptions[i] = sad;
        isPromise(source) && (source = observableFromPromise(source));
        sad.setDisposable(source.subscribe(new ZipObserver(observer, i, this, q, done)));
      }

      return new NAryDisposable(subscriptions);
    };

    return ZipObservable;
  }(ObservableBase);

  var ZipObserver = function (__super__) {
    inherits(ZipObserver, __super__);
    function ZipObserver(o, i, p, q, d) {
      this._o = o;
      this._i = i;
      this._p = p;
      this._q = q;
      this._d = d;
      __super__.call(this);
    }

    function notEmpty(x) {
      return x.length > 0;
    }
    function shiftEach(x) {
      return x.shift();
    }
    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    ZipObserver.prototype.next = function (x) {
      this._q[this._i].push(x);
      if (this._q.every(notEmpty)) {
        var queuedValues = this._q.map(shiftEach);
        var res = tryCatch(this._p._cb).apply(null, queuedValues);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._o.onNext(res);
      } else if (this._d.filter(notTheSame(this._i)).every(identity)) {
        this._o.onCompleted();
      }
    };

    ZipObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ZipObserver.prototype.completed = function () {
      this._d[this._i] = true;
      this._d.every(identity) && this._o.onCompleted();
    };

    return ZipObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.
   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.
   */
  observableProto.zip = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);

    var parent = this;
    args.unshift(parent);

    return new ZipObservable(args, resultSelector);
  };

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   * @param arguments Observable sources.
   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  Observable.zip = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];
    }
    var first = args.shift();
    return first.zip.apply(first, args);
  };

  function falseFactory() {
    return false;
  }
  function emptyArrayFactory() {
    return [];
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var ZipIterableObservable = function (__super__) {
    inherits(ZipIterableObservable, __super__);
    function ZipIterableObservable(sources, cb) {
      this.sources = sources;
      this._cb = cb;
      __super__.call(this);
    }

    ZipIterableObservable.prototype.subscribeCore = function (o) {
      var sources = this.sources,
          len = sources.length,
          subscriptions = new Array(len);

      var state = {
        q: arrayInitialize(len, emptyArrayFactory),
        done: arrayInitialize(len, falseFactory),
        cb: this._cb,
        o: o
      };

      for (var i = 0; i < len; i++) {
        (function (i) {
          var source = sources[i],
              sad = new SingleAssignmentDisposable();
          (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));

          subscriptions[i] = sad;
          sad.setDisposable(source.subscribe(new ZipIterableObserver(state, i)));
        })(i);
      }

      return new NAryDisposable(subscriptions);
    };

    return ZipIterableObservable;
  }(ObservableBase);

  var ZipIterableObserver = function (__super__) {
    inherits(ZipIterableObserver, __super__);
    function ZipIterableObserver(s, i) {
      this._s = s;
      this._i = i;
      __super__.call(this);
    }

    function notEmpty(x) {
      return x.length > 0;
    }
    function shiftEach(x) {
      return x.shift();
    }
    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    ZipIterableObserver.prototype.next = function (x) {
      this._s.q[this._i].push(x);
      if (this._s.q.every(notEmpty)) {
        var queuedValues = this._s.q.map(shiftEach),
            res = tryCatch(this._s.cb).apply(null, queuedValues);
        if (res === errorObj) {
          return this._s.o.onError(res.e);
        }
        this._s.o.onNext(res);
      } else if (this._s.done.filter(notTheSame(this._i)).every(identity)) {
        this._s.o.onCompleted();
      }
    };

    ZipIterableObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    ZipIterableObserver.prototype.completed = function () {
      this._s.done[this._i] = true;
      this._s.done.every(identity) && this._s.o.onCompleted();
    };

    return ZipIterableObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.
   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.
   */
  observableProto.zipIterable = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;

    var parent = this;
    args.unshift(parent);
    return new ZipIterableObservable(args, resultSelector);
  };

  function asObservable(source) {
    return function subscribe(o) {
      return source.subscribe(o);
    };
  }

  /**
   *  Hides the identity of an observable sequence.
   * @returns {Observable} An observable sequence that hides the identity of the source sequence.
   */
  observableProto.asObservable = function () {
    return new AnonymousObservable(asObservable(this), this);
  };

  function toArray(x) {
    return x.toArray();
  }
  function notEmpty(x) {
    return x.length > 0;
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
   * @param {Number} count Length of each buffer.
   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithCount = observableProto.bufferCount = function (count, skip) {
    typeof skip !== 'number' && (skip = count);
    return this.windowWithCount(count, skip).flatMap(toArray).filter(notEmpty);
  };

  var DematerializeObservable = function (__super__) {
    inherits(DematerializeObservable, __super__);
    function DematerializeObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    DematerializeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DematerializeObserver(o));
    };

    return DematerializeObservable;
  }(ObservableBase);

  var DematerializeObserver = function (__super__) {
    inherits(DematerializeObserver, __super__);

    function DematerializeObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    DematerializeObserver.prototype.next = function (x) {
      x.accept(this._o);
    };
    DematerializeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    DematerializeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return DematerializeObserver;
  }(AbstractObserver);

  /**
   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
   */
  observableProto.dematerialize = function () {
    return new DematerializeObservable(this);
  };

  var DistinctUntilChangedObservable = function (__super__) {
    inherits(DistinctUntilChangedObservable, __super__);
    function DistinctUntilChangedObservable(source, keyFn, comparer) {
      this.source = source;
      this.keyFn = keyFn;
      this.comparer = comparer;
      __super__.call(this);
    }

    DistinctUntilChangedObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));
    };

    return DistinctUntilChangedObservable;
  }(ObservableBase);

  var DistinctUntilChangedObserver = function (__super__) {
    inherits(DistinctUntilChangedObserver, __super__);
    function DistinctUntilChangedObserver(o, keyFn, comparer) {
      this.o = o;
      this.keyFn = keyFn;
      this.comparer = comparer;
      this.hasCurrentKey = false;
      this.currentKey = null;
      __super__.call(this);
    }

    DistinctUntilChangedObserver.prototype.next = function (x) {
      var key = x,
          comparerEquals;
      if (isFunction(this.keyFn)) {
        key = tryCatch(this.keyFn)(x);
        if (key === errorObj) {
          return this.o.onError(key.e);
        }
      }
      if (this.hasCurrentKey) {
        comparerEquals = tryCatch(this.comparer)(this.currentKey, key);
        if (comparerEquals === errorObj) {
          return this.o.onError(comparerEquals.e);
        }
      }
      if (!this.hasCurrentKey || !comparerEquals) {
        this.hasCurrentKey = true;
        this.currentKey = key;
        this.o.onNext(x);
      }
    };
    DistinctUntilChangedObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    DistinctUntilChangedObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return DistinctUntilChangedObserver;
  }(AbstractObserver);

  /**
  *  Returns an observable sequence that contains only distinct contiguous elements according to the keyFn and the comparer.
  * @param {Function} [keyFn] A function to compute the comparison key for each element. If not provided, it projects the value.
  * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.
  * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
  */
  observableProto.distinctUntilChanged = function (keyFn, comparer) {
    comparer || (comparer = defaultComparer);
    return new DistinctUntilChangedObservable(this, keyFn, comparer);
  };

  var TapObservable = function (__super__) {
    inherits(TapObservable, __super__);
    function TapObservable(source, observerOrOnNext, onError, onCompleted) {
      this.source = source;
      this._oN = observerOrOnNext;
      this._oE = onError;
      this._oC = onCompleted;
      __super__.call(this);
    }

    TapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, p) {
      this.o = o;
      this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;
      this.isStopped = false;
      AbstractObserver.call(this);
    }
    InnerObserver.prototype.next = function (x) {
      var res = tryCatch(this.t.onNext).call(this.t, x);
      if (res === errorObj) {
        this.o.onError(res.e);
      }
      this.o.onNext(x);
    };
    InnerObserver.prototype.error = function (err) {
      var res = tryCatch(this.t.onError).call(this.t, err);
      if (res === errorObj) {
        return this.o.onError(res.e);
      }
      this.o.onError(err);
    };
    InnerObserver.prototype.completed = function () {
      var res = tryCatch(this.t.onCompleted).call(this.t);
      if (res === errorObj) {
        return this.o.onError(res.e);
      }
      this.o.onCompleted();
    };

    return TapObservable;
  }(ObservableBase);

  /**
  *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an o.
  * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
  * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto['do'] = observableProto.tap = observableProto.doAction = function (observerOrOnNext, onError, onCompleted) {
    return new TapObservable(this, observerOrOnNext, onError, onCompleted);
  };

  /**
  *  Invokes an action for each element in the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onNext Action to invoke for each element in the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
    return this.tap(typeof thisArg !== 'undefined' ? function (x) {
      onNext.call(thisArg, x);
    } : onNext);
  };

  /**
  *  Invokes an action upon exceptional termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {
    return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) {
      onError.call(thisArg, e);
    } : onError);
  };

  /**
  *  Invokes an action upon graceful termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {
    return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () {
      onCompleted.call(thisArg);
    } : onCompleted);
  };

  var FinallyObservable = function (__super__) {
    inherits(FinallyObservable, __super__);
    function FinallyObservable(source, fn, thisArg) {
      this.source = source;
      this._fn = bindCallback(fn, thisArg, 0);
      __super__.call(this);
    }

    FinallyObservable.prototype.subscribeCore = function (o) {
      var d = tryCatch(this.source.subscribe).call(this.source, o);
      if (d === errorObj) {
        this._fn();
        thrower(d.e);
      }

      return new FinallyDisposable(d, this._fn);
    };

    function FinallyDisposable(s, fn) {
      this.isDisposed = false;
      this._s = s;
      this._fn = fn;
    }
    FinallyDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        var res = tryCatch(this._s.dispose).call(this._s);
        this._fn();
        res === errorObj && thrower(res.e);
      }
    };

    return FinallyObservable;
  }(ObservableBase);

  /**
   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.
   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.
   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.
   */
  observableProto['finally'] = function (action, thisArg) {
    return new FinallyObservable(this, action, thisArg);
  };

  var IgnoreElementsObservable = function (__super__) {
    inherits(IgnoreElementsObservable, __super__);

    function IgnoreElementsObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    IgnoreElementsObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o));
    };

    function InnerObserver(o) {
      this.o = o;
      this.isStopped = false;
    }
    InnerObserver.prototype.onNext = noop;
    InnerObserver.prototype.onError = function (err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.o.onError(err);
      }
    };
    InnerObserver.prototype.onCompleted = function () {
      if (!this.isStopped) {
        this.isStopped = true;
        this.o.onCompleted();
      }
    };
    InnerObserver.prototype.dispose = function () {
      this.isStopped = true;
    };
    InnerObserver.prototype.fail = function (e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }

      return false;
    };

    return IgnoreElementsObservable;
  }(ObservableBase);

  /**
   *  Ignores all elements in an observable sequence leaving only the termination messages.
   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.
   */
  observableProto.ignoreElements = function () {
    return new IgnoreElementsObservable(this);
  };

  var MaterializeObservable = function (__super__) {
    inherits(MaterializeObservable, __super__);
    function MaterializeObservable(source, fn) {
      this.source = source;
      __super__.call(this);
    }

    MaterializeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new MaterializeObserver(o));
    };

    return MaterializeObservable;
  }(ObservableBase);

  var MaterializeObserver = function (__super__) {
    inherits(MaterializeObserver, __super__);

    function MaterializeObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    MaterializeObserver.prototype.next = function (x) {
      this._o.onNext(notificationCreateOnNext(x));
    };
    MaterializeObserver.prototype.error = function (e) {
      this._o.onNext(notificationCreateOnError(e));this._o.onCompleted();
    };
    MaterializeObserver.prototype.completed = function () {
      this._o.onNext(notificationCreateOnCompleted());this._o.onCompleted();
    };

    return MaterializeObserver;
  }(AbstractObserver);

  /**
   *  Materializes the implicit notifications of an observable sequence as explicit notification values.
   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.
   */
  observableProto.materialize = function () {
    return new MaterializeObservable(this);
  };

  /**
   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.
   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.
   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.
   */
  observableProto.repeat = function (repeatCount) {
    return enumerableRepeat(this, repeatCount).concat();
  };

  /**
   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.
   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
   *
   * @example
   *  var res = retried = retry.repeat();
   *  var res = retried = retry.repeat(2);
   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
   */
  observableProto.retry = function (retryCount) {
    return enumerableRepeat(this, retryCount).catchError();
  };

  function repeat(value) {
    return {
      '@@iterator': function iterator() {
        return {
          next: function next() {
            return { done: false, value: value };
          }
        };
      }
    };
  }

  var RetryWhenObservable = function (__super__) {
    function createDisposable(state) {
      return {
        isDisposed: false,
        dispose: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            state.isDisposed = true;
          }
        }
      };
    }

    function RetryWhenObservable(source, notifier) {
      this.source = source;
      this._notifier = notifier;
      __super__.call(this);
    }

    inherits(RetryWhenObservable, __super__);

    RetryWhenObservable.prototype.subscribeCore = function (o) {
      var exceptions = new Subject(),
          notifier = new Subject(),
          handled = this._notifier(exceptions),
          notificationDisposable = handled.subscribe(notifier);

      var e = this.source['@@iterator']();

      var state = { isDisposed: false },
          lastError,
          subscription = new SerialDisposable();
      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, recurse) {
        if (state.isDisposed) {
          return;
        }
        var currentItem = e.next();

        if (currentItem.done) {
          if (lastError) {
            o.onError(lastError);
          } else {
            o.onCompleted();
          }
          return;
        }

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new BinaryDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(function (x) {
          o.onNext(x);
        }, function (exn) {
          inner.setDisposable(notifier.subscribe(recurse, function (ex) {
            o.onError(ex);
          }, function () {
            o.onCompleted();
          }));

          exceptions.onNext(exn);
          outer.dispose();
        }, function () {
          o.onCompleted();
        }));
      });

      return new NAryDisposable([notificationDisposable, subscription, cancelable, createDisposable(state)]);
    };

    return RetryWhenObservable;
  }(ObservableBase);

  observableProto.retryWhen = function (notifier) {
    return new RetryWhenObservable(repeat(this), notifier);
  };

  function repeat(value) {
    return {
      '@@iterator': function iterator() {
        return {
          next: function next() {
            return { done: false, value: value };
          }
        };
      }
    };
  }

  var RepeatWhenObservable = function (__super__) {
    function createDisposable(state) {
      return {
        isDisposed: false,
        dispose: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            state.isDisposed = true;
          }
        }
      };
    }

    function RepeatWhenObservable(source, notifier) {
      this.source = source;
      this._notifier = notifier;
      __super__.call(this);
    }

    inherits(RepeatWhenObservable, __super__);

    RepeatWhenObservable.prototype.subscribeCore = function (o) {
      var completions = new Subject(),
          notifier = new Subject(),
          handled = this._notifier(completions),
          notificationDisposable = handled.subscribe(notifier);

      var e = this.source['@@iterator']();

      var state = { isDisposed: false },
          lastError,
          subscription = new SerialDisposable();
      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, recurse) {
        if (state.isDisposed) {
          return;
        }
        var currentItem = e.next();

        if (currentItem.done) {
          if (lastError) {
            o.onError(lastError);
          } else {
            o.onCompleted();
          }
          return;
        }

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new BinaryDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(function (x) {
          o.onNext(x);
        }, function (exn) {
          o.onError(exn);
        }, function () {
          inner.setDisposable(notifier.subscribe(recurse, function (ex) {
            o.onError(ex);
          }, function () {
            o.onCompleted();
          }));

          completions.onNext(null);
          outer.dispose();
        }));
      });

      return new NAryDisposable([notificationDisposable, subscription, cancelable, createDisposable(state)]);
    };

    return RepeatWhenObservable;
  }(ObservableBase);

  observableProto.repeatWhen = function (notifier) {
    return new RepeatWhenObservable(repeat(this), notifier);
  };

  var ScanObservable = function (__super__) {
    inherits(ScanObservable, __super__);
    function ScanObservable(source, accumulator, hasSeed, seed) {
      this.source = source;
      this.accumulator = accumulator;
      this.hasSeed = hasSeed;
      this.seed = seed;
      __super__.call(this);
    }

    ScanObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ScanObserver(o, this));
    };

    return ScanObservable;
  }(ObservableBase);

  var ScanObserver = function (__super__) {
    inherits(ScanObserver, __super__);
    function ScanObserver(o, parent) {
      this._o = o;
      this._p = parent;
      this._fn = parent.accumulator;
      this._hs = parent.hasSeed;
      this._s = parent.seed;
      this._ha = false;
      this._a = null;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    ScanObserver.prototype.next = function (x) {
      !this._hv && (this._hv = true);
      if (this._ha) {
        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);
      } else {
        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;
        this._ha = true;
      }
      if (this._a === errorObj) {
        return this._o.onError(this._a.e);
      }
      this._o.onNext(this._a);
      this._i++;
    };

    ScanObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ScanObserver.prototype.completed = function () {
      !this._hv && this._hs && this._o.onNext(this._s);
      this._o.onCompleted();
    };

    return ScanObserver;
  }(AbstractObserver);

  /**
  *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
  *  For aggregation behavior with no intermediate results, see Observable.aggregate.
  * @param {Mixed} [seed] The initial accumulator value.
  * @param {Function} accumulator An accumulator function to be invoked on each element.
  * @returns {Observable} An observable sequence containing the accumulated values.
  */
  observableProto.scan = function () {
    var hasSeed = false,
        seed,
        accumulator = arguments[0];
    if (arguments.length === 2) {
      hasSeed = true;
      seed = arguments[1];
    }
    return new ScanObservable(this, accumulator, hasSeed, seed);
  };

  var SkipLastObservable = function (__super__) {
    inherits(SkipLastObservable, __super__);
    function SkipLastObservable(source, c) {
      this.source = source;
      this._c = c;
      __super__.call(this);
    }

    SkipLastObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipLastObserver(o, this._c));
    };

    return SkipLastObservable;
  }(ObservableBase);

  var SkipLastObserver = function (__super__) {
    inherits(SkipLastObserver, __super__);
    function SkipLastObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    SkipLastObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._o.onNext(this._q.shift());
    };

    SkipLastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    SkipLastObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipLastObserver;
  }(AbstractObserver);

  /**
   *  Bypasses a specified number of elements at the end of an observable sequence.
   * @description
   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are
   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.
   * @param count Number of elements to bypass at the end of the source sequence.
   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.
   */
  observableProto.skipLast = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new SkipLastObservable(this, count);
  };

  /**
   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.
   *  @example
   *  var res = source.startWith(1, 2, 3);
   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);
   * @param {Arguments} args The specified values to prepend to the observable sequence
   * @returns {Observable} The source sequence prepended with the specified values.
   */
  observableProto.startWith = function () {
    var values,
        scheduler,
        start = 0;
    if (!!arguments.length && isScheduler(arguments[0])) {
      scheduler = arguments[0];
      start = 1;
    } else {
      scheduler = immediateScheduler;
    }
    for (var args = [], i = start, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    return observableConcat.apply(null, [observableFromArray(args, scheduler), this]);
  };

  var TakeLastObserver = function (__super__) {
    inherits(TakeLastObserver, __super__);
    function TakeLastObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    TakeLastObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._q.shift();
    };

    TakeLastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TakeLastObserver.prototype.completed = function () {
      while (this._q.length > 0) {
        this._o.onNext(this._q.shift());
      }
      this._o.onCompleted();
    };

    return TakeLastObserver;
  }(AbstractObserver);

  /**
   *  Returns a specified number of contiguous elements from the end of an observable sequence.
   * @description
   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of
   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
   * @param {Number} count Number of elements to take from the end of the source sequence.
   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLast = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      return source.subscribe(new TakeLastObserver(o, count));
    }, source);
  };

  var TakeLastBufferObserver = function (__super__) {
    inherits(TakeLastBufferObserver, __super__);
    function TakeLastBufferObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    TakeLastBufferObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._q.shift();
    };

    TakeLastBufferObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TakeLastBufferObserver.prototype.completed = function () {
      this._o.onNext(this._q);
      this._o.onCompleted();
    };

    return TakeLastBufferObserver;
  }(AbstractObserver);

  /**
   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.
   *
   * @description
   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the
   *  source sequence, this buffer is produced on the result sequence.
   * @param {Number} count Number of elements to take from the end of the source sequence.
   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLastBuffer = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      return source.subscribe(new TakeLastBufferObserver(o, count));
    }, source);
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
   * @param {Number} count Length of each window.
   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithCount = observableProto.windowCount = function (count, skip) {
    var source = this;
    +count || (count = 0);
    Math.abs(count) === Infinity && (count = 0);
    if (count <= 0) {
      throw new ArgumentOutOfRangeError();
    }
    skip == null && (skip = count);
    +skip || (skip = 0);
    Math.abs(skip) === Infinity && (skip = 0);

    if (skip <= 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new AnonymousObservable(function (observer) {
      var m = new SingleAssignmentDisposable(),
          refCountDisposable = new RefCountDisposable(m),
          n = 0,
          q = [];

      function createWindow() {
        var s = new Subject();
        q.push(s);
        observer.onNext(addRef(s, refCountDisposable));
      }

      createWindow();

      m.setDisposable(source.subscribe(function (x) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onNext(x);
        }
        var c = n - count + 1;
        c >= 0 && c % skip === 0 && q.shift().onCompleted();
        ++n % skip === 0 && createWindow();
      }, function (e) {
        while (q.length > 0) {
          q.shift().onError(e);
        }
        observer.onError(e);
      }, function () {
        while (q.length > 0) {
          q.shift().onCompleted();
        }
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  function concatMap(source, selector, thisArg) {
    var selectorFunc = bindCallback(selector, thisArg, 3);
    return source.map(function (x, i) {
      var result = selectorFunc(x, i, source);
      isPromise(result) && (result = observableFromPromise(result));
      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
      return result;
    }).concatAll();
  }

  /**
   *  One of the Following:
   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   *
   * @example
   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });
   *  Or:
   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
   *
   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
   *  Or:
   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
   *
   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));
   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the
   * source sequence onto which could be either an observable or Promise.
   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
   */
  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {
    if (isFunction(selector) && isFunction(resultSelector)) {
      return this.concatMap(function (x, i) {
        var selectorResult = selector(x, i);
        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));

        return selectorResult.map(function (y, i2) {
          return resultSelector(x, y, i, i2);
        });
      });
    }
    return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function () {
      return selector;
    });
  };

  /**
   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.
   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
   */
  observableProto.concatMapObserver = observableProto.selectConcatObserver = function (onNext, onError, onCompleted, thisArg) {
    var source = this,
        onNextFunc = bindCallback(onNext, thisArg, 2),
        onErrorFunc = bindCallback(onError, thisArg, 1),
        onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
    return new AnonymousObservable(function (observer) {
      var index = 0;
      return source.subscribe(function (x) {
        var result;
        try {
          result = onNextFunc(x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
      }, function (err) {
        var result;
        try {
          result = onErrorFunc(err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      }, function () {
        var result;
        try {
          result = onCompletedFunc();
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
    }, this).concatAll();
  };

  var DefaultIfEmptyObserver = function (__super__) {
    inherits(DefaultIfEmptyObserver, __super__);
    function DefaultIfEmptyObserver(o, d) {
      this._o = o;
      this._d = d;
      this._f = false;
      __super__.call(this);
    }

    DefaultIfEmptyObserver.prototype.next = function (x) {
      this._f = true;
      this._o.onNext(x);
    };

    DefaultIfEmptyObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    DefaultIfEmptyObserver.prototype.completed = function () {
      !this._f && this._o.onNext(this._d);
      this._o.onCompleted();
    };

    return DefaultIfEmptyObserver;
  }(AbstractObserver);

  /**
   *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
   *
   *  var res = obs = xs.defaultIfEmpty();
   *  2 - obs = xs.defaultIfEmpty(false);
   *
   * @memberOf Observable#
   * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
   * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
   */
  observableProto.defaultIfEmpty = function (defaultValue) {
    var source = this;
    defaultValue === undefined && (defaultValue = null);
    return new AnonymousObservable(function (o) {
      return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));
    }, source);
  };

  // Swap out for Array.findIndex
  function arrayIndexOfComparer(array, item, comparer) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (comparer(array[i], item)) {
        return i;
      }
    }
    return -1;
  }

  function HashSet(comparer) {
    this.comparer = comparer;
    this.set = [];
  }
  HashSet.prototype.push = function (value) {
    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
    retValue && this.set.push(value);
    return retValue;
  };

  var DistinctObservable = function (__super__) {
    inherits(DistinctObservable, __super__);
    function DistinctObservable(source, keyFn, cmpFn) {
      this.source = source;
      this._keyFn = keyFn;
      this._cmpFn = cmpFn;
      __super__.call(this);
    }

    DistinctObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DistinctObserver(o, this._keyFn, this._cmpFn));
    };

    return DistinctObservable;
  }(ObservableBase);

  var DistinctObserver = function (__super__) {
    inherits(DistinctObserver, __super__);
    function DistinctObserver(o, keyFn, cmpFn) {
      this._o = o;
      this._keyFn = keyFn;
      this._h = new HashSet(cmpFn);
      __super__.call(this);
    }

    DistinctObserver.prototype.next = function (x) {
      var key = x;
      if (isFunction(this._keyFn)) {
        key = tryCatch(this._keyFn)(x);
        if (key === errorObj) {
          return this._o.onError(key.e);
        }
      }
      this._h.push(key) && this._o.onNext(x);
    };

    DistinctObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    DistinctObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return DistinctObserver;
  }(AbstractObserver);

  /**
   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.
   *
   * @example
   *  var res = obs = xs.distinct();
   *  2 - obs = xs.distinct(function (x) { return x.id; });
   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });
   * @param {Function} [keySelector]  A function to compute the comparison key for each element.
   * @param {Function} [comparer]  Used to compare items in the collection.
   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
   */
  observableProto.distinct = function (keySelector, comparer) {
    comparer || (comparer = defaultComparer);
    return new DistinctObservable(this, keySelector, comparer);
  };

  /**
   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
   *
   * @example
   *  var res = observable.groupBy(function (x) { return x.id; });
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   */
  observableProto.groupBy = function (keySelector, elementSelector) {
    return this.groupByUntil(keySelector, elementSelector, observableNever);
  };

  /**
   *  Groups the elements of an observable sequence according to a specified key selector function.
   *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
   *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
   *
   * @example
   *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} durationSelector A function to signal the expiration of a group.
   * @returns {Observable}
   *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
   *
   */
  observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var map = new Map(),
          groupDisposable = new CompositeDisposable(),
          refCountDisposable = new RefCountDisposable(groupDisposable),
          handleError = function handleError(e) {
        return function (item) {
          item.onError(e);
        };
      };

      groupDisposable.add(source.subscribe(function (x) {
        var key = tryCatch(keySelector)(x);
        if (key === errorObj) {
          map.forEach(handleError(key.e));
          return o.onError(key.e);
        }

        var fireNewMapEntry = false,
            writer = map.get(key);
        if (writer === undefined) {
          writer = new Subject();
          map.set(key, writer);
          fireNewMapEntry = true;
        }

        if (fireNewMapEntry) {
          var group = new GroupedObservable(key, writer, refCountDisposable),
              durationGroup = new GroupedObservable(key, writer);
          var duration = tryCatch(durationSelector)(durationGroup);
          if (duration === errorObj) {
            map.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }

          o.onNext(group);

          var md = new SingleAssignmentDisposable();
          groupDisposable.add(md);

          md.setDisposable(duration.take(1).subscribe(noop, function (e) {
            map.forEach(handleError(e));
            o.onError(e);
          }, function () {
            if (map['delete'](key)) {
              writer.onCompleted();
            }
            groupDisposable.remove(md);
          }));
        }

        var element = x;
        if (isFunction(elementSelector)) {
          element = tryCatch(elementSelector)(x);
          if (element === errorObj) {
            map.forEach(handleError(element.e));
            return o.onError(element.e);
          }
        }

        writer.onNext(element);
      }, function (e) {
        map.forEach(handleError(e));
        o.onError(e);
      }, function () {
        map.forEach(function (item) {
          item.onCompleted();
        });
        o.onCompleted();
      }));

      return refCountDisposable;
    }, source);
  };

  var MapObservable = function (__super__) {
    inherits(MapObservable, __super__);

    function MapObservable(source, selector, thisArg) {
      this.source = source;
      this.selector = bindCallback(selector, thisArg, 3);
      __super__.call(this);
    }

    function innerMap(selector, self) {
      return function (x, i, o) {
        return selector.call(this, self.selector(x, i, o), i, o);
      };
    }

    MapObservable.prototype.internalMap = function (selector, thisArg) {
      return new MapObservable(this.source, innerMap(selector, this), thisArg);
    };

    MapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.selector, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, selector, source) {
      this.o = o;
      this.selector = selector;
      this.source = source;
      this.i = 0;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      var result = tryCatch(this.selector)(x, this.i++, this.source);
      if (result === errorObj) {
        return this.o.onError(result.e);
      }
      this.o.onNext(result);
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return MapObservable;
  }(ObservableBase);

  /**
  * Projects each element of an observable sequence into a new form by incorporating the element's index.
  * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.
  */
  observableProto.map = observableProto.select = function (selector, thisArg) {
    var selectorFn = typeof selector === 'function' ? selector : function () {
      return selector;
    };
    return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
  };

  function plucker(args, len) {
    return function mapper(x) {
      var currentProp = x;
      for (var i = 0; i < len; i++) {
        var p = currentProp[args[i]];
        if (typeof p !== 'undefined') {
          currentProp = p;
        } else {
          return undefined;
        }
      }
      return currentProp;
    };
  }

  /**
   * Retrieves the value of a specified nested property from all elements in
   * the Observable sequence.
   * @param {Arguments} arguments The nested properties to pluck.
   * @returns {Observable} Returns a new Observable sequence of property values.
   */
  observableProto.pluck = function () {
    var len = arguments.length,
        args = new Array(len);
    if (len === 0) {
      throw new Error('List of properties cannot be empty.');
    }
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return this.map(plucker(args, len));
  };

  observableProto.flatMap = observableProto.selectMany = observableProto.mergeMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
  };

  /**
   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
   */
  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var index = 0;

      return source.subscribe(function (x) {
        var result;
        try {
          result = onNext.call(thisArg, x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
      }, function (err) {
        var result;
        try {
          result = onError.call(thisArg, err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      }, function () {
        var result;
        try {
          result = onCompleted.call(thisArg);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
    }, source).mergeAll();
  };

  observableProto.flatMapLatest = observableProto.switchMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
  };

  var SkipObservable = function (__super__) {
    inherits(SkipObservable, __super__);
    function SkipObservable(source, count) {
      this.source = source;
      this._count = count;
      __super__.call(this);
    }

    SkipObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipObserver(o, this._count));
    };

    function SkipObserver(o, c) {
      this._o = o;
      this._r = c;
      AbstractObserver.call(this);
    }

    inherits(SkipObserver, AbstractObserver);

    SkipObserver.prototype.next = function (x) {
      if (this._r <= 0) {
        this._o.onNext(x);
      } else {
        this._r--;
      }
    };
    SkipObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipObservable;
  }(ObservableBase);

  /**
   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
   * @param {Number} count The number of elements to skip before returning the remaining elements.
   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.
   */
  observableProto.skip = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new SkipObservable(this, count);
  };

  var SkipWhileObservable = function (__super__) {
    inherits(SkipWhileObservable, __super__);
    function SkipWhileObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SkipWhileObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipWhileObserver(o, this));
    };

    return SkipWhileObservable;
  }(ObservableBase);

  var SkipWhileObserver = function (__super__) {
    inherits(SkipWhileObserver, __super__);

    function SkipWhileObserver(o, p) {
      this._o = o;
      this._p = p;
      this._i = 0;
      this._r = false;
      __super__.call(this);
    }

    SkipWhileObserver.prototype.next = function (x) {
      if (!this._r) {
        var res = tryCatch(this._p._fn)(x, this._i++, this._p);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._r = !res;
      }
      this._r && this._o.onNext(x);
    };
    SkipWhileObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipWhileObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipWhileObserver;
  }(AbstractObserver);

  /**
   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
   *  The element's index is used in the logic of the predicate function.
   *
   *  var res = source.skipWhile(function (value) { return value < 10; });
   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });
   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
   */
  observableProto.skipWhile = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new SkipWhileObservable(this, fn);
  };

  var TakeObservable = function (__super__) {
    inherits(TakeObservable, __super__);
    function TakeObservable(source, count) {
      this.source = source;
      this._count = count;
      __super__.call(this);
    }

    TakeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeObserver(o, this._count));
    };

    function TakeObserver(o, c) {
      this._o = o;
      this._c = c;
      this._r = c;
      AbstractObserver.call(this);
    }

    inherits(TakeObserver, AbstractObserver);

    TakeObserver.prototype.next = function (x) {
      if (this._r-- > 0) {
        this._o.onNext(x);
        this._r <= 0 && this._o.onCompleted();
      }
    };

    TakeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TakeObservable;
  }(ObservableBase);

  /**
   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).
   * @param {Number} count The number of elements to return.
   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name="count count</paramref> is set to 0.
   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.
   */
  observableProto.take = function (count, scheduler) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    if (count === 0) {
      return observableEmpty(scheduler);
    }
    return new TakeObservable(this, count);
  };

  var TakeWhileObservable = function (__super__) {
    inherits(TakeWhileObservable, __super__);
    function TakeWhileObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    TakeWhileObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeWhileObserver(o, this));
    };

    return TakeWhileObservable;
  }(ObservableBase);

  var TakeWhileObserver = function (__super__) {
    inherits(TakeWhileObserver, __super__);

    function TakeWhileObserver(o, p) {
      this._o = o;
      this._p = p;
      this._i = 0;
      this._r = true;
      __super__.call(this);
    }

    TakeWhileObserver.prototype.next = function (x) {
      if (this._r) {
        this._r = tryCatch(this._p._fn)(x, this._i++, this._p);
        if (this._r === errorObj) {
          return this._o.onError(this._r.e);
        }
      }
      if (this._r) {
        this._o.onNext(x);
      } else {
        this._o.onCompleted();
      }
    };
    TakeWhileObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeWhileObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TakeWhileObserver;
  }(AbstractObserver);

  /**
   *  Returns elements from an observable sequence as long as a specified condition is true.
   *  The element's index is used in the logic of the predicate function.
   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   */
  observableProto.takeWhile = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new TakeWhileObservable(this, fn);
  };

  var FilterObservable = function (__super__) {
    inherits(FilterObservable, __super__);

    function FilterObservable(source, predicate, thisArg) {
      this.source = source;
      this.predicate = bindCallback(predicate, thisArg, 3);
      __super__.call(this);
    }

    FilterObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.predicate, this));
    };

    function innerPredicate(predicate, self) {
      return function (x, i, o) {
        return self.predicate(x, i, o) && predicate.call(this, x, i, o);
      };
    }

    FilterObservable.prototype.internalFilter = function (predicate, thisArg) {
      return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, predicate, source) {
      this.o = o;
      this.predicate = predicate;
      this.source = source;
      this.i = 0;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
      if (shouldYield === errorObj) {
        return this.o.onError(shouldYield.e);
      }
      shouldYield && this.o.onNext(x);
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return FilterObservable;
  }(ObservableBase);

  /**
  *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
  * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.
  */
  observableProto.filter = observableProto.where = function (predicate, thisArg) {
    return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
  };

  var ExtremaByObservable = function (__super__) {
    inherits(ExtremaByObservable, __super__);
    function ExtremaByObservable(source, k, c) {
      this.source = source;
      this._k = k;
      this._c = c;
      __super__.call(this);
    }

    ExtremaByObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ExtremaByObserver(o, this._k, this._c));
    };

    return ExtremaByObservable;
  }(ObservableBase);

  var ExtremaByObserver = function (__super__) {
    inherits(ExtremaByObserver, __super__);
    function ExtremaByObserver(o, k, c) {
      this._o = o;
      this._k = k;
      this._c = c;
      this._v = null;
      this._hv = false;
      this._l = [];
      __super__.call(this);
    }

    ExtremaByObserver.prototype.next = function (x) {
      var key = tryCatch(this._k)(x);
      if (key === errorObj) {
        return this._o.onError(key.e);
      }
      var comparison = 0;
      if (!this._hv) {
        this._hv = true;
        this._v = key;
      } else {
        comparison = tryCatch(this._c)(key, this._v);
        if (comparison === errorObj) {
          return this._o.onError(comparison.e);
        }
      }
      if (comparison > 0) {
        this._v = key;
        this._l = [];
      }
      if (comparison >= 0) {
        this._l.push(x);
      }
    };

    ExtremaByObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ExtremaByObserver.prototype.completed = function () {
      this._o.onNext(this._l);
      this._o.onCompleted();
    };

    return ExtremaByObserver;
  }(AbstractObserver);

  function firstOnly(x) {
    if (x.length === 0) {
      throw new EmptyError();
    }
    return x[0];
  }

  var ReduceObservable = function (__super__) {
    inherits(ReduceObservable, __super__);
    function ReduceObservable(source, accumulator, hasSeed, seed) {
      this.source = source;
      this.accumulator = accumulator;
      this.hasSeed = hasSeed;
      this.seed = seed;
      __super__.call(this);
    }

    ReduceObservable.prototype.subscribeCore = function (observer) {
      return this.source.subscribe(new ReduceObserver(observer, this));
    };

    return ReduceObservable;
  }(ObservableBase);

  var ReduceObserver = function (__super__) {
    inherits(ReduceObserver, __super__);
    function ReduceObserver(o, parent) {
      this._o = o;
      this._p = parent;
      this._fn = parent.accumulator;
      this._hs = parent.hasSeed;
      this._s = parent.seed;
      this._ha = false;
      this._a = null;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    ReduceObserver.prototype.next = function (x) {
      !this._hv && (this._hv = true);
      if (this._ha) {
        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);
      } else {
        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;
        this._ha = true;
      }
      if (this._a === errorObj) {
        return this._o.onError(this._a.e);
      }
      this._i++;
    };

    ReduceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ReduceObserver.prototype.completed = function () {
      this._hv && this._o.onNext(this._a);
      !this._hv && this._hs && this._o.onNext(this._s);
      !this._hv && !this._hs && this._o.onError(new EmptyError());
      this._o.onCompleted();
    };

    return ReduceObserver;
  }(AbstractObserver);

  /**
  * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
  * For aggregation behavior with incremental intermediate results, see Observable.scan.
  * @param {Function} accumulator An accumulator function to be invoked on each element.
  * @param {Any} [seed] The initial accumulator value.
  * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
  */
  observableProto.reduce = function () {
    var hasSeed = false,
        seed,
        accumulator = arguments[0];
    if (arguments.length === 2) {
      hasSeed = true;
      seed = arguments[1];
    }
    return new ReduceObservable(this, accumulator, hasSeed, seed);
  };

  var SomeObservable = function (__super__) {
    inherits(SomeObservable, __super__);
    function SomeObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SomeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SomeObserver(o, this._fn, this.source));
    };

    return SomeObservable;
  }(ObservableBase);

  var SomeObserver = function (__super__) {
    inherits(SomeObserver, __super__);

    function SomeObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    SomeObserver.prototype.next = function (x) {
      var result = tryCatch(this._fn)(x, this._i++, this._s);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      if (Boolean(result)) {
        this._o.onNext(true);
        this._o.onCompleted();
      }
    };
    SomeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SomeObserver.prototype.completed = function () {
      this._o.onNext(false);
      this._o.onCompleted();
    };

    return SomeObserver;
  }(AbstractObserver);

  /**
   * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.
   * @param {Function} [predicate] A function to test each element for a condition.
   * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.
   */
  observableProto.some = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new SomeObservable(this, fn);
  };

  var IsEmptyObservable = function (__super__) {
    inherits(IsEmptyObservable, __super__);
    function IsEmptyObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    IsEmptyObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new IsEmptyObserver(o));
    };

    return IsEmptyObservable;
  }(ObservableBase);

  var IsEmptyObserver = function (__super__) {
    inherits(IsEmptyObserver, __super__);
    function IsEmptyObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    IsEmptyObserver.prototype.next = function () {
      this._o.onNext(false);
      this._o.onCompleted();
    };
    IsEmptyObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IsEmptyObserver.prototype.completed = function () {
      this._o.onNext(true);
      this._o.onCompleted();
    };

    return IsEmptyObserver;
  }(AbstractObserver);

  /**
   * Determines whether an observable sequence is empty.
   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.
   */
  observableProto.isEmpty = function () {
    return new IsEmptyObservable(this);
  };

  var EveryObservable = function (__super__) {
    inherits(EveryObservable, __super__);
    function EveryObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    EveryObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new EveryObserver(o, this._fn, this.source));
    };

    return EveryObservable;
  }(ObservableBase);

  var EveryObserver = function (__super__) {
    inherits(EveryObserver, __super__);

    function EveryObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    EveryObserver.prototype.next = function (x) {
      var result = tryCatch(this._fn)(x, this._i++, this._s);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      if (!Boolean(result)) {
        this._o.onNext(false);
        this._o.onCompleted();
      }
    };
    EveryObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    EveryObserver.prototype.completed = function () {
      this._o.onNext(true);
      this._o.onCompleted();
    };

    return EveryObserver;
  }(AbstractObserver);

  /**
   * Determines whether all elements of an observable sequence satisfy a condition.
   * @param {Function} [predicate] A function to test each element for a condition.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.
   */
  observableProto.every = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new EveryObservable(this, fn);
  };

  var IncludesObservable = function (__super__) {
    inherits(IncludesObservable, __super__);
    function IncludesObservable(source, elem, idx) {
      var n = +idx || 0;
      Math.abs(n) === Infinity && (n = 0);

      this.source = source;
      this._elem = elem;
      this._n = n;
      __super__.call(this);
    }

    IncludesObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(false);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new IncludesObserver(o, this._elem, this._n));
    };

    return IncludesObservable;
  }(ObservableBase);

  var IncludesObserver = function (__super__) {
    inherits(IncludesObserver, __super__);
    function IncludesObserver(o, elem, n) {
      this._o = o;
      this._elem = elem;
      this._n = n;
      this._i = 0;
      __super__.call(this);
    }

    function comparer(a, b) {
      return a === 0 && b === 0 || a === b || isNaN(a) && isNaN(b);
    }

    IncludesObserver.prototype.next = function (x) {
      if (this._i++ >= this._n && comparer(x, this._elem)) {
        this._o.onNext(true);
        this._o.onCompleted();
      }
    };
    IncludesObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IncludesObserver.prototype.completed = function () {
      this._o.onNext(false);this._o.onCompleted();
    };

    return IncludesObserver;
  }(AbstractObserver);

  /**
   * Determines whether an observable sequence includes a specified element with an optional equality comparer.
   * @param searchElement The value to locate in the source sequence.
   * @param {Number} [fromIndex] An equality comparer to compare elements.
   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence includes an element that has the specified value from the given index.
   */
  observableProto.includes = function (searchElement, fromIndex) {
    return new IncludesObservable(this, searchElement, fromIndex);
  };

  var CountObservable = function (__super__) {
    inherits(CountObservable, __super__);
    function CountObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    CountObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new CountObserver(o, this._fn, this.source));
    };

    return CountObservable;
  }(ObservableBase);

  var CountObserver = function (__super__) {
    inherits(CountObserver, __super__);

    function CountObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      this._c = 0;
      __super__.call(this);
    }

    CountObserver.prototype.next = function (x) {
      if (this._fn) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        Boolean(result) && this._c++;
      } else {
        this._c++;
      }
    };
    CountObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    CountObserver.prototype.completed = function () {
      this._o.onNext(this._c);
      this._o.onCompleted();
    };

    return CountObserver;
  }(AbstractObserver);

  /**
   * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.
   * @example
   * res = source.count();
   * res = source.count(function (x) { return x > 3; });
   * @param {Function} [predicate]A function to test each element for a condition.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.
   */
  observableProto.count = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new CountObservable(this, fn);
  };

  var IndexOfObservable = function (__super__) {
    inherits(IndexOfObservable, __super__);
    function IndexOfObservable(source, e, n) {
      this.source = source;
      this._e = e;
      this._n = n;
      __super__.call(this);
    }

    IndexOfObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(-1);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new IndexOfObserver(o, this._e, this._n));
    };

    return IndexOfObservable;
  }(ObservableBase);

  var IndexOfObserver = function (__super__) {
    inherits(IndexOfObserver, __super__);
    function IndexOfObserver(o, e, n) {
      this._o = o;
      this._e = e;
      this._n = n;
      this._i = 0;
      __super__.call(this);
    }

    IndexOfObserver.prototype.next = function (x) {
      if (this._i >= this._n && x === this._e) {
        this._o.onNext(this._i);
        this._o.onCompleted();
      }
      this._i++;
    };
    IndexOfObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IndexOfObserver.prototype.completed = function () {
      this._o.onNext(-1);this._o.onCompleted();
    };

    return IndexOfObserver;
  }(AbstractObserver);

  /**
   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
   * @param {Any} searchElement Element to locate in the array.
   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
   */
  observableProto.indexOf = function (searchElement, fromIndex) {
    var n = +fromIndex || 0;
    Math.abs(n) === Infinity && (n = 0);
    return new IndexOfObservable(this, searchElement, n);
  };

  var SumObservable = function (__super__) {
    inherits(SumObservable, __super__);
    function SumObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SumObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SumObserver(o, this._fn, this.source));
    };

    return SumObservable;
  }(ObservableBase);

  var SumObserver = function (__super__) {
    inherits(SumObserver, __super__);

    function SumObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      this._c = 0;
      __super__.call(this);
    }

    SumObserver.prototype.next = function (x) {
      if (this._fn) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        this._c += result;
      } else {
        this._c += x;
      }
    };
    SumObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SumObserver.prototype.completed = function () {
      this._o.onNext(this._c);
      this._o.onCompleted();
    };

    return SumObserver;
  }(AbstractObserver);

  /**
   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.
   * @param {Function} [selector] A transform function to apply to each element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.
   */
  observableProto.sum = function (keySelector, thisArg) {
    var fn = bindCallback(keySelector, thisArg, 3);
    return new SumObservable(this, fn);
  };

  /**
   * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
   * @example
   * var res = source.minBy(function (x) { return x.value; });
   * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });
   * @param {Function} keySelector Key selector function.
   * @param {Function} [comparer] Comparer used to compare key values.
   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.
   */
  observableProto.minBy = function (keySelector, comparer) {
    comparer || (comparer = defaultSubComparer);
    return new ExtremaByObservable(this, keySelector, function (x, y) {
      return comparer(x, y) * -1;
    });
  };

  /**
   * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.
   * @example
   * var res = source.min();
   * var res = source.min(function (x, y) { return x.value - y.value; });
   * @param {Function} [comparer] Comparer used to compare elements.
   * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.
   */
  observableProto.min = function (comparer) {
    return this.minBy(identity, comparer).map(firstOnly);
  };

  /**
   * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.
   * @example
   * var res = source.maxBy(function (x) { return x.value; });
   * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });
   * @param {Function} keySelector Key selector function.
   * @param {Function} [comparer]  Comparer used to compare key values.
   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.
   */
  observableProto.maxBy = function (keySelector, comparer) {
    comparer || (comparer = defaultSubComparer);
    return new ExtremaByObservable(this, keySelector, comparer);
  };

  /**
   * Returns the maximum value in an observable sequence according to the specified comparer.
   * @example
   * var res = source.max();
   * var res = source.max(function (x, y) { return x.value - y.value; });
   * @param {Function} [comparer] Comparer used to compare elements.
   * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.
   */
  observableProto.max = function (comparer) {
    return this.maxBy(identity, comparer).map(firstOnly);
  };

  var AverageObservable = function (__super__) {
    inherits(AverageObservable, __super__);
    function AverageObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    AverageObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new AverageObserver(o, this._fn, this.source));
    };

    return AverageObservable;
  }(ObservableBase);

  var AverageObserver = function (__super__) {
    inherits(AverageObserver, __super__);
    function AverageObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._c = 0;
      this._t = 0;
      __super__.call(this);
    }

    AverageObserver.prototype.next = function (x) {
      if (this._fn) {
        var r = tryCatch(this._fn)(x, this._c++, this._s);
        if (r === errorObj) {
          return this._o.onError(r.e);
        }
        this._t += r;
      } else {
        this._c++;
        this._t += x;
      }
    };
    AverageObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    AverageObserver.prototype.completed = function () {
      if (this._c === 0) {
        return this._o.onError(new EmptyError());
      }
      this._o.onNext(this._t / this._c);
      this._o.onCompleted();
    };

    return AverageObserver;
  }(AbstractObserver);

  /**
   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.
   * @param {Function} [selector] A transform function to apply to each element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.
   */
  observableProto.average = function (keySelector, thisArg) {
    var source = this,
        fn;
    if (isFunction(keySelector)) {
      fn = bindCallback(keySelector, thisArg, 3);
    }
    return new AverageObservable(source, fn);
  };

  /**
   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
   *
   * @example
   * var res = res = source.sequenceEqual([1,2,3]);
   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });
   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));
   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });
   * @param {Observable} second Second observable sequence or array to compare.
   * @param {Function} [comparer] Comparer used to compare elements of both sequences.
   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
   */
  observableProto.sequenceEqual = function (second, comparer) {
    var first = this;
    comparer || (comparer = defaultComparer);
    return new AnonymousObservable(function (o) {
      var donel = false,
          doner = false,
          ql = [],
          qr = [];
      var subscription1 = first.subscribe(function (x) {
        if (qr.length > 0) {
          var v = qr.shift();
          var equal = tryCatch(comparer)(v, x);
          if (equal === errorObj) {
            return o.onError(equal.e);
          }
          if (!equal) {
            o.onNext(false);
            o.onCompleted();
          }
        } else if (doner) {
          o.onNext(false);
          o.onCompleted();
        } else {
          ql.push(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        donel = true;
        if (ql.length === 0) {
          if (qr.length > 0) {
            o.onNext(false);
            o.onCompleted();
          } else if (doner) {
            o.onNext(true);
            o.onCompleted();
          }
        }
      });

      (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
      isPromise(second) && (second = observableFromPromise(second));
      var subscription2 = second.subscribe(function (x) {
        if (ql.length > 0) {
          var v = ql.shift();
          var equal = tryCatch(comparer)(v, x);
          if (equal === errorObj) {
            return o.onError(equal.e);
          }
          if (!equal) {
            o.onNext(false);
            o.onCompleted();
          }
        } else if (donel) {
          o.onNext(false);
          o.onCompleted();
        } else {
          qr.push(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        doner = true;
        if (qr.length === 0) {
          if (ql.length > 0) {
            o.onNext(false);
            o.onCompleted();
          } else if (donel) {
            o.onNext(true);
            o.onCompleted();
          }
        }
      });
      return new BinaryDisposable(subscription1, subscription2);
    }, first);
  };

  var ElementAtObservable = function (__super__) {
    inherits(ElementAtObservable, __super__);
    function ElementAtObservable(source, i, d) {
      this.source = source;
      this._i = i;
      this._d = d;
      __super__.call(this);
    }

    ElementAtObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ElementAtObserver(o, this._i, this._d));
    };

    return ElementAtObservable;
  }(ObservableBase);

  var ElementAtObserver = function (__super__) {
    inherits(ElementAtObserver, __super__);

    function ElementAtObserver(o, i, d) {
      this._o = o;
      this._i = i;
      this._d = d;
      __super__.call(this);
    }

    ElementAtObserver.prototype.next = function (x) {
      if (this._i-- === 0) {
        this._o.onNext(x);
        this._o.onCompleted();
      }
    };
    ElementAtObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    ElementAtObserver.prototype.completed = function () {
      if (this._d === undefined) {
        this._o.onError(new ArgumentOutOfRangeError());
      } else {
        this._o.onNext(this._d);
        this._o.onCompleted();
      }
    };

    return ElementAtObserver;
  }(AbstractObserver);

  /**
   * Returns the element at a specified index in a sequence or default value if not found.
   * @param {Number} index The zero-based index of the element to retrieve.
   * @param {Any} [defaultValue] The default value to use if elementAt does not find a value.
   * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.
   */
  observableProto.elementAt = function (index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new ElementAtObservable(this, index, defaultValue);
  };

  var SingleObserver = function (__super__) {
    inherits(SingleObserver, __super__);
    function SingleObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      this._hv = false;
      this._v = null;
      __super__.call(this);
    }

    SingleObserver.prototype.next = function (x) {
      var shouldYield = false;
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        Boolean(res) && (shouldYield = true);
      } else if (!this._obj.predicate) {
        shouldYield = true;
      }
      if (shouldYield) {
        if (this._hv) {
          return this._o.onError(new Error('Sequence contains more than one matching element'));
        }
        this._hv = true;
        this._v = x;
      }
    };
    SingleObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SingleObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
        this._o.onCompleted();
      } else if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return SingleObserver;
  }(AbstractObserver);

  /**
   * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.
   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.
   */
  observableProto.single = function (predicate, thisArg) {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new AnonymousObservable(function (o) {
      return source.subscribe(new SingleObserver(o, obj, source));
    }, source);
  };

  var FirstObservable = function (__super__) {
    inherits(FirstObservable, __super__);
    function FirstObservable(source, obj) {
      this.source = source;
      this._obj = obj;
      __super__.call(this);
    }

    FirstObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new FirstObserver(o, this._obj, this.source));
    };

    return FirstObservable;
  }(ObservableBase);

  var FirstObserver = function (__super__) {
    inherits(FirstObserver, __super__);
    function FirstObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    FirstObserver.prototype.next = function (x) {
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        if (Boolean(res)) {
          this._o.onNext(x);
          this._o.onCompleted();
        }
      } else if (!this._obj.predicate) {
        this._o.onNext(x);
        this._o.onCompleted();
      }
    };
    FirstObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    FirstObserver.prototype.completed = function () {
      if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return FirstObserver;
  }(AbstractObserver);

  /**
   * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.
   * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.
   */
  observableProto.first = function () {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new FirstObservable(this, obj);
  };

  var LastObservable = function (__super__) {
    inherits(LastObservable, __super__);
    function LastObservable(source, obj) {
      this.source = source;
      this._obj = obj;
      __super__.call(this);
    }

    LastObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new LastObserver(o, this._obj, this.source));
    };

    return LastObservable;
  }(ObservableBase);

  var LastObserver = function (__super__) {
    inherits(LastObserver, __super__);
    function LastObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      this._hv = false;
      this._v = null;
      __super__.call(this);
    }

    LastObserver.prototype.next = function (x) {
      var shouldYield = false;
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        Boolean(res) && (shouldYield = true);
      } else if (!this._obj.predicate) {
        shouldYield = true;
      }
      if (shouldYield) {
        this._hv = true;
        this._v = x;
      }
    };
    LastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    LastObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
        this._o.onCompleted();
      } else if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return LastObserver;
  }(AbstractObserver);

  /**
   * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.
   * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.
   */
  observableProto.last = function () {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new LastObservable(this, obj);
  };

  var FindValueObserver = function (__super__) {
    inherits(FindValueObserver, __super__);
    function FindValueObserver(observer, source, callback, yieldIndex) {
      this._o = observer;
      this._s = source;
      this._cb = callback;
      this._y = yieldIndex;
      this._i = 0;
      __super__.call(this);
    }

    FindValueObserver.prototype.next = function (x) {
      var shouldRun = tryCatch(this._cb)(x, this._i, this._s);
      if (shouldRun === errorObj) {
        return this._o.onError(shouldRun.e);
      }
      if (shouldRun) {
        this._o.onNext(this._y ? this._i : x);
        this._o.onCompleted();
      } else {
        this._i++;
      }
    };

    FindValueObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    FindValueObserver.prototype.completed = function () {
      this._y && this._o.onNext(-1);
      this._o.onCompleted();
    };

    return FindValueObserver;
  }(AbstractObserver);

  function findValue(source, predicate, thisArg, yieldIndex) {
    var callback = bindCallback(predicate, thisArg, 3);
    return new AnonymousObservable(function (o) {
      return source.subscribe(new FindValueObserver(o, source, callback, yieldIndex));
    }, source);
  }

  /**
   * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.
   * @param {Function} predicate The predicate that defines the conditions of the element to search for.
   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
   * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.
   */
  observableProto.find = function (predicate, thisArg) {
    return findValue(this, predicate, thisArg, false);
  };

  /**
   * Searches for an element that matches the conditions defined by the specified predicate, and returns
   * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.
   * @param {Function} predicate The predicate that defines the conditions of the element to search for.
   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
   * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.
  */
  observableProto.findIndex = function (predicate, thisArg) {
    return findValue(this, predicate, thisArg, true);
  };

  var ToSetObservable = function (__super__) {
    inherits(ToSetObservable, __super__);
    function ToSetObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    ToSetObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ToSetObserver(o));
    };

    return ToSetObservable;
  }(ObservableBase);

  var ToSetObserver = function (__super__) {
    inherits(ToSetObserver, __super__);
    function ToSetObserver(o) {
      this._o = o;
      this._s = new root.Set();
      __super__.call(this);
    }

    ToSetObserver.prototype.next = function (x) {
      this._s.add(x);
    };

    ToSetObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ToSetObserver.prototype.completed = function () {
      this._o.onNext(this._s);
      this._o.onCompleted();
    };

    return ToSetObserver;
  }(AbstractObserver);

  /**
   * Converts the observable sequence to a Set if it exists.
   * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.
   */
  observableProto.toSet = function () {
    if (typeof root.Set === 'undefined') {
      throw new TypeError();
    }
    return new ToSetObservable(this);
  };

  var ToMapObservable = function (__super__) {
    inherits(ToMapObservable, __super__);
    function ToMapObservable(source, k, e) {
      this.source = source;
      this._k = k;
      this._e = e;
      __super__.call(this);
    }

    ToMapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ToMapObserver(o, this._k, this._e));
    };

    return ToMapObservable;
  }(ObservableBase);

  var ToMapObserver = function (__super__) {
    inherits(ToMapObserver, __super__);
    function ToMapObserver(o, k, e) {
      this._o = o;
      this._k = k;
      this._e = e;
      this._m = new root.Map();
      __super__.call(this);
    }

    ToMapObserver.prototype.next = function (x) {
      var key = tryCatch(this._k)(x);
      if (key === errorObj) {
        return this._o.onError(key.e);
      }
      var elem = x;
      if (this._e) {
        elem = tryCatch(this._e)(x);
        if (elem === errorObj) {
          return this._o.onError(elem.e);
        }
      }

      this._m.set(key, elem);
    };

    ToMapObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ToMapObserver.prototype.completed = function () {
      this._o.onNext(this._m);
      this._o.onCompleted();
    };

    return ToMapObserver;
  }(AbstractObserver);

  /**
  * Converts the observable sequence to a Map if it exists.
  * @param {Function} keySelector A function which produces the key for the Map.
  * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.
  * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.
  */
  observableProto.toMap = function (keySelector, elementSelector) {
    if (typeof root.Map === 'undefined') {
      throw new TypeError();
    }
    return new ToMapObservable(this, keySelector, elementSelector);
  };

  var SliceObservable = function (__super__) {
    inherits(SliceObservable, __super__);
    function SliceObservable(source, b, e) {
      this.source = source;
      this._b = b;
      this._e = e;
      __super__.call(this);
    }

    SliceObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SliceObserver(o, this._b, this._e));
    };

    return SliceObservable;
  }(ObservableBase);

  var SliceObserver = function (__super__) {
    inherits(SliceObserver, __super__);

    function SliceObserver(o, b, e) {
      this._o = o;
      this._b = b;
      this._e = e;
      this._i = 0;
      __super__.call(this);
    }

    SliceObserver.prototype.next = function (x) {
      if (this._i >= this._b) {
        if (this._e === this._i) {
          this._o.onCompleted();
        } else {
          this._o.onNext(x);
        }
      }
      this._i++;
    };
    SliceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SliceObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SliceObserver;
  }(AbstractObserver);

  /*
  * The slice() method returns a shallow copy of a portion of an Observable into a new Observable object.
  * Unlike the array version, this does not support negative numbers for being or end.
  * @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.
  * @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.
  * If omitted, this will emit the rest of the Observable object.
  * @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.
  */
  observableProto.slice = function (begin, end) {
    var start = begin || 0;
    if (start < 0) {
      throw new Rx.ArgumentOutOfRangeError();
    }
    if (typeof end === 'number' && end < start) {
      throw new Rx.ArgumentOutOfRangeError();
    }
    return new SliceObservable(this, start, end);
  };

  var LastIndexOfObservable = function (__super__) {
    inherits(LastIndexOfObservable, __super__);
    function LastIndexOfObservable(source, e, n) {
      this.source = source;
      this._e = e;
      this._n = n;
      __super__.call(this);
    }

    LastIndexOfObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(-1);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new LastIndexOfObserver(o, this._e, this._n));
    };

    return LastIndexOfObservable;
  }(ObservableBase);

  var LastIndexOfObserver = function (__super__) {
    inherits(LastIndexOfObserver, __super__);
    function LastIndexOfObserver(o, e, n) {
      this._o = o;
      this._e = e;
      this._n = n;
      this._v = 0;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    LastIndexOfObserver.prototype.next = function (x) {
      if (this._i >= this._n && x === this._e) {
        this._hv = true;
        this._v = this._i;
      }
      this._i++;
    };
    LastIndexOfObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    LastIndexOfObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
      } else {
        this._o.onNext(-1);
      }
      this._o.onCompleted();
    };

    return LastIndexOfObserver;
  }(AbstractObserver);

  /**
   * Returns the last index at which a given element can be found in the observable sequence, or -1 if it is not present.
   * @param {Any} searchElement Element to locate in the array.
   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
   * @returns {Observable} And observable sequence containing the last index at which a given element can be found in the observable sequence, or -1 if it is not present.
   */
  observableProto.lastIndexOf = function (searchElement, fromIndex) {
    var n = +fromIndex || 0;
    Math.abs(n) === Infinity && (n = 0);
    return new LastIndexOfObservable(this, searchElement, n);
  };

  Observable.wrap = function (fn) {
    function createObservable() {
      return Observable.spawn.call(this, fn.apply(this, arguments));
    }

    createObservable.__generatorFunction__ = fn;
    return createObservable;
  };

  var spawn = Observable.spawn = function () {
    var gen = arguments[0],
        self = this,
        args = [];
    for (var i = 1, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }

    return new AnonymousObservable(function (o) {
      var g = new CompositeDisposable();

      if (isFunction(gen)) {
        gen = gen.apply(self, args);
      }
      if (!gen || !isFunction(gen.next)) {
        o.onNext(gen);
        return o.onCompleted();
      }

      function processGenerator(res) {
        var ret = tryCatch(gen.next).call(gen, res);
        if (ret === errorObj) {
          return o.onError(ret.e);
        }
        next(ret);
      }

      processGenerator();

      function onError(err) {
        var ret = tryCatch(gen.next).call(gen, err);
        if (ret === errorObj) {
          return o.onError(ret.e);
        }
        next(ret);
      }

      function next(ret) {
        if (ret.done) {
          o.onNext(ret.value);
          o.onCompleted();
          return;
        }
        var obs = toObservable.call(self, ret.value);
        var value = null;
        var hasValue = false;
        if (Observable.isObservable(obs)) {
          g.add(obs.subscribe(function (val) {
            hasValue = true;
            value = val;
          }, onError, function () {
            hasValue && processGenerator(value);
          }));
        } else {
          onError(new TypeError('type not supported'));
        }
      }

      return g;
    });
  };

  function toObservable(obj) {
    if (!obj) {
      return obj;
    }
    if (Observable.isObservable(obj)) {
      return obj;
    }
    if (isPromise(obj)) {
      return Observable.fromPromise(obj);
    }
    if (isGeneratorFunction(obj) || isGenerator(obj)) {
      return spawn.call(this, obj);
    }
    if (isFunction(obj)) {
      return thunkToObservable.call(this, obj);
    }
    if (isArrayLike(obj) || isIterable(obj)) {
      return arrayToObservable.call(this, obj);
    }
    if (isObject(obj)) {
      return objectToObservable.call(this, obj);
    }
    return obj;
  }

  function arrayToObservable(obj) {
    return Observable.from(obj).concatMap(function (o) {
      if (Observable.isObservable(o) || isObject(o)) {
        return toObservable.call(null, o);
      } else {
        return Rx.Observable.just(o);
      }
    }).toArray();
  }

  function objectToObservable(obj) {
    var results = new obj.constructor(),
        keys = Object.keys(obj),
        observables = [];
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      var observable = toObservable.call(this, obj[key]);

      if (observable && Observable.isObservable(observable)) {
        defer(observable, key);
      } else {
        results[key] = obj[key];
      }
    }

    return Observable.forkJoin.apply(Observable, observables).map(function () {
      return results;
    });

    function defer(observable, key) {
      results[key] = undefined;
      observables.push(observable.map(function (next) {
        results[key] = next;
      }));
    }
  }

  function thunkToObservable(fn) {
    var self = this;
    return new AnonymousObservable(function (o) {
      fn.call(self, function () {
        var err = arguments[0],
            res = arguments[1];
        if (err) {
          return o.onError(err);
        }
        if (arguments.length > 2) {
          var args = [];
          for (var i = 1, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
          }
          res = args;
        }
        o.onNext(res);
        o.onCompleted();
      });
    });
  }

  function isGenerator(obj) {
    return isFunction(obj.next) && isFunction(obj['throw']);
  }

  function isGeneratorFunction(obj) {
    var ctor = obj.constructor;
    if (!ctor) {
      return false;
    }
    if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') {
      return true;
    }
    return isGenerator(ctor.prototype);
  }

  function isObject(val) {
    return Object == val.constructor;
  }

  /**
   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.
   *
   * @example
   * var res = Rx.Observable.start(function () { console.log('hello'); });
   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
   *
   * @param {Function} func Function to run asynchronously.
   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
   *
   * Remarks
   * * The function is called immediately, not during the subscription of the resulting sequence.
   * * Multiple subscriptions to the resulting sequence can observe the function's result.
   */
  Observable.start = function (func, context, scheduler) {
    return observableToAsync(func, context, scheduler)();
  };

  /**
   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.
   * @param {Function} function Function to convert to an asynchronous function.
   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns {Function} Asynchronous function.
   */
  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return function () {
      var args = arguments,
          subject = new AsyncSubject();

      scheduler.schedule(null, function () {
        var result;
        try {
          result = func.apply(context, args);
        } catch (e) {
          subject.onError(e);
          return;
        }
        subject.onNext(result);
        subject.onCompleted();
      });
      return subject.asObservable();
    };
  };

  function createCbObservable(fn, ctx, selector, args) {
    var o = new AsyncSubject();

    args.push(createCbHandler(o, ctx, selector));
    fn.apply(ctx, args);

    return o.asObservable();
  }

  function createCbHandler(o, ctx, selector) {
    return function handler() {
      var len = arguments.length,
          results = new Array(len);
      for (var i = 0; i < len; i++) {
        results[i] = arguments[i];
      }

      if (isFunction(selector)) {
        results = tryCatch(selector).apply(ctx, results);
        if (results === errorObj) {
          return o.onError(results.e);
        }
        o.onNext(results);
      } else {
        if (results.length <= 1) {
          o.onNext(results[0]);
        } else {
          o.onNext(results);
        }
      }

      o.onCompleted();
    };
  }

  /**
   * Converts a callback function to an observable sequence.
   *
   * @param {Function} fn Function with a callback as the last parameter to convert to an Observable sequence.
   * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.
   * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.
   */
  Observable.fromCallback = function (fn, ctx, selector) {
    return function () {
      typeof ctx === 'undefined' && (ctx = this);

      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return createCbObservable(fn, ctx, selector, args);
    };
  };

  function createNodeObservable(fn, ctx, selector, args) {
    var o = new AsyncSubject();

    args.push(createNodeHandler(o, ctx, selector));
    fn.apply(ctx, args);

    return o.asObservable();
  }

  function createNodeHandler(o, ctx, selector) {
    return function handler() {
      var err = arguments[0];
      if (err) {
        return o.onError(err);
      }

      var len = arguments.length,
          results = [];
      for (var i = 1; i < len; i++) {
        results[i - 1] = arguments[i];
      }

      if (isFunction(selector)) {
        var results = tryCatch(selector).apply(ctx, results);
        if (results === errorObj) {
          return o.onError(results.e);
        }
        o.onNext(results);
      } else {
        if (results.length <= 1) {
          o.onNext(results[0]);
        } else {
          o.onNext(results);
        }
      }

      o.onCompleted();
    };
  }

  /**
   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
   * @param {Function} fn The function to call
   * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.
   * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.
   */
  Observable.fromNodeCallback = function (fn, ctx, selector) {
    return function () {
      typeof ctx === 'undefined' && (ctx = this);
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return createNodeObservable(fn, ctx, selector, args);
    };
  };

  function isNodeList(el) {
    if (root.StaticNodeList) {
      // IE8 Specific
      // instanceof is slower than Object#toString, but Object#toString will not work as intended in IE8
      return el instanceof root.StaticNodeList || el instanceof root.NodeList;
    } else {
      return Object.prototype.toString.call(el) === '[object NodeList]';
    }
  }

  function ListenDisposable(e, n, fn) {
    this._e = e;
    this._n = n;
    this._fn = fn;
    this._e.addEventListener(this._n, this._fn, false);
    this.isDisposed = false;
  }
  ListenDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this._e.removeEventListener(this._n, this._fn, false);
      this.isDisposed = true;
    }
  };

  function createEventListener(el, eventName, handler) {
    var disposables = new CompositeDisposable();

    // Asume NodeList or HTMLCollection
    var elemToString = Object.prototype.toString.call(el);
    if (isNodeList(el) || elemToString === '[object HTMLCollection]') {
      for (var i = 0, len = el.length; i < len; i++) {
        disposables.add(createEventListener(el.item(i), eventName, handler));
      }
    } else if (el) {
      disposables.add(new ListenDisposable(el, eventName, handler));
    }

    return disposables;
  }

  /**
   * Configuration option to determine whether to use native events only
   */
  Rx.config.useNativeEvents = false;

  var EventObservable = function (__super__) {
    inherits(EventObservable, __super__);
    function EventObservable(el, name, fn) {
      this._el = el;
      this._n = name;
      this._fn = fn;
      __super__.call(this);
    }

    function createHandler(o, fn) {
      return function handler() {
        var results = arguments[0];
        if (isFunction(fn)) {
          results = tryCatch(fn).apply(null, arguments);
          if (results === errorObj) {
            return o.onError(results.e);
          }
        }
        o.onNext(results);
      };
    }

    EventObservable.prototype.subscribeCore = function (o) {
      return createEventListener(this._el, this._n, createHandler(o, this._fn));
    };

    return EventObservable;
  }(ObservableBase);

  /**
   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
   * @param {Object} element The DOMElement or NodeList to attach a listener.
   * @param {String} eventName The event name to attach the observable sequence.
   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns {Observable} An observable sequence of events from the specified element and the specified event.
   */
  Observable.fromEvent = function (element, eventName, selector) {
    // Node.js specific
    if (element.addListener) {
      return fromEventPattern(function (h) {
        element.addListener(eventName, h);
      }, function (h) {
        element.removeListener(eventName, h);
      }, selector);
    }

    // Use only if non-native events are allowed
    if (!Rx.config.useNativeEvents) {
      // Handles jq, Angular.js, Zepto, Marionette, Ember.js
      if (typeof element.on === 'function' && typeof element.off === 'function') {
        return fromEventPattern(function (h) {
          element.on(eventName, h);
        }, function (h) {
          element.off(eventName, h);
        }, selector);
      }
    }

    return new EventObservable(element, eventName, selector).publish().refCount();
  };

  var EventPatternObservable = function (__super__) {
    inherits(EventPatternObservable, __super__);
    function EventPatternObservable(add, del, fn) {
      this._add = add;
      this._del = del;
      this._fn = fn;
      __super__.call(this);
    }

    function createHandler(o, fn) {
      return function handler() {
        var results = arguments[0];
        if (isFunction(fn)) {
          results = tryCatch(fn).apply(null, arguments);
          if (results === errorObj) {
            return o.onError(results.e);
          }
        }
        o.onNext(results);
      };
    }

    EventPatternObservable.prototype.subscribeCore = function (o) {
      var fn = createHandler(o, this._fn);
      var returnValue = this._add(fn);
      return new EventPatternDisposable(this._del, fn, returnValue);
    };

    function EventPatternDisposable(del, fn, ret) {
      this._del = del;
      this._fn = fn;
      this._ret = ret;
      this.isDisposed = false;
    }

    EventPatternDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        isFunction(this._del) && this._del(this._fn, this._ret);
        this.isDisposed = true;
      }
    };

    return EventPatternObservable;
  }(ObservableBase);

  /**
   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.
   * @param {Function} addHandler The function to add a handler to the emitter.
   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.
   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns {Observable} An observable sequence which wraps an event from an event emitter
   */
  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {
    return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();
  };

  /**
   * Invokes the asynchronous function, surfacing the result through an observable sequence.
   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.
   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
   */
  Observable.startAsync = function (functionAsync) {
    var promise = tryCatch(functionAsync)();
    if (promise === errorObj) {
      return observableThrow(promise.e);
    }
    return observableFromPromise(promise);
  };

  var PausableObservable = function (__super__) {
    inherits(PausableObservable, __super__);
    function PausableObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      this.paused = true;

      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }

      __super__.call(this);
    }

    PausableObservable.prototype._subscribe = function (o) {
      var conn = this.source.publish(),
          subscription = conn.subscribe(o),
          connection = disposableEmpty;

      var pausable = this.pauser.startWith(!this.paused).distinctUntilChanged().subscribe(function (b) {
        if (b) {
          connection = conn.connect();
        } else {
          connection.dispose();
          connection = disposableEmpty;
        }
      });

      return new NAryDisposable([subscription, connection, pausable]);
    };

    PausableObservable.prototype.pause = function () {
      this.paused = true;
      this.controller.onNext(false);
    };

    PausableObservable.prototype.resume = function () {
      this.paused = false;
      this.controller.onNext(true);
    };

    return PausableObservable;
  }(Observable);

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausable(pauser);
   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
   * @returns {Observable} The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausable = function (pauser) {
    return new PausableObservable(this, pauser);
  };

  function combineLatestSource(source, subject, resultSelector) {
    return new AnonymousObservable(function (o) {
      var hasValue = [false, false],
          hasValueAll = false,
          isDone = false,
          values = new Array(2),
          err;

      function next(x, i) {
        values[i] = x;
        hasValue[i] = true;
        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
          if (err) {
            return o.onError(err);
          }
          var res = tryCatch(resultSelector).apply(null, values);
          if (res === errorObj) {
            return o.onError(res.e);
          }
          o.onNext(res);
        }
        isDone && values[1] && o.onCompleted();
      }

      return new BinaryDisposable(source.subscribe(function (x) {
        next(x, 0);
      }, function (e) {
        if (values[1]) {
          o.onError(e);
        } else {
          err = e;
        }
      }, function () {
        isDone = true;
        values[1] && o.onCompleted();
      }), subject.subscribe(function (x) {
        next(x, 1);
      }, function (e) {
        o.onError(e);
      }, function () {
        isDone = true;
        next(true, 1);
      }));
    }, source);
  }

  var PausableBufferedObservable = function (__super__) {
    inherits(PausableBufferedObservable, __super__);
    function PausableBufferedObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      this.paused = true;

      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }

      __super__.call(this);
    }

    PausableBufferedObservable.prototype._subscribe = function (o) {
      var q = [],
          previousShouldFire;

      function drainQueue() {
        while (q.length > 0) {
          o.onNext(q.shift());
        }
      }

      var subscription = combineLatestSource(this.source, this.pauser.startWith(!this.paused).distinctUntilChanged(), function (data, shouldFire) {
        return { data: data, shouldFire: shouldFire };
      }).subscribe(function (results) {
        if (previousShouldFire !== undefined && results.shouldFire !== previousShouldFire) {
          previousShouldFire = results.shouldFire;
          // change in shouldFire
          if (results.shouldFire) {
            drainQueue();
          }
        } else {
          previousShouldFire = results.shouldFire;
          // new data
          if (results.shouldFire) {
            o.onNext(results.data);
          } else {
            q.push(results.data);
          }
        }
      }, function (err) {
        drainQueue();
        o.onError(err);
      }, function () {
        drainQueue();
        o.onCompleted();
      });
      return subscription;
    };

    PausableBufferedObservable.prototype.pause = function () {
      this.paused = true;
      this.controller.onNext(false);
    };

    PausableBufferedObservable.prototype.resume = function () {
      this.paused = false;
      this.controller.onNext(true);
    };

    return PausableBufferedObservable;
  }(Observable);

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
   * and yields the values that were buffered while paused.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
   * @returns {Observable} The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausableBuffered = function (pauser) {
    return new PausableBufferedObservable(this, pauser);
  };

  var ControlledObservable = function (__super__) {
    inherits(ControlledObservable, __super__);
    function ControlledObservable(source, enableQueue, scheduler) {
      __super__.call(this);
      this.subject = new ControlledSubject(enableQueue, scheduler);
      this.source = source.multicast(this.subject).refCount();
    }

    ControlledObservable.prototype._subscribe = function (o) {
      return this.source.subscribe(o);
    };

    ControlledObservable.prototype.request = function (numberOfItems) {
      return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
    };

    return ControlledObservable;
  }(Observable);

  var ControlledSubject = function (__super__) {
    inherits(ControlledSubject, __super__);
    function ControlledSubject(enableQueue, scheduler) {
      enableQueue == null && (enableQueue = true);

      __super__.call(this);
      this.subject = new Subject();
      this.enableQueue = enableQueue;
      this.queue = enableQueue ? [] : null;
      this.requestedCount = 0;
      this.requestedDisposable = null;
      this.error = null;
      this.hasFailed = false;
      this.hasCompleted = false;
      this.scheduler = scheduler || currentThreadScheduler;
    }

    addProperties(ControlledSubject.prototype, Observer, {
      _subscribe: function _subscribe(o) {
        return this.subject.subscribe(o);
      },
      onCompleted: function onCompleted() {
        this.hasCompleted = true;
        if (!this.enableQueue || this.queue.length === 0) {
          this.subject.onCompleted();
          this.disposeCurrentRequest();
        } else {
          this.queue.push(Notification.createOnCompleted());
        }
      },
      onError: function onError(error) {
        this.hasFailed = true;
        this.error = error;
        if (!this.enableQueue || this.queue.length === 0) {
          this.subject.onError(error);
          this.disposeCurrentRequest();
        } else {
          this.queue.push(Notification.createOnError(error));
        }
      },
      onNext: function onNext(value) {
        if (this.requestedCount <= 0) {
          this.enableQueue && this.queue.push(Notification.createOnNext(value));
        } else {
          this.requestedCount-- === 0 && this.disposeCurrentRequest();
          this.subject.onNext(value);
        }
      },
      _processRequest: function _processRequest(numberOfItems) {
        if (this.enableQueue) {
          while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {
            var first = this.queue.shift();
            first.accept(this.subject);
            if (first.kind === 'N') {
              numberOfItems--;
            } else {
              this.disposeCurrentRequest();
              this.queue = [];
            }
          }
        }

        return numberOfItems;
      },
      request: function request(number) {
        this.disposeCurrentRequest();
        var self = this;

        this.requestedDisposable = this.scheduler.schedule(number, function (s, i) {
          var remaining = self._processRequest(i);
          var stopped = self.hasCompleted || self.hasFailed;
          if (!stopped && remaining > 0) {
            self.requestedCount = remaining;

            return disposableCreate(function () {
              self.requestedCount = 0;
            });
            // Scheduled item is still in progress. Return a new
            // disposable to allow the request to be interrupted
            // via dispose.
          }
        });

        return this.requestedDisposable;
      },
      disposeCurrentRequest: function disposeCurrentRequest() {
        if (this.requestedDisposable) {
          this.requestedDisposable.dispose();
          this.requestedDisposable = null;
        }
      }
    });

    return ControlledSubject;
  }(Observable);

  /**
   * Attaches a controller to the observable sequence with the ability to queue.
   * @example
   * var source = Rx.Observable.interval(100).controlled();
   * source.request(3); // Reads 3 values
   * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request
   * @param {Scheduler} scheduler determines how the requests will be scheduled
   * @returns {Observable} The observable sequence which only propagates values on request.
   */
  observableProto.controlled = function (enableQueue, scheduler) {

    if (enableQueue && isScheduler(enableQueue)) {
      scheduler = enableQueue;
      enableQueue = true;
    }

    if (enableQueue == null) {
      enableQueue = true;
    }
    return new ControlledObservable(this, enableQueue, scheduler);
  };

  var StopAndWaitObservable = function (__super__) {
    inherits(StopAndWaitObservable, __super__);
    function StopAndWaitObservable(source) {
      __super__.call(this);
      this.source = source;
    }

    function scheduleMethod(s, self) {
      return self.source.request(1);
    }

    StopAndWaitObservable.prototype._subscribe = function (o) {
      this.subscription = this.source.subscribe(new StopAndWaitObserver(o, this, this.subscription));
      return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));
    };

    var StopAndWaitObserver = function (__sub__) {
      inherits(StopAndWaitObserver, __sub__);
      function StopAndWaitObserver(observer, observable, cancel) {
        __sub__.call(this);
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.scheduleDisposable = null;
      }

      StopAndWaitObserver.prototype.completed = function () {
        this.observer.onCompleted();
        this.dispose();
      };

      StopAndWaitObserver.prototype.error = function (error) {
        this.observer.onError(error);
        this.dispose();
      };

      function innerScheduleMethod(s, self) {
        return self.observable.source.request(1);
      }

      StopAndWaitObserver.prototype.next = function (value) {
        this.observer.onNext(value);
        this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod);
      };

      StopAndWaitObserver.dispose = function () {
        this.observer = null;
        if (this.cancel) {
          this.cancel.dispose();
          this.cancel = null;
        }
        if (this.scheduleDisposable) {
          this.scheduleDisposable.dispose();
          this.scheduleDisposable = null;
        }
        __sub__.prototype.dispose.call(this);
      };

      return StopAndWaitObserver;
    }(AbstractObserver);

    return StopAndWaitObservable;
  }(Observable);

  /**
   * Attaches a stop and wait observable to the current observable.
   * @returns {Observable} A stop and wait observable.
   */
  ControlledObservable.prototype.stopAndWait = function () {
    return new StopAndWaitObservable(this);
  };

  var WindowedObservable = function (__super__) {
    inherits(WindowedObservable, __super__);
    function WindowedObservable(source, windowSize) {
      __super__.call(this);
      this.source = source;
      this.windowSize = windowSize;
    }

    function scheduleMethod(s, self) {
      return self.source.request(self.windowSize);
    }

    WindowedObservable.prototype._subscribe = function (o) {
      this.subscription = this.source.subscribe(new WindowedObserver(o, this, this.subscription));
      return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));
    };

    var WindowedObserver = function (__sub__) {
      inherits(WindowedObserver, __sub__);
      function WindowedObserver(observer, observable, cancel) {
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.received = 0;
        this.scheduleDisposable = null;
        __sub__.call(this);
      }

      WindowedObserver.prototype.completed = function () {
        this.observer.onCompleted();
        this.dispose();
      };

      WindowedObserver.prototype.error = function (error) {
        this.observer.onError(error);
        this.dispose();
      };

      function innerScheduleMethod(s, self) {
        return self.observable.source.request(self.observable.windowSize);
      }

      WindowedObserver.prototype.next = function (value) {
        this.observer.onNext(value);
        this.received = ++this.received % this.observable.windowSize;
        this.received === 0 && (this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod));
      };

      WindowedObserver.prototype.dispose = function () {
        this.observer = null;
        if (this.cancel) {
          this.cancel.dispose();
          this.cancel = null;
        }
        if (this.scheduleDisposable) {
          this.scheduleDisposable.dispose();
          this.scheduleDisposable = null;
        }
        __sub__.prototype.dispose.call(this);
      };

      return WindowedObserver;
    }(AbstractObserver);

    return WindowedObservable;
  }(Observable);

  /**
   * Creates a sliding windowed observable based upon the window size.
   * @param {Number} windowSize The number of items in the window
   * @returns {Observable} A windowed observable based upon the window size.
   */
  ControlledObservable.prototype.windowed = function (windowSize) {
    return new WindowedObservable(this, windowSize);
  };

  /**
   * Pipes the existing Observable sequence into a Node.js Stream.
   * @param {Stream} dest The destination Node.js stream.
   * @returns {Stream} The destination stream.
   */
  observableProto.pipe = function (dest) {
    var source = this.pausableBuffered();

    function onDrain() {
      source.resume();
    }

    dest.addListener('drain', onDrain);

    source.subscribe(function (x) {
      !dest.write(x) && source.pause();
    }, function (err) {
      dest.emit('error', err);
    }, function () {
      // Hack check because STDIO is not closable
      !dest._isStdio && dest.end();
      dest.removeListener('drain', onDrain);
    });

    source.resume();

    return dest;
  };

  var MulticastObservable = function (__super__) {
    inherits(MulticastObservable, __super__);
    function MulticastObservable(source, fn1, fn2) {
      this.source = source;
      this._fn1 = fn1;
      this._fn2 = fn2;
      __super__.call(this);
    }

    MulticastObservable.prototype.subscribeCore = function (o) {
      var connectable = this.source.multicast(this._fn1());
      return new BinaryDisposable(this._fn2(connectable).subscribe(o), connectable.connect());
    };

    return MulticastObservable;
  }(ObservableBase);

  /**
   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each
   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's
   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
   *
   * @example
   * 1 - res = source.multicast(observable);
   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });
   *
   * @param {Function|Subject} subjectOrSubjectSelector
   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
   * Or:
   * Subject to push source elements into.
   *
   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name="subjectOrSubjectSelector" is a factory function.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.multicast = function (subjectOrSubjectSelector, selector) {
    return isFunction(subjectOrSubjectSelector) ? new MulticastObservable(this, subjectOrSubjectSelector, selector) : new ConnectableObservable(this, subjectOrSubjectSelector);
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.
   * This operator is a specialization of Multicast using a regular Subject.
   *
   * @example
   * var resres = source.publish();
   * var res = source.publish(function (x) { return x; });
   *
   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publish = function (selector) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new Subject();
    }, selector) : this.multicast(new Subject());
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence.
   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.share = function () {
    return this.publish().refCount();
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
   * This operator is a specialization of Multicast using a AsyncSubject.
   *
   * @example
   * var res = source.publishLast();
   * var res = source.publishLast(function (x) { return x; });
   *
   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publishLast = function (selector) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new AsyncSubject();
    }, selector) : this.multicast(new AsyncSubject());
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
   * This operator is a specialization of Multicast using a BehaviorSubject.
   *
   * @example
   * var res = source.publishValue(42);
   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);
   *
   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.
   * @param {Mixed} initialValue Initial value received by observers upon subscription.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publishValue = function (initialValueOrSelector, initialValue) {
    return arguments.length === 2 ? this.multicast(function () {
      return new BehaviorSubject(initialValue);
    }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.
   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   * @param {Mixed} initialValue Initial value received by observers upon subscription.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.shareValue = function (initialValue) {
    return this.publishValue(initialValue).refCount();
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
   * This operator is a specialization of Multicast using a ReplaySubject.
   *
   * @example
   * var res = source.replay(null, 3);
   * var res = source.replay(null, 3, 500);
   * var res = source.replay(null, 3, 500, scheduler);
   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);
   *
   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
   * @param bufferSize [Optional] Maximum element count of the replay buffer.
   * @param windowSize [Optional] Maximum time length of the replay buffer.
   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.replay = function (selector, bufferSize, windowSize, scheduler) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new ReplaySubject(bufferSize, windowSize, scheduler);
    }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   *
   * @example
   * var res = source.shareReplay(3);
   * var res = source.shareReplay(3, 500);
   * var res = source.shareReplay(3, 500, scheduler);
   *
    * @param bufferSize [Optional] Maximum element count of the replay buffer.
   * @param window [Optional] Maximum time length of the replay buffer.
   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.shareReplay = function (bufferSize, windowSize, scheduler) {
    return this.replay(null, bufferSize, windowSize, scheduler).refCount();
  };

  var InnerSubscription = function InnerSubscription(s, o) {
    this._s = s;
    this._o = o;
  };

  InnerSubscription.prototype.dispose = function () {
    if (!this._s.isDisposed && this._o !== null) {
      var idx = this._s.observers.indexOf(this._o);
      this._s.observers.splice(idx, 1);
      this._o = null;
    }
  };

  var RefCountObservable = function (__super__) {
    inherits(RefCountObservable, __super__);
    function RefCountObservable(source) {
      this.source = source;
      this._count = 0;
      this._connectableSubscription = null;
      __super__.call(this);
    }

    RefCountObservable.prototype.subscribeCore = function (o) {
      var subscription = this.source.subscribe(o);
      ++this._count === 1 && (this._connectableSubscription = this.source.connect());
      return new RefCountDisposable(this, subscription);
    };

    function RefCountDisposable(p, s) {
      this._p = p;
      this._s = s;
      this.isDisposed = false;
    }

    RefCountDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        this._s.dispose();
        --this._p._count === 0 && this._p._connectableSubscription.dispose();
      }
    };

    return RefCountObservable;
  }(ObservableBase);

  var ConnectableObservable = Rx.ConnectableObservable = function (__super__) {
    inherits(ConnectableObservable, __super__);
    function ConnectableObservable(source, subject) {
      this.source = source;
      this._connection = null;
      this._source = source.asObservable();
      this._subject = subject;
      __super__.call(this);
    }

    function ConnectDisposable(parent, subscription) {
      this._p = parent;
      this._s = subscription;
    }

    ConnectDisposable.prototype.dispose = function () {
      if (this._s) {
        this._s.dispose();
        this._s = null;
        this._p._connection = null;
      }
    };

    ConnectableObservable.prototype.connect = function () {
      if (!this._connection) {
        if (this._subject.isStopped) {
          return disposableEmpty;
        }
        var subscription = this._source.subscribe(this._subject);
        this._connection = new ConnectDisposable(this, subscription);
      }
      return this._connection;
    };

    ConnectableObservable.prototype._subscribe = function (o) {
      return this._subject.subscribe(o);
    };

    ConnectableObservable.prototype.refCount = function () {
      return new RefCountObservable(this);
    };

    return ConnectableObservable;
  }(Observable);

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence
   * can be resubscribed to, even if all prior subscriptions have ended. (unlike `.publish().refCount()`)
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source.
   */
  observableProto.singleInstance = function () {
    var source = this,
        hasObservable = false,
        observable;

    function getObservable() {
      if (!hasObservable) {
        hasObservable = true;
        observable = source['finally'](function () {
          hasObservable = false;
        }).publish().refCount();
      }
      return observable;
    }

    return new AnonymousObservable(function (o) {
      return getObservable().subscribe(o);
    });
  };

  /**
   *  Correlates the elements of two sequences based on overlapping durations.
   *
   *  @param {Observable} right The right observable sequence to join elements for.
   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.
   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
   */
  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
    var left = this;
    return new AnonymousObservable(function (o) {
      var group = new CompositeDisposable();
      var leftDone = false,
          rightDone = false;
      var leftId = 0,
          rightId = 0;
      var leftMap = new Map(),
          rightMap = new Map();
      var handleError = function handleError(e) {
        o.onError(e);
      };

      group.add(left.subscribe(function (value) {
        var id = leftId++,
            md = new SingleAssignmentDisposable();

        leftMap.set(id, value);
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, handleError, function () {
          leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();
          group.remove(md);
        }));

        rightMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(value, v);
          if (result === errorObj) {
            return o.onError(result.e);
          }
          o.onNext(result);
        });
      }, handleError, function () {
        leftDone = true;
        (rightDone || leftMap.size === 0) && o.onCompleted();
      }));

      group.add(right.subscribe(function (value) {
        var id = rightId++,
            md = new SingleAssignmentDisposable();

        rightMap.set(id, value);
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, handleError, function () {
          rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();
          group.remove(md);
        }));

        leftMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(v, value);
          if (result === errorObj) {
            return o.onError(result.e);
          }
          o.onNext(result);
        });
      }, handleError, function () {
        rightDone = true;
        (leftDone || rightMap.size === 0) && o.onCompleted();
      }));
      return group;
    }, left);
  };

  /**
   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.
   *
   *  @param {Observable} right The right observable sequence to join elements for.
   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.
   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
   */
  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
    var left = this;
    return new AnonymousObservable(function (o) {
      var group = new CompositeDisposable();
      var r = new RefCountDisposable(group);
      var leftMap = new Map(),
          rightMap = new Map();
      var leftId = 0,
          rightId = 0;
      var handleError = function handleError(e) {
        return function (v) {
          v.onError(e);
        };
      };

      function handleError(e) {};

      group.add(left.subscribe(function (value) {
        var s = new Subject();
        var id = leftId++;
        leftMap.set(id, s);

        var result = tryCatch(resultSelector)(value, addRef(s, r));
        if (result === errorObj) {
          leftMap.forEach(handleError(result.e));
          return o.onError(result.e);
        }
        o.onNext(result);

        rightMap.forEach(function (v) {
          s.onNext(v);
        });

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, function (e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function () {
          leftMap['delete'](id) && s.onCompleted();
          group.remove(md);
        }));
      }, function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      }, function () {
        o.onCompleted();
      }));

      group.add(right.subscribe(function (value) {
        var id = rightId++;
        rightMap.set(id, value);

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, function (e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function () {
          rightMap['delete'](id);
          group.remove(md);
        }));

        leftMap.forEach(function (v) {
          v.onNext(value);
        });
      }, function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      }));

      return r;
    }, left);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers.
   *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns {Observable} An observable sequence of windows.
   */
  observableProto.buffer = function () {
    return this.window.apply(this, arguments).flatMap(toArray);
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows.
   *
   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns {Observable} An observable sequence of windows.
   */
  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {
    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
      return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
    }
    return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
  };

  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {
      return win;
    });
  }

  function observableWindowWithBoundaries(windowBoundaries) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var win = new Subject(),
          d = new CompositeDisposable(),
          r = new RefCountDisposable(d);

      observer.onNext(addRef(win, r));

      d.add(source.subscribe(function (x) {
        win.onNext(x);
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));

      d.add(windowBoundaries.subscribe(function (w) {
        win.onCompleted();
        win = new Subject();
        observer.onNext(addRef(win, r));
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      return r;
    }, source);
  }

  function observableWindowWithClosingSelector(windowClosingSelector) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var m = new SerialDisposable(),
          d = new CompositeDisposable(m),
          r = new RefCountDisposable(d),
          win = new Subject();
      observer.onNext(addRef(win, r));
      d.add(source.subscribe(function (x) {
        win.onNext(x);
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      function createWindowClose() {
        var windowClose;
        try {
          windowClose = windowClosingSelector();
        } catch (e) {
          observer.onError(e);
          return;
        }

        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));

        var m1 = new SingleAssignmentDisposable();
        m.setDisposable(m1);
        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {
          win.onError(err);
          observer.onError(err);
        }, function () {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
          createWindowClose();
        }));
      }

      createWindowClose();
      return r;
    }, source);
  }

  var PairwiseObservable = function (__super__) {
    inherits(PairwiseObservable, __super__);
    function PairwiseObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    PairwiseObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new PairwiseObserver(o));
    };

    return PairwiseObservable;
  }(ObservableBase);

  var PairwiseObserver = function (__super__) {
    inherits(PairwiseObserver, __super__);
    function PairwiseObserver(o) {
      this._o = o;
      this._p = null;
      this._hp = false;
      __super__.call(this);
    }

    PairwiseObserver.prototype.next = function (x) {
      if (this._hp) {
        this._o.onNext([this._p, x]);
      } else {
        this._hp = true;
      }
      this._p = x;
    };
    PairwiseObserver.prototype.error = function (err) {
      this._o.onError(err);
    };
    PairwiseObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return PairwiseObserver;
  }(AbstractObserver);

  /**
   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.
   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.
   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.
   */
  observableProto.pairwise = function () {
    return new PairwiseObservable(this);
  };

  /**
   * Returns two observables which partition the observations of the source by the given function.
   * The first will trigger observations for those values for which the predicate returns true.
   * The second will trigger observations for those values where the predicate returns false.
   * The predicate is executed once for each subscribed observer.
   * Both also propagate all error observations arising from the source and each completes
   * when the source completes.
   * @param {Function} predicate
   *    The function to determine which output Observable will trigger a particular observation.
   * @returns {Array}
   *    An array of observables. The first triggers when the predicate returns true,
   *    and the second triggers when the predicate returns false.
  */
  observableProto.partition = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return [this.filter(predicate, thisArg), this.filter(function (x, i, o) {
      return !fn(x, i, o);
    })];
  };

  var WhileEnumerable = function (__super__) {
    inherits(WhileEnumerable, __super__);
    function WhileEnumerable(c, s) {
      this.c = c;
      this.s = s;
    }
    WhileEnumerable.prototype[$iterator$] = function () {
      var self = this;
      return {
        next: function next() {
          return self.c() ? { done: false, value: self.s } : { done: true, value: void 0 };
        }
      };
    };
    return WhileEnumerable;
  }(Enumerable);

  function enumerableWhile(condition, source) {
    return new WhileEnumerable(condition, source);
  }

  /**
  *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
  *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
  *
  * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
  * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
  */
  observableProto.letBind = observableProto['let'] = function (func) {
    return func(this);
  };

  /**
  *  Determines whether an observable collection contains values. 
  *
  * @example
  *  1 - res = Rx.Observable.if(condition, obs1);
  *  2 - res = Rx.Observable.if(condition, obs1, obs2);
  *  3 - res = Rx.Observable.if(condition, obs1, scheduler);
  * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.
  * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.
  * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
  * @returns {Observable} An observable sequence which is either the thenSource or elseSource.
  */
  Observable['if'] = function (condition, thenSource, elseSourceOrScheduler) {
    return observableDefer(function () {
      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());

      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));

      // Assume a scheduler for empty only
      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
      return condition() ? thenSource : elseSourceOrScheduler;
    });
  };

  /**
  *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
  * There is an alias for this method called 'forIn' for browsers <IE9
  * @param {Array} sources An array of values to turn into an observable sequence.
  * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
  * @returns {Observable} An observable sequence from the concatenated observable sequences.
  */
  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {
    return enumerableOf(sources, resultSelector, thisArg).concat();
  };

  /**
  *  Repeats source as long as condition holds emulating a while loop.
  * There is an alias for this method called 'whileDo' for browsers <IE9
  *
  * @param {Function} condition The condition which determines if the source will be repeated.
  * @param {Observable} source The observable sequence that will be run if the condition function returns true.
  * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
  */
  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {
    isPromise(source) && (source = observableFromPromise(source));
    return enumerableWhile(condition, source).concat();
  };

  /**
  *  Repeats source as long as condition holds emulating a do while loop.
  *
  * @param {Function} condition The condition which determines if the source will be repeated.
  * @param {Observable} source The observable sequence that will be run if the condition function returns true.
  * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
  */
  observableProto.doWhile = function (condition) {
    return observableConcat([this, observableWhileDo(condition, this)]);
  };

  /**
  *  Uses selector to determine which source in sources to use.
  * @param {Function} selector The function which extracts the value for to test in a case statement.
  * @param {Array} sources A object which has keys which correspond to the case statement labels.
  * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.
  *
  * @returns {Observable} An observable sequence which is determined by a case statement.
  */
  Observable['case'] = function (selector, sources, defaultSourceOrScheduler) {
    return observableDefer(function () {
      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());

      isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));

      var result = sources[selector()];
      isPromise(result) && (result = observableFromPromise(result));

      return result || defaultSourceOrScheduler;
    });
  };

  var ExpandObservable = function (__super__) {
    inherits(ExpandObservable, __super__);
    function ExpandObservable(source, fn, scheduler) {
      this.source = source;
      this._fn = fn;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleRecursive(args, recurse) {
      var state = args[0],
          self = args[1];
      var work;
      if (state.q.length > 0) {
        work = state.q.shift();
      } else {
        state.isAcquired = false;
        return;
      }
      var m1 = new SingleAssignmentDisposable();
      state.d.add(m1);
      m1.setDisposable(work.subscribe(new ExpandObserver(state, self, m1)));
      recurse([state, self]);
    }

    ExpandObservable.prototype._ensureActive = function (state) {
      var isOwner = false;
      if (state.q.length > 0) {
        isOwner = !state.isAcquired;
        state.isAcquired = true;
      }
      isOwner && state.m.setDisposable(this._scheduler.scheduleRecursive([state, this], scheduleRecursive));
    };

    ExpandObservable.prototype.subscribeCore = function (o) {
      var m = new SerialDisposable(),
          d = new CompositeDisposable(m),
          state = {
        q: [],
        m: m,
        d: d,
        activeCount: 0,
        isAcquired: false,
        o: o
      };

      state.q.push(this.source);
      state.activeCount++;
      this._ensureActive(state);
      return d;
    };

    return ExpandObservable;
  }(ObservableBase);

  var ExpandObserver = function (__super__) {
    inherits(ExpandObserver, __super__);
    function ExpandObserver(state, parent, m1) {
      this._s = state;
      this._p = parent;
      this._m1 = m1;
      __super__.call(this);
    }

    ExpandObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
      var result = tryCatch(this._p._fn)(x);
      if (result === errorObj) {
        return this._s.o.onError(result.e);
      }
      this._s.q.push(result);
      this._s.activeCount++;
      this._p._ensureActive(this._s);
    };

    ExpandObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    ExpandObserver.prototype.completed = function () {
      this._s.d.remove(this._m1);
      this._s.activeCount--;
      this._s.activeCount === 0 && this._s.o.onCompleted();
    };

    return ExpandObserver;
  }(AbstractObserver);

  /**
  *  Expands an observable sequence by recursively invoking selector.
  *
  * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
  * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
  * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.
  */
  observableProto.expand = function (selector, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new ExpandObservable(this, selector, scheduler);
  };

  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var ForkJoinObservable = function (__super__) {
    inherits(ForkJoinObservable, __super__);
    function ForkJoinObservable(sources, cb) {
      this._sources = sources;
      this._cb = cb;
      __super__.call(this);
    }

    ForkJoinObservable.prototype.subscribeCore = function (o) {
      if (this._sources.length === 0) {
        o.onCompleted();
        return disposableEmpty;
      }

      var count = this._sources.length;
      var state = {
        finished: false,
        hasResults: new Array(count),
        hasCompleted: new Array(count),
        results: new Array(count)
      };

      var subscriptions = new CompositeDisposable();
      for (var i = 0, len = this._sources.length; i < len; i++) {
        var source = this._sources[i];
        isPromise(source) && (source = observableFromPromise(source));
        subscriptions.add(source.subscribe(new ForkJoinObserver(o, state, i, this._cb, subscriptions)));
      }

      return subscriptions;
    };

    return ForkJoinObservable;
  }(ObservableBase);

  var ForkJoinObserver = function (__super__) {
    inherits(ForkJoinObserver, __super__);
    function ForkJoinObserver(o, s, i, cb, subs) {
      this._o = o;
      this._s = s;
      this._i = i;
      this._cb = cb;
      this._subs = subs;
      __super__.call(this);
    }

    ForkJoinObserver.prototype.next = function (x) {
      if (!this._s.finished) {
        this._s.hasResults[this._i] = true;
        this._s.results[this._i] = x;
      }
    };

    ForkJoinObserver.prototype.error = function (e) {
      this._s.finished = true;
      this._o.onError(e);
      this._subs.dispose();
    };

    ForkJoinObserver.prototype.completed = function () {
      if (!this._s.finished) {
        if (!this._s.hasResults[this._i]) {
          return this._o.onCompleted();
        }
        this._s.hasCompleted[this._i] = true;
        for (var i = 0; i < this._s.results.length; i++) {
          if (!this._s.hasCompleted[i]) {
            return;
          }
        }
        this._s.finished = true;

        var res = tryCatch(this._cb).apply(null, this._s.results);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }

        this._o.onNext(res);
        this._o.onCompleted();
      }
    };

    return ForkJoinObserver;
  }(AbstractObserver);

  /**
  *  Runs all observable sequences in parallel and collect their last elements.
  *
  * @example
  *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);
  *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
  * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
  */
  Observable.forkJoin = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);
    return new ForkJoinObservable(args, resultSelector);
  };

  /**
  *  Runs two observable sequences in parallel and combines their last elemenets.
  * @param {Observable} second Second observable sequence.
  * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.
  * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.
  */
  observableProto.forkJoin = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args[0].unshift(this);
    } else {
      args.unshift(this);
    }
    return Observable.forkJoin.apply(null, args);
  };

  /**
   * Comonadic bind operator.
   * @param {Function} selector A transform function to apply to each element.
   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.
   * @returns {Observable} An observable sequence which results from the comonadic bind operation.
   */
  observableProto.manySelect = observableProto.extend = function (selector, scheduler) {
    isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);
    var source = this;
    return observableDefer(function () {
      var chain;

      return source.map(function (x) {
        var curr = new ChainObservable(x);

        chain && chain.onNext(x);
        chain = curr;

        return curr;
      }).tap(noop, function (e) {
        chain && chain.onError(e);
      }, function () {
        chain && chain.onCompleted();
      }).observeOn(scheduler).map(selector);
    }, source);
  };

  var ChainObservable = function (__super__) {
    inherits(ChainObservable, __super__);
    function ChainObservable(head) {
      __super__.call(this);
      this.head = head;
      this.tail = new AsyncSubject();
    }

    addProperties(ChainObservable.prototype, Observer, {
      _subscribe: function _subscribe(o) {
        var g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(this, function (_, self) {
          o.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(o));
        }));

        return g;
      },
      onCompleted: function onCompleted() {
        this.onNext(Observable.empty());
      },
      onError: function onError(e) {
        this.onNext(Observable['throw'](e));
      },
      onNext: function onNext(v) {
        this.tail.onNext(v);
        this.tail.onCompleted();
      }
    });

    return ChainObservable;
  }(Observable);

  var Map = root.Map || function () {
    function Map() {
      this.size = 0;
      this._values = [];
      this._keys = [];
    }

    Map.prototype['delete'] = function (key) {
      var i = this._keys.indexOf(key);
      if (i === -1) {
        return false;
      }
      this._values.splice(i, 1);
      this._keys.splice(i, 1);
      this.size--;
      return true;
    };

    Map.prototype.get = function (key) {
      var i = this._keys.indexOf(key);
      return i === -1 ? undefined : this._values[i];
    };

    Map.prototype.set = function (key, value) {
      var i = this._keys.indexOf(key);
      if (i === -1) {
        this._keys.push(key);
        this._values.push(value);
        this.size++;
      } else {
        this._values[i] = value;
      }
      return this;
    };

    Map.prototype.forEach = function (cb, thisArg) {
      for (var i = 0; i < this.size; i++) {
        cb.call(thisArg, this._values[i], this._keys[i]);
      }
    };

    return Map;
  }();

  /**
   * @constructor
   * Represents a join pattern over observable sequences.
   */
  function Pattern(patterns) {
    this.patterns = patterns;
  }

  /**
   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.
   *  @param other Observable sequence to match in addition to the current pattern.
   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.
   */
  Pattern.prototype.and = function (other) {
    return new Pattern(this.patterns.concat(other));
  };

  /**
   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.
   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.
   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  Pattern.prototype.thenDo = function (selector) {
    return new Plan(this, selector);
  };

  function Plan(expression, selector) {
    this.expression = expression;
    this.selector = selector;
  }

  function handleOnError(o) {
    return function (e) {
      o.onError(e);
    };
  }
  function handleOnNext(self, observer) {
    return function onNext() {
      var result = tryCatch(self.selector).apply(self, arguments);
      if (result === errorObj) {
        return observer.onError(result.e);
      }
      observer.onNext(result);
    };
  }

  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {
    var joinObservers = [],
        errHandler = handleOnError(observer);
    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {
      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], errHandler));
    }
    var activePlan = new ActivePlan(joinObservers, handleOnNext(this, observer), function () {
      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {
        joinObservers[j].removeActivePlan(activePlan);
      }
      deactivate(activePlan);
    });
    for (i = 0, len = joinObservers.length; i < len; i++) {
      joinObservers[i].addActivePlan(activePlan);
    }
    return activePlan;
  };

  function planCreateObserver(externalSubscriptions, observable, onError) {
    var entry = externalSubscriptions.get(observable);
    if (!entry) {
      var observer = new JoinObserver(observable, onError);
      externalSubscriptions.set(observable, observer);
      return observer;
    }
    return entry;
  }

  function ActivePlan(joinObserverArray, onNext, onCompleted) {
    this.joinObserverArray = joinObserverArray;
    this.onNext = onNext;
    this.onCompleted = onCompleted;
    this.joinObservers = new Map();
    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {
      var joinObserver = this.joinObserverArray[i];
      this.joinObservers.set(joinObserver, joinObserver);
    }
  }

  ActivePlan.prototype.dequeue = function () {
    this.joinObservers.forEach(function (v) {
      v.queue.shift();
    });
  };

  ActivePlan.prototype.match = function () {
    var i,
        len,
        hasValues = true;
    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
      if (this.joinObserverArray[i].queue.length === 0) {
        hasValues = false;
        break;
      }
    }
    if (hasValues) {
      var firstValues = [],
          isCompleted = false;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        firstValues.push(this.joinObserverArray[i].queue[0]);
        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
      }
      if (isCompleted) {
        this.onCompleted();
      } else {
        this.dequeue();
        var values = [];
        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
          values.push(firstValues[i].value);
        }
        this.onNext.apply(this, values);
      }
    }
  };

  var JoinObserver = function (__super__) {
    inherits(JoinObserver, __super__);

    function JoinObserver(source, onError) {
      __super__.call(this);
      this.source = source;
      this.onError = onError;
      this.queue = [];
      this.activePlans = [];
      this.subscription = new SingleAssignmentDisposable();
      this.isDisposed = false;
    }

    var JoinObserverPrototype = JoinObserver.prototype;

    JoinObserverPrototype.next = function (notification) {
      if (!this.isDisposed) {
        if (notification.kind === 'E') {
          return this.onError(notification.error);
        }
        this.queue.push(notification);
        var activePlans = this.activePlans.slice(0);
        for (var i = 0, len = activePlans.length; i < len; i++) {
          activePlans[i].match();
        }
      }
    };

    JoinObserverPrototype.error = noop;
    JoinObserverPrototype.completed = noop;

    JoinObserverPrototype.addActivePlan = function (activePlan) {
      this.activePlans.push(activePlan);
    };

    JoinObserverPrototype.subscribe = function () {
      this.subscription.setDisposable(this.source.materialize().subscribe(this));
    };

    JoinObserverPrototype.removeActivePlan = function (activePlan) {
      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
      this.activePlans.length === 0 && this.dispose();
    };

    JoinObserverPrototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      if (!this.isDisposed) {
        this.isDisposed = true;
        this.subscription.dispose();
      }
    };

    return JoinObserver;
  }(AbstractObserver);

  /**
   *  Creates a pattern that matches when both observable sequences have an available value.
   *
   *  @param right Observable sequence to match with the current sequence.
   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.
   */
  observableProto.and = function (right) {
    return new Pattern([this, right]);
  };

  /**
   *  Matches when the observable sequence has an available value and projects the value.
   *
   *  @param {Function} selector Selector that will be invoked for values in the source sequence.
   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  observableProto.thenDo = function (selector) {
    return new Pattern([this]).thenDo(selector);
  };

  /**
   *  Joins together the results from several patterns.
   *
   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.
   *  @returns {Observable} Observable sequence with the results form matching several patterns.
   */
  Observable.when = function () {
    var len = arguments.length,
        plans;
    if (Array.isArray(arguments[0])) {
      plans = arguments[0];
    } else {
      plans = new Array(len);
      for (var i = 0; i < len; i++) {
        plans[i] = arguments[i];
      }
    }
    return new AnonymousObservable(function (o) {
      var activePlans = [],
          externalSubscriptions = new Map();
      var outObserver = observerCreate(function (x) {
        o.onNext(x);
      }, function (err) {
        externalSubscriptions.forEach(function (v) {
          v.onError(err);
        });
        o.onError(err);
      }, function (x) {
        o.onCompleted();
      });
      try {
        for (var i = 0, len = plans.length; i < len; i++) {
          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {
            var idx = activePlans.indexOf(activePlan);
            activePlans.splice(idx, 1);
            activePlans.length === 0 && o.onCompleted();
          }));
        }
      } catch (e) {
        return observableThrow(e).subscribe(o);
      }
      var group = new CompositeDisposable();
      externalSubscriptions.forEach(function (joinObserver) {
        joinObserver.subscribe();
        group.add(joinObserver);
      });

      return group;
    });
  };

  var TimerObservable = function (__super__) {
    inherits(TimerObservable, __super__);
    function TimerObservable(dt, s) {
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    TimerObservable.prototype.subscribeCore = function (o) {
      return this._s.scheduleFuture(o, this._dt, scheduleMethod);
    };

    function scheduleMethod(s, o) {
      o.onNext(0);
      o.onCompleted();
    }

    return TimerObservable;
  }(ObservableBase);

  function _observableTimer(dueTime, scheduler) {
    return new TimerObservable(dueTime, scheduler);
  }

  function observableTimerDateAndPeriod(dueTime, period, scheduler) {
    return new AnonymousObservable(function (observer) {
      var d = dueTime,
          p = normalizeTime(period);
      return scheduler.scheduleRecursiveFuture(0, d, function (count, self) {
        if (p > 0) {
          var now = scheduler.now();
          d = new Date(d.getTime() + p);
          d.getTime() <= now && (d = new Date(now + p));
        }
        observer.onNext(count);
        self(count + 1, new Date(d));
      });
    });
  }

  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
    return dueTime === period ? new AnonymousObservable(function (observer) {
      return scheduler.schedulePeriodic(0, period, function (count) {
        observer.onNext(count);
        return count + 1;
      });
    }) : observableDefer(function () {
      return observableTimerDateAndPeriod(new Date(scheduler.now() + dueTime), period, scheduler);
    });
  }

  /**
   *  Returns an observable sequence that produces a value after each period.
   *
   * @example
   *  1 - res = Rx.Observable.interval(1000);
   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);
   *
   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).
   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.
   * @returns {Observable} An observable sequence that produces a value after each period.
   */
  var observableinterval = Observable.interval = function (period, scheduler) {
    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);
  };

  /**
   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.
   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.
   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.
   */
  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {
    var period;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {
      period = periodOrScheduler;
    } else if (isScheduler(periodOrScheduler)) {
      scheduler = periodOrScheduler;
    }
    if ((dueTime instanceof Date || typeof dueTime === 'number') && period === undefined) {
      return _observableTimer(dueTime, scheduler);
    }
    if (dueTime instanceof Date && period !== undefined) {
      return observableTimerDateAndPeriod(dueTime, periodOrScheduler, scheduler);
    }
    return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
  };

  function observableDelayRelative(source, dueTime, scheduler) {
    return new AnonymousObservable(function (o) {
      var active = false,
          cancelable = new SerialDisposable(),
          exception = null,
          q = [],
          running = false,
          subscription;
      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {
        var d, shouldRun;
        if (notification.value.kind === 'E') {
          q = [];
          q.push(notification);
          exception = notification.value.error;
          shouldRun = !running;
        } else {
          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });
          shouldRun = !active;
          active = true;
        }
        if (shouldRun) {
          if (exception !== null) {
            o.onError(exception);
          } else {
            d = new SingleAssignmentDisposable();
            cancelable.setDisposable(d);
            d.setDisposable(scheduler.scheduleRecursiveFuture(null, dueTime, function (_, self) {
              var e, recurseDueTime, result, shouldRecurse;
              if (exception !== null) {
                return;
              }
              running = true;
              do {
                result = null;
                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                  result = q.shift().value;
                }
                if (result !== null) {
                  result.accept(o);
                }
              } while (result !== null);
              shouldRecurse = false;
              recurseDueTime = 0;
              if (q.length > 0) {
                shouldRecurse = true;
                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
              } else {
                active = false;
              }
              e = exception;
              running = false;
              if (e !== null) {
                o.onError(e);
              } else if (shouldRecurse) {
                self(null, recurseDueTime);
              }
            }));
          }
        }
      });
      return new BinaryDisposable(subscription, cancelable);
    }, source);
  }

  function observableDelayAbsolute(source, dueTime, scheduler) {
    return observableDefer(function () {
      return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);
    });
  }

  function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {
    var subDelay, selector;
    if (isFunction(subscriptionDelay)) {
      selector = subscriptionDelay;
    } else {
      subDelay = subscriptionDelay;
      selector = delayDurationSelector;
    }
    return new AnonymousObservable(function (o) {
      var delays = new CompositeDisposable(),
          atEnd = false,
          subscription = new SerialDisposable();

      function start() {
        subscription.setDisposable(source.subscribe(function (x) {
          var delay = tryCatch(selector)(x);
          if (delay === errorObj) {
            return o.onError(delay.e);
          }
          var d = new SingleAssignmentDisposable();
          delays.add(d);
          d.setDisposable(delay.subscribe(function () {
            o.onNext(x);
            delays.remove(d);
            done();
          }, function (e) {
            o.onError(e);
          }, function () {
            o.onNext(x);
            delays.remove(d);
            done();
          }));
        }, function (e) {
          o.onError(e);
        }, function () {
          atEnd = true;
          subscription.dispose();
          done();
        }));
      }

      function done() {
        atEnd && delays.length === 0 && o.onCompleted();
      }

      if (!subDelay) {
        start();
      } else {
        subscription.setDisposable(subDelay.subscribe(start, function (e) {
          o.onError(e);
        }, start));
      }

      return new BinaryDisposable(subscription, delays);
    }, source);
  }

  /**
   *  Time shifts the observable sequence by dueTime.
   *  The relative time intervals between the values are preserved.
   *
   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.
   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Time-shifted sequence.
   */
  observableProto.delay = function () {
    var firstArg = arguments[0];
    if (typeof firstArg === 'number' || firstArg instanceof Date) {
      var dueTime = firstArg,
          scheduler = arguments[1];
      isScheduler(scheduler) || (scheduler = defaultScheduler);
      return dueTime instanceof Date ? observableDelayAbsolute(this, dueTime, scheduler) : observableDelayRelative(this, dueTime, scheduler);
    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
      return delayWithSelector(this, firstArg, arguments[1]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  var DebounceObservable = function (__super__) {
    inherits(DebounceObservable, __super__);
    function DebounceObservable(source, dt, s) {
      isScheduler(s) || (s = defaultScheduler);
      this.source = source;
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    DebounceObservable.prototype.subscribeCore = function (o) {
      var cancelable = new SerialDisposable();
      return new BinaryDisposable(this.source.subscribe(new DebounceObserver(o, this._dt, this._s, cancelable)), cancelable);
    };

    return DebounceObservable;
  }(ObservableBase);

  var DebounceObserver = function (__super__) {
    inherits(DebounceObserver, __super__);
    function DebounceObserver(observer, dueTime, scheduler, cancelable) {
      this._o = observer;
      this._d = dueTime;
      this._scheduler = scheduler;
      this._c = cancelable;
      this._v = null;
      this._hv = false;
      this._id = 0;
      __super__.call(this);
    }

    function scheduleFuture(s, state) {
      state.self._hv && state.self._id === state.currentId && state.self._o.onNext(state.x);
      state.self._hv = false;
    }

    DebounceObserver.prototype.next = function (x) {
      this._hv = true;
      this._v = x;
      var currentId = ++this._id,
          d = new SingleAssignmentDisposable();
      this._c.setDisposable(d);
      d.setDisposable(this._scheduler.scheduleFuture(this, this._d, function (_, self) {
        self._hv && self._id === currentId && self._o.onNext(x);
        self._hv = false;
      }));
    };

    DebounceObserver.prototype.error = function (e) {
      this._c.dispose();
      this._o.onError(e);
      this._hv = false;
      this._id++;
    };

    DebounceObserver.prototype.completed = function () {
      this._c.dispose();
      this._hv && this._o.onNext(this._v);
      this._o.onCompleted();
      this._hv = false;
      this._id++;
    };

    return DebounceObserver;
  }(AbstractObserver);

  function debounceWithSelector(source, durationSelector) {
    return new AnonymousObservable(function (o) {
      var value,
          hasValue = false,
          cancelable = new SerialDisposable(),
          id = 0;
      var subscription = source.subscribe(function (x) {
        var throttle = tryCatch(durationSelector)(x);
        if (throttle === errorObj) {
          return o.onError(throttle.e);
        }

        isPromise(throttle) && (throttle = observableFromPromise(throttle));

        hasValue = true;
        value = x;
        id++;
        var currentid = id,
            d = new SingleAssignmentDisposable();
        cancelable.setDisposable(d);
        d.setDisposable(throttle.subscribe(function () {
          hasValue && id === currentid && o.onNext(value);
          hasValue = false;
          d.dispose();
        }, function (e) {
          o.onError(e);
        }, function () {
          hasValue && id === currentid && o.onNext(value);
          hasValue = false;
          d.dispose();
        }));
      }, function (e) {
        cancelable.dispose();
        o.onError(e);
        hasValue = false;
        id++;
      }, function () {
        cancelable.dispose();
        hasValue && o.onNext(value);
        o.onCompleted();
        hasValue = false;
        id++;
      });
      return new BinaryDisposable(subscription, cancelable);
    }, source);
  }

  observableProto.debounce = function () {
    if (isFunction(arguments[0])) {
      return debounceWithSelector(this, arguments[0]);
    } else if (typeof arguments[0] === 'number') {
      return new DebounceObservable(this, arguments[0], arguments[1]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.
   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).
   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.
   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithTime = observableProto.windowTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
    var source = this,
        timeShift;
    timeShiftOrScheduler == null && (timeShift = timeSpan);
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    if (typeof timeShiftOrScheduler === 'number') {
      timeShift = timeShiftOrScheduler;
    } else if (isScheduler(timeShiftOrScheduler)) {
      timeShift = timeSpan;
      scheduler = timeShiftOrScheduler;
    }
    return new AnonymousObservable(function (observer) {
      var groupDisposable,
          nextShift = timeShift,
          nextSpan = timeSpan,
          q = [],
          refCountDisposable,
          timerD = new SerialDisposable(),
          totalTime = 0;
      groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);

      function createTimer() {
        var m = new SingleAssignmentDisposable(),
            isSpan = false,
            isShift = false;
        timerD.setDisposable(m);
        if (nextSpan === nextShift) {
          isSpan = true;
          isShift = true;
        } else if (nextSpan < nextShift) {
          isSpan = true;
        } else {
          isShift = true;
        }
        var newTotalTime = isSpan ? nextSpan : nextShift,
            ts = newTotalTime - totalTime;
        totalTime = newTotalTime;
        if (isSpan) {
          nextSpan += timeShift;
        }
        if (isShift) {
          nextShift += timeShift;
        }
        m.setDisposable(scheduler.scheduleFuture(null, ts, function () {
          if (isShift) {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          isSpan && q.shift().onCompleted();
          createTimer();
        }));
      };
      q.push(new Subject());
      observer.onNext(addRef(q[0], refCountDisposable));
      createTimer();
      groupDisposable.add(source.subscribe(function (x) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onNext(x);
        }
      }, function (e) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onError(e);
        }
        observer.onError(e);
      }, function () {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onCompleted();
        }
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  /**
   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.
   * @param {Number} timeSpan Maximum time length of a window.
   * @param {Number} count Maximum element count of a window.
   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithTimeOrCount = observableProto.windowTimeOrCount = function (timeSpan, count, scheduler) {
    var source = this;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new AnonymousObservable(function (observer) {
      var timerD = new SerialDisposable(),
          groupDisposable = new CompositeDisposable(timerD),
          refCountDisposable = new RefCountDisposable(groupDisposable),
          n = 0,
          windowId = 0,
          s = new Subject();

      function createTimer(id) {
        var m = new SingleAssignmentDisposable();
        timerD.setDisposable(m);
        m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {
          if (id !== windowId) {
            return;
          }
          n = 0;
          var newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
          createTimer(newId);
        }));
      }

      observer.onNext(addRef(s, refCountDisposable));
      createTimer(0);

      groupDisposable.add(source.subscribe(function (x) {
        var newId = 0,
            newWindow = false;
        s.onNext(x);
        if (++n === count) {
          newWindow = true;
          n = 0;
          newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
        }
        newWindow && createTimer(newId);
      }, function (e) {
        s.onError(e);
        observer.onError(e);
      }, function () {
        s.onCompleted();
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
   * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).
   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.
   * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithTime = observableProto.bufferTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
    return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.
   * @param {Number} timeSpan Maximum time length of a buffer.
   * @param {Number} count Maximum element count of a buffer.
   * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithTimeOrCount = observableProto.bufferTimeOrCount = function (timeSpan, count, scheduler) {
    return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
  };

  var TimeIntervalObservable = function (__super__) {
    inherits(TimeIntervalObservable, __super__);
    function TimeIntervalObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    TimeIntervalObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TimeIntervalObserver(o, this._s));
    };

    return TimeIntervalObservable;
  }(ObservableBase);

  var TimeIntervalObserver = function (__super__) {
    inherits(TimeIntervalObserver, __super__);

    function TimeIntervalObserver(o, s) {
      this._o = o;
      this._s = s;
      this._l = s.now();
      __super__.call(this);
    }

    TimeIntervalObserver.prototype.next = function (x) {
      var now = this._s.now(),
          span = now - this._l;
      this._l = now;
      this._o.onNext({ value: x, interval: span });
    };
    TimeIntervalObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TimeIntervalObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TimeIntervalObserver;
  }(AbstractObserver);

  /**
   *  Records the time interval between consecutive values in an observable sequence.
   *
   * @example
   *  1 - res = source.timeInterval();
   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);
   *
   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence with time interval information on values.
   */
  observableProto.timeInterval = function (scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TimeIntervalObservable(this, scheduler);
  };

  var TimestampObservable = function (__super__) {
    inherits(TimestampObservable, __super__);
    function TimestampObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    TimestampObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TimestampObserver(o, this._s));
    };

    return TimestampObservable;
  }(ObservableBase);

  var TimestampObserver = function (__super__) {
    inherits(TimestampObserver, __super__);
    function TimestampObserver(o, s) {
      this._o = o;
      this._s = s;
      __super__.call(this);
    }

    TimestampObserver.prototype.next = function (x) {
      this._o.onNext({ value: x, timestamp: this._s.now() });
    };

    TimestampObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TimestampObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TimestampObserver;
  }(AbstractObserver);

  /**
   *  Records the timestamp for each value in an observable sequence.
   *
   * @example
   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }
   *  2 - res = source.timestamp(Rx.Scheduler.default);
   *
   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the default scheduler is used.
   * @returns {Observable} An observable sequence with timestamp information on values.
   */
  observableProto.timestamp = function (scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TimestampObservable(this, scheduler);
  };

  var SampleObservable = function (__super__) {
    inherits(SampleObservable, __super__);
    function SampleObservable(source, sampler) {
      this.source = source;
      this._sampler = sampler;
      __super__.call(this);
    }

    SampleObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        atEnd: false,
        value: null,
        hasValue: false,
        sourceSubscription: new SingleAssignmentDisposable()
      };

      state.sourceSubscription.setDisposable(this.source.subscribe(new SampleSourceObserver(state)));
      return new BinaryDisposable(state.sourceSubscription, this._sampler.subscribe(new SamplerObserver(state)));
    };

    return SampleObservable;
  }(ObservableBase);

  var SamplerObserver = function (__super__) {
    inherits(SamplerObserver, __super__);
    function SamplerObserver(s) {
      this._s = s;
      __super__.call(this);
    }

    SamplerObserver.prototype._handleMessage = function () {
      if (this._s.hasValue) {
        this._s.hasValue = false;
        this._s.o.onNext(this._s.value);
      }
      this._s.atEnd && this._s.o.onCompleted();
    };

    SamplerObserver.prototype.next = function () {
      this._handleMessage();
    };
    SamplerObserver.prototype.error = function (e) {
      this._s.onError(e);
    };
    SamplerObserver.prototype.completed = function () {
      this._handleMessage();
    };

    return SamplerObserver;
  }(AbstractObserver);

  var SampleSourceObserver = function (__super__) {
    inherits(SampleSourceObserver, __super__);
    function SampleSourceObserver(s) {
      this._s = s;
      __super__.call(this);
    }

    SampleSourceObserver.prototype.next = function (x) {
      this._s.hasValue = true;
      this._s.value = x;
    };
    SampleSourceObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    SampleSourceObserver.prototype.completed = function () {
      this._s.atEnd = true;
      this._s.sourceSubscription.dispose();
    };

    return SampleSourceObserver;
  }(AbstractObserver);

  /**
   *  Samples the observable sequence at each interval.
   *
   * @example
   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence
   *  2 - res = source.sample(5000); // 5 seconds
   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds
   *
   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.
   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Sampled observable sequence.
   */
  observableProto.sample = function (intervalOrSampler, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return typeof intervalOrSampler === 'number' ? new SampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : new SampleObservable(this, intervalOrSampler);
  };

  var TimeoutError = Rx.TimeoutError = function (message) {
    this.message = message || 'Timeout has occurred';
    this.name = 'TimeoutError';
    Error.call(this);
  };
  TimeoutError.prototype = Object.create(Error.prototype);

  function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {
    if (isFunction(firstTimeout)) {
      other = timeoutDurationSelector;
      timeoutDurationSelector = firstTimeout;
      firstTimeout = observableNever();
    }
    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));
    return new AnonymousObservable(function (o) {
      var subscription = new SerialDisposable(),
          timer = new SerialDisposable(),
          original = new SingleAssignmentDisposable();

      subscription.setDisposable(original);

      var id = 0,
          switched = false;

      function setTimer(timeout) {
        var myId = id,
            d = new SingleAssignmentDisposable();

        function timerWins() {
          switched = myId === id;
          return switched;
        }

        timer.setDisposable(d);
        d.setDisposable(timeout.subscribe(function () {
          timerWins() && subscription.setDisposable(other.subscribe(o));
          d.dispose();
        }, function (e) {
          timerWins() && o.onError(e);
        }, function () {
          timerWins() && subscription.setDisposable(other.subscribe(o));
        }));
      };

      setTimer(firstTimeout);

      function oWins() {
        var res = !switched;
        if (res) {
          id++;
        }
        return res;
      }

      original.setDisposable(source.subscribe(function (x) {
        if (oWins()) {
          o.onNext(x);
          var timeout = tryCatch(timeoutDurationSelector)(x);
          if (timeout === errorObj) {
            return o.onError(timeout.e);
          }
          setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
        }
      }, function (e) {
        oWins() && o.onError(e);
      }, function () {
        oWins() && o.onCompleted();
      }));
      return new BinaryDisposable(subscription, timer);
    }, source);
  }

  function timeout(source, dueTime, other, scheduler) {
    if (isScheduler(other)) {
      scheduler = other;
      other = observableThrow(new TimeoutError());
    }
    if (other instanceof Error) {
      other = observableThrow(other);
    }
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));
    return new AnonymousObservable(function (o) {
      var id = 0,
          original = new SingleAssignmentDisposable(),
          subscription = new SerialDisposable(),
          switched = false,
          timer = new SerialDisposable();

      subscription.setDisposable(original);

      function createTimer() {
        var myId = id;
        timer.setDisposable(scheduler.scheduleFuture(null, dueTime, function () {
          switched = id === myId;
          if (switched) {
            isPromise(other) && (other = observableFromPromise(other));
            subscription.setDisposable(other.subscribe(o));
          }
        }));
      }

      createTimer();

      original.setDisposable(source.subscribe(function (x) {
        if (!switched) {
          id++;
          o.onNext(x);
          createTimer();
        }
      }, function (e) {
        if (!switched) {
          id++;
          o.onError(e);
        }
      }, function () {
        if (!switched) {
          id++;
          o.onCompleted();
        }
      }));
      return new BinaryDisposable(subscription, timer);
    }, source);
  }

  observableProto.timeout = function () {
    var firstArg = arguments[0];
    if (firstArg instanceof Date || typeof firstArg === 'number') {
      return timeout(this, firstArg, arguments[1], arguments[2]);
    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
      return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  var GenerateAbsoluteObservable = function (__super__) {
    inherits(GenerateAbsoluteObservable, __super__);
    function GenerateAbsoluteObservable(state, cndFn, itrFn, resFn, timeFn, s) {
      this._state = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._timeFn = timeFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      state.hasResult && state.o.onNext(state.result);

      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }
      state.hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (state.hasResult === errorObj) {
        return state.o.onError(state.hasResult.e);
      }
      if (state.hasResult) {
        state.result = tryCatch(state.self._resFn)(state.newState);
        if (state.result === errorObj) {
          return state.o.onError(state.result.e);
        }
        var time = tryCatch(state.self._timeFn)(state.newState);
        if (time === errorObj) {
          return state.o.onError(time.e);
        }
        recurse(state, time);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateAbsoluteObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        newState: this._state,
        first: true,
        hasResult: false
      };
      return this._s.scheduleRecursiveFuture(state, new Date(this._s.now()), scheduleRecursive);
    };

    return GenerateAbsoluteObservable;
  }(ObservableBase);

  /**
   *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithAbsoluteTime(0,
   *      function (x) { return return true; },
   *      function (x) { return x + 1; },
   *      function (x) { return x; },
   *      function (x) { return new Date(); }
   *  });
   *
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.
   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns {Observable} The generated sequence.
   */
  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
  };

  var GenerateRelativeObservable = function (__super__) {
    inherits(GenerateRelativeObservable, __super__);
    function GenerateRelativeObservable(state, cndFn, itrFn, resFn, timeFn, s) {
      this._state = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._timeFn = timeFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      state.hasResult && state.o.onNext(state.result);

      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }

      state.hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (state.hasResult === errorObj) {
        return state.o.onError(state.hasResult.e);
      }
      if (state.hasResult) {
        state.result = tryCatch(state.self._resFn)(state.newState);
        if (state.result === errorObj) {
          return state.o.onError(state.result.e);
        }
        var time = tryCatch(state.self._timeFn)(state.newState);
        if (time === errorObj) {
          return state.o.onError(time.e);
        }
        recurse(state, time);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateRelativeObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        newState: this._state,
        first: true,
        hasResult: false
      };
      return this._s.scheduleRecursiveFuture(state, 0, scheduleRecursive);
    };

    return GenerateRelativeObservable;
  }(ObservableBase);

  /**
   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithRelativeTime(0,
   *      function (x) { return return true; },
   *      function (x) { return x + 1; },
   *      function (x) { return x; },
   *      function (x) { return 500; }
   *  );
   *
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.
   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns {Observable} The generated sequence.
   */
  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
  };

  var DelaySubscription = function (__super__) {
    inherits(DelaySubscription, __super__);
    function DelaySubscription(source, dt, s) {
      this.source = source;
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    DelaySubscription.prototype.subscribeCore = function (o) {
      var d = new SerialDisposable();

      d.setDisposable(this._s.scheduleFuture([this.source, o, d], this._dt, scheduleMethod));

      return d;
    };

    function scheduleMethod(s, state) {
      var source = state[0],
          o = state[1],
          d = state[2];
      d.setDisposable(source.subscribe(o));
    }

    return DelaySubscription;
  }(ObservableBase);

  /**
   *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
   *
   * @example
   *  1 - res = source.delaySubscription(5000); // 5s
   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds
   *
   * @param {Number} dueTime Relative or absolute time shift of the subscription.
   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Time-shifted sequence.
   */
  observableProto.delaySubscription = function (dueTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new DelaySubscription(this, dueTime, scheduler);
  };

  var SkipLastWithTimeObservable = function (__super__) {
    inherits(SkipLastWithTimeObservable, __super__);
    function SkipLastWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    SkipLastWithTimeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipLastWithTimeObserver(o, this));
    };

    return SkipLastWithTimeObservable;
  }(ObservableBase);

  var SkipLastWithTimeObserver = function (__super__) {
    inherits(SkipLastWithTimeObserver, __super__);

    function SkipLastWithTimeObserver(o, p) {
      this._o = o;
      this._s = p._s;
      this._d = p._d;
      this._q = [];
      __super__.call(this);
    }

    SkipLastWithTimeObserver.prototype.next = function (x) {
      var now = this._s.now();
      this._q.push({ interval: now, value: x });
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._o.onNext(this._q.shift().value);
      }
    };
    SkipLastWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipLastWithTimeObserver.prototype.completed = function () {
      var now = this._s.now();
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._o.onNext(this._q.shift().value);
      }
      this._o.onCompleted();
    };

    return SkipLastWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for skipping elements from the end of the sequence.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout
   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
   */
  observableProto.skipLastWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipLastWithTimeObservable(this, duration, scheduler);
  };

  var TakeLastWithTimeObservable = function (__super__) {
    inherits(TakeLastWithTimeObservable, __super__);
    function TakeLastWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    TakeLastWithTimeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeLastWithTimeObserver(o, this._d, this._s));
    };

    return TakeLastWithTimeObservable;
  }(ObservableBase);

  var TakeLastWithTimeObserver = function (__super__) {
    inherits(TakeLastWithTimeObserver, __super__);

    function TakeLastWithTimeObserver(o, d, s) {
      this._o = o;
      this._d = d;
      this._s = s;
      this._q = [];
      __super__.call(this);
    }

    TakeLastWithTimeObserver.prototype.next = function (x) {
      var now = this._s.now();
      this._q.push({ interval: now, value: x });
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._q.shift();
      }
    };
    TakeLastWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeLastWithTimeObserver.prototype.completed = function () {
      var now = this._s.now();
      while (this._q.length > 0) {
        var next = this._q.shift();
        if (now - next.interval <= this._d) {
          this._o.onNext(next.value);
        }
      }
      this._o.onCompleted();
    };

    return TakeLastWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the end of the sequence.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.
   */
  observableProto.takeLastWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TakeLastWithTimeObservable(this, duration, scheduler);
  };

  /**
   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the end of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.
   */
  observableProto.takeLastBufferWithTime = function (duration, scheduler) {
    var source = this;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new AnonymousObservable(function (o) {
      var q = [];
      return source.subscribe(function (x) {
        var now = scheduler.now();
        q.push({ interval: now, value: x });
        while (q.length > 0 && now - q[0].interval >= duration) {
          q.shift();
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        var now = scheduler.now(),
            res = [];
        while (q.length > 0) {
          var next = q.shift();
          now - next.interval <= duration && res.push(next.value);
        }
        o.onNext(res);
        o.onCompleted();
      });
    }, source);
  };

  var TakeWithTimeObservable = function (__super__) {
    inherits(TakeWithTimeObservable, __super__);
    function TakeWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    function scheduleMethod(s, o) {
      o.onCompleted();
    }

    TakeWithTimeObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._s.scheduleFuture(o, this._d, scheduleMethod), this.source.subscribe(o));
    };

    return TakeWithTimeObservable;
  }(ObservableBase);

  /**
   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   *
   * @example
   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the start of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.
   */
  observableProto.takeWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TakeWithTimeObservable(this, duration, scheduler);
  };

  var SkipWithTimeObservable = function (__super__) {
    inherits(SkipWithTimeObservable, __super__);
    function SkipWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      this._open = false;
      __super__.call(this);
    }

    function scheduleMethod(s, self) {
      self._open = true;
    }

    SkipWithTimeObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._s.scheduleFuture(this, this._d, scheduleMethod), this.source.subscribe(new SkipWithTimeObserver(o, this)));
    };

    return SkipWithTimeObservable;
  }(ObservableBase);

  var SkipWithTimeObserver = function (__super__) {
    inherits(SkipWithTimeObserver, __super__);

    function SkipWithTimeObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipWithTimeObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };
    SkipWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipWithTimeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.
   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded
   *  may not execute immediately, despite the zero due time.
   *
   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.
   * @param {Number} duration Duration for skipping elements from the start of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
   */
  observableProto.skipWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipWithTimeObservable(this, duration, scheduler);
  };

  var SkipUntilWithTimeObservable = function (__super__) {
    inherits(SkipUntilWithTimeObservable, __super__);
    function SkipUntilWithTimeObservable(source, startTime, scheduler) {
      this.source = source;
      this._st = startTime;
      this._s = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(s, state) {
      state._open = true;
    }

    SkipUntilWithTimeObservable.prototype.subscribeCore = function (o) {
      this._open = false;
      return new BinaryDisposable(this._s.scheduleFuture(this, this._st, scheduleMethod), this.source.subscribe(new SkipUntilWithTimeObserver(o, this)));
    };

    return SkipUntilWithTimeObservable;
  }(ObservableBase);

  var SkipUntilWithTimeObserver = function (__super__) {
    inherits(SkipUntilWithTimeObserver, __super__);

    function SkipUntilWithTimeObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipUntilWithTimeObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };
    SkipUntilWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipUntilWithTimeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipUntilWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.
   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.
   *
   * @examples
   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);
   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);
   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.
   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.
   */
  observableProto.skipUntilWithTime = function (startTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipUntilWithTimeObservable(this, startTime, scheduler);
  };

  /**
   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.
   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.
   * @param {Scheduler} [scheduler] Scheduler to run the timer on.
   * @returns {Observable} An observable sequence with the elements taken until the specified end time.
   */
  observableProto.takeUntilWithTime = function (endTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    var source = this;
    return new AnonymousObservable(function (o) {
      return new BinaryDisposable(scheduler.scheduleFuture(o, endTime, function (_, o) {
        o.onCompleted();
      }), source.subscribe(o));
    }, source);
  };

  /**
   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.
   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item
   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.
   * @returns {Observable} An Observable that performs the throttle operation.
   */
  observableProto.throttle = function (windowDuration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    var duration = +windowDuration || 0;
    if (duration <= 0) {
      throw new RangeError('windowDuration cannot be less or equal zero.');
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      var lastOnNext = 0;
      return source.subscribe(function (x) {
        var now = scheduler.now();
        if (lastOnNext === 0 || now - lastOnNext >= duration) {
          lastOnNext = now;
          o.onNext(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        o.onCompleted();
      });
    }, source);
  };

  var TransduceObserver = function (__super__) {
    inherits(TransduceObserver, __super__);
    function TransduceObserver(o, xform) {
      this._o = o;
      this._xform = xform;
      __super__.call(this);
    }

    TransduceObserver.prototype.next = function (x) {
      var res = tryCatch(this._xform['@@transducer/step']).call(this._xform, this._o, x);
      if (res === errorObj) {
        this._o.onError(res.e);
      }
    };

    TransduceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TransduceObserver.prototype.completed = function () {
      this._xform['@@transducer/result'](this._o);
    };

    return TransduceObserver;
  }(AbstractObserver);

  function transformForObserver(o) {
    return {
      '@@transducer/init': function transducerInit() {
        return o;
      },
      '@@transducer/step': function transducerStep(obs, input) {
        return obs.onNext(input);
      },
      '@@transducer/result': function transducerResult(obs) {
        return obs.onCompleted();
      }
    };
  }

  /**
   * Executes a transducer to transform the observable sequence
   * @param {Transducer} transducer A transducer to execute
   * @returns {Observable} An Observable sequence containing the results from the transducer.
   */
  observableProto.transduce = function (transducer) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var xform = transducer(transformForObserver(o));
      return source.subscribe(new TransduceObserver(o, xform));
    }, source);
  };

  var SwitchFirstObservable = function (__super__) {
    inherits(SwitchFirstObservable, __super__);
    function SwitchFirstObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    SwitchFirstObservable.prototype.subscribeCore = function (o) {
      var m = new SingleAssignmentDisposable(),
          g = new CompositeDisposable(),
          state = {
        hasCurrent: false,
        isStopped: false,
        o: o,
        g: g
      };

      g.add(m);
      m.setDisposable(this.source.subscribe(new SwitchFirstObserver(state)));
      return g;
    };

    return SwitchFirstObservable;
  }(ObservableBase);

  var SwitchFirstObserver = function (__super__) {
    inherits(SwitchFirstObserver, __super__);
    function SwitchFirstObserver(state) {
      this._s = state;
      __super__.call(this);
    }

    SwitchFirstObserver.prototype.next = function (x) {
      if (!this._s.hasCurrent) {
        this._s.hasCurrent = true;
        isPromise(x) && (x = observableFromPromise(x));
        var inner = new SingleAssignmentDisposable();
        this._s.g.add(inner);
        inner.setDisposable(x.subscribe(new InnerObserver(this._s, inner)));
      }
    };

    SwitchFirstObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    SwitchFirstObserver.prototype.completed = function () {
      this._s.isStopped = true;
      !this._s.hasCurrent && this._s.g.length === 1 && this._s.o.onCompleted();
    };

    inherits(InnerObserver, __super__);
    function InnerObserver(state, inner) {
      this._s = state;
      this._i = inner;
      __super__.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this._s.g.remove(this._i);
      this._s.hasCurrent = false;
      this._s.isStopped && this._s.g.length === 1 && this._s.o.onCompleted();
    };

    return SwitchFirstObserver;
  }(AbstractObserver);

  /**
   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.
   */
  observableProto.switchFirst = function () {
    return new SwitchFirstObservable(this);
  };

  observableProto.flatMapFirst = observableProto.exhaustMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
  };

  observableProto.flatMapWithMaxConcurrent = observableProto.flatMapMaxConcurrent = function (limit, selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
  };

  /** Provides a set of extension methods for virtual time scheduling. */
  var VirtualTimeScheduler = Rx.VirtualTimeScheduler = function (__super__) {
    inherits(VirtualTimeScheduler, __super__);

    /**
     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.
     *
     * @constructor
     * @param {Number} initialClock Initial value for the clock.
     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
     */
    function VirtualTimeScheduler(initialClock, comparer) {
      this.clock = initialClock;
      this.comparer = comparer;
      this.isEnabled = false;
      this.queue = new PriorityQueue(1024);
      __super__.call(this);
    }

    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

    VirtualTimeSchedulerPrototype.now = function () {
      return this.toAbsoluteTime(this.clock);
    };

    VirtualTimeSchedulerPrototype.schedule = function (state, action) {
      return this.scheduleAbsolute(state, this.clock, action);
    };

    VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
      var dt = dueTime instanceof Date ? this.toRelativeTime(dueTime - this.now()) : this.toRelativeTime(dueTime);

      return this.scheduleRelative(state, dt, action);
    };

    /**
     * Adds a relative time value to an absolute time value.
     * @param {Number} absolute Absolute virtual time value.
     * @param {Number} relative Relative virtual time value to add.
     * @return {Number} Resulting absolute virtual time sum value.
     */
    VirtualTimeSchedulerPrototype.add = notImplemented;

    /**
     * Converts an absolute time to a number
     * @param {Any} The absolute time.
     * @returns {Number} The absolute time in ms
     */
    VirtualTimeSchedulerPrototype.toAbsoluteTime = notImplemented;

    /**
     * Converts the TimeSpan value to a relative virtual time value.
     * @param {Number} timeSpan TimeSpan value to convert.
     * @return {Number} Corresponding relative virtual time value.
     */
    VirtualTimeSchedulerPrototype.toRelativeTime = notImplemented;

    /**
     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.
     * @param {Mixed} state Initial state passed to the action upon the first iteration.
     * @param {Number} period Period for running the work periodically.
     * @param {Function} action Action to be executed, potentially updating the state.
     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
     */
    VirtualTimeSchedulerPrototype.schedulePeriodic = function (state, period, action) {
      var s = new SchedulePeriodicRecursive(this, state, period, action);
      return s.start();
    };

    /**
     * Schedules an action to be executed after dueTime.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Number} dueTime Relative time after which to execute the action.
     * @param {Function} action Action to be executed.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    VirtualTimeSchedulerPrototype.scheduleRelative = function (state, dueTime, action) {
      var runAt = this.add(this.clock, dueTime);
      return this.scheduleAbsolute(state, runAt, action);
    };

    /**
     * Starts the virtual time scheduler.
     */
    VirtualTimeSchedulerPrototype.start = function () {
      if (!this.isEnabled) {
        this.isEnabled = true;
        do {
          var next = this.getNext();
          if (next !== null) {
            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
            next.invoke();
          } else {
            this.isEnabled = false;
          }
        } while (this.isEnabled);
      }
    };

    /**
     * Stops the virtual time scheduler.
     */
    VirtualTimeSchedulerPrototype.stop = function () {
      this.isEnabled = false;
    };

    /**
     * Advances the scheduler's clock to the specified time, running all work till that point.
     * @param {Number} time Absolute time to advance the scheduler's clock to.
     */
    VirtualTimeSchedulerPrototype.advanceTo = function (time) {
      var dueToClock = this.comparer(this.clock, time);
      if (this.comparer(this.clock, time) > 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (dueToClock === 0) {
        return;
      }
      if (!this.isEnabled) {
        this.isEnabled = true;
        do {
          var next = this.getNext();
          if (next !== null && this.comparer(next.dueTime, time) <= 0) {
            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
            next.invoke();
          } else {
            this.isEnabled = false;
          }
        } while (this.isEnabled);
        this.clock = time;
      }
    };

    /**
     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.
     * @param {Number} time Relative time to advance the scheduler's clock by.
     */
    VirtualTimeSchedulerPrototype.advanceBy = function (time) {
      var dt = this.add(this.clock, time),
          dueToClock = this.comparer(this.clock, dt);
      if (dueToClock > 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (dueToClock === 0) {
        return;
      }

      this.advanceTo(dt);
    };

    /**
     * Advances the scheduler's clock by the specified relative time.
     * @param {Number} time Relative time to advance the scheduler's clock by.
     */
    VirtualTimeSchedulerPrototype.sleep = function (time) {
      var dt = this.add(this.clock, time);
      if (this.comparer(this.clock, dt) >= 0) {
        throw new ArgumentOutOfRangeError();
      }

      this.clock = dt;
    };

    /**
     * Gets the next scheduled item to be executed.
     * @returns {ScheduledItem} The next scheduled item.
     */
    VirtualTimeSchedulerPrototype.getNext = function () {
      while (this.queue.length > 0) {
        var next = this.queue.peek();
        if (next.isCancelled()) {
          this.queue.dequeue();
        } else {
          return next;
        }
      }
      return null;
    };

    /**
     * Schedules an action to be executed at dueTime.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Number} dueTime Absolute time at which to execute the action.
     * @param {Function} action Action to be executed.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (state, dueTime, action) {
      var self = this;

      function run(scheduler, state1) {
        self.queue.remove(si);
        return action(scheduler, state1);
      }

      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
      this.queue.enqueue(si);

      return si.disposable;
    };

    return VirtualTimeScheduler;
  }(Scheduler);

  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */
  Rx.HistoricalScheduler = function (__super__) {
    inherits(HistoricalScheduler, __super__);

    /**
     * Creates a new historical scheduler with the specified initial clock value.
     * @constructor
     * @param {Number} initialClock Initial value for the clock.
     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
     */
    function HistoricalScheduler(initialClock, comparer) {
      var clock = initialClock == null ? 0 : initialClock;
      var cmp = comparer || defaultSubComparer;
      __super__.call(this, clock, cmp);
    }

    var HistoricalSchedulerProto = HistoricalScheduler.prototype;

    /**
     * Adds a relative time value to an absolute time value.
     * @param {Number} absolute Absolute virtual time value.
     * @param {Number} relative Relative virtual time value to add.
     * @return {Number} Resulting absolute virtual time sum value.
     */
    HistoricalSchedulerProto.add = function (absolute, relative) {
      return absolute + relative;
    };

    HistoricalSchedulerProto.toAbsoluteTime = function (absolute) {
      return new Date(absolute).getTime();
    };

    /**
     * Converts the TimeSpan value to a relative virtual time value.
     * @memberOf HistoricalScheduler
     * @param {Number} timeSpan TimeSpan value to convert.
     * @return {Number} Corresponding relative virtual time value.
     */
    HistoricalSchedulerProto.toRelativeTime = function (timeSpan) {
      return timeSpan;
    };

    return HistoricalScheduler;
  }(Rx.VirtualTimeScheduler);

  function OnNextPredicate(predicate) {
    this.predicate = predicate;
  }

  OnNextPredicate.prototype.equals = function (other) {
    if (other === this) {
      return true;
    }
    if (other == null) {
      return false;
    }
    if (other.kind !== 'N') {
      return false;
    }
    return this.predicate(other.value);
  };

  function OnErrorPredicate(predicate) {
    this.predicate = predicate;
  }

  OnErrorPredicate.prototype.equals = function (other) {
    if (other === this) {
      return true;
    }
    if (other == null) {
      return false;
    }
    if (other.kind !== 'E') {
      return false;
    }
    return this.predicate(other.error);
  };

  var ReactiveTest = Rx.ReactiveTest = {
    /** Default virtual time used for creation of observable sequences in unit tests. */
    created: 100,
    /** Default virtual time used to subscribe to observable sequences in unit tests. */
    subscribed: 200,
    /** Default virtual time used to dispose subscriptions in unit tests. */
    disposed: 1000,

    /**
     * Factory method for an OnNext notification record at a given time with a given value or a predicate function.
     *
     * 1 - ReactiveTest.onNext(200, 42);
     * 2 - ReactiveTest.onNext(200, function (x) { return x.length == 2; });
     *
     * @param ticks Recorded virtual time the OnNext notification occurs.
     * @param value Recorded value stored in the OnNext notification or a predicate.
     * @return Recorded OnNext notification.
     */
    onNext: function onNext(ticks, value) {
      return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
    },
    /**
     * Factory method for an OnError notification record at a given time with a given error.
     *
     * 1 - ReactiveTest.onNext(200, new Error('error'));
     * 2 - ReactiveTest.onNext(200, function (e) { return e.message === 'error'; });
     *
     * @param ticks Recorded virtual time the OnError notification occurs.
     * @param exception Recorded exception stored in the OnError notification.
     * @return Recorded OnError notification.
     */
    onError: function onError(ticks, error) {
      return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
    },
    /**
     * Factory method for an OnCompleted notification record at a given time.
     *
     * @param ticks Recorded virtual time the OnCompleted notification occurs.
     * @return Recorded OnCompleted notification.
     */
    onCompleted: function onCompleted(ticks) {
      return new Recorded(ticks, Notification.createOnCompleted());
    },
    /**
     * Factory method for a subscription record based on a given subscription and disposal time.
     *
     * @param start Virtual time indicating when the subscription was created.
     * @param end Virtual time indicating when the subscription was disposed.
     * @return Subscription object.
     */
    subscribe: function subscribe(start, end) {
      return new Subscription(start, end);
    }
  };

  /**
   * Creates a new object recording the production of the specified value at the given virtual time.
   *
   * @constructor
   * @param {Number} time Virtual time the value was produced on.
   * @param {Mixed} value Value that was produced.
   * @param {Function} comparer An optional comparer.
   */
  var Recorded = Rx.Recorded = function (time, value, comparer) {
    this.time = time;
    this.value = value;
    this.comparer = comparer || defaultComparer;
  };

  /**
   * Checks whether the given recorded object is equal to the current instance.
   *
   * @param {Recorded} other Recorded object to check for equality.
   * @returns {Boolean} true if both objects are equal; false otherwise.
   */
  Recorded.prototype.equals = function (other) {
    return this.time === other.time && this.comparer(this.value, other.value);
  };

  /**
   * Returns a string representation of the current Recorded value.
   *
   * @returns {String} String representation of the current Recorded value.
   */
  Recorded.prototype.toString = function () {
    return this.value.toString() + '@' + this.time;
  };

  /**
   * Creates a new subscription object with the given virtual subscription and unsubscription time.
   *
   * @constructor
   * @param {Number} subscribe Virtual time at which the subscription occurred.
   * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.
   */
  var Subscription = Rx.Subscription = function (start, end) {
    this.subscribe = start;
    this.unsubscribe = end || Number.MAX_VALUE;
  };

  /**
   * Checks whether the given subscription is equal to the current instance.
   * @param other Subscription object to check for equality.
   * @returns {Boolean} true if both objects are equal; false otherwise.
   */
  Subscription.prototype.equals = function (other) {
    return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
  };

  /**
   * Returns a string representation of the current Subscription value.
   * @returns {String} String representation of the current Subscription value.
   */
  Subscription.prototype.toString = function () {
    return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
  };

  var MockDisposable = Rx.MockDisposable = function (scheduler) {
    this.scheduler = scheduler;
    this.disposes = [];
    this.disposes.push(this.scheduler.clock);
  };

  MockDisposable.prototype.dispose = function () {
    this.disposes.push(this.scheduler.clock);
  };

  var MockObserver = function (__super__) {
    inherits(MockObserver, __super__);

    function MockObserver(scheduler) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = [];
    }

    var MockObserverPrototype = MockObserver.prototype;

    MockObserverPrototype.onNext = function (value) {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
    };

    MockObserverPrototype.onError = function (e) {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(e)));
    };

    MockObserverPrototype.onCompleted = function () {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
    };

    return MockObserver;
  }(Observer);

  function MockPromise(scheduler, messages) {
    var self = this;
    this.scheduler = scheduler;
    this.messages = messages;
    this.subscriptions = [];
    this.observers = [];
    for (var i = 0, len = this.messages.length; i < len; i++) {
      var message = this.messages[i],
          notification = message.value;
      (function (innerNotification) {
        scheduler.scheduleAbsolute(null, message.time, function () {
          var obs = self.observers.slice(0);

          for (var j = 0, jLen = obs.length; j < jLen; j++) {
            innerNotification.accept(obs[j]);
          }
          return disposableEmpty;
        });
      })(notification);
    }
  }

  MockPromise.prototype.then = function (onResolved, onRejected) {
    var self = this;

    this.subscriptions.push(new Subscription(this.scheduler.clock));
    var index = this.subscriptions.length - 1;

    var newPromise;

    var observer = Rx.Observer.create(function (x) {
      var retValue = onResolved(x);
      if (retValue && typeof retValue.then === 'function') {
        newPromise = retValue;
      } else {
        var ticks = self.scheduler.clock;
        newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
      }
      var idx = self.observers.indexOf(observer);
      self.observers.splice(idx, 1);
      self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
    }, function (err) {
      onRejected(err);
      var idx = self.observers.indexOf(observer);
      self.observers.splice(idx, 1);
      self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
    });
    this.observers.push(observer);

    return newPromise || new MockPromise(this.scheduler, this.messages);
  };

  var HotObservable = function (__super__) {
    inherits(HotObservable, __super__);

    function HotObservable(scheduler, messages) {
      __super__.call(this);
      var message,
          notification,
          observable = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0, len = this.messages.length; i < len; i++) {
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) {
          scheduler.scheduleAbsolute(null, message.time, function () {
            var obs = observable.observers.slice(0);

            for (var j = 0, jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }

    HotObservable.prototype._subscribe = function (o) {
      var observable = this;
      this.observers.push(o);
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      return disposableCreate(function () {
        var idx = observable.observers.indexOf(o);
        observable.observers.splice(idx, 1);
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
      });
    };

    return HotObservable;
  }(Observable);

  var ColdObservable = function (__super__) {
    inherits(ColdObservable, __super__);

    function ColdObservable(scheduler, messages) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
    }

    ColdObservable.prototype._subscribe = function (o) {
      var message,
          notification,
          observable = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var d = new CompositeDisposable();
      for (var i = 0, len = this.messages.length; i < len; i++) {
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) {
          d.add(observable.scheduler.scheduleRelative(null, message.time, function () {
            innerNotification.accept(o);
            return disposableEmpty;
          }));
        })(notification);
      }
      return disposableCreate(function () {
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        d.dispose();
      });
    };

    return ColdObservable;
  }(Observable);

  /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */
  Rx.TestScheduler = function (__super__) {
    inherits(TestScheduler, __super__);

    function baseComparer(x, y) {
      return x > y ? 1 : x < y ? -1 : 0;
    }

    function TestScheduler() {
      __super__.call(this, 0, baseComparer);
    }

    /**
     * Schedules an action to be executed at the specified virtual time.
     *
     * @param state State passed to the action to be executed.
     * @param dueTime Absolute virtual time at which to execute the action.
     * @param action Action to be executed.
     * @return Disposable object used to cancel the scheduled action (best effort).
     */
    TestScheduler.prototype.scheduleAbsolute = function (state, dueTime, action) {
      dueTime <= this.clock && (dueTime = this.clock + 1);
      return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);
    };
    /**
     * Adds a relative virtual time to an absolute virtual time value.
     *
     * @param absolute Absolute virtual time value.
     * @param relative Relative virtual time value to add.
     * @return Resulting absolute virtual time sum value.
     */
    TestScheduler.prototype.add = function (absolute, relative) {
      return absolute + relative;
    };
    /**
     * Converts the absolute virtual time value to a DateTimeOffset value.
     *
     * @param absolute Absolute virtual time value to convert.
     * @return Corresponding DateTimeOffset value.
     */
    TestScheduler.prototype.toAbsoluteTime = function (absolute) {
      return new Date(absolute).getTime();
    };
    /**
     * Converts the TimeSpan value to a relative virtual time value.
     *
     * @param timeSpan TimeSpan value to convert.
     * @return Corresponding relative virtual time value.
     */
    TestScheduler.prototype.toRelativeTime = function (timeSpan) {
      return timeSpan;
    };
    /**
     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
     *
     * @param create Factory method to create an observable sequence.
     * @param created Virtual time at which to invoke the factory to create an observable sequence.
     * @param subscribed Virtual time at which to subscribe to the created observable sequence.
     * @param disposed Virtual time at which to dispose the subscription.
     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.
     */
    TestScheduler.prototype.startScheduler = function (createFn, settings) {
      settings || (settings = {});
      settings.created == null && (settings.created = ReactiveTest.created);
      settings.subscribed == null && (settings.subscribed = ReactiveTest.subscribed);
      settings.disposed == null && (settings.disposed = ReactiveTest.disposed);

      var observer = this.createObserver(),
          source,
          subscription;

      this.scheduleAbsolute(null, settings.created, function () {
        source = createFn();
        return disposableEmpty;
      });

      this.scheduleAbsolute(null, settings.subscribed, function () {
        subscription = source.subscribe(observer);
        return disposableEmpty;
      });

      this.scheduleAbsolute(null, settings.disposed, function () {
        subscription.dispose();
        return disposableEmpty;
      });

      this.start();

      return observer;
    };

    /**
     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.
     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createHotObservable = function () {
      var len = arguments.length,
          args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return new HotObservable(this, args);
    };

    /**
     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.
     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createColdObservable = function () {
      var len = arguments.length,
          args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return new ColdObservable(this, args);
    };

    /**
     * Creates a resolved promise with the given value and ticks
     * @param {Number} ticks The absolute time of the resolution.
     * @param {Any} value The value to yield at the given tick.
     * @returns {MockPromise} A mock Promise which fulfills with the given value.
     */
    TestScheduler.prototype.createResolvedPromise = function (ticks, value) {
      return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
    };

    /**
     * Creates a rejected promise with the given reason and ticks
     * @param {Number} ticks The absolute time of the resolution.
     * @param {Any} reason The reason for rejection to yield at the given tick.
     * @returns {MockPromise} A mock Promise which rejects with the given reason.
     */
    TestScheduler.prototype.createRejectedPromise = function (ticks, reason) {
      return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
    };

    /**
     * Creates an observer that records received notification messages and timestamps those.
     * @return Observer that can be used to assert the timing of received notifications.
     */
    TestScheduler.prototype.createObserver = function () {
      return new MockObserver(this);
    };

    return TestScheduler;
  }(VirtualTimeScheduler);

  var AnonymousObservable = Rx.AnonymousObservable = function (__super__) {
    inherits(AnonymousObservable, __super__);

    // Fix subscriber to check for undefined or function returned to decorate as Disposable
    function fixSubscriber(subscriber) {
      return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
    }

    function setDisposable(s, state) {
      var ado = state[0],
          self = state[1];
      var sub = tryCatch(self.__subscribe).call(self, ado);
      if (sub === errorObj && !ado.fail(errorObj.e)) {
        thrower(errorObj.e);
      }
      ado.setDisposable(fixSubscriber(sub));
    }

    function AnonymousObservable(subscribe, parent) {
      this.source = parent;
      this.__subscribe = subscribe;
      __super__.call(this);
    }

    AnonymousObservable.prototype._subscribe = function (o) {
      var ado = new AutoDetachObserver(o),
          state = [ado, this];

      if (currentThreadScheduler.scheduleRequired()) {
        currentThreadScheduler.schedule(state, setDisposable);
      } else {
        setDisposable(null, state);
      }
      return ado;
    };

    return AnonymousObservable;
  }(Observable);

  var AutoDetachObserver = function (__super__) {
    inherits(AutoDetachObserver, __super__);

    function AutoDetachObserver(observer) {
      __super__.call(this);
      this.observer = observer;
      this.m = new SingleAssignmentDisposable();
    }

    var AutoDetachObserverPrototype = AutoDetachObserver.prototype;

    AutoDetachObserverPrototype.next = function (value) {
      var result = tryCatch(this.observer.onNext).call(this.observer, value);
      if (result === errorObj) {
        this.dispose();
        thrower(result.e);
      }
    };

    AutoDetachObserverPrototype.error = function (err) {
      var result = tryCatch(this.observer.onError).call(this.observer, err);
      this.dispose();
      result === errorObj && thrower(result.e);
    };

    AutoDetachObserverPrototype.completed = function () {
      var result = tryCatch(this.observer.onCompleted).call(this.observer);
      this.dispose();
      result === errorObj && thrower(result.e);
    };

    AutoDetachObserverPrototype.setDisposable = function (value) {
      this.m.setDisposable(value);
    };
    AutoDetachObserverPrototype.getDisposable = function () {
      return this.m.getDisposable();
    };

    AutoDetachObserverPrototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this.m.dispose();
    };

    return AutoDetachObserver;
  }(AbstractObserver);

  var UnderlyingObservable = function (__super__) {
    inherits(UnderlyingObservable, __super__);
    function UnderlyingObservable(m, u) {
      this._m = m;
      this._u = u;
      __super__.call(this);
    }

    UnderlyingObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._m.getDisposable(), this._u.subscribe(o));
    };

    return UnderlyingObservable;
  }(ObservableBase);

  var GroupedObservable = function (__super__) {
    inherits(GroupedObservable, __super__);
    function GroupedObservable(key, underlyingObservable, mergedDisposable) {
      __super__.call(this);
      this.key = key;
      this.underlyingObservable = !mergedDisposable ? underlyingObservable : new UnderlyingObservable(mergedDisposable, underlyingObservable);
    }

    GroupedObservable.prototype._subscribe = function (o) {
      return this.underlyingObservable.subscribe(o);
    };

    return GroupedObservable;
  }(Observable);

  /**
   *  Represents an object that is both an observable sequence as well as an observer.
   *  Each notification is broadcasted to all subscribed observers.
   */
  var Subject = Rx.Subject = function (__super__) {
    inherits(Subject, __super__);
    function Subject() {
      __super__.call(this);
      this.isDisposed = false;
      this.isStopped = false;
      this.observers = [];
      this.hasError = false;
    }

    addProperties(Subject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(o);
          return new InnerSubscription(this, o);
        }
        if (this.hasError) {
          o.onError(this.error);
          return disposableEmpty;
        }
        o.onCompleted();
        return disposableEmpty;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onCompleted();
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onError(error);
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (!this.isStopped) {
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        }
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
      }
    });

    /**
     * Creates a subject from the specified observer and observable.
     * @param {Observer} observer The observer used to send messages to the subject.
     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.
     * @returns {Subject} Subject implemented using the given observer and observable.
     */
    Subject.create = function (observer, observable) {
      return new AnonymousSubject(observer, observable);
    };

    return Subject;
  }(Observable);

  /**
   *  Represents the result of an asynchronous operation.
   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
   */
  var AsyncSubject = Rx.AsyncSubject = function (__super__) {
    inherits(AsyncSubject, __super__);

    /**
     * Creates a subject that can only receive one value and that value is cached for all future observations.
     * @constructor
     */
    function AsyncSubject() {
      __super__.call(this);
      this.isDisposed = false;
      this.isStopped = false;
      this.hasValue = false;
      this.observers = [];
      this.hasError = false;
    }

    addProperties(AsyncSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);

        if (!this.isStopped) {
          this.observers.push(o);
          return new InnerSubscription(this, o);
        }

        if (this.hasError) {
          o.onError(this.error);
        } else if (this.hasValue) {
          o.onNext(this.value);
          o.onCompleted();
        } else {
          o.onCompleted();
        }

        return disposableEmpty;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
       */
      onCompleted: function onCompleted() {
        var i, len;
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          var os = cloneArray(this.observers),
              len = os.length;

          if (this.hasValue) {
            for (i = 0; i < len; i++) {
              var o = os[i];
              o.onNext(this.value);
              o.onCompleted();
            }
          } else {
            for (i = 0; i < len; i++) {
              os[i].onCompleted();
            }
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the error.
       * @param {Mixed} error The Error to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasError = true;
          this.error = error;

          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onError(error);
          }

          this.observers.length = 0;
        }
      },
      /**
       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
       * @param {Mixed} value The value to store in the subject.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.value = value;
        this.hasValue = true;
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
        this.error = null;
        this.value = null;
      }
    });

    return AsyncSubject;
  }(Observable);

  /**
   *  Represents a value that changes over time.
   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
   */
  var BehaviorSubject = Rx.BehaviorSubject = function (__super__) {
    inherits(BehaviorSubject, __super__);
    function BehaviorSubject(value) {
      __super__.call(this);
      this.value = value;
      this.observers = [];
      this.isDisposed = false;
      this.isStopped = false;
      this.hasError = false;
    }

    addProperties(BehaviorSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(o);
          o.onNext(this.value);
          return new InnerSubscription(this, o);
        }
        if (this.hasError) {
          o.onError(this.error);
        } else {
          o.onCompleted();
        }
        return disposableEmpty;
      },
      /**
       * Gets the current value or throws an exception.
       * Value is frozen after onCompleted is called.
       * After onError is called always throws the specified exception.
       * An exception is always thrown after dispose is called.
       * @returns {Mixed} The initial value passed to the constructor until onNext is called; after which, the last value passed to onNext.
       */
      getValue: function getValue() {
        checkDisposed(this);
        if (this.hasError) {
          thrower(this.error);
        }
        return this.value;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onCompleted();
        }

        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.hasError = true;
        this.error = error;

        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onError(error);
        }

        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.value = value;
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onNext(value);
        }
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
        this.value = null;
        this.error = null;
      }
    });

    return BehaviorSubject;
  }(Observable);

  /**
   * Represents an object that is both an observable sequence as well as an observer.
   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
   */
  var ReplaySubject = Rx.ReplaySubject = function (__super__) {

    var maxSafeInteger = Math.pow(2, 53) - 1;

    function createRemovableDisposable(subject, observer) {
      return disposableCreate(function () {
        observer.dispose();
        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
      });
    }

    inherits(ReplaySubject, __super__);

    /**
     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.
     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.
     *  @param {Number} [windowSize] Maximum time length of the replay buffer.
     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.
     */
    function ReplaySubject(bufferSize, windowSize, scheduler) {
      this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
      this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
      this.scheduler = scheduler || currentThreadScheduler;
      this.q = [];
      this.observers = [];
      this.isStopped = false;
      this.isDisposed = false;
      this.hasError = false;
      this.error = null;
      __super__.call(this);
    }

    addProperties(ReplaySubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        var so = new ScheduledObserver(this.scheduler, o),
            subscription = createRemovableDisposable(this, so);

        this._trim(this.scheduler.now());
        this.observers.push(so);

        for (var i = 0, len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }

        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }

        so.ensureActive();
        return subscription;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      _trim: function _trim(now) {
        while (this.q.length > this.bufferSize) {
          this.q.shift();
        }
        while (this.q.length > 0 && now - this.q[0].interval > this.windowSize) {
          this.q.shift();
        }
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        var now = this.scheduler.now();
        this.q.push({ interval: now, value: value });
        this._trim(now);

        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onNext(value);
          observer.ensureActive();
        }
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.error = error;
        this.hasError = true;
        var now = this.scheduler.now();
        this._trim(now);
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onError(error);
          observer.ensureActive();
        }
        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        var now = this.scheduler.now();
        this._trim(now);
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onCompleted();
          observer.ensureActive();
        }
        this.observers.length = 0;
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
      }
    });

    return ReplaySubject;
  }(Observable);

  var AnonymousSubject = Rx.AnonymousSubject = function (__super__) {
    inherits(AnonymousSubject, __super__);
    function AnonymousSubject(observer, observable) {
      this.observer = observer;
      this.observable = observable;
      __super__.call(this);
    }

    addProperties(AnonymousSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        return this.observable.subscribe(o);
      },
      onCompleted: function onCompleted() {
        this.observer.onCompleted();
      },
      onError: function onError(error) {
        this.observer.onError(error);
      },
      onNext: function onNext(value) {
        this.observer.onNext(value);
      }
    });

    return AnonymousSubject;
  }(Observable);

  /**
  * Used to pause and resume streams.
  */
  Rx.Pauser = function (__super__) {
    inherits(Pauser, __super__);
    function Pauser() {
      __super__.call(this);
    }

    /**
     * Pauses the underlying sequence.
     */
    Pauser.prototype.pause = function () {
      this.onNext(false);
    };

    /**
    * Resumes the underlying sequence.
    */
    Pauser.prototype.resume = function () {
      this.onNext(true);
    };

    return Pauser;
  }(Subject);

  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
    root.Rx = Rx;

    define(function () {
      return Rx;
    });
  } else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = Rx).Rx = Rx;
    } else {
      freeExports.Rx = Rx;
    }
  } else {
    // in a browser or Rhino
    root.Rx = Rx;
  }

  // All code before this point will be filtered from stack traces.
  var rEndingLine = captureLine();
}).call(undefined);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":108}],124:[function(require,module,exports){
'use strict';

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

},{"buffer":3}],125:[function(require,module,exports){
'use strict';

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":30,"readable-stream/duplex.js":110,"readable-stream/passthrough.js":119,"readable-stream/readable.js":120,"readable-stream/transform.js":121,"readable-stream/writable.js":122}],126:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":124}],127:[function(require,module,exports){
"use strict";

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function () /*varargs*/{
    this._defaults.push({ fn: fn, arguments: arguments });
    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, def.arguments);
  });
};

module.exports = Agent;

},{}],128:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = undefined;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop() {};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function (method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  } else {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP.6.0');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP.3.0');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return (/[\/+]json($|[^-\w])/.test(mime)
  );
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function (user, pass, options) {
  if (1 === arguments.length) pass = '';
  if ((typeof pass === 'undefined' ? 'undefined' : _typeof(pass)) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function (val) {
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function () {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function () {
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch (e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function () {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function (url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":127,"./is-object":129,"./request-base":130,"./response-base":131,"component-emitter":4}],129:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(obj) {
  return null !== obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj));
}

module.exports = isObject;

},{}],130:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options) {
  if (!options || 'object' !== (typeof options === 'undefined' ? 'undefined' : _typeof(options))) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function () {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function (n) {
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data ? this._data + '&' + data : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function () {
  console.trace("Unsupported");
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":129}],131:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util

  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct);

  // params
  var params = utils.params(ct);
  for (var key in params) {
    this[key] = params[key];
  }this.links = {};

  // links
  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {
    // ignore
  }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.redirect = 3 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = 4 == type || 5 == type ? this.toError() : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.forbidden = 403 == status;
  this.notFound = 404 == status;
};

},{"./utils":132}],132:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],133:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],134:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:54 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("timeline", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.timeline = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.timeline = t());
}(window, function () {
  return function (a) {
    var r = {};function n(e) {
      if (r[e]) return r[e].exports;var t = r[e] = { i: e, l: !1, exports: {} };return a[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports;
    }return n.m = a, n.c = r, n.d = function (e, t, a) {
      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: a });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, n.t = function (t, e) {
      if (1 & e && (t = n(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var a = Object.create(null);if (n.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) {
        n.d(a, r, function (e) {
          return t[e];
        }.bind(null, r));
      }return a;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "localhost:8080/dist/plugin/", n(n.s = 0);
  }([function (e, t, a) {
    "use strict";
    function r(e, t) {
      for (var a = 0; a < t.length; a++) {
        var r = t[a];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
      }
    }function n(e, t, a) {
      return t && r(e.prototype, t), a && r(e, a), e;
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var i = function () {
      function r(e, t) {
        var a = this;if (function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, r), o.call(this), this.container = "string" == typeof e.container ? document.querySelector(e.container) : e.container, !this.container) throw new Error("No container for wavesurfer timeline");this.wavesurfer = t, this.util = t.util, this.params = this.util.extend({}, { height: 20, notchPercentHeight: 90, labelPadding: 5, unlabeledNotchColor: "#c0c0c0", primaryColor: "#000", secondaryColor: "#c0c0c0", primaryFontColor: "#000", secondaryFontColor: "#000", fontFamily: "Arial", fontSize: 10, zoomDebounce: !1, formatTimeCallback: this.defaultFormatTimeCallback, timeInterval: this.defaultTimeInterval, primaryLabelInterval: this.defaultPrimaryLabelInterval, secondaryLabelInterval: this.defaultSecondaryLabelInterval }, e), this.canvases = [], this.wrapper = null, this.drawer = null, this.pixelRatio = null, this.maxCanvasWidth = null, this.maxCanvasElementWidth = null, this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {
          return a.render();
        }, this.params.zoomDebounce) : function () {
          return a.render();
        };
      }return n(r, null, [{ key: "create", value: function value(e) {
          return { name: "timeline", deferInit: !(!e || !e.deferInit) && e.deferInit, params: e, instance: r };
        } }]), n(r, [{ key: "init", value: function value() {
          this.wavesurfer.on("ready", this._onReady), this.wavesurfer.isReady && this._onReady();
        } }, { key: "destroy", value: function value() {
          this.unAll(), this.wavesurfer.un("redraw", this._onRedraw), this.wavesurfer.un("zoom", this._onZoom), this.wavesurfer.un("ready", this._onReady), this.wavesurfer.drawer.wrapper.removeEventListener("scroll", this._onScroll), this.wrapper && this.wrapper.parentNode && (this.wrapper.removeEventListener("click", this._onWrapperClick), this.wrapper.parentNode.removeChild(this.wrapper), this.wrapper = null);
        } }, { key: "createWrapper", value: function value() {
          var e = this.wavesurfer.params;this.container.innerHTML = "", this.wrapper = this.container.appendChild(document.createElement("timeline")), this.util.style(this.wrapper, { display: "block", position: "relative", userSelect: "none", webkitUserSelect: "none", height: "".concat(this.params.height, "px") }), (e.fillParent || e.scrollParent) && this.util.style(this.wrapper, { width: "100%", overflowX: "hidden", overflowY: "hidden" }), this.wrapper.addEventListener("click", this._onWrapperClick);
        } }, { key: "render", value: function value() {
          this.wrapper || this.createWrapper(), this.updateCanvases(), this.updateCanvasesPositioning(), this.renderCanvases();
        } }, { key: "updateCanvases", value: function value() {
          for (var e, t, a = this, r = Math.round(this.drawer.wrapper.scrollWidth), n = Math.ceil(r / this.maxCanvasElementWidth); this.canvases.length < n;) {
            void 0, e = a.wrapper.appendChild(document.createElement("canvas")), a.canvases.push(e), a.util.style(e, { position: "absolute", zIndex: 4 });
          }for (; this.canvases.length > n;) {
            t = void 0, (t = a.canvases.pop()).parentElement.removeChild(t);
          }
        } }, { key: "updateCanvasesPositioning", value: function value() {
          var r = this,
              n = this.canvases.length;this.canvases.forEach(function (e, t) {
            var a = t === n - 1 ? r.drawer.wrapper.scrollWidth - r.maxCanvasElementWidth * (n - 1) : r.maxCanvasElementWidth;e.width = a * r.pixelRatio, e.height = (r.params.height + 1) * r.pixelRatio, r.util.style(e, { width: "".concat(a, "px"), height: "".concat(r.params.height, "px"), left: "".concat(t * r.maxCanvasElementWidth, "px") });
          });
        } }, { key: "renderCanvases", value: function value() {
          var r = this,
              e = this.wavesurfer.backend.getDuration();if (!(e <= 0)) {
            var t,
                a = this.wavesurfer.params,
                n = this.params.fontSize * a.pixelRatio,
                i = parseInt(e, 10) + 1,
                o = a.fillParent && !a.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * a.pixelRatio,
                s = this.params.height * this.pixelRatio,
                l = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio,
                c = o / e,
                u = this.params.formatTimeCallback,
                h = function h(e) {
              return "function" == typeof e ? e(c) : e;
            },
                p = h(this.params.timeInterval),
                f = h(this.params.primaryLabelInterval),
                d = h(this.params.secondaryLabelInterval),
                v = 0,
                m = 0,
                y = [];for (t = 0; t < i / p; t++) {
              y.push([t, m, v]), m += p, v += c * p;
            }var w = function w(t) {
              y.forEach(function (e) {
                t(e[0], e[1], e[2]);
              });
            };this.setFillStyles(this.params.primaryColor), this.setFonts("".concat(n, "px ").concat(this.params.fontFamily)), this.setFillStyles(this.params.primaryFontColor), w(function (e, t, a) {
              e % f == 0 && (r.fillRect(a, 0, 1, s), r.fillText(u(t, c), a + r.params.labelPadding * r.pixelRatio, s));
            }), this.setFillStyles(this.params.secondaryColor), this.setFonts("".concat(n, "px ").concat(this.params.fontFamily)), this.setFillStyles(this.params.secondaryFontColor), w(function (e, t, a) {
              e % d == 0 && (r.fillRect(a, 0, 1, s), r.fillText(u(t, c), a + r.params.labelPadding * r.pixelRatio, s));
            }), this.setFillStyles(this.params.unlabeledNotchColor), w(function (e, t, a) {
              e % d != 0 && e % f != 0 && r.fillRect(a, 0, 1, l);
            });
          }
        } }, { key: "setFillStyles", value: function value(t) {
          this.canvases.forEach(function (e) {
            e.getContext("2d").fillStyle = t;
          });
        } }, { key: "setFonts", value: function value(t) {
          this.canvases.forEach(function (e) {
            e.getContext("2d").font = t;
          });
        } }, { key: "fillRect", value: function value(n, i, o, s) {
          var l = this;this.canvases.forEach(function (e, t) {
            var a = t * l.maxCanvasWidth,
                r = { x1: Math.max(n, t * l.maxCanvasWidth), y1: i, x2: Math.min(n + o, t * l.maxCanvasWidth + e.width), y2: i + s };r.x1 < r.x2 && e.getContext("2d").fillRect(r.x1 - a, r.y1, r.x2 - r.x1, r.y2 - r.y1);
          });
        } }, { key: "fillText", value: function value(r, n, i) {
          var o,
              s = 0;this.canvases.forEach(function (e) {
            var t = e.getContext("2d"),
                a = t.canvas.width;n + o < s || (n < s + a && (o = t.measureText(r).width, t.fillText(r, n - s, i)), s += a);
          });
        } }, { key: "defaultFormatTimeCallback", value: function value(e, t) {
          if (1 < e / 60) {
            var a = parseInt(e / 60, 10);return e = (e = parseInt(e % 60, 10)) < 10 ? "0" + e : e, "".concat(a, ":").concat(e);
          }return Math.round(1e3 * e) / 1e3;
        } }, { key: "defaultTimeInterval", value: function value(e) {
          return 25 <= e ? 1 : 25 <= 5 * e ? 5 : 25 <= 15 * e ? 15 : 60 * Math.ceil(.5 / e);
        } }, { key: "defaultPrimaryLabelInterval", value: function value(e) {
          return 25 <= e ? 10 : 25 <= 5 * e ? 6 : 4;
        } }, { key: "defaultSecondaryLabelInterval", value: function value(e) {
          return 25 <= e ? 5 : 2;
        } }]), r;
    }();t.default = i;var o = function o() {
      var a = this;this._onScroll = function () {
        a.wrapper && a.drawer.wrapper && (a.wrapper.scrollLeft = a.drawer.wrapper.scrollLeft);
      }, this._onRedraw = function () {
        return a.render();
      }, this._onReady = function () {
        var e = a.wavesurfer;a.drawer = e.drawer, a.pixelRatio = e.drawer.params.pixelRatio, a.maxCanvasWidth = e.drawer.maxCanvasWidth || e.drawer.width, a.maxCanvasElementWidth = e.drawer.maxCanvasElementWidth || Math.round(a.maxCanvasWidth / a.pixelRatio), e.drawer.wrapper.addEventListener("scroll", a._onScroll), e.on("redraw", a._onRedraw), e.on("zoom", a._onZoom), a.render();
      }, this._onWrapperClick = function (e) {
        e.preventDefault();var t = "offsetX" in e ? e.offsetX : e.layerX;a.fireEvent("click", t / a.wrapper.scrollWidth || 0);
      };
    };e.exports = t.default;
  }]);
});


},{}],135:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:49 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("WaveSurfer", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.WaveSurfer = t() : e.WaveSurfer = t();
}(window, function () {
  return function (r) {
    var n = {};function i(e) {
      if (n[e]) return n[e].exports;var t = n[e] = { i: e, l: !1, exports: {} };return r[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
    }return i.m = r, i.c = n, i.d = function (e, t, r) {
      i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r });
    }, i.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, i.t = function (t, e) {
      if (1 & e && (t = i(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var r = Object.create(null);if (i.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var n in t) {
        i.d(r, n, function (e) {
          return t[e];
        }.bind(null, n));
      }return r;
    }, i.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return i.d(t, "a", t), t;
    }, i.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, i.p = "", i(i.s = 4);
  }([function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "ajax", { enumerable: !0, get: function get() {
        return n.default;
      } }), Object.defineProperty(t, "getId", { enumerable: !0, get: function get() {
        return i.default;
      } }), Object.defineProperty(t, "max", { enumerable: !0, get: function get() {
        return a.default;
      } }), Object.defineProperty(t, "min", { enumerable: !0, get: function get() {
        return s.default;
      } }), Object.defineProperty(t, "Observer", { enumerable: !0, get: function get() {
        return o.default;
      } }), Object.defineProperty(t, "extend", { enumerable: !0, get: function get() {
        return u.default;
      } }), Object.defineProperty(t, "style", { enumerable: !0, get: function get() {
        return l.default;
      } }), Object.defineProperty(t, "requestAnimationFrame", { enumerable: !0, get: function get() {
        return c.default;
      } }), Object.defineProperty(t, "frame", { enumerable: !0, get: function get() {
        return h.default;
      } }), Object.defineProperty(t, "debounce", { enumerable: !0, get: function get() {
        return f.default;
      } }), Object.defineProperty(t, "preventClick", { enumerable: !0, get: function get() {
        return d.default;
      } });var n = p(r(5)),
        i = p(r(6)),
        a = p(r(7)),
        s = p(r(8)),
        o = p(r(1)),
        u = p(r(9)),
        l = p(r(10)),
        c = p(r(2)),
        h = p(r(11)),
        f = p(r(12)),
        d = p(r(13));function p(e) {
      return e && e.__esModule ? e : { default: e };
    }
  }, function (e, t, r) {
    "use strict";
    function i(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function () {
      function e() {
        !function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, e), this.handlers = null;
      }var t, r, n;return t = e, (r = [{ key: "on", value: function value(e, t) {
          var r = this;this.handlers || (this.handlers = {});var n = this.handlers[e];return n || (n = this.handlers[e] = []), n.push(t), { name: e, callback: t, un: function un(e, t) {
              return r.un(e, t);
            } };
        } }, { key: "un", value: function value(e, t) {
          if (this.handlers) {
            var r,
                n = this.handlers[e];if (n) if (t) for (r = n.length - 1; 0 <= r; r--) {
              n[r] == t && n.splice(r, 1);
            } else n.length = 0;
          }
        } }, { key: "unAll", value: function value() {
          this.handlers = null;
        } }, { key: "once", value: function value(i, a) {
          var s = this;return this.on(i, function e() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) {
              r[n] = arguments[n];
            }a.apply(s, r), setTimeout(function () {
              s.un(i, e);
            }, 0);
          });
        } }, { key: "fireEvent", value: function value(e) {
          for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), n = 1; n < t; n++) {
            r[n - 1] = arguments[n];
          }if (this.handlers) {
            var i = this.handlers[e];i && i.forEach(function (e) {
              e.apply(void 0, r);
            });
          }
        } }]) && i(t.prototype, r), n && i(t, n), e;
    }();t.default = n, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e, t) {
      return setTimeout(e, 1e3 / 60);
    }).bind(window);t.default = n, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function a(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
    }function s(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function o(e) {
      return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function u(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function l(e, t, r) {
      return t && u(e.prototype, t), r && u(e, r), e;
    }function c(e, t) {
      return (c = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var h = "playing",
        f = "paused",
        d = "finished",
        p = function (e) {
      function i(e) {
        var t, r, n;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, i), (n = s(this, o(i).call(this))).audioContext = null, n.offlineAudioContext = null, n.stateBehaviors = (a(t = {}, h, { init: function init() {
            this.addOnAudioProcess();
          }, getPlayedPercents: function getPlayedPercents() {
            var e = this.getDuration();return this.getCurrentTime() / e || 0;
          }, getCurrentTime: function getCurrentTime() {
            return this.startPosition + this.getPlayedTime();
          } }), a(t, f, { init: function init() {
            this.removeOnAudioProcess();
          }, getPlayedPercents: function getPlayedPercents() {
            var e = this.getDuration();return this.getCurrentTime() / e || 0;
          }, getCurrentTime: function getCurrentTime() {
            return this.startPosition;
          } }), a(t, d, { init: function init() {
            this.removeOnAudioProcess(), this.fireEvent("finish");
          }, getPlayedPercents: function getPlayedPercents() {
            return 1;
          }, getCurrentTime: function getCurrentTime() {
            return this.getDuration();
          } }), t), n.params = e, n.ac = e.audioContext || n.getAudioContext(), n.lastPlay = n.ac.currentTime, n.startPosition = 0, n.scheduledPause = null, n.states = (a(r = {}, h, Object.create(n.stateBehaviors[h])), a(r, f, Object.create(n.stateBehaviors[f])), a(r, d, Object.create(n.stateBehaviors[d])), r), n.analyser = null, n.buffer = null, n.filters = [], n.gainNode = null, n.mergedPeaks = null, n.offlineAc = null, n.peaks = null, n.playbackRate = 1, n.analyser = null, n.scriptNode = null, n.source = null, n.splitPeaks = [], n.state = null, n.explicitDuration = null, n;
      }return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && c(e, t);
      }(i, n.Observer), l(i, [{ key: "supportsWebAudio", value: function value() {
          return !(!window.AudioContext && !window.webkitAudioContext);
        } }, { key: "getAudioContext", value: function value() {
          return window.WaveSurferAudioContext || (window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)()), window.WaveSurferAudioContext;
        } }, { key: "getOfflineAudioContext", value: function value(e) {
          return window.WaveSurferOfflineAudioContext || (window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, e)), window.WaveSurferOfflineAudioContext;
        } }]), l(i, [{ key: "init", value: function value() {
          this.createVolumeNode(), this.createScriptNode(), this.createAnalyserNode(), this.setState(f), this.setPlaybackRate(this.params.audioRate), this.setLength(0);
        } }, { key: "disconnectFilters", value: function value() {
          this.filters && (this.filters.forEach(function (e) {
            e && e.disconnect();
          }), this.filters = null, this.analyser.connect(this.gainNode));
        } }, { key: "setState", value: function value(e) {
          this.state !== this.states[e] && (this.state = this.states[e], this.state.init.call(this));
        } }, { key: "setFilter", value: function value() {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
            t[r] = arguments[r];
          }this.setFilters(t);
        } }, { key: "setFilters", value: function value(e) {
          this.disconnectFilters(), e && e.length && (this.filters = e, this.analyser.disconnect(), e.reduce(function (e, t) {
            return e.connect(t), t;
          }, this.analyser).connect(this.gainNode));
        } }, { key: "createScriptNode", value: function value() {
          this.params.audioScriptProcessor ? this.scriptNode = this.params.audioScriptProcessor : this.ac.createScriptProcessor ? this.scriptNode = this.ac.createScriptProcessor(i.scriptBufferSize) : this.scriptNode = this.ac.createJavaScriptNode(i.scriptBufferSize), this.scriptNode.connect(this.ac.destination);
        } }, { key: "addOnAudioProcess", value: function value() {
          var t = this;this.scriptNode.onaudioprocess = function () {
            var e = t.getCurrentTime();e >= t.getDuration() ? (t.setState(d), t.fireEvent("pause")) : e >= t.scheduledPause ? t.pause() : t.state === t.states[h] && t.fireEvent("audioprocess", e);
          };
        } }, { key: "removeOnAudioProcess", value: function value() {
          this.scriptNode.onaudioprocess = null;
        } }, { key: "createAnalyserNode", value: function value() {
          this.analyser = this.ac.createAnalyser(), this.analyser.connect(this.gainNode);
        } }, { key: "createVolumeNode", value: function value() {
          this.ac.createGain ? this.gainNode = this.ac.createGain() : this.gainNode = this.ac.createGainNode(), this.gainNode.connect(this.ac.destination);
        } }, { key: "setSinkId", value: function value(e) {
          if (e) {
            var t = new window.Audio();if (!t.setSinkId) return Promise.reject(new Error("setSinkId is not supported in your browser"));t.autoplay = !0;var r = this.ac.createMediaStreamDestination();return this.gainNode.disconnect(), this.gainNode.connect(r), t.srcObject = r.stream, t.setSinkId(e);
          }return Promise.reject(new Error("Invalid deviceId: " + e));
        } }, { key: "setVolume", value: function value(e) {
          this.gainNode.gain.setValueAtTime(e, this.ac.currentTime);
        } }, { key: "getVolume", value: function value() {
          return this.gainNode.gain.value;
        } }, { key: "decodeArrayBuffer", value: function value(e, t, r) {
          this.offlineAc || (this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100)), this.offlineAc.decodeAudioData(e, function (e) {
            return t(e);
          }, r);
        } }, { key: "setPeaks", value: function value(e, t) {
          this.explicitDuration = t, this.peaks = e;
        } }, { key: "setLength", value: function value(e) {
          if (!this.mergedPeaks || e != 2 * this.mergedPeaks.length - 1 + 2) {
            this.splitPeaks = [], this.mergedPeaks = [];var t,
                r = this.buffer ? this.buffer.numberOfChannels : 1;for (t = 0; t < r; t++) {
              this.splitPeaks[t] = [], this.splitPeaks[t][2 * (e - 1)] = 0, this.splitPeaks[t][2 * (e - 1) + 1] = 0;
            }this.mergedPeaks[2 * (e - 1)] = 0, this.mergedPeaks[2 * (e - 1) + 1] = 0;
          }
        } }, { key: "getPeaks", value: function value(e, t, r) {
          if (this.peaks) return this.peaks;if (t = t || 0, r = r || e - 1, this.setLength(e), !this.buffer.length) {
            var n = this.createBuffer(1, 4096, this.sampleRate);this.buffer = n.buffer;
          }var i,
              a = this.buffer.length / e,
              s = ~~(a / 10) || 1,
              o = this.buffer.numberOfChannels;for (i = 0; i < o; i++) {
            var u = this.splitPeaks[i],
                l = this.buffer.getChannelData(i),
                c = void 0;for (c = t; c <= r; c++) {
              var h = ~~(c * a),
                  f = ~~(h + a),
                  d = 0,
                  p = 0,
                  v = void 0;for (v = h; v < f; v += s) {
                var y = l[v];p < y && (p = y), y < d && (d = y);
              }u[2 * c] = p, u[2 * c + 1] = d, (0 == i || p > this.mergedPeaks[2 * c]) && (this.mergedPeaks[2 * c] = p), (0 == i || d < this.mergedPeaks[2 * c + 1]) && (this.mergedPeaks[2 * c + 1] = d);
            }
          }return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
        } }, { key: "getPlayedPercents", value: function value() {
          return this.state.getPlayedPercents.call(this);
        } }, { key: "disconnectSource", value: function value() {
          this.source && this.source.disconnect();
        } }, { key: "destroy", value: function value() {
          this.isPaused() || this.pause(), this.unAll(), this.buffer = null, this.disconnectFilters(), this.disconnectSource(), this.gainNode.disconnect(), this.scriptNode.disconnect(), this.analyser.disconnect(), this.params.closeAudioContext && ("function" == typeof this.ac.close && "closed" != this.ac.state && this.ac.close(), this.ac = null, this.params.audioContext ? this.params.audioContext = null : window.WaveSurferAudioContext = null, window.WaveSurferOfflineAudioContext = null);
        } }, { key: "load", value: function value(e) {
          this.startPosition = 0, this.lastPlay = this.ac.currentTime, this.buffer = e, this.createSource();
        } }, { key: "createSource", value: function value() {
          this.disconnectSource(), this.source = this.ac.createBufferSource(), this.source.start = this.source.start || this.source.noteGrainOn, this.source.stop = this.source.stop || this.source.noteOff, this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime), this.source.buffer = this.buffer, this.source.connect(this.analyser);
        } }, { key: "isPaused", value: function value() {
          return this.state !== this.states[h];
        } }, { key: "getDuration", value: function value() {
          return this.buffer ? this.buffer.duration : this.explicitDuration ? this.explicitDuration : 0;
        } }, { key: "seekTo", value: function value(e, t) {
          if (this.buffer) return (this.scheduledPause = null) == e && (e = this.getCurrentTime()) >= this.getDuration() && (e = 0), null == t && (t = this.getDuration()), this.startPosition = e, this.lastPlay = this.ac.currentTime, this.state === this.states[d] && this.setState(f), { start: e, end: t };
        } }, { key: "getPlayedTime", value: function value() {
          return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
        } }, { key: "play", value: function value(e, t) {
          if (this.buffer) {
            this.createSource();var r = this.seekTo(e, t);e = r.start, t = r.end, this.scheduledPause = t, this.source.start(0, e, t - e), "suspended" == this.ac.state && this.ac.resume && this.ac.resume(), this.setState(h), this.fireEvent("play");
          }
        } }, { key: "pause", value: function value() {
          this.scheduledPause = null, this.startPosition += this.getPlayedTime(), this.source && this.source.stop(0), this.setState(f), this.fireEvent("pause");
        } }, { key: "getCurrentTime", value: function value() {
          return this.state.getCurrentTime.call(this);
        } }, { key: "getPlaybackRate", value: function value() {
          return this.playbackRate;
        } }, { key: "setPlaybackRate", value: function value(e) {
          e = e || 1, this.isPaused() ? this.playbackRate = e : (this.pause(), this.playbackRate = e, this.play());
        } }]), i;
    }();(t.default = p).scriptBufferSize = 256, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var i = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0)),
        a = n(r(14)),
        s = n(r(3)),
        o = n(r(16)),
        u = n(r(17));function n(e) {
      return e && e.__esModule ? e : { default: e };
    }function l(e) {
      return (l = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function c(e, t) {
      return !t || "object" !== l(t) && "function" != typeof t ? d(e) : t;
    }function h(e) {
      return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function f(e, t) {
      return (f = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }function d(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e;
    }function p(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function v(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function y(e, t, r) {
      return t && v(e.prototype, t), r && v(e, r), e;
    }var m = function (e) {
      function n(e) {
        var t;if (p(this, n), (t = c(this, h(n).call(this))).defaultParams = { audioContext: null, audioRate: 1, autoCenter: !0, backend: "WebAudio", barHeight: 1, barGap: null, container: null, cursorColor: "#333", cursorWidth: 1, dragSelection: !0, fillParent: !0, forceDecode: !1, height: 128, hideScrollbar: !1, interact: !0, loopSelection: !0, maxCanvasWidth: 4e3, mediaContainer: null, mediaControls: !1, mediaType: "audio", minPxPerSec: 20, normalize: !1, partialRender: !1, pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI, plugins: [], progressColor: "#555", removeMediaElementOnDestroy: !0, renderer: a.default, responsive: !1, scrollParent: !1, skipLength: 2, splitChannels: !1, waveColor: "#999", xhr: {} }, t.backends = { MediaElement: o.default, WebAudio: s.default }, t.util = i, t.params = i.extend({}, t.defaultParams, e), t.container = "string" == typeof e.container ? document.querySelector(t.params.container) : t.params.container, !t.container) throw new Error("Container element not found");if (null == t.params.mediaContainer ? t.mediaContainer = t.container : "string" == typeof t.params.mediaContainer ? t.mediaContainer = document.querySelector(t.params.mediaContainer) : t.mediaContainer = t.params.mediaContainer, !t.mediaContainer) throw new Error("Media Container element not found");if (t.params.maxCanvasWidth <= 1) throw new Error("maxCanvasWidth must be greater than 1");if (t.params.maxCanvasWidth % 2 == 1) throw new Error("maxCanvasWidth must be an even number");if (t.savedVolume = 0, t.isMuted = !1, t.tmpEvents = [], t.currentAjax = null, t.arraybuffer = null, t.drawer = null, t.backend = null, t.peakCache = null, "function" != typeof t.params.renderer) throw new Error("Renderer parameter is invalid");t.Drawer = t.params.renderer, t.Backend = t.backends[t.params.backend], t.initialisedPluginList = {}, t.isDestroyed = !1, t.isReady = !1;var r = 0;return t._onResize = i.debounce(function () {
          r == t.drawer.wrapper.clientWidth || t.params.scrollParent || (r = t.drawer.wrapper.clientWidth, t.drawer.fireEvent("redraw"));
        }, "number" == typeof t.params.responsive ? t.params.responsive : 100), c(t, d(d(t)));
      }return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && f(e, t);
      }(n, i.Observer), y(n, null, [{ key: "create", value: function value(e) {
          return new n(e).init();
        } }]), y(n, [{ key: "init", value: function value() {
          return this.registerPlugins(this.params.plugins), this.createDrawer(), this.createBackend(), this.createPeakCache(), this;
        } }, { key: "registerPlugins", value: function value(e) {
          var t = this;return e.forEach(function (e) {
            return t.addPlugin(e);
          }), e.forEach(function (e) {
            e.deferInit || t.initPlugin(e.name);
          }), this.fireEvent("plugins-registered", e), this;
        } }, { key: "addPlugin", value: function value(t) {
          var r = this;if (!t.name) throw new Error("Plugin does not have a name!");if (!t.instance) throw new Error("Plugin ".concat(t.name, " does not have an instance property!"));t.staticProps && Object.keys(t.staticProps).forEach(function (e) {
            r[e] = t.staticProps[e];
          });var n = t.instance;return Object.getOwnPropertyNames(i.Observer.prototype).forEach(function (e) {
            n.prototype[e] = i.Observer.prototype[e];
          }), this[t.name] = new n(t.params || {}, this), this.fireEvent("plugin-added", t.name), this;
        } }, { key: "initPlugin", value: function value(e) {
          if (!this[e]) throw new Error("Plugin ".concat(e, " has not been added yet!"));return this.initialisedPluginList[e] && this.destroyPlugin(e), this[e].init(), this.initialisedPluginList[e] = !0, this.fireEvent("plugin-initialised", e), this;
        } }, { key: "destroyPlugin", value: function value(e) {
          if (!this[e]) throw new Error("Plugin ".concat(e, " has not been added yet and cannot be destroyed!"));if (!this.initialisedPluginList[e]) throw new Error("Plugin ".concat(e, " is not active and cannot be destroyed!"));if ("function" != typeof this[e].destroy) throw new Error("Plugin ".concat(e, " does not have a destroy function!"));return this[e].destroy(), delete this.initialisedPluginList[e], this.fireEvent("plugin-destroyed", e), this;
        } }, { key: "destroyAllPlugins", value: function value() {
          var t = this;Object.keys(this.initialisedPluginList).forEach(function (e) {
            return t.destroyPlugin(e);
          });
        } }, { key: "createDrawer", value: function value() {
          var r = this;this.drawer = new this.Drawer(this.container, this.params), this.drawer.init(), this.fireEvent("drawer-created", this.drawer), !1 !== this.params.responsive && (window.addEventListener("resize", this._onResize, !0), window.addEventListener("orientationchange", this._onResize, !0)), this.drawer.on("redraw", function () {
            r.drawBuffer(), r.drawer.progress(r.backend.getPlayedPercents());
          }), this.drawer.on("click", function (e, t) {
            setTimeout(function () {
              return r.seekTo(t);
            }, 0);
          }), this.drawer.on("scroll", function (e) {
            r.params.partialRender && r.drawBuffer(), r.fireEvent("scroll", e);
          });
        } }, { key: "createBackend", value: function value() {
          var t = this;this.backend && this.backend.destroy(), "AudioElement" == this.params.backend && (this.params.backend = "MediaElement"), "WebAudio" != this.params.backend || this.Backend.prototype.supportsWebAudio.call(null) || (this.params.backend = "MediaElement"), this.backend = new this.Backend(this.params), this.backend.init(), this.fireEvent("backend-created", this.backend), this.backend.on("finish", function () {
            return t.fireEvent("finish");
          }), this.backend.on("play", function () {
            return t.fireEvent("play");
          }), this.backend.on("pause", function () {
            return t.fireEvent("pause");
          }), this.backend.on("audioprocess", function (e) {
            t.drawer.progress(t.backend.getPlayedPercents()), t.fireEvent("audioprocess", e);
          });
        } }, { key: "createPeakCache", value: function value() {
          this.params.partialRender && (this.peakCache = new u.default());
        } }, { key: "getDuration", value: function value() {
          return this.backend.getDuration();
        } }, { key: "getCurrentTime", value: function value() {
          return this.backend.getCurrentTime();
        } }, { key: "setCurrentTime", value: function value(e) {
          e >= this.getDuration() ? this.seekTo(1) : this.seekTo(e / this.getDuration());
        } }, { key: "play", value: function value(e, t) {
          var r = this;return this.fireEvent("interaction", function () {
            return r.play(e, t);
          }), this.backend.play(e, t);
        } }, { key: "pause", value: function value() {
          if (!this.backend.isPaused()) return this.backend.pause();
        } }, { key: "playPause", value: function value() {
          return this.backend.isPaused() ? this.play() : this.pause();
        } }, { key: "isPlaying", value: function value() {
          return !this.backend.isPaused();
        } }, { key: "skipBackward", value: function value(e) {
          this.skip(-e || -this.params.skipLength);
        } }, { key: "skipForward", value: function value(e) {
          this.skip(e || this.params.skipLength);
        } }, { key: "skip", value: function value(e) {
          var t = this.getDuration() || 1,
              r = this.getCurrentTime() || 0;r = Math.max(0, Math.min(t, r + (e || 0))), this.seekAndCenter(r / t);
        } }, { key: "seekAndCenter", value: function value(e) {
          this.seekTo(e), this.drawer.recenter(e);
        } }, { key: "seekTo", value: function value(e) {
          var t = this;if ("number" != typeof e || !isFinite(e) || e < 0 || 1 < e) return console.error("Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!");this.fireEvent("interaction", function () {
            return t.seekTo(e);
          });var r = this.backend.isPaused();r || this.backend.pause();var n = this.params.scrollParent;this.params.scrollParent = !1, this.backend.seekTo(e * this.getDuration()), this.drawer.progress(e), r || this.backend.play(), this.params.scrollParent = n, this.fireEvent("seek", e);
        } }, { key: "stop", value: function value() {
          this.pause(), this.seekTo(0), this.drawer.progress(0);
        } }, { key: "setSinkId", value: function value(e) {
          return this.backend.setSinkId(e);
        } }, { key: "setVolume", value: function value(e) {
          this.backend.setVolume(e), this.fireEvent("volume", e);
        } }, { key: "getVolume", value: function value() {
          return this.backend.getVolume();
        } }, { key: "setPlaybackRate", value: function value(e) {
          this.backend.setPlaybackRate(e);
        } }, { key: "getPlaybackRate", value: function value() {
          return this.backend.getPlaybackRate();
        } }, { key: "toggleMute", value: function value() {
          this.setMute(!this.isMuted);
        } }, { key: "setMute", value: function value(e) {
          e !== this.isMuted && (e ? (this.savedVolume = this.backend.getVolume(), this.backend.setVolume(0), this.isMuted = !0, this.fireEvent("volume", 0)) : (this.backend.setVolume(this.savedVolume), this.isMuted = !1, this.fireEvent("volume", this.savedVolume))), this.fireEvent("mute", this.isMuted);
        } }, { key: "getMute", value: function value() {
          return this.isMuted;
        } }, { key: "isReady", value: function value() {
          return this.isReady;
        } }, { key: "getFilters", value: function value() {
          return this.backend.filters || [];
        } }, { key: "toggleScroll", value: function value() {
          this.params.scrollParent = !this.params.scrollParent, this.drawBuffer();
        } }, { key: "toggleInteraction", value: function value() {
          this.params.interact = !this.params.interact;
        } }, { key: "getWaveColor", value: function value() {
          return this.params.waveColor;
        } }, { key: "setWaveColor", value: function value(e) {
          this.params.waveColor = e, this.drawBuffer();
        } }, { key: "getProgressColor", value: function value() {
          return this.params.progressColor;
        } }, { key: "setProgressColor", value: function value(e) {
          this.params.progressColor = e, this.drawBuffer();
        } }, { key: "getCursorColor", value: function value() {
          return this.params.cursorColor;
        } }, { key: "setCursorColor", value: function value(e) {
          this.params.cursorColor = e, this.drawer.updateCursor();
        } }, { key: "getHeight", value: function value() {
          return this.params.height;
        } }, { key: "setHeight", value: function value(e) {
          this.params.height = e, this.drawer.setHeight(e * this.params.pixelRatio), this.drawBuffer();
        } }, { key: "drawBuffer", value: function value() {
          var e,
              t = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio),
              r = this.drawer.getWidth(),
              n = t,
              i = this.drawer.getScrollX(),
              a = Math.max(i + r, n);if (this.params.fillParent && (!this.params.scrollParent || t < r) && (i = 0, a = n = r), this.params.partialRender) {
            var s,
                o = this.peakCache.addRangeToPeakCache(n, i, a);for (s = 0; s < o.length; s++) {
              e = this.backend.getPeaks(n, o[s][0], o[s][1]), this.drawer.drawPeaks(e, n, o[s][0], o[s][1]);
            }
          } else e = this.backend.getPeaks(n, i, a), this.drawer.drawPeaks(e, n, i, a);this.fireEvent("redraw", e, n);
        } }, { key: "zoom", value: function value(e) {
          this.params.scrollParent = e ? (this.params.minPxPerSec = e, !0) : (this.params.minPxPerSec = this.defaultParams.minPxPerSec, !1), this.drawBuffer(), this.drawer.progress(this.backend.getPlayedPercents()), this.drawer.recenter(this.getCurrentTime() / this.getDuration()), this.fireEvent("zoom", e);
        } }, { key: "loadArrayBuffer", value: function value(e) {
          var t = this;this.decodeArrayBuffer(e, function (e) {
            t.isDestroyed || t.loadDecodedBuffer(e);
          });
        } }, { key: "loadDecodedBuffer", value: function value(e) {
          this.backend.load(e), this.drawBuffer(), this.fireEvent("ready"), this.isReady = !0;
        } }, { key: "loadBlob", value: function value(e) {
          var t = this,
              r = new FileReader();r.addEventListener("progress", function (e) {
            return t.onProgress(e);
          }), r.addEventListener("load", function (e) {
            return t.loadArrayBuffer(e.target.result);
          }), r.addEventListener("error", function () {
            return t.fireEvent("error", "Error reading file");
          }), r.readAsArrayBuffer(e), this.empty();
        } }, { key: "load", value: function value(e, t, r, n) {
          if (this.empty(), r) {
            var i = { "Preload is not 'auto', 'none' or 'metadata'": -1 === ["auto", "metadata", "none"].indexOf(r), "Peaks are not provided": !t, "Backend is not of type MediaElement": "MediaElement" !== this.params.backend, "Url is not of type string": "string" != typeof e },
                a = Object.keys(i).filter(function (e) {
              return i[e];
            });a.length && (console.warn("Preload parameter of wavesurfer.load will be ignored because:\n\t- " + a.join("\n\t- ")), r = null);
          }switch (this.params.backend) {case "WebAudio":
              return this.loadBuffer(e, t, n);case "MediaElement":
              return this.loadMediaElement(e, t, r, n);}
        } }, { key: "loadBuffer", value: function value(t, e, r) {
          var n = this,
              i = function i(e) {
            return e && n.tmpEvents.push(n.once("ready", e)), n.getArrayBuffer(t, function (e) {
              return n.loadArrayBuffer(e);
            });
          };if (!e) return i();this.backend.setPeaks(e, r), this.drawBuffer(), this.tmpEvents.push(this.once("interaction", i));
        } }, { key: "loadMediaElement", value: function value(e, t, r, n) {
          var i = this,
              a = e;if ("string" == typeof e) this.backend.load(a, this.mediaContainer, t, r);else {
            var s = e;this.backend.loadElt(s, t), a = s.src;
          }this.tmpEvents.push(this.backend.once("canplay", function () {
            i.drawBuffer(), i.fireEvent("ready"), i.isReady = !0;
          }), this.backend.once("error", function (e) {
            return i.fireEvent("error", e);
          })), t && this.backend.setPeaks(t, n), t && !this.params.forceDecode || !this.backend.supportsWebAudio() || this.getArrayBuffer(a, function (e) {
            i.decodeArrayBuffer(e, function (e) {
              i.backend.buffer = e, i.backend.setPeaks(null), i.drawBuffer(), i.fireEvent("waveform-ready");
            });
          });
        } }, { key: "decodeArrayBuffer", value: function value(t, r) {
          var n = this;this.arraybuffer = t, this.backend.decodeArrayBuffer(t, function (e) {
            n.isDestroyed || n.arraybuffer != t || (r(e), n.arraybuffer = null);
          }, function () {
            return n.fireEvent("error", "Error decoding audiobuffer");
          });
        } }, { key: "getArrayBuffer", value: function value(e, r) {
          var n = this,
              t = i.ajax({ url: e, responseType: "arraybuffer", xhr: this.params.xhr });return this.currentAjax = t, this.tmpEvents.push(t.on("progress", function (e) {
            n.onProgress(e);
          }), t.on("success", function (e, t) {
            r(e), n.currentAjax = null;
          }), t.on("error", function (e) {
            n.fireEvent("error", "XHR error: " + e.target.statusText), n.currentAjax = null;
          })), t;
        } }, { key: "onProgress", value: function value(e) {
          var t;t = e.lengthComputable ? e.loaded / e.total : e.loaded / (e.loaded + 1e6), this.fireEvent("loading", Math.round(100 * t), e.target);
        } }, { key: "exportPCM", value: function value(e, t, r, n) {
          e = e || 1024, n = n || 0, t = t || 1e4, r = r || !1;var i = this.backend.getPeaks(e, n),
              a = [].map.call(i, function (e) {
            return Math.round(e * t) / t;
          }),
              s = JSON.stringify(a);return r || window.open("data:application/json;charset=utf-8," + encodeURIComponent(s)), s;
        } }, { key: "exportImage", value: function value(e, t) {
          return e || (e = "image/png"), t || (t = 1), this.drawer.getImage(e, t);
        } }, { key: "cancelAjax", value: function value() {
          this.currentAjax && (this.currentAjax.xhr.abort(), this.currentAjax = null);
        } }, { key: "clearTmpEvents", value: function value() {
          this.tmpEvents.forEach(function (e) {
            return e.un();
          });
        } }, { key: "empty", value: function value() {
          this.backend.isPaused() || (this.stop(), this.backend.disconnectSource()), this.isReady = !1, this.cancelAjax(), this.clearTmpEvents(), this.drawer.progress(0), this.drawer.setWidth(0), this.drawer.drawPeaks({ length: this.drawer.getWidth() }, 0);
        } }, { key: "destroy", value: function value() {
          this.destroyAllPlugins(), this.fireEvent("destroy"), this.cancelAjax(), this.clearTmpEvents(), this.unAll(), !1 !== this.params.responsive && (window.removeEventListener("resize", this._onResize, !0), window.removeEventListener("orientationchange", this._onResize, !0)), this.backend.destroy(), this.drawer.destroy(), this.isDestroyed = !0, this.isReady = !1, this.arraybuffer = null;
        } }]), n;
    }();(t.default = m).VERSION = "2.1.0", m.util = i, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
      var t = new i.default(),
          r = new XMLHttpRequest(),
          n = !1;r.open(e.method || "GET", e.url, !0), r.responseType = e.responseType || "json", e.xhr && (e.xhr.requestHeaders && e.xhr.requestHeaders.forEach(function (e) {
        r.setRequestHeader(e.key, e.value);
      }), e.xhr.withCredentials && (r.withCredentials = !0));return r.addEventListener("progress", function (e) {
        t.fireEvent("progress", e), e.lengthComputable && e.loaded == e.total && (n = !0);
      }), r.addEventListener("load", function (e) {
        n || t.fireEvent("progress", e), t.fireEvent("load", e), 200 == r.status || 206 == r.status ? t.fireEvent("success", r.response, e) : t.fireEvent("error", e);
      }), r.addEventListener("error", function (e) {
        return t.fireEvent("error", e);
      }), r.send(), t.xhr = r, t;
    };var n,
        i = (n = r(1)) && n.__esModule ? n : { default: n };e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function () {
      return "wavesurfer_" + Math.random().toString(32).substring(2);
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t) {
      var r = -1 / 0;return Object.keys(t).forEach(function (e) {
        t[e] > r && (r = t[e]);
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t) {
      var r = Number(1 / 0);return Object.keys(t).forEach(function (e) {
        t[e] < r && (r = t[e]);
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (r) {
      for (var e = arguments.length, t = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++) {
        t[n - 1] = arguments[n];
      }return t.forEach(function (t) {
        Object.keys(t).forEach(function (e) {
          r[e] = t[e];
        });
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t, r) {
      return Object.keys(r).forEach(function (e) {
        t.style[e] !== r[e] && (t.style[e] = r[e]);
      }), t;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (n) {
      return function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
          t[r] = arguments[r];
        }return (0, i.default)(function () {
          return n.apply(void 0, t);
        });
      };
    };var n,
        i = (n = r(2)) && n.__esModule ? n : { default: n };e.exports = t.default;
  }, function (e, t) {
    function r(t, r, n) {
      var i, a, s, o, u;function l() {
        var e = Date.now() - o;e < r && 0 <= e ? i = setTimeout(l, r - e) : (i = null, n || (u = t.apply(s, a), s = a = null));
      }null == r && (r = 100);var e = function e() {
        s = this, a = arguments, o = Date.now();var e = n && !i;return i || (i = setTimeout(l, r)), e && (u = t.apply(s, a), s = a = null), u;
      };return e.clear = function () {
        i && (clearTimeout(i), i = null);
      }, e.flush = function () {
        i && (u = t.apply(s, a), s = a = null, clearTimeout(i), i = null);
      }, e;
    }r.debounce = r, e.exports = r;
  }, function (e, t, r) {
    "use strict";
    function n(e) {
      e.stopPropagation(), document.body.removeEventListener("click", n, !0);
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
      document.body.addEventListener("click", n, !0);
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n,
        a = (n = r(15)) && n.__esModule ? n : { default: n },
        f = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e) {
      return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function l(e, t) {
      return (l = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var c = function (e) {
      function n(e, t) {
        var r;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (r = o(this, u(n).call(this, e, t))).maxCanvasWidth = t.maxCanvasWidth, r.maxCanvasElementWidth = Math.round(t.maxCanvasWidth / t.pixelRatio), r.hasProgressCanvas = t.waveColor != t.progressColor, r.halfPixel = .5 / t.pixelRatio, r.canvases = [], r.progressWave = null, r;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && l(e, t);
      }(n, a.default), t = n, (r = [{ key: "init", value: function value() {
          this.createWrapper(), this.createElements();
        } }, { key: "createElements", value: function value() {
          this.progressWave = this.wrapper.appendChild(this.style(document.createElement("wave"), { position: "absolute", zIndex: 3, left: 0, top: 0, bottom: 0, overflow: "hidden", width: "0", display: "none", boxSizing: "border-box", borderRightStyle: "solid", pointerEvents: "none" })), this.addCanvas(), this.updateCursor();
        } }, { key: "updateCursor", value: function value() {
          this.style(this.progressWave, { borderRightWidth: this.params.cursorWidth + "px", borderRightColor: this.params.cursorColor });
        } }, { key: "updateSize", value: function value() {
          for (var n = this, e = Math.round(this.width / this.params.pixelRatio), t = Math.ceil(e / this.maxCanvasElementWidth); this.canvases.length < t;) {
            this.addCanvas();
          }for (; this.canvases.length > t;) {
            this.removeCanvas();
          }this.canvases.forEach(function (e, t) {
            var r = n.maxCanvasWidth + 2 * Math.ceil(n.params.pixelRatio / 2);t == n.canvases.length - 1 && (r = n.width - n.maxCanvasWidth * (n.canvases.length - 1)), n.updateDimensions(e, r, n.height), n.clearWaveForEntry(e);
          });
        } }, { key: "addCanvas", value: function value() {
          var e = {},
              t = this.maxCanvasElementWidth * this.canvases.length;e.wave = this.wrapper.appendChild(this.style(document.createElement("canvas"), { position: "absolute", zIndex: 2, left: t + "px", top: 0, bottom: 0, height: "100%", pointerEvents: "none" })), e.waveCtx = e.wave.getContext("2d"), this.hasProgressCanvas && (e.progress = this.progressWave.appendChild(this.style(document.createElement("canvas"), { position: "absolute", left: t + "px", top: 0, bottom: 0, height: "100%" })), e.progressCtx = e.progress.getContext("2d")), this.canvases.push(e);
        } }, { key: "removeCanvas", value: function value() {
          var e = this.canvases.pop();e.wave.parentElement.removeChild(e.wave), this.hasProgressCanvas && e.progress.parentElement.removeChild(e.progress);
        } }, { key: "updateDimensions", value: function value(e, t, r) {
          var n = Math.round(t / this.params.pixelRatio),
              i = Math.round(this.width / this.params.pixelRatio);e.start = e.waveCtx.canvas.offsetLeft / i || 0, e.end = e.start + n / i, e.waveCtx.canvas.width = t, e.waveCtx.canvas.height = r, this.style(e.waveCtx.canvas, { width: n + "px" }), this.style(this.progressWave, { display: "block" }), this.hasProgressCanvas && (e.progressCtx.canvas.width = t, e.progressCtx.canvas.height = r, this.style(e.progressCtx.canvas, { width: n + "px" }));
        } }, { key: "clearWave", value: function value() {
          var t = this;this.canvases.forEach(function (e) {
            return t.clearWaveForEntry(e);
          });
        } }, { key: "clearWaveForEntry", value: function value(e) {
          e.waveCtx.clearRect(0, 0, e.waveCtx.canvas.width, e.waveCtx.canvas.height), this.hasProgressCanvas && e.progressCtx.clearRect(0, 0, e.progressCtx.canvas.width, e.progressCtx.canvas.height);
        } }, { key: "drawBars", value: function value(e, t, v, y) {
          var m = this;return this.prepareDraw(e, t, v, y, function (e) {
            var t = e.absmax,
                r = e.hasMinVals,
                n = (e.height, e.offsetY),
                i = e.halfH,
                a = e.peaks;if (void 0 !== v) {
              var s,
                  o = r ? 2 : 1,
                  u = a.length / o,
                  l = m.params.barWidth * m.params.pixelRatio,
                  c = l + (null === m.params.barGap ? Math.max(m.params.pixelRatio, ~~(l / 2)) : Math.max(m.params.pixelRatio, m.params.barGap * m.params.pixelRatio)),
                  h = u / m.width,
                  f = y;for (s = v; s < f; s += c) {
                var d = a[Math.floor(s * h * o)] || 0,
                    p = Math.round(d / t * i);m.fillRect(s + m.halfPixel, i - p + n, l + m.halfPixel, 2 * p);
              }
            }
          });
        } }, { key: "drawWave", value: function value(e, t, l, c) {
          var h = this;return this.prepareDraw(e, t, l, c, function (e) {
            var t = e.absmax,
                r = e.hasMinVals,
                n = (e.height, e.offsetY),
                i = e.halfH,
                a = e.peaks;if (!r) {
              var s,
                  o = [],
                  u = a.length;for (s = 0; s < u; s++) {
                o[2 * s] = a[s], o[2 * s + 1] = -a[s];
              }a = o;
            }void 0 !== l && h.drawLine(a, t, i, n, l, c), h.fillRect(0, i + n - h.halfPixel, h.width, h.halfPixel);
          });
        } }, { key: "drawLine", value: function value(t, r, n, i, a, s) {
          var o = this;this.canvases.forEach(function (e) {
            o.setFillStyles(e), o.drawLineToContext(e, e.waveCtx, t, r, n, i, a, s), o.drawLineToContext(e, e.progressCtx, t, r, n, i, a, s);
          });
        } }, { key: "drawLineToContext", value: function value(e, t, r, n, i, a, s, o) {
          if (t) {
            var u = r.length / 2,
                l = this.params.fillParent && this.width != u ? this.width / u : 1,
                c = Math.round(u * e.start),
                h = Math.round(u * e.end) + 1;if (!(o < c || h < s)) {
              var f,
                  d,
                  p = Math.min(c, s),
                  v = Math.max(h, o);for (t.beginPath(), t.moveTo((p - c) * l + this.halfPixel, i + a), f = p; f < v; f++) {
                var y = r[2 * f] || 0,
                    m = Math.round(y / n * i);t.lineTo((f - c) * l + this.halfPixel, i - m + a);
              }for (d = v - 1; p <= d; d--) {
                var b = r[2 * d + 1] || 0,
                    g = Math.round(b / n * i);t.lineTo((d - c) * l + this.halfPixel, i - g + a);
              }t.closePath(), t.fill();
            }
          }
        } }, { key: "fillRect", value: function value(e, t, r, n) {
          var i,
              a = Math.floor(e / this.maxCanvasWidth),
              s = Math.min(Math.ceil((e + r) / this.maxCanvasWidth) + 1, this.canvases.length);for (i = a; i < s; i++) {
            var o = this.canvases[i],
                u = i * this.maxCanvasWidth,
                l = { x1: Math.max(e, i * this.maxCanvasWidth), y1: t, x2: Math.min(e + r, i * this.maxCanvasWidth + o.waveCtx.canvas.width), y2: t + n };l.x1 < l.x2 && (this.setFillStyles(o), this.fillRectToContext(o.waveCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1), this.fillRectToContext(o.progressCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1));
          }
        } }, { key: "prepareDraw", value: function value(s, o, u, l, c) {
          var h = this;return f.frame(function () {
            if (s[0] instanceof Array) {
              var e = s;if (h.params.splitChannels) return h.setHeight(e.length * h.params.height * h.params.pixelRatio), e.forEach(function (e, t) {
                return h.prepareDraw(e, t, u, l, c);
              });s = e[0];
            }var t = 1 / h.params.barHeight;if (h.params.normalize) {
              var r = f.max(s),
                  n = f.min(s);t = r < -n ? -n : r;
            }var i = [].some.call(s, function (e) {
              return e < 0;
            }),
                a = h.params.height * h.params.pixelRatio;return c({ absmax: t, hasMinVals: i, height: a, offsetY: a * o || 0, halfH: a / 2, peaks: s });
          })();
        } }, { key: "fillRectToContext", value: function value(e, t, r, n, i) {
          e && e.fillRect(t, r, n, i);
        } }, { key: "setFillStyles", value: function value(e) {
          e.waveCtx.fillStyle = this.params.waveColor, this.hasProgressCanvas && (e.progressCtx.fillStyle = this.params.progressColor);
        } }, { key: "getImage", value: function value(t, r) {
          var e = this.canvases.map(function (e) {
            return e.wave.toDataURL(t, r);
          });return 1 < e.length ? e : e[0];
        } }, { key: "updateProgress", value: function value(e) {
          this.style(this.progressWave, { width: e + "px" });
        } }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = c, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var a = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function n(e) {
      return (n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== n(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e) {
      return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function l(e, t) {
      return (l = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var i = function (e) {
      function n(e, t) {
        var r;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (r = o(this, u(n).call(this))).container = e, r.params = t, r.width = 0, r.height = t.height * r.params.pixelRatio, r.lastPos = 0, r.wrapper = null, r;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && l(e, t);
      }(n, a.Observer), t = n, (r = [{ key: "style", value: function value(e, t) {
          return a.style(e, t);
        } }, { key: "createWrapper", value: function value() {
          this.wrapper = this.container.appendChild(document.createElement("wave")), this.style(this.wrapper, { display: "block", position: "relative", userSelect: "none", webkitUserSelect: "none", height: this.params.height + "px" }), (this.params.fillParent || this.params.scrollParent) && this.style(this.wrapper, { width: "100%", overflowX: this.params.hideScrollbar ? "hidden" : "auto", overflowY: "hidden" }), this.setupWrapperEvents();
        } }, { key: "handleEvent", value: function value(e, t) {
          !t && e.preventDefault();var r,
              n = e.targetTouches ? e.targetTouches[0].clientX : e.clientX,
              i = this.wrapper.getBoundingClientRect(),
              a = this.width,
              s = this.getWidth();return !this.params.fillParent && a < s ? 1 < (r = (n - i.left) * (this.params.pixelRatio / a) || 0) && (r = 1) : r = (n - i.left + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0, r;
        } }, { key: "setupWrapperEvents", value: function value() {
          var n = this;this.wrapper.addEventListener("click", function (e) {
            var t = n.wrapper.offsetHeight - n.wrapper.clientHeight;if (0 != t) {
              var r = n.wrapper.getBoundingClientRect();if (e.clientY >= r.bottom - t) return;
            }n.params.interact && n.fireEvent("click", e, n.handleEvent(e));
          }), this.wrapper.addEventListener("scroll", function (e) {
            return n.fireEvent("scroll", e);
          });
        } }, { key: "drawPeaks", value: function value(e, t, r, n) {
          this.setWidth(t) || this.clearWave(), this.params.barWidth ? this.drawBars(e, 0, r, n) : this.drawWave(e, 0, r, n);
        } }, { key: "resetScroll", value: function value() {
          null !== this.wrapper && (this.wrapper.scrollLeft = 0);
        } }, { key: "recenter", value: function value(e) {
          var t = this.wrapper.scrollWidth * e;this.recenterOnPosition(t, !0);
        } }, { key: "recenterOnPosition", value: function value(e, t) {
          var r = this.wrapper.scrollLeft,
              n = ~~(this.wrapper.clientWidth / 2),
              i = this.wrapper.scrollWidth - this.wrapper.clientWidth,
              a = e - n,
              s = a - r;if (0 != i) {
            if (!t && -n <= s && s < n) {
              a = r + (s = Math.max(-5, Math.min(5, s)));
            }(a = Math.max(0, Math.min(i, a))) != r && (this.wrapper.scrollLeft = a);
          }
        } }, { key: "getScrollX", value: function value() {
          var e = this.params.pixelRatio,
              t = Math.round(this.wrapper.scrollLeft * e);if (this.params.scrollParent) {
            var r = ~~(this.wrapper.scrollWidth * e - this.getWidth());t = Math.min(r, Math.max(0, t));
          }return t;
        } }, { key: "getWidth", value: function value() {
          return Math.round(this.container.clientWidth * this.params.pixelRatio);
        } }, { key: "setWidth", value: function value(e) {
          return this.width != e && (this.width = e, this.params.fillParent || this.params.scrollParent ? this.style(this.wrapper, { width: "" }) : this.style(this.wrapper, { width: ~~(this.width / this.params.pixelRatio) + "px" }), this.updateSize(), !0);
        } }, { key: "setHeight", value: function value(e) {
          return e != this.height && (this.height = e, this.style(this.wrapper, { height: ~~(this.height / this.params.pixelRatio) + "px" }), this.updateSize(), !0);
        } }, { key: "progress", value: function value(e) {
          var t = 1 / this.params.pixelRatio,
              r = Math.round(e * this.width) * t;if (r < this.lastPos || r - this.lastPos >= t) {
            if (this.lastPos = r, this.params.scrollParent && this.params.autoCenter) {
              var n = ~~(this.wrapper.scrollWidth * e);this.recenterOnPosition(n);
            }this.updateProgress(r);
          }
        } }, { key: "destroy", value: function value() {
          this.unAll(), this.wrapper && (this.wrapper.parentNode == this.container && this.container.removeChild(this.wrapper), this.wrapper = null);
        } }, { key: "updateCursor", value: function value() {} }, { key: "updateSize", value: function value() {} }, { key: "drawBars", value: function value(e, t, r, n) {} }, { key: "drawWave", value: function value(e, t, r, n) {} }, { key: "clearWave", value: function value() {} }, { key: "updateProgress", value: function value(e) {} }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = i, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n,
        a = (n = r(3)) && n.__esModule ? n : { default: n };!function (e) {
      {
        if (e && e.__esModule) return;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }t.default = e;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e, t, r) {
      return (u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, r) {
        var n = function (e, t) {
          for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = l(e));) {}return e;
        }(e, t);if (n) {
          var i = Object.getOwnPropertyDescriptor(n, t);return i.get ? i.get.call(r) : i.value;
        }
      })(e, t, r || e);
    }function l(e) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function c(e, t) {
      return (c = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var h = function (e) {
      function n(e) {
        var t;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (t = o(this, l(n).call(this, e))).params = e, t.media = { currentTime: 0, duration: 0, paused: !0, playbackRate: 1, play: function play() {}, pause: function pause() {}, volume: 0 }, t.mediaType = e.mediaType.toLowerCase(), t.elementPosition = e.elementPosition, t.peaks = null, t.playbackRate = 1, t.volume = 1, t.buffer = null, t.onPlayEnd = null, t;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && c(e, t);
      }(n, a.default), t = n, (r = [{ key: "init", value: function value() {
          this.setPlaybackRate(this.params.audioRate), this.createTimer();
        } }, { key: "createTimer", value: function value() {
          var t = this;this.on("play", function e() {
            t.isPaused() || (t.fireEvent("audioprocess", t.getCurrentTime()), (window.requestAnimationFrame || window.webkitRequestAnimationFrame)(e));
          }), this.on("pause", function () {
            t.fireEvent("audioprocess", t.getCurrentTime());
          });
        } }, { key: "load", value: function value(e, t, r, n) {
          var i = document.createElement(this.mediaType);i.controls = this.params.mediaControls, i.autoplay = this.params.autoplay || !1, i.preload = null == n ? "auto" : n, i.src = e, i.style.width = "100%";var a = t.querySelector(this.mediaType);a && t.removeChild(a), t.appendChild(i), this._load(i, r);
        } }, { key: "loadElt", value: function value(e, t) {
          e.controls = this.params.mediaControls, e.autoplay = this.params.autoplay || !1, this._load(e, t);
        } }, { key: "_load", value: function value(e, t) {
          var r = this;"function" == typeof e.load && e.load(), e.addEventListener("error", function () {
            r.fireEvent("error", "Error loading media element");
          }), e.addEventListener("canplay", function () {
            r.fireEvent("canplay");
          }), e.addEventListener("ended", function () {
            r.fireEvent("finish");
          }), e.addEventListener("play", function () {
            r.fireEvent("play");
          }), e.addEventListener("pause", function () {
            r.fireEvent("pause");
          }), this.media = e, this.peaks = t, this.onPlayEnd = null, this.buffer = null, this.setPlaybackRate(this.playbackRate), this.setVolume(this.volume);
        } }, { key: "isPaused", value: function value() {
          return !this.media || this.media.paused;
        } }, { key: "getDuration", value: function value() {
          if (this.explicitDuration) return this.explicitDuration;var e = (this.buffer || this.media).duration;return 1 / 0 <= e && (e = this.media.seekable.end(0)), e;
        } }, { key: "getCurrentTime", value: function value() {
          return this.media && this.media.currentTime;
        } }, { key: "getPlayedPercents", value: function value() {
          return this.getCurrentTime() / this.getDuration() || 0;
        } }, { key: "getPlaybackRate", value: function value() {
          return this.playbackRate || this.media.playbackRate;
        } }, { key: "setPlaybackRate", value: function value(e) {
          this.playbackRate = e || 1, this.media.playbackRate = this.playbackRate;
        } }, { key: "seekTo", value: function value(e) {
          null != e && (this.media.currentTime = e), this.clearPlayEnd();
        } }, { key: "play", value: function value(e, t) {
          this.seekTo(e);var r = this.media.play();return t && this.setPlayEnd(t), r;
        } }, { key: "pause", value: function value() {
          var e;return this.media && (e = this.media.pause()), this.clearPlayEnd(), e;
        } }, { key: "setPlayEnd", value: function value(t) {
          var r = this;this._onPlayEnd = function (e) {
            t <= e && (r.pause(), r.seekTo(t));
          }, this.on("audioprocess", this._onPlayEnd);
        } }, { key: "clearPlayEnd", value: function value() {
          this._onPlayEnd && (this.un("audioprocess", this._onPlayEnd), this._onPlayEnd = null);
        } }, { key: "getPeaks", value: function value(e, t, r) {
          return this.buffer ? u(l(n.prototype), "getPeaks", this).call(this, e, t, r) : this.peaks || [];
        } }, { key: "setSinkId", value: function value(e) {
          return e ? this.media.setSinkId ? this.media.setSinkId(e) : Promise.reject(new Error("setSinkId is not supported in your browser")) : Promise.reject(new Error("Invalid deviceId: " + e));
        } }, { key: "getVolume", value: function value() {
          return this.volume || this.media.volume;
        } }, { key: "setVolume", value: function value(e) {
          this.volume = e, this.media.volume = this.volume;
        } }, { key: "destroy", value: function value() {
          this.pause(), this.unAll(), this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode && this.media.parentNode.removeChild(this.media), this.media = null;
        } }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = h, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    function i(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function () {
      function e() {
        !function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, e), this.clearPeakCache();
      }var t, r, n;return t = e, (r = [{ key: "clearPeakCache", value: function value() {
          this.peakCacheRanges = [], this.peakCacheLength = -1;
        } }, { key: "addRangeToPeakCache", value: function value(e, t, r) {
          e != this.peakCacheLength && (this.clearPeakCache(), this.peakCacheLength = e);for (var n = [], i = 0; i < this.peakCacheRanges.length && this.peakCacheRanges[i] < t;) {
            i++;
          }for (i % 2 == 0 && n.push(t); i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= r;) {
            n.push(this.peakCacheRanges[i]), i++;
          }i % 2 == 0 && n.push(r), n = n.filter(function (e, t, r) {
            return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];
          }), this.peakCacheRanges = this.peakCacheRanges.concat(n), this.peakCacheRanges = this.peakCacheRanges.sort(function (e, t) {
            return e - t;
          }).filter(function (e, t, r) {
            return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];
          });var a = [];for (i = 0; i < n.length; i += 2) {
            a.push([n[i], n[i + 1]]);
          }return a;
        } }, { key: "getCacheRanges", value: function value() {
          var e,
              t = [];for (e = 0; e < this.peakCacheRanges.length; e += 2) {
            t.push([this.peakCacheRanges[e], this.peakCacheRanges[e + 1]]);
          }return t;
        } }]) && i(t.prototype, r), n && i(t, n), e;
    }();t.default = n, e.exports = t.default;
  }]);
});


},{}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * (Single) Region plugin class
 *
 * Must be turned into an observer before instantiating. This is done in
 * RegionsPlugin (main plugin class)
 *
 * @extends {Observer}
 */
var Region = function () {
    function Region(params, ws) {
        var _this = this;

        _classCallCheck(this, Region);

        this.wavesurfer = ws;
        this.wrapper = ws.drawer.wrapper;
        this.util = ws.util;
        this.style = this.util.style;

        this.id = params.id == null ? ws.util.getId() : params.id;
        this.start = Number(params.start) || 0;
        this.end = params.end == null ? // small marker-like region
        this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);
        this.resize = params.resize === undefined ? true : Boolean(params.resize);
        this.drag = params.drag === undefined ? true : Boolean(params.drag);
        this.loop = Boolean(params.loop);
        this.color = params.color || 'rgba(0, 0, 0, 0.1)';
        this.data = params.data || {};
        this.attributes = params.attributes || {};

        this.maxLength = params.maxLength;
        this.minLength = params.minLength;
        this._onRedraw = function () {
            return _this.updateRender();
        };

        this.scroll = params.scroll !== false && ws.params.scrollParent;
        this.scrollSpeed = params.scrollSpeed || 1;
        this.scrollThreshold = params.scrollThreshold || 10;

        this.bindInOut();
        this.render();
        this.wavesurfer.on('zoom', this._onRedraw);
        this.wavesurfer.on('redraw', this._onRedraw);
        this.wavesurfer.fireEvent('region-created', this);
    }

    /* Update region params. */


    _createClass(Region, [{
        key: 'update',
        value: function update(params) {
            if (null != params.start) {
                this.start = Number(params.start);
            }
            if (null != params.end) {
                this.end = Number(params.end);
            }
            if (null != params.loop) {
                this.loop = Boolean(params.loop);
            }
            if (null != params.color) {
                this.color = params.color;
            }
            if (null != params.data) {
                this.data = params.data;
            }
            if (null != params.resize) {
                this.resize = Boolean(params.resize);
            }
            if (null != params.drag) {
                this.drag = Boolean(params.drag);
            }
            if (null != params.maxLength) {
                this.maxLength = Number(params.maxLength);
            }
            if (null != params.minLength) {
                this.minLength = Number(params.minLength);
            }
            if (null != params.attributes) {
                this.attributes = params.attributes;
            }

            this.updateRender();
            this.fireEvent('update');
            this.wavesurfer.fireEvent('region-updated', this);
        }

        /* Remove a single region. */

    }, {
        key: 'remove',
        value: function remove() {
            if (this.element) {
                this.wrapper.removeChild(this.element);
                this.element = null;
                this.fireEvent('remove');
                this.wavesurfer.un('zoom', this._onRedraw);
                this.wavesurfer.un('redraw', this._onRedraw);
                this.wavesurfer.fireEvent('region-removed', this);
            }
        }

        /* Play the audio region. */

    }, {
        key: 'play',
        value: function play() {
            this.wavesurfer.play(this.start, this.end);
            this.fireEvent('play');
            this.wavesurfer.fireEvent('region-play', this);
        }

        /* Play the region in loop. */

    }, {
        key: 'playLoop',
        value: function playLoop() {
            var _this2 = this;

            this.play();
            this.once('out', function () {
                return _this2.playLoop();
            });
        }

        /* Render a region as a DOM element. */

    }, {
        key: 'render',
        value: function render() {
            var regionEl = document.createElement('region');
            regionEl.className = 'wavesurfer-region';
            regionEl.title = this.formatTime(this.start, this.end);
            regionEl.setAttribute('data-id', this.id);

            for (var attrname in this.attributes) {
                regionEl.setAttribute('data-region-' + attrname, this.attributes[attrname]);
            }

            var width = this.wrapper.scrollWidth;
            this.style(regionEl, {
                position: 'absolute',
                zIndex: 2,
                height: '100%',
                top: '0px'
            });

            /* Resize handles */
            if (this.resize) {
                var handleLeft = regionEl.appendChild(document.createElement('handle'));
                var handleRight = regionEl.appendChild(document.createElement('handle'));
                handleLeft.className = 'wavesurfer-handle wavesurfer-handle-start';
                handleRight.className = 'wavesurfer-handle wavesurfer-handle-end';
                var css = {
                    cursor: 'col-resize',
                    position: 'absolute',
                    left: '0px',
                    top: '0px',
                    width: '1%',
                    maxWidth: '4px',
                    height: '100%'
                };
                this.style(handleLeft, css);
                this.style(handleRight, css);
                this.style(handleRight, {
                    left: '100%'
                });
            }

            this.element = this.wrapper.appendChild(regionEl);
            this.updateRender();
            this.bindEvents(regionEl);
        }
    }, {
        key: 'formatTime',
        value: function formatTime(start, end) {
            return (start == end ? [start] : [start, end]).map(function (time) {
                return [Math.floor(time % 3600 / 60), // minutes
                ('00' + Math.floor(time % 60)).slice(-2) // seconds
                ].join(':');
            }).join('-');
        }
    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
        }

        /* Update element's position, width, color. */

    }, {
        key: 'updateRender',
        value: function updateRender() {
            var dur = this.wavesurfer.getDuration();
            var width = this.getWidth();

            if (this.start < 0) {
                this.start = 0;
                this.end = this.end - this.start;
            }
            if (this.end > dur) {
                this.end = dur;
                this.start = dur - (this.end - this.start);
            }

            if (this.minLength != null) {
                this.end = Math.max(this.start + this.minLength, this.end);
            }

            if (this.maxLength != null) {
                this.end = Math.min(this.start + this.maxLength, this.end);
            }

            if (this.element != null) {
                // Calculate the left and width values of the region such that
                // no gaps appear between regions.
                var left = Math.round(this.start / dur * width);
                var regionWidth = Math.round(this.end / dur * width) - left;

                this.style(this.element, {
                    left: left + 'px',
                    width: regionWidth + 'px',
                    backgroundColor: this.color,
                    cursor: this.drag ? 'move' : 'default'
                });

                for (var attrname in this.attributes) {
                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                }

                this.element.title = this.formatTime(this.start, this.end);
            }
        }

        /* Bind audio events. */

    }, {
        key: 'bindInOut',
        value: function bindInOut() {
            var _this3 = this;

            this.firedIn = false;
            this.firedOut = false;

            var onProcess = function onProcess(time) {
                if (!_this3.firedOut && _this3.firedIn && (_this3.start >= Math.round(time * 100) / 100 || _this3.end <= Math.round(time * 100) / 100)) {
                    _this3.firedOut = true;
                    _this3.firedIn = false;
                    _this3.fireEvent('out');
                    _this3.wavesurfer.fireEvent('region-out', _this3);
                }
                if (!_this3.firedIn && _this3.start <= time && _this3.end > time) {
                    _this3.firedIn = true;
                    _this3.firedOut = false;
                    _this3.fireEvent('in');
                    _this3.wavesurfer.fireEvent('region-in', _this3);
                }
            };

            this.wavesurfer.backend.on('audioprocess', onProcess);

            this.on('remove', function () {
                _this3.wavesurfer.backend.un('audioprocess', onProcess);
            });

            /* Loop playback. */
            this.on('out', function () {
                if (_this3.loop) {
                    _this3.wavesurfer.play(_this3.start);
                }
            });
        }

        /* Bind DOM events. */

    }, {
        key: 'bindEvents',
        value: function bindEvents() {
            var _this4 = this;

            this.element.addEventListener('mouseenter', function (e) {
                _this4.fireEvent('mouseenter', e);
                _this4.wavesurfer.fireEvent('region-mouseenter', _this4, e);
            });

            this.element.addEventListener('mouseleave', function (e) {
                _this4.fireEvent('mouseleave', e);
                _this4.wavesurfer.fireEvent('region-mouseleave', _this4, e);
            });

            this.element.addEventListener('click', function (e) {
                e.preventDefault();
                _this4.fireEvent('click', e);
                _this4.wavesurfer.fireEvent('region-click', _this4, e);
            });

            this.element.addEventListener('dblclick', function (e) {
                e.stopPropagation();
                e.preventDefault();
                _this4.fireEvent('dblclick', e);
                _this4.wavesurfer.fireEvent('region-dblclick', _this4, e);
            });

            /* Drag or resize on mousemove. */
            (this.drag || this.resize) && function () {
                var container = _this4.wavesurfer.drawer.container;
                var duration = _this4.wavesurfer.getDuration();
                var scrollSpeed = _this4.scrollSpeed;
                var scrollThreshold = _this4.scrollThreshold;
                var startTime = void 0;
                var touchId = void 0;
                var drag = void 0;
                var maxScroll = void 0;
                var resize = void 0;
                var updated = false;
                var scrollDirection = void 0;
                var wrapperRect = void 0;

                // Scroll when the user is dragging within the threshold
                var edgeScroll = function edgeScroll(e) {
                    if (!scrollDirection || !drag && !resize) {
                        return;
                    }

                    // Update scroll position
                    var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                    _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft));

                    // Update time
                    var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;
                    var delta = time - startTime;
                    startTime = time;

                    // Continue dragging or resizing
                    drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize);

                    // Repeat
                    window.requestAnimationFrame(function () {
                        edgeScroll(e);
                    });
                };

                var onDown = function onDown(e) {
                    if (e.touches && e.touches.length > 1) {
                        return;
                    }
                    touchId = e.targetTouches ? e.targetTouches[0].identifier : null;

                    e.stopPropagation();
                    startTime = _this4.wavesurfer.drawer.handleEvent(e, true) * duration;

                    // Store for scroll calculations
                    maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                    wrapperRect = _this4.wrapper.getBoundingClientRect();

                    if (e.target.tagName.toLowerCase() == 'handle') {
                        if (e.target.classList.contains('wavesurfer-handle-start')) {
                            resize = 'start';
                        } else {
                            resize = 'end';
                        }
                    } else {
                        drag = true;
                        resize = false;
                    }
                };
                var onUp = function onUp(e) {
                    if (e.touches && e.touches.length > 1) {
                        return;
                    }

                    if (drag || resize) {
                        drag = false;
                        scrollDirection = null;
                        resize = false;
                    }

                    if (updated) {
                        updated = false;
                        _this4.util.preventClick();
                        _this4.fireEvent('update-end', e);
                        _this4.wavesurfer.fireEvent('region-update-end', _this4, e);
                    }
                };
                var onMove = function onMove(e) {
                    if (e.touches && e.touches.length > 1) {
                        return;
                    }
                    if (e.targetTouches && e.targetTouches[0].identifier != touchId) {
                        return;
                    }

                    if (drag || resize) {
                        var oldTime = startTime;
                        var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;
                        var delta = time - startTime;
                        startTime = time;

                        // Drag
                        if (_this4.drag && drag) {
                            updated = updated || !!delta;
                            _this4.onDrag(delta);
                        }

                        // Resize
                        if (_this4.resize && resize) {
                            updated = updated || !!delta;
                            _this4.onResize(delta, resize);
                        }

                        if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                            if (drag) {
                                // The threshold is not between the mouse and the container edge
                                // but is between the region and the container edge
                                var regionRect = _this4.element.getBoundingClientRect();
                                var x = regionRect.left - wrapperRect.left;

                                // Check direction
                                if (time < oldTime && x >= 0) {
                                    scrollDirection = -1;
                                } else if (time > oldTime && x + regionRect.width <= wrapperRect.right) {
                                    scrollDirection = 1;
                                }

                                // Check that we are still beyond the threshold
                                if (scrollDirection === -1 && x > scrollThreshold || scrollDirection === 1 && x + regionRect.width < wrapperRect.right - scrollThreshold) {
                                    scrollDirection = null;
                                }
                            } else {
                                // Mouse based threshold
                                var _x = e.clientX - wrapperRect.left;

                                // Check direction
                                if (_x <= scrollThreshold) {
                                    scrollDirection = -1;
                                } else if (_x >= wrapperRect.right - scrollThreshold) {
                                    scrollDirection = 1;
                                } else {
                                    scrollDirection = null;
                                }
                            }

                            scrollDirection && edgeScroll(e);
                        }
                    }
                };

                _this4.element.addEventListener('mousedown', onDown);
                _this4.element.addEventListener('touchstart', onDown);

                _this4.wrapper.addEventListener('mousemove', onMove);
                _this4.wrapper.addEventListener('touchmove', onMove);

                document.body.addEventListener('mouseup', onUp);
                document.body.addEventListener('touchend', onUp);

                _this4.on('remove', function () {
                    document.body.removeEventListener('mouseup', onUp);
                    document.body.removeEventListener('touchend', onUp);
                    _this4.wrapper.removeEventListener('mousemove', onMove);
                    _this4.wrapper.removeEventListener('touchmove', onMove);
                });

                _this4.wavesurfer.on('destroy', function () {
                    document.body.removeEventListener('mouseup', onUp);
                    document.body.removeEventListener('touchend', onUp);
                });
            }();
        }
    }, {
        key: 'onDrag',
        value: function onDrag(delta) {
            var maxEnd = this.wavesurfer.getDuration();
            if (this.end + delta > maxEnd || this.start + delta < 0) {
                return;
            }

            this.update({
                start: this.start + delta,
                end: this.end + delta
            });
        }
    }, {
        key: 'onResize',
        value: function onResize(delta, direction) {
            if (direction == 'start') {
                this.update({
                    start: Math.min(this.start + delta, this.end),
                    end: Math.max(this.start + delta, this.end)
                });
            } else {
                this.update({
                    start: Math.min(this.end + delta, this.start),
                    end: Math.max(this.end + delta, this.start)
                });
            }
        }
    }]);

    return Region;
}();

/**
 * @typedef {Object} RegionsPluginParams
 * @property {?boolean} dragSelection Enable creating regions by dragging wih
 * the mouse
 * @property {?RegionParams[]} regions Regions that should be added upon
 * initialisation
 * @property {number} slop=2 The sensitivity of the mouse dragging
 * @property {?boolean} deferInit Set to true to manually call
 * `initPlugin('regions')`
 */

/**
 * @typedef {Object} RegionParams
 * @desc The parameters used to describe a region.
 * @example wavesurfer.addRegion(regionParams);
 * @property {string} id=→random The id of the region
 * @property {number} start=0 The start position of the region (in seconds).
 * @property {number} end=0 The end position of the region (in seconds).
 * @property {?boolean} loop Whether to loop the region when played back.
 * @property {boolean} drag=true Allow/dissallow dragging the region.
 * @property {boolean} resize=true Allow/dissallow resizing the region.
 * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.
 */

/**
 * Regions are visual overlays on waveform that can be used to play and loop
 * portions of audio. Regions can be dragged and resized.
 *
 * Visual customization is possible via CSS (using the selectors
 * `.wavesurfer-region` and `.wavesurfer-handle`).
 *
 * @implements {PluginClass}
 * @extends {Observer}
 *
 * @example
 * // es6
 * import RegionsPlugin from 'wavesurfer.regions.js';
 *
 * // commonjs
 * var RegionsPlugin = require('wavesurfer.regions.js');
 *
 * // if you are using <script> tags
 * var RegionsPlugin = window.WaveSurfer.regions;
 *
 * // ... initialising wavesurfer with the plugin
 * var wavesurfer = WaveSurfer.create({
 *   // wavesurfer options ...
 *   plugins: [
 *     RegionsPlugin.create({
 *       // plugin options ...
 *     })
 *   ]
 * });
 */


var RegionsPlugin = function () {
    _createClass(RegionsPlugin, null, [{
        key: 'create',

        /**
         * Regions plugin definition factory
         *
         * This function must be used to create a plugin definition which can be
         * used by wavesurfer to correctly instantiate the plugin.
         *
         * @param {RegionsPluginParams} params parameters use to initialise the plugin
         * @return {PluginDefinition} an object representing the plugin
         */
        value: function create(params) {
            return {
                name: 'regions',
                deferInit: params && params.deferInit ? params.deferInit : false,
                params: params,
                staticProps: {
                    initRegions: function initRegions() {
                        console.warn('Deprecated initRegions! Use wavesurfer.initPlugins("regions") instead!');
                        this.initPlugin('regions');
                    },
                    addRegion: function addRegion(options) {
                        if (!this.initialisedPluginList.regions) {
                            this.initPlugin('regions');
                        }
                        return this.regions.add(options);
                    },
                    clearRegions: function clearRegions() {
                        this.regions && this.regions.clear();
                    },
                    enableDragSelection: function enableDragSelection(options) {
                        if (!this.initialisedPluginList.regions) {
                            this.initPlugin('regions');
                        }
                        this.regions.enableDragSelection(options);
                    },
                    disableDragSelection: function disableDragSelection() {
                        this.regions.disableDragSelection();
                    }
                },
                instance: RegionsPlugin
            };
        }
    }]);

    function RegionsPlugin(params, ws) {
        var _this5 = this;

        _classCallCheck(this, RegionsPlugin);

        this.params = params;
        this.wavesurfer = ws;
        this.util = ws.util;

        // turn the plugin instance into an observer
        var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);
        observerPrototypeKeys.forEach(function (key) {
            Region.prototype[key] = _this5.util.Observer.prototype[key];
        });
        this.wavesurfer.Region = Region;

        // Id-based hash of regions.
        this.list = {};
        this._onReady = function () {
            _this5.wrapper = _this5.wavesurfer.drawer.wrapper;
            if (_this5.params.regions) {
                _this5.params.regions.forEach(function (region) {
                    _this5.add(region);
                });
            }
            if (_this5.params.dragSelection) {
                _this5.enableDragSelection(_this5.params);
            }
        };
    }

    _createClass(RegionsPlugin, [{
        key: 'init',
        value: function init() {
            // Check if ws is ready
            if (this.wavesurfer.isReady) {
                this._onReady();
            }
            this.wavesurfer.on('ready', this._onReady);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.wavesurfer.un('ready', this._onReady);
            this.disableDragSelection();
            this.clear();
        }
        /* Add a region. */

    }, {
        key: 'add',
        value: function add(params) {
            var _this6 = this;

            var region = new this.wavesurfer.Region(params, this.wavesurfer);

            this.list[region.id] = region;

            region.on('remove', function () {
                delete _this6.list[region.id];
            });

            return region;
        }

        /* Remove all regions. */

    }, {
        key: 'clear',
        value: function clear() {
            var _this7 = this;

            Object.keys(this.list).forEach(function (id) {
                _this7.list[id].remove();
            });
        }
    }, {
        key: 'enableDragSelection',
        value: function enableDragSelection(params) {
            var _this8 = this;

            var slop = params.slop || 2;
            var container = this.wavesurfer.drawer.container;
            var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;
            var scrollSpeed = params.scrollSpeed || 1;
            var scrollThreshold = params.scrollThreshold || 10;
            var drag = void 0;
            var duration = this.wavesurfer.getDuration();
            var maxScroll = void 0;
            var start = void 0;
            var region = void 0;
            var touchId = void 0;
            var pxMove = 0;
            var scrollDirection = void 0;
            var wrapperRect = void 0;

            // Scroll when the user is dragging within the threshold
            var edgeScroll = function edgeScroll(e) {
                if (!region || !scrollDirection) {
                    return;
                }

                // Update scroll position
                var scrollLeft = _this8.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                _this8.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft));

                // Update range
                var end = _this8.wavesurfer.drawer.handleEvent(e);
                region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                });

                // Check that there is more to scroll and repeat
                if (scrollLeft < maxScroll && scrollLeft > 0) {
                    window.requestAnimationFrame(function () {
                        edgeScroll(e);
                    });
                }
            };

            var eventDown = function eventDown(e) {
                if (e.touches && e.touches.length > 1) {
                    return;
                }
                duration = _this8.wavesurfer.getDuration();
                touchId = e.targetTouches ? e.targetTouches[0].identifier : null;

                // Store for scroll calculations
                maxScroll = _this8.wrapper.scrollWidth - _this8.wrapper.clientWidth;
                wrapperRect = _this8.wrapper.getBoundingClientRect();

                drag = true;
                start = _this8.wavesurfer.drawer.handleEvent(e, true);
                region = null;
                scrollDirection = null;
            };
            this.wrapper.addEventListener('mousedown', eventDown);
            this.wrapper.addEventListener('touchstart', eventDown);
            this.on('disable-drag-selection', function () {
                _this8.wrapper.removeEventListener('touchstart', eventDown);
                _this8.wrapper.removeEventListener('mousedown', eventDown);
            });

            var eventUp = function eventUp(e) {
                if (e.touches && e.touches.length > 1) {
                    return;
                }

                drag = false;
                pxMove = 0;
                scrollDirection = null;

                if (region) {
                    _this8.util.preventClick();
                    region.fireEvent('update-end', e);
                    _this8.wavesurfer.fireEvent('region-update-end', region, e);
                }

                region = null;
            };
            this.wrapper.addEventListener('mouseup', eventUp);
            this.wrapper.addEventListener('touchend', eventUp);

            document.body.addEventListener('mouseup', eventUp);
            document.body.addEventListener('touchend', eventUp);
            this.on('disable-drag-selection', function () {
                document.body.removeEventListener('mouseup', eventUp);
                document.body.removeEventListener('touchend', eventUp);
                _this8.wrapper.removeEventListener('touchend', eventUp);
                _this8.wrapper.removeEventListener('mouseup', eventUp);
            });

            var eventMove = function eventMove(e) {
                if (!drag) {
                    return;
                }
                if (++pxMove <= slop) {
                    return;
                }

                if (e.touches && e.touches.length > 1) {
                    return;
                }
                if (e.targetTouches && e.targetTouches[0].identifier != touchId) {
                    return;
                }

                if (!region) {
                    region = _this8.add(params || {});
                }

                var end = _this8.wavesurfer.drawer.handleEvent(e);
                region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                });

                // If scrolling is enabled
                if (scroll && container.clientWidth < _this8.wrapper.scrollWidth) {
                    // Check threshold based on mouse
                    var x = e.clientX - wrapperRect.left;
                    if (x <= scrollThreshold) {
                        scrollDirection = -1;
                    } else if (x >= wrapperRect.right - scrollThreshold) {
                        scrollDirection = 1;
                    } else {
                        scrollDirection = null;
                    }
                    scrollDirection && edgeScroll(e);
                }
            };
            this.wrapper.addEventListener('mousemove', eventMove);
            this.wrapper.addEventListener('touchmove', eventMove);
            this.on('disable-drag-selection', function () {
                _this8.wrapper.removeEventListener('touchmove', eventMove);
                _this8.wrapper.removeEventListener('mousemove', eventMove);
            });
        }
    }, {
        key: 'disableDragSelection',
        value: function disableDragSelection() {
            this.fireEvent('disable-drag-selection');
        }

        /* Get current region
         *  The smallest region that contains the current time.
         *  If several such regions exist, we take the first.
         *  Return null if none exist. */

    }, {
        key: 'getCurrentRegion',
        value: function getCurrentRegion() {
            var _this9 = this;

            var time = this.wavesurfer.getCurrentTime();
            var min = null;
            Object.keys(this.list).forEach(function (id) {
                var cur = _this9.list[id];
                if (cur.start <= time && cur.end >= time) {
                    if (!min || cur.end - cur.start < min.end - min.start) {
                        min = cur;
                    }
                }
            });

            return min;
        }
    }]);

    return RegionsPlugin;
}();

exports.default = RegionsPlugin;

},{}],137:[function(require,module,exports){
'use strict';

// lib

var _require = require('iblokz-data'),
    obj = _require.obj;

// initial state


var initial = {
	number: 0
};

// action
var set = function set(number) {
	return function (state) {
		return obj.patch(state, 'counter', { number: number });
	};
};
var incr = function incr() {
	return function (state) {
		return obj.patch(state, 'counter', { number: state.counter.number + 1 });
	};
};
var decr = function decr() {
	return function (state) {
		return obj.patch(state, 'counter', { number: state.counter.number - 1 });
	};
};

module.exports = {
	initial: initial,
	set: set,
	incr: incr,
	decr: decr
};

},{"iblokz-data":10}],138:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

// namespaces=


var counter = require('./counter');
var midiMap = require('./midi-map');

// initial
var initial = {
	mode: 1,
	stt: false,
	sttMic: false,
	query: '',
	session: {
		sample: 'assets/LatinEthnoElektroGroove.mp3',
		playing: false,
		focused: [0, 0],
		pads: {}
	},
	samples: {
		list: [],
		query: {
			page: 1,
			pattern: '',
			source: 'freesound',
			limit: 12
		}
	},
	rack: {
		vcf: {
			on: false,
			type: 'lowpass',
			cutoff: 0.64,
			resonance: 0,
			gain: 0
		},
		reverb: {
			on: false,
			seconds: 3,
			decay: 2,
			reverse: false,
			dry: 0.8,
			wet: 0.7
		}
	}
};

// actions
var set = function set(key, value) {
	return function (state) {
		return obj.patch(state, key, value);
	};
};
var toggle = function toggle(key) {
	return function (state) {
		return obj.patch(state, key, !obj.sub(state, key));
	};
};
var arrToggle = function arrToggle(key, value) {
	return function (state) {
		return obj.patch(state, key, arr.toggle(obj.sub(state, key), value));
	};
};

module.exports = {
	initial: initial,
	// namespaces
	midiMap: midiMap,
	// actions
	set: set,
	toggle: toggle,
	arrToggle: arrToggle
};

},{"./counter":137,"./midi-map":139,"iblokz-data":10}],139:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Rx = require('rx');
var $ = Rx.Observable;

// util

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

var arrMod = function arrMod(a, p, v) {
	return [].concat(a.slice(0, p[0]), [p.length === 1 ? v : arrMod(a[p[0]], p.slice(1), v)], a.slice(p[0] + 1));
};

var initial = {
	devices: {
		inputs: [],
		outputs: []
	},
	settings: {
		midiRouteToActive: true
	},
	clock: {
		in: [],
		out: []
	},
	data: {
		in: [],
		out: []
	},
	pitch: 0,
	channels: {},
	map: [['controller', 20, ['instrument', 'vcf', 'cutoff']], ['controller', 21, ['instrument', 'vcf', 'resonance']], ['controller', 22, ['studio', 'bpm'], 60, 200, 0], ['controller', 23, ['studio', 'volume']], ['controller', 24, ['instrument', 'eg', 'attack']], ['controller', 25, ['instrument', 'eg', 'decay']], ['controller', 26, ['instrument', 'eg', 'sustain']], ['controller', 27, ['instrument', 'eg', 'release']]]
};

var connect = function connect(devices) {
	return function (state) {
		return obj.patch(state, 'midiMap', {
			devices: devices,
			data: _extends({}, state.midiMap.data, {
				in: state.midiMap.data.in.indexOf(devices.inputs.findIndex(function (dev) {
					return dev.name.match(/MPKmini2/);
				})) === -1 ? arr.add(state.midiMap.data.in, devices.inputs.findIndex(function (dev) {
					return dev.name.match(/MPKmini2/);
				})) : state.midiMap.data.in
			})
		});
	};
};

var toggleClock = function toggleClock(inOut, index) {
	return function (state) {
		return obj.patch(state, ['midiMap', 'clock', inOut], arr.toggle(obj.sub(state, ['midiMap', 'clock'])[inOut], index));
	};
};

var toggleData = function toggleData(inOut, index) {
	return function (state) {
		return obj.patch(state, ['midiMap', 'data', inOut], arr.toggle(obj.sub(state, ['midiMap', 'data', inOut]), index));
	};
};

var noteOn = function noteOn() {
	var device = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	var channel = arguments[1];
	var note = arguments[2];
	var velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	return function (state) {
		return channel !== undefined ?
		// console.log(state.midiMap.channels, obj.sub(state, ['midiMap', 'channels', channel, note]), channel, note, velocity),
		velocity !== 0 ? obj.patch(state, ['midiMap', 'channels', device, channel, note], velocity) : obj.patch(state, ['midiMap', 'channels', device], _defineProperty({}, channel, obj.filter(obj.sub(state, ['midiMap', 'channels', device, channel]) || {}, function (key, value) {
			return key !== note;
		}))) : state;
	};
};

var panic = function panic() {
	return function (state) {
		return obj.patch(state, ['midiMap', 'channels'], {});
	};
};

var modify = function modify(p, v) {
	return function (state) {
		return obj.patch(state, ['midiMap'], {
			map: arrMod(state.midiMap.map, p, v)
		});
	};
};

module.exports = {
	initial: initial,
	connect: connect,
	toggleClock: toggleClock,
	toggleData: toggleData,
	noteOn: noteOn,
	panic: panic,
	modify: modify
};

},{"iblokz-data":10,"rx":123}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _regions = require('wavesurfer.js/src/plugin/regions.js');

var _regions2 = _interopRequireDefault(_regions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ExtWSRegionsPlugin = function (_RegionsPlugin) {
	_inherits(ExtWSRegionsPlugin, _RegionsPlugin);

	function ExtWSRegionsPlugin() {
		_classCallCheck(this, ExtWSRegionsPlugin);

		return _possibleConstructorReturn(this, (ExtWSRegionsPlugin.__proto__ || Object.getPrototypeOf(ExtWSRegionsPlugin)).apply(this, arguments));
	}

	_createClass(ExtWSRegionsPlugin, [{
		key: 'add',
		value: function add(params) {
			var _this2 = this;

			// console.log(this.params);
			if (this.params.singleRegion === true) {
				this.clear();
			}

			var region = new this.wavesurfer.Region(params, this.wavesurfer);

			this.list[region.id] = region;

			region.on('remove', function () {
				delete _this2.list[region.id];
			});

			return region;
		}
	}], [{
		key: 'create',

		// constructor(params, ws) {
		// 	super(params, ws);
		// }
		value: function create(params) {
			var _RegionsPlugin$create = _regions2.default.create(params),
			    staticProps = _RegionsPlugin$create.staticProps;

			return {
				name: 'regions',
				deferInit: params && params.deferInit ? params.deferInit : false,
				params: params,
				staticProps: staticProps,
				instance: ExtWSRegionsPlugin
			};
		}
	}]);

	return ExtWSRegionsPlugin;
}(_regions2.default);

exports.default = ExtWSRegionsPlugin;

},{"wavesurfer.js/src/plugin/regions.js":136}],141:[function(require,module,exports){
'use strict';

// lib

var Rx = require('rx');
var $ = Rx.Observable;

// iblokz
var vdom = require('iblokz-snabbdom-helpers');

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

// app


var app = require('./util/app');
var actions = app.adapt(require('./actions'));
var ui = require('./ui');
var actions$ = void 0;
var state$ = new Rx.BehaviorSubject();
// services
// wavesurfer
var wavesurfer = require('./services/wavesurfer.js');
// samples - audiocommons
var samples = require('./services/samples.js');
actions = app.attach(actions, 'samples', samples.actions);
// pads
var pads = require('./services/pads.js');
actions = app.attach(actions, 'pads', pads.actions);
// midi
var midi = require('./services/midi.js');
actions = app.attach(actions, 'midi', midi.actions);
// stt - speach to text
var stt = require('./services/stt.js');
// control
var control = require('./services/control.js');
actions = app.attach(actions, 'control', control.actions);

// hot reloading
if (module.hot) {
	// actions
	actions$ = $.fromEventPattern(function (h) {
		return module.hot.accept("./actions", h);
	}).flatMap(function () {
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		return actions.stream.startWith(function (state) {
			return state;
		});
	}).merge(actions.stream);
	// ui
	module.hot.accept("./ui", function () {
		ui = require('./ui');
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// services
	// wavesurfer
	module.hot.accept("./services/wavesurfer.js", function () {
		wavesurfer.unhook();
		wavesurfer = require('./services/wavesurfer.js');
		wavesurfer.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// samples
	module.hot.accept("./services/samples.js", function () {
		samples.unhook();
		samples = require('./services/samples.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		samples.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// pads
	module.hot.accept("./services/pads.js", function () {
		pads.unhook();
		pads = require('./services/pads.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		pads.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// midi
	module.hot.accept("./services/midi.js", function () {
		midi.unhook();
		midi = require('./services/midi.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		midi.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// stt
	module.hot.accept("./services/stt.js", function () {
		stt.unhook();
		stt = require('./services/stt.js');
		stt.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// control
	module.hot.accept("./services/control.js", function () {
		control.unhook();
		control = require('./services/control.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		control.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
} else {
	actions$ = actions.stream;
}

// actions -> state
actions$.map(function (action) {
	return action.path && console.log(action.path.join('.'), action.payload), console.log(action), action;
}).startWith(function () {
	return actions.initial;
}).scan(function (state, change) {
	return change(state);
}, {}).map(function (state) {
	return console.log(state), state;
}).subscribe(function (state) {
	return state$.onNext(state);
});

// state -> ui
var ui$ = state$.map(function (state) {
	return ui({ state: state, actions: actions });
});
vdom.patchStream(ui$, '#ui');

wavesurfer.hook({ state$: state$, actions: actions });
samples.hook({ state$: state$, actions: actions });
pads.hook({ state$: state$, actions: actions });
midi.hook({ state$: state$, actions: actions });
stt.hook({ state$: state$, actions: actions });
control.hook({ state$: state$, actions: actions });

// livereload impl.
if (module.hot) {
	document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></script>');
}

},{"./actions":138,"./services/control.js":142,"./services/midi.js":143,"./services/pads.js":144,"./services/samples.js":145,"./services/stt.js":146,"./services/wavesurfer.js":147,"./ui":150,"./util/app":156,"iblokz-data":10,"iblokz-snabbdom-helpers":15,"rx":123}],142:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;

var gamepad = require('../util/gamepad');

var actions = {
	initial: {}
};

var play = function play(url) {
	var an = document.createElement('AUDIO');
	an.setAttribute('autoplay', true);
	an.src = url;
};

var keyMap = [['7', '8', '9', '0'], ['u', 'i', 'o', 'p'], ['j', 'k', 'l', ';'], ['m', ',', '.', '/']];

var getIndex = function getIndex(key) {
	return keyMap.reduce(function (p1, cols, row) {
		return p1.row === -1 ? cols.reduce(function (p2, mapKey, col) {
			return key === mapKey ? { row: row, col: col } : p2;
		}, p1) : p1;
	}, { row: -1, col: -1 });
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	gamepad.changes().map(function (pads) {
		return console.log({ pads: pads }), pads;
	}).withLatestFrom(state$, function (pads, state) {
		return { pads: pads, state: state };
	}).subscribe(function (_ref2) {
		var pads = _ref2.pads,
		    state = _ref2.state;

		console.log(pads[0]);
		if (pads[0]) {
			if (pads[0].axes[1] === -1) actions.samples.prev();
			// if (pads[0].axes[0] > 0) actions.move('right');
			if (pads[0].axes[1] === 1) actions.samples.next();
			// if (pads[0].axes[0] < 0) actions.move('left');
			if (pads[0].buttons[8].pressed === true) {
				if (state.samples.list[state.samples.index]) play(state.samples.list[state.samples.index].sound);
			}
			if (pads[0].buttons[3].pressed === true) {
				var sample = state.samples.list[state.samples.index];
				if (sample) actions.pads.load(sample, sample.sound);
			}
			if (pads[0].buttons[0].pressed === true) {
				actions.set('sttMic', true);
			}
			if (pads[0].buttons[1].pressed === true) {
				actions.set('mode', 0);
			}
			if (pads[0].buttons[2].pressed === true) {
				actions.set('mode', 1);
			}
		}
	});

	$.fromEvent(document, 'keydown').filter(function (ev) {
		return ['input', 'textarea'].indexOf(ev.target.tagName.toLowerCase()) === -1 || ev.target.tagName.toLowerCase() === 'input' && ev.target.type === 'range';
	}).withLatestFrom(state$, function (ev, state) {
		return { ev: ev, state: state };
	}).subscribe(function (_ref3) {
		var ev = _ref3.ev,
		    state = _ref3.state;

		if (ev.key > 0 && ev.key < 4) {
			actions.set('mode', parseInt(ev.key, 10) - 1);
		} else {
			var pos = getIndex(ev.key);
			console.log(ev.key, ev.target, pos);
			if (pos.row !== -1) {
				actions.set(['pads', 'focused'], [pos.row, pos.col]);
				if (state.mode === 2) actions.midi.trigger(pos.row, pos.col);
			}
		}
	});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/gamepad":165,"rx":123}],143:[function(require,module,exports){
'use strict';
// lib

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj;

var midi = require('../util/midi');
var pocket = require('../util/pocket');
var a = require('../util/audio');
var sampler = require('../util/audio/sources/sampler');

var reverb = a.connect(a.create('reverb', {
	on: false,
	wet: 0.1,
	dry: 0.9
}), a.context.destination);

var vcf = a.connect(a.create('vcf', {
	on: false,
	type: 'lowpass',
	cutoff: 0.64,
	resonance: 0,
	gain: 0
}), reverb);

var rack = {};

var getIds = function getIds(inputs, indexes) {
	return inputs.map(function (inp) {
		return inp.id;
	}).filter(function (id, i) {
		return indexes.indexOf(i) > -1;
	});
};

var trigger = function trigger(row, col) {
	return function (state) {
		var sampleId = obj.sub(state, ['pads', 'map', row, col, 'id']);
		if (sampleId) {
			var inst = sampler.clone(pocket.get(['sampleBank', sampleId]));
			inst = a.connect(inst, state.rack.vcf.on ? vcf : state.rack.reverb.on ? reverb : a.context.destination);
			a.start(inst);
		}
		return state;
	};
};

var actions = {
	initial: {},
	trigger: trigger
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	var _midi$init = midi.init(),
	    devices$ = _midi$init.devices$,
	    msg$ = _midi$init.msg$;

	// audio rack


	subs.push(state$.distinctUntilChanged(function (state) {
		return state.rack;
	}).subscribe(function (state) {
		reverb = a.update(reverb, state.rack.reverb);
		vcf = a.update(vcf, state.rack.vcf);
		if (state.rack.reverb.on) {
			vcf = a.disconnect(vcf);
			vcf = a.connect(vcf, reverb);
		} else {
			vcf = a.disconnect(vcf);
			vcf = a.connect(vcf, a.context.destination);
		}
	}));

	// midi device access
	subs.push(devices$.subscribe(function (data) {
		return actions.midiMap.connect(data);
	}));

	var parsedMidiMsg$ = msg$.map(function (raw) {
		return { msg: midi.parseMidiMsg(raw.msg), raw: raw };
	})
	// .map(data => (console.log(data), data))
	.share();

	// midi messages
	subs.push(parsedMidiMsg$.map(function (midiData) {
		return console.log({ midiData: midiData }), midiData;
	})
	// .filter(({msg}) => ['noteOn', 'noteOff'].indexOf(msg.state) > -1)
	.filter(function (_ref2) {
		var msg = _ref2.msg;
		return msg.state === 'controller' || msg.state === 'noteOn';
	}).withLatestFrom(state$, function (midiData, state) {
		return _extends({}, midiData, { state: state });
	})
	// .filter(({raw, state}) => (
	// 	// console.log(raw.input.id, state.midiMap.devices.inputs, state.midiMap.data.in),
	// 	getIds(state.midiMap.devices.inputs, state.midiMap.data.in).indexOf(
	// 		raw.input.id
	// 	) > -1
	// ))
	.subscribe(function (_ref3) {
		var raw = _ref3.raw,
		    msg = _ref3.msg,
		    state = _ref3.state;

		// console.log(state.midiMap.devices.inputs, raw.input);
		// traktor
		if (msg.channel === 13 && msg.state === 'controller' && msg.value === 1) {
			if (msg.controller >= 10 && msg.controller <= 26) {
				var col = (msg.controller - 10) % 4;
				var row = (msg.controller - 10 - col) / 4;
				var sampleId = obj.sub(state, ['pads', 'map', row, col]);
				// let inst;
				actions.set(['pads', 'focused'], [row, col]);
				if (state.mode === 2) trigger(row, col)(state);
			}
			if (msg.controller >= 37 && msg.controller <= 39) {
				actions.set('mode', msg.controller - 37);
			}
		}
		if (msg.channel === 10 && msg.state === 'noteOn') {
			var _col = (msg.note.number - 60) % 4;
			var _row = (msg.note.number - 60 - _col) / 4 + ((msg.note.number - 60 - _col) / 4 % 2 === 1 ? -1 : 1);
			// console.log((msg.note.number - 60 - col) / 4, (msg.note.number - 60 - col) % 2, row, col);
			actions.set(['pads', 'focused'], [_row, _col]);
			if (state.mode === 2) trigger(_row, _col)(state);
		}
		if (msg.channel === 11 && msg.state === 'noteOn') {
			var _col2 = (msg.note.number - 55) % 10;
			var _row2 = (msg.note.number - 55 - _col2) / 10;
			// console.log((msg.note.number - 60 - col) / 4, (msg.note.number - 60 - col) % 2, row, col);
			actions.set(['pads', 'focused'], [_row2, _col2]);
			if (state.mode === 2) trigger(_row2, _col2)(state);
		}
	}));

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/audio":161,"../util/audio/sources/sampler":162,"../util/midi":166,"../util/pocket":167,"iblokz-data":10,"rx":123}],144:[function(require,module,exports){
'use strict';
// lib

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var pocket = require('../util/pocket');
var file = require('../util/file');

var _require2 = require('../util/audio'),
    context = _require2.context;

var sampler = require('../util/audio/sources/sampler');

var load = function load(sample, url) {
	return $.fromPromise(fetch(url.replace('http://', '//')).then(function (res) {
		return res.arrayBuffer();
	})).concatMap(function (buffer) {
		return $.fromCallback(context.decodeAudioData, context)(buffer);
	}).map(function (buffer) {
		return {
			sample: sample,
			node: sampler.create(url, buffer)
		};
	}).map(function (_ref) {
		var sample = _ref.sample,
		    node = _ref.node;
		return pocket.put(['sampleBank', sample.id], node), function (state) {
			return obj.patch(state, ['pads', 'map'].concat(_toConsumableArray(state.pads.focused)), sample);
		};
	});
};

var actions = {
	initial: {
		focused: [0, 0],
		map: {}
	},
	load: load
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/audio":161,"../util/audio/sources/sampler":162,"../util/file":163,"../util/pocket":167,"iblokz-data":10,"rx":123}],145:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;

var request = require('superagent');

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = require('../util/pocket');

var url = 'https://m2.audiocommons.org/api/audioclips';

var search = function search(_ref) {
	var pattern = _ref.pattern,
	    _ref$source = _ref.source,
	    source = _ref$source === undefined ? 'freesound' : _ref$source,
	    _ref$limit = _ref.limit,
	    limit = _ref$limit === undefined ? 12 : _ref$limit,
	    _ref$page = _ref.page,
	    page = _ref$page === undefined ? 1 : _ref$page;
	return request.get(url + '/search').query({ pattern: pattern, source: source, limit: limit, page: page }).then(function (res) {
		return res.body.results;
	}).then(function (results) {
		return console.log(results), results;
	}).then(function (results) {
		return results[0].members.map(function (m) {
			return {
				id: m.content['@id'],
				name: m.content.title,
				author: m.content.author.replace('freesound-users:', ''),
				sound: m.content.availableAs[0].locator,
				image: m.content.images[0].locator,
				license: m.content.license,
				duration: m.content.duration
			};
		});
	}).then(function (list) {
		return function (state) {
			return obj.patch(state, ['samples'], {
				list: page > 1 ? [].concat(state.samples.list, list) : list,
				query: { pattern: pattern, source: source, limit: limit, page: page } });
		};
	});
};

var next = function next() {
	return function (state) {
		return obj.patch(state, ['samples'], {
			index: state.samples.index < state.samples.list.length - 1 ? state.samples.index + 1 : state.samples.index
		});
	};
};

var prev = function prev() {
	return function (state) {
		return obj.patch(state, ['samples'], {
			index: state.samples.index > 0 ? state.samples.index - 1 : state.samples.index
		});
	};
};

var actions = {
	initial: {
		list: [],
		index: 0
	},
	search: search,
	next: next,
	prev: prev
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];
	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/pocket":167,"iblokz-data":10,"rx":123,"superagent":128}],146:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;
var request = require('superagent');

var SpeechSDK = window.SpeechSDK;

var subscriptionKey = 'c63057e1219441489c1b43132685c4b8';
var region = 'westus';
var url = 'https://' + region + '.api.cognitive.microsoft.com/sts/v1.0/issueToken';

var init = function init(token) {
	var speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
	speechConfig.speechRecognitionLanguage = "en-GB";
	var audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
	var recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);
	return recognizer;
};

var recognize = function recognize(recognizer) {
	return $.fromCallback(recognizer.recognizeOnceAsync, recognizer)().map(function (res) {
		return console.log(res), res;
	});
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	request.post(url).set({
		'Content-Type': 'application/json',
		'Ocp-Apim-Subscription-Key': subscriptionKey
	}).then(function (res) {
		return actions.set('stt', res.text);
	});

	state$.distinctUntilChanged(function (state) {
		return state.stt + ' ' + state.sttMic;
	}).filter(function (state) {
		return state.stt && state.sttMic;
	}).map(function (state) {
		return init(state.stt);
	}).flatMap(recognize).subscribe(function (res) {
		var pattern = res.privText.replace(/\.$/, '');
		actions.samples.search({ pattern: pattern });
		actions.set('sttMic', false);
	});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"rx":123,"superagent":128}],147:[function(require,module,exports){
'use strict';
// lib

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Rx = require('rx');
var $ = Rx.Observable;

var WaveSurfer = require('wavesurfer.js');
// window.WaveSurfer = WaveSurfer;
var TimelinePlugin = require('wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js');
var ExtWSRegionsPlugin = require('../ext/ws/regions.js').default;
// console.log(RegionsPlugin);
// require('wavesurfer/plugin/wavesurfer.timeline.js');
// WaveSurfer = window.WaveSurfer;

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = require('../util/pocket');

var init = function init(container) {
	container.innerHTML = '';
	var wavesurfer = WaveSurfer.create({
		container: '#waveform',
		waveColor: '#000',
		progressColor: '#111516',
		plugins: [TimelinePlugin.create({
			container: '#wave-timeline'
			// deferInit: true // stop the plugin from initialising immediately
		}), ExtWSRegionsPlugin.create({
			dragSelection: true,
			singleRegion: true
			// plugin options ...
		})]
	});
	// wavesurfer.load('assets/LatinEthnoElektroGroove.mp3');
	return wavesurfer;
};

var load = function load(_ref) {
	var wavesurfer = _ref.wavesurfer,
	    sample = _ref.sample;

	console.log(wavesurfer, sample, pocket);
	if (sample[0] === 'url') wavesurfer.load(sample[1]);else if (sample[1]) wavesurfer.loadDecodedBuffer(pocket.get(['sampleBank', sample[1]]).output.buffer);
	return wavesurfer;
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];

	var wavesurfer$ = $.interval(100).map(function () {
		return document.querySelector('#waveform');
	}).distinctUntilChanged(function (el) {
		return el;
	}).filter(function (el) {
		return el;
	}).map(init);

	var sampleChange$ = state$.distinctUntilChanged(function (state) {
		return state.pads.focused.toString() + ' ' + obj.sub(state.pads, ['map'].concat(_toConsumableArray(state.pads.focused), ['id']));
	}).map(function (state) {
		return ['id', obj.sub(state.pads.map, [].concat(_toConsumableArray(state.pads.focused), ['id']))];
	}).startWith(['url', 'assets/LatinEthnoElektroGroove.mp3']);

	wavesurfer$.flatMap(function (wavesurfer) {
		return $.merge(sampleChange$.map(function (sample) {
			return function (wavesurfer) {
				return load({ wavesurfer: wavesurfer, sample: sample });
			};
		}), state$.distinctUntilChanged(function (state) {
			return state.session.playing;
		}).map(function (state) {
			return function (wavesurfer) {
				return wavesurfer.playPause(), wavesurfer;
			};
		})).scan(function (wavesurfer, reducer) {
			return reducer(wavesurfer);
		}, wavesurfer);
	}).subscribe(function (data) {});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../ext/ws/regions.js":140,"../util/pocket":167,"iblokz-data":10,"rx":123,"wavesurfer.js":135,"wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js":134}],148:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    select = _require.select,
    option = _require.option,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var formUtil = require('../../util/form');

var _require2 = require('iblokz-data'),
    fn = _require2.fn,
    obj = _require2.obj;

var play = function play(url) {
	var an = document.createElement('AUDIO');
	an.setAttribute('autoplay', true);
	an.src = url;
};

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#board', [].concat(form('#board-search', {
		on: {
			submit: function submit(ev) {
				ev.preventDefault();
				var data = formUtil.toData(ev.target);
				console.log(data);
				actions.samples.search(data);
			}
		}
	}, [input('[type="hidden"][name="page"][value=1]'), input('#board-search-pattern[name="pattern"][placeholder="Query"]', {
		attrs: {
			value: state.samples.query.pattern
		}
	}), select('[name="source"]', ['freesound', 'jamendo', 'europeana'].map(function (s) {
		return option('[value="' + s + '"]', s);
	})), button('Search')]), state.samples.list.length > 0 ? ul('#board-samples', [].concat(state.samples.list.map(function (sample, index) {
		return li({
			class: {
				selected: index === state.samples.index
			}
		}, [img('.wave[src="' + sample.image + '"]'), span('.name', {
			on: {
				click: function click() {
					return actions.set(['samples', 'index'], index);
				}
			}
		}, sample.name), a('.author[title="' + sample.author + '"]', i('.fa.fa-user')), span('.duration', (sample.duration / 1000).toFixed(2) + ' s'), a('.license[target="_blank"][href="' + sample.license + '"]', fn.pipe(function () {
			return sample.license.replace('http://creativecommons.org/', '');
		}, function (license) {
			return obj.switch(license, {
				'default': license,
				'licenses/by/3.0/': [i('.cc.cc-cc.cc-2x'), i('.cc.cc-by.cc-2x')],
				'publicdomain/zero/1.0/': [i('.cc.cc-cc.cc-2x'), i('.cc.cc-zero.cc-2x')],
				'licenses/by-nc/3.0/': [i('.cc.cc-cc.cc-2x'), i('.cc.cc-by.cc-2x'), i('.cc.cc-nc.cc-2x')],
				'licenses/sampling+/1.0/': [i('.cc.cc-cc.cc-2x')]
			});
		})()), span('.controls', [button({
			on: {
				click: function click() {
					return play(sample.sound);
				},
				touchstart: function touchstart() {
					return play(sample.sound);
				}
			}
		}, i('.fa.fa-play')), button({
			on: {
				click: function click(ev) {
					return actions.pads.load(sample, sample.sound);
				},
				touchstart: function touchstart(ev) {
					return actions.pads.load(sample, sample.sound);
				}
			}
		}, i('.fa.fa-plus')), a({
			attrs: {
				href: sample.sound,
				target: '_blank'
			}
		}, i('.fa.fa-download'))])]);
	}), li(button('.full', {
		on: {
			click: function click() {
				return actions.samples.search(_extends({}, state.samples.query, { page: state.samples.query.page + 1 }));
			}
		}
	}, 'Load more samples...')))) : []));
};

},{"../../util/form":164,"iblokz-data":10,"iblokz-snabbdom-helpers":15}],149:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    button = _require.button,
    span = _require.span,
    header = _require.header,
    h1 = _require.h1,
    ul = _require.ul,
    li = _require.li,
    i = _require.i,
    img = _require.img;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return header([ul('.left', [li(button({
		on: {
			click: function click() {
				return actions.set('mode', 0);
			}
		},
		class: {
			selected: state.mode === 0
		}
	}, img('[src="assets/icons/midi.svg"]'))), li(button({
		on: {
			click: function click() {
				return actions.set('mode', 1);
			}
		},
		class: {
			selected: state.mode === 1
		}
	}, i('.fa.fa-edit'))), li(button({
		on: {
			click: function click() {
				return actions.set('mode', 2);
			}
		},
		class: {
			selected: state.mode === 2
		}
	}, i('.fa.fa-music')))]), h1('xAmplR'), ul('.right', [li(button({
		on: {
			click: function click() {
				return actions.set('sttMic', true);
			}
		},
		class: {
			selected: state.sttMic
		}
	}, i('.fa.fa-volume-control-phone')))])]);
};

},{"iblokz-snabbdom-helpers":15}],150:[function(require,module,exports){
'use strict';

// dom

var _require = require('iblokz-snabbdom-helpers'),
    h1 = _require.h1,
    a = _require.a,
    div = _require.div,
    i = _require.i,
    section = _require.section,
    button = _require.button,
    span = _require.span;
// components


var header = require('./header');
var board = require('./board');
var pads = require('./pads');
var rack = require('./rack');
var waveditor = require('./waveditor');
// const counter = require('./counter');

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#ui', [header({ state: state, actions: actions }), waveditor({ state: state, actions: actions }), board({ state: state, actions: actions }), pads({ state: state, actions: actions }), rack({ state: state, actions: actions })]);
};

},{"./board":148,"./header":149,"./pads":151,"./rack":152,"./waveditor":155,"iblokz-snabbdom-helpers":15}],151:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var _require2 = require('iblokz-data'),
    obj = _require2.obj;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#pads', div('.rows', Array(4).fill({}).map(function (a, row) {
		return div('.cols', Array(4).fill({}).map(function (a, col) {
			return button('.pad', {
				style: _extends({}, obj.sub(state, ['pads', 'map', row, col, 'id']) ? { backgroundImage: 'url(' + obj.sub(state, ['pads', 'map', row, col, 'image']) + ')' } : {}),
				class: {
					focused: state.pads.focused[0] === row && state.pads.focused[1] === col,
					assigned: obj.sub(state, ['pads', 'map', row, col, 'id'])
				},
				on: {
					focus: function focus() {
						return actions.set(['pads', 'focused'], [row, col]);
					},
					mousedown: function mousedown() {
						return state.mode === 2 && actions.midi.trigger(row, col), state.mode === 1 && actions.set(['pads', 'focused'], [row, col]);
					},
					touchstart: function touchstart() {
						return state.mode === 2 && actions.midi.trigger(row, col), state.mode === 1 && actions.set(['pads', 'focused'], [row, col]);
					}
				}
			}, obj.sub(state, ['pads', 'map', row, col, 'name']) || '');
		}));
	})));
};

},{"iblokz-data":10,"iblokz-snabbdom-helpers":15}],152:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var _require2 = require('iblokz-data'),
    obj = _require2.obj;

var vcf = require('./vcf');
var reverb = require('./reverb');

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#rack', [].concat(vcf({
		name: 'vcf',
		props: state.rack.vcf,
		update: function update(path, value) {
			return actions.set([].concat(['rack', 'vcf'], path), value);
		}
	}), reverb({
		name: 'reverb',
		props: state.rack.reverb,
		update: function update(path, value) {
			return actions.set([].concat(['rack', 'reverb'], path), value);
		}
	})));
};

},{"./reverb":153,"./vcf":154,"iblokz-data":10,"iblokz-snabbdom-helpers":15}],153:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    div = _require.div,
    h2 = _require.h2,
    span = _require.span,
    p = _require.p,
    ul = _require.ul,
    li = _require.li,
    hr = _require.hr,
    button = _require.button,
    br = _require.br,
    form = _require.form,
    label = _require.label,
    input = _require.input,
    fieldset = _require.fieldset,
    legend = _require.legend,
    i = _require.i,
    img = _require.img;

module.exports = function (_ref) {
	var _ref$name = _ref.name,
	    name = _ref$name === undefined ? 'reverb' : _ref$name,
	    props = _ref.props,
	    update = _ref.update;
	return fieldset([legend([span('.on', [name.toUpperCase()])]), div('.on-switch.fa', {
		on: { click: function click(ev) {
				return update('on', !props.on);
			} },
		class: {
			'fa-circle-thin': !props.on,
			'on': props.on,
			'fa-circle': props.on
		}
	}), div([label('Seconds'), ' ',
	// span('.right', `${props.seconds}`),
	input('[type="number"]', {
		attrs: { min: 1, max: 50, step: 0.01 },
		props: { value: props.seconds },
		on: { change: function change(ev) {
				return update('seconds', parseFloat(ev.target.value));
			} }
	}), ' ', label('Decay'),
	// span('.right', `${props.decay}`),
	' ', input('[type="number"]', {
		attrs: { min: 0, max: 100, step: 0.01 },
		props: { value: props.decay },
		on: { change: function change(ev) {
				return update('decay', parseFloat(ev.target.value));
			} }
	}), ' ',
	/*
 label(`Reverse`),
 // span('.right', `${props.reverse}`),
 ' ',
 button('.fa', {
 	class: {
 		'fa-toggle-on': props.reverse,
 		'fa-toggle-off': !props.reverse
 	},
 	on: {
 		click: () => update('reverse', !props.reverse)
 	}
 }),
 */
	br(), label('Dry'), span('.right', '' + props.dry), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.dry },
		on: { change: function change(ev) {
				return update('dry', parseFloat(ev.target.value));
			} }
	}), label('Wet'), span('.right', '' + props.wet), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.wet },
		on: { change: function change(ev) {
				return update('wet', parseFloat(ev.target.value));
			} }
	})
	// label(`Gain`),
	// span('.right', `${props.gain}`),
	// input('[type="range"]', {
	// 	attrs: {min: 0, max: 1, step: 0.005},
	// 	props: {value: props.gain},
	// 	on: {change: ev => update('gain', parseFloat(ev.target.value))}
	// })
	])]);
};

},{"iblokz-snabbdom-helpers":15}],154:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    div = _require.div,
    h2 = _require.h2,
    span = _require.span,
    p = _require.p,
    ul = _require.ul,
    li = _require.li,
    hr = _require.hr,
    button = _require.button,
    br = _require.br,
    a = _require.a,
    form = _require.form,
    label = _require.label,
    input = _require.input,
    fieldset = _require.fieldset,
    legend = _require.legend,
    i = _require.i,
    img = _require.img,
    select = _require.select,
    option = _require.option;

module.exports = function (_ref) {
	var _ref$name = _ref.name,
	    name = _ref$name === undefined ? 'reverb' : _ref$name,
	    props = _ref.props,
	    update = _ref.update;
	return fieldset([legend([span('.on', [name.toUpperCase()])]), div('.on-switch.fa', {
		on: { click: function click(ev) {
				return update('on', !props.on);
			} },
		class: {
			'fa-circle-thin': !props.on,
			'on': props.on,
			'fa-circle': props.on
		}
	}), div([div([label('Type'), select({
		on: { change: function change(ev) {
				return update('type', ev.target.value);
			} }
	}, ['lowpass', 'highpass'
	// 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'
	].map(function (type) {
		return option({
			attrs: {
				value: type
			},
			props: {
				selected: props.type === type
			}
		}, type);
	}))]), div([label('Cutoff'), span('.right', '' + props.cutoff), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.cutoff },
		on: { change: function change(ev) {
				return update('cutoff', parseFloat(ev.target.value));
			} }
	})]), label('Resonance'), span('.right', '' + props.resonance), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.resonance },
		on: { change: function change(ev) {
				return update('resonance', parseFloat(ev.target.value));
			} }
	})
	// label(`Gain`),
	// span('.right', `${props.gain}`),
	// input('[type="range"]', {
	// 	attrs: {min: 0, max: 1, step: 0.005},
	// 	props: {value: props.gain},
	// 	on: {change: ev => update('gain', parseFloat(ev.target.value))}
	// })
	])]);
};

},{"iblokz-snabbdom-helpers":15}],155:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var _require2 = require('iblokz-data'),
    obj = _require2.obj;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#waveditor', [div('#wave-timeline'), div('#waveform'), button({
		on: {
			click: function click() {
				return actions.toggle(['session', 'playing']);
			}
		}
	}, i('.fa.fa-' + (state.session.playing ? 'pause' : 'play'))), div('#tools', [button('.fa.fa-microphone'), button('.fa.fa-scissors'), button('.fa.fa-exchange'), button('.fa.fa-times')])]);
};

},{"iblokz-data":10,"iblokz-snabbdom-helpers":15}],156:[function(require,module,exports){
'use strict';

// lib

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    arr = _require.arr,
    obj = _require.obj;

var observe = function observe(source) {
	return source instanceof Rx.Observable ? source : source.then instanceof Function ? Rx.Observable.fromPromise(source) : Rx.Observable.just(source);
};

var adapt = function adapt(o) {
	var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	return Object.keys(o).filter(function (key) {
		return key !== 'initial';
	}).reduce(function (o2, key) {
		return _extends({}, o2, o[key] instanceof Function && obj.keyValue(key, function () {
			var _arguments = arguments;

			observe(o[key].apply(null, Array.from(arguments))).subscribe(function (resp) {
				return o2.stream.onNext(_extends(resp, {
					path: [].concat(p, key),
					payload: Array.from(_arguments)
				}));
			});
		}) || o[key] instanceof Object && function () {
			var o3 = adapt(o[key], [].concat(p, key));
			o3.stream.subscribe(function (resp) {
				return o2.stream.onNext(resp);
			});
			return _extends({
				initial: _extends({}, o2.initial, obj.keyValue(key, o3.initial))
			}, obj.keyValue(key, o3));
		}() || obj.keyValue(key, o[key]));
	}, { stream: new Rx.Subject(), initial: o.initial || {} });
};

var attach = function attach(tree, path, node) {
	return [adapt(node, path)].map(function (adaptedNode) {
		return adaptedNode.stream.subscribe(function (resp) {
			return tree.stream.onNext(resp);
		}), _extends({}, obj.patch(tree, path, adaptedNode), {
			initial: obj.patch(tree.initial, path, adaptedNode.initial)
		});
	}).pop();
};

module.exports = {
	adapt: adapt,
	attach: attach
};

},{"iblokz-data":10,"rx":123}],157:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData,
    schedule = _require2.schedule;

var create = function create(prefs) {
	return [{
		prefs: _extends({
			volume: 0.41,
			attack: 0.31,
			decay: 0.16,
			sustain: 0.8,
			release: 0.21
		}, prefs),
		through: _create('gain')
	}].map(function (n) {
		return set(n.through.gain, 'value', 0), n;
	}).pop();
};

var update = function update(n, prefs) {
	return set(n, 'prefs', _extends({}, n.prefs, prefs)), n;
};

var noteOn = function noteOn(node, velocity, time) {
	var now = context.currentTime;
	time = (time || now) + 0.0001;

	node.through.gain.cancelScheduledValues(0);

	var changes = [].concat(
	// attack
	node.prefs.attack > 0 ? [[0, time], [velocity * node.prefs.volume, node.prefs.attack]] : [[velocity * node.prefs.volume, time]],
	// decay
	node.prefs.decay > 0 ? [[node.prefs.sustain * velocity * node.prefs.volume, node.prefs.decay]] : []).reduce(function (a, c) {
		return [[].concat(a[0], c[0]), [].concat(a[1], c[1])];
	}, [[], []]);

	schedule(node.through, 'gain', changes[0], changes[1]);
	return node;
};

var noteOff = function noteOff(node, time) {
	var now = context.currentTime;
	time = time || now + 0.0001;

	setTimeout(function () {
		return node.through.gain.cancelScheduledValues(0), node.through.gain.setValueCurveAtTime(new Float32Array([node.through.gain.value, 0]), time, node.prefs.release > 0 && node.prefs.release || 0.00001);
	}, (time - now) * 1000);
	return node;
};

module.exports = {
	create: create,
	update: update,
	noteOn: noteOn,
	noteOff: noteOff
};

},{"../core":158,"iblokz-data":10}],158:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext)();

var set = function set(o, k, v) {
	return o[k] = v;
};
var isSet = function isSet(v) {
	return v !== undefined;
};
var isGet = function isGet(v) {
	return isSet(v) ? v : null;
};

var apply = function apply(o1, o2) {
	return Object.keys(o2).reduce(function (o, k) {
		return set(o, k, o2[k]);
	}, o1);
};

var create = function create(type) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	return (
		// console.log(type),
		obj.switch(type, {
			oscillator: function oscillator() {
				return context.createOscillator.apply(context, args);
			},
			gain: function gain() {
				return context.createGain.apply(context, args);
			},
			biquadFilter: function biquadFilter() {
				return context.createBiquadFilter.apply(context, args);
			},
			convolver: function convolver() {
				return context.createConvolver.apply(context, args);
			},
			buffer: function buffer() {
				return context.createBuffer.apply(context, args);
			},
			bufferSource: function bufferSource() {
				return context.createBufferSource.apply(context, args);
			}
		})()
	);
};

var update = function update(node, prefs) {
	return apply(node, prefs);
};

var connect = function connect(n1, n2) {
	return (
		// console.log(n1, n2),
		n1.connect(n2), n1
	);
};
var disconnect = function disconnect(n1, n2) {
	// since there is no way to determine if they are connected
	try {
		n1.disconnect(n2);
	} catch (err) {
		console.log(err);
	}
	return n1;
};

var chain = function chain() {
	for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		nodes[_key2] = arguments[_key2];
	}

	return nodes.forEach(function (n, i) {
		return isSet(nodes[i + 1]) && connect(n, nodes[i + 1]);
	}), nodes[0];
};

var unchain = function unchain() {
	for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
		nodes[_key3] = arguments[_key3];
	}

	return nodes.slice().reverse().forEach(function (n, i) {
		return isSet(nodes[i - 1]) && disconnect(nodes[i - 1], n);
	}), nodes[0];
};

var duration = function duration(seconds) {
	return context.sampleRate * seconds;
};
var chData = function chData(node) {
	for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		args[_key4 - 1] = arguments[_key4];
	}

	return (
		// console.log(node, args),
		node.getChannelData.apply(node, args)
	);
};

var schedule = function schedule(node, pref, values, times) {
	return values.length === 1 ? node[pref].setValueAtTime(values[0], times[0]) : (node[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [times[0] + times[1]].concat(times.slice(2))));
};

module.exports = {
	context: context,
	set: set,
	isSet: isSet,
	isGet: isGet,
	create: create,
	update: update,
	connect: connect,
	disconnect: disconnect,
	chain: chain,
	unchain: unchain,
	// util
	duration: duration,
	chData: chData,
	schedule: schedule
};

},{"iblokz-data":10}],159:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;

var create = function create(prefs) {
	return [{
		prefs: _extends({
			type: 'sawtooth',
			frequency: 5,
			gain: 15
		}, prefs),
		effect: _create('oscillator'),
		output: _create('gain')
	}].map(function (n) {
		return chain(n.effect, n.output), set(n.effect.frequency, 'value', n.prefs.frequency), set(n.output.gain, 'value', n.prefs.gain), set(n.effect, 'type', n.prefs.type), n;
	}).pop();
};

var update = function update(n, prefs) {
	return set(n, 'prefs', _extends({}, n.prefs, prefs)), set(n.effect.frequency, 'value', n.prefs.frequency), set(n.output.gain, 'value', n.prefs.gain), set(n.effect, 'type', n.prefs.type), n;
};

var start = function start(n) {
	return n.effect.start(), n;
};

// const clone = n => create(null, n.output.buffer);

module.exports = {
	create: create,
	update: update,
	start: start
};

},{"../core":158,"iblokz-data":10}],160:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;
// const {context} = core;

var buildImpulse = function buildImpulse(_ref) {
	var seconds = _ref.seconds,
	    decay = _ref.decay;

	var impulse = _create('buffer', 2, duration(seconds), context.sampleRate);
	var channelData = [chData(impulse, 0), chData(impulse, 1)];
	for (var i = 0; i < duration(seconds); i++) {
		channelData[0][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
		channelData[1][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
	}
	return impulse;
};

var create = function create(prefs) {
	return [{
		prefs: _extends({ seconds: 3, decay: 2, wet: 0, dry: 1 }, prefs),
		input: _create('gain'),
		output: _create('gain'),
		effect: _create('convolver'),
		wet: _create('gain'),
		dry: _create('gain')
	}].map(function (n) {
		return chain(n.input, n.dry, n.output), chain(n.input, n.effect, n.wet, n.output), set(n.dry.gain, 'value', n.prefs.dry), set(n.wet.gain, 'value', n.prefs.wet), set(n.effect, 'buffer', buildImpulse(n.prefs)), n;
	}
	// n

	/*
 n.input.connect(n.effect);
 n.effect.connect(n.wet);
 n.wet.connect(n.output);
 	n.input.connect(n.dry);
 n.dry.connect(n.output);
 */
	/*
 n.dry.gain.value = n.prefs.dry;
 n.wet.gain.value = n.prefs.wet;
 n.effect.buffer = buildImpulse(n.prefs);
 */
	// set(n.wet.gain, 'value', n.prefs.wet),
	// set(n.effect, 'buffer', buildImpulse(n.prefs)),
	// return n;
	).pop();
};

var update = function update(n, prefs) {
	return (
		//	console.log(prefs, n.prefs),
		(n.prefs.seconds !== prefs.seconds || n.prefs.decay !== prefs.decay) && set(n.effect, 'buffer', buildImpulse(n.prefs)), n.prefs.dry !== prefs.dry && set(n.dry.gain, 'value', prefs.dry), n.prefs.wet !== prefs.wet && set(n.wet.gain, 'value', prefs.wet), set(n, 'prefs', _extends({}, n.prefs, prefs)), n
	);
};

module.exports = {
	create: create,
	update: update
};

},{"../core":158,"iblokz-data":10}],161:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('./core'),
    context = _require2.context,
    set = _require2.set,
    isSet = _require2.isSet,
    isGet = _require2.isGet,
    _schedule = _require2.schedule,
    _create = _require2.create,
    _connect = _require2.connect,
    _disconnect = _require2.disconnect;

var _reverb = require('./effects/reverb');
var _lfo = require('./effects/lfo');
var _adsr = require('./controls/adsr');

var create = function create(type) {
	var prefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context;
	return _extends({}, obj.switch(type, {
		vco: function vco() {
			return { output: _create('oscillator') };
		},
		vca: function vca() {
			return { through: _create('gain') };
		},
		vcf: function vcf() {
			return { through: _create('biquadFilter') };
		},
		lfo: function lfo() {
			return _lfo.create(prefs);
		},
		reverb: function reverb() {
			return _reverb.create(prefs);
		},
		adsr: function adsr() {
			return _adsr.create(prefs);
		}
	})(), { type: type, out: [] });
};

var cutoffToFreq = function cutoffToFreq(cutoff) {
	var minValue = 40;
	var maxValue = context.sampleRate / 2;
	// Logarithm (base 2) to compute how many octaves fall in the range.
	var numberOfOctaves = Math.log(maxValue / minValue) / Math.LN2;
	// Compute a multiplier from 0 to 1 based on an exponential scale.
	var multiplier = Math.pow(2, numberOfOctaves * (cutoff - 1.0));
	// Get back to the frequency value between min and max.
	return maxValue * multiplier;
};

var update = function update(node, prefs) {
	return obj.switch(node.type, {
		vco: function vco() {
			return isSet(prefs.type) && set(node.output, 'type', prefs.type), isSet(prefs.freq) && set(node.output.frequency, 'value', prefs.freq), isSet(prefs.detune) && set(node.output.detune, 'value', prefs.detune), _extends(node, { prefs: prefs });
		},
		vca: function vca() {
			return isSet(prefs.gain) && set(node.through.gain, 'value', prefs.gain), _extends(node, { prefs: prefs });
		},
		vcf: function vcf() {
			return isSet(prefs.type) && set(node.through, 'type', prefs.type), isSet(prefs.cutoff) && _schedule(node.through, 'frequency', [cutoffToFreq(prefs.cutoff)], [context.currentTime + 0.0001]),
			// set(node.through.frequency, 'value', cutoffToFreq(prefs.cutoff)),
			isSet(prefs.resonance) && _schedule(node.through, 'Q', [prefs.resonance * 30], [context.currentTime + 0.0001]), _extends(node, { prefs: prefs });
		},
		reverb: function reverb() {
			return _reverb.update(node, prefs);
		},
		adsr: function adsr() {
			return _adsr.update(node, prefs);
		},
		lfo: function lfo() {
			return _lfo.update(node, prefs);
		}
	})();
};

var connect = function connect(node1, node2) {
	return !(node1.out && node1.out.indexOf(node2) > -1) ? (_connect(
	// input
	isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1,
	// output
	node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), _extends({}, node1, {
		out: [].concat(node1.out || [], [node2])
	})) : node1;
};

var disconnect = function disconnect(node1, node2) {
	return (
		// (console.log('dissconnecting', node1, node2)),
		node1.out.indexOf(node2) > -1 ? (_disconnect(
		// input
		isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1,
		// output
		node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), _extends({}, node1, {
			out: [].concat(node1.out.slice(0, node1.out.indexOf(node2)), node1.out.slice(node1.out.indexOf(node2) + 1))
		})) : typeof node2 === 'undefined' ? node1.out.reduce(function (node1, prevNode) {
			return disconnect(node1, prevNode);
		}, node1) : node1
	);
};

var reroute = function reroute(node1, node2) {
	return node1.out && node1.out.indexOf(node2) === -1 ? connect(disconnect(node1), node2) : node1;
};

var chain = function chain() {
	for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
		nodes[_key] = arguments[_key];
	}

	return nodes.forEach(function (n, i) {
		return isSet(n[i + 1]) && connect(n, nodes[i + 1]);
	}), nodes[0];
};

var unchain = function unchain() {
	for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		nodes[_key2] = arguments[_key2];
	}

	return nodes.slice().reverse().forEach(function (n, i) {
		return isSet(n[i - 1]) && disconnect(nodes[i - 1], n);
	}), nodes[0];
};

var start = function start(node) {
	var _node$output;

	for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		args[_key3 - 1] = arguments[_key3];
	}

	return node.type === 'lfo' && _lfo.start.apply(_lfo, [node].concat(args)) || (_node$output = node.output).start.apply(_node$output, args), node;
};

var stop = function stop(node) {
	var _node$output2;

	for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		args[_key4 - 1] = arguments[_key4];
	}

	return (_node$output2 = node.output).stop.apply(_node$output2, args), node;
};

var schedule = function schedule(node, pref, values, times) {
	return values.length === 1 ? node.through[pref].setValueAtTime(values[0], times[0]) : (node.through[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [times[0] + times[1]].concat(times.slice(2))));
};

var noteToFrequency = function noteToFrequency(note) {
	var notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
	var keyNumber;
	var octave;

	if (note.length === 3) {
		octave = note.charAt(2);
	} else {
		octave = note.charAt(1);
	}

	keyNumber = notes.indexOf(note.slice(0, -1));

	if (keyNumber < 3) {
		keyNumber = keyNumber + 12 + (octave - 1) * 12 + 1;
	} else {
		keyNumber = keyNumber + (octave - 1) * 12 + 1;
	}

	return 440 * Math.pow(2, (keyNumber - 49) / 12);
};

module.exports = {
	context: context,
	create: create,
	update: update,
	schedule: schedule,
	connect: connect,
	disconnect: disconnect,
	reroute: reroute,
	chain: chain,
	unchain: unchain,
	noteToFrequency: noteToFrequency,
	start: start,
	stop: stop,
	vco: function vco(prefs) {
		return update(create('vco', {}, context), prefs);
	},
	vcf: function vcf(prefs) {
		return update(create('vcf', {}, context), prefs);
	},
	lfo: function lfo(prefs) {
		return update(create('lfo', {}, context), prefs);
	},
	vca: function vca(prefs) {
		return update(create('vca', {}, context), prefs);
	},
	adsr: function adsr(prefs) {
		return create('adsr', prefs, context);
	},
	noteOn: _adsr.noteOn,
	noteOff: _adsr.noteOff
};

},{"./controls/adsr":157,"./core":158,"./effects/lfo":159,"./effects/reverb":160,"iblokz-data":10}],162:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;

var create = function create(file, buffer) {
	return [{
		output: _create('bufferSource')
	}].map(function (n) {
		return !buffer ? fetch(file).then(function (res) {
			return res.arrayBuffer();
		}).then(function (buffer) {
			return context.decodeAudioData(buffer, function (buffer) {
				return set(n.output, 'buffer', buffer);
			});
		}) : set(n.output, 'buffer', buffer), n;
	}).pop();
};

var update = function update() {};

var clone = function clone(n) {
	return create(null, n.output.buffer);
};

module.exports = {
	create: create,
	update: update,
	clone: clone
};

},{"../core":158,"iblokz-data":10}],163:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;
var fileSaver = require('file-saver');
var jsZip = require("jszip");

var _require = require("iblokz-data"),
    fn = _require.fn,
    obj = _require.obj;

var load = function load(file) {
	var readAs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
	return $.create(function (stream) {
		var fr = new FileReader();
		fr.onload = function (ev) {
			// console.log(readAs, ev.target.result);
			stream.onNext(readAs === 'json' ? JSON.parse(ev.target.result) : ev.target.result);
			stream.onCompleted();
		};
		// console.log(file, readAs);
		(typeof file === 'string' ? $.fromPromise(fetch(file)).flatMap(function (res) {
			return res.blob();
		}) : $.just(file)).subscribe(function (f) {
			return fn.switch(readAs, {
				arrayBuffer: function arrayBuffer(f) {
					return fr.readAsArrayBuffer(f);
				},
				default: function _default(f) {
					return fr.readAsText(f);
				}
			})(f);
		});
	});
};

var loadZip = function loadZip(file) {
	return load(file, 'arrayBuffer').flatMap(function (data) {
		return $.fromPromise(jsZip.loadAsync(data));
	}).flatMap(function (zf) {
		return $.concat(Object.keys(zf.files).filter(function (k) {
			return !zf.files[k].dir;
		})
		// .map(k => (console.log(k), k))
		.map(function (k) {
			return $.fromPromise(zf.files[k].async('arraybuffer')).map(function (v) {
				return { k: k, v: v };
			});
		})).reduce(function (o, _ref) {
			var k = _ref.k,
			    v = _ref.v;
			return obj.patch(o, k, v);
		}, {});
	});
};

var save = function save(fileName, content) {
	return fileSaver.saveAs(new Blob([JSON.stringify(content)], { type: "text/plain;charset=utf-8" }), fileName);
};

module.exports = {
	load: load,
	loadZip: loadZip,
	save: save
};

},{"file-saver":7,"iblokz-data":10,"jszip":42,"rx":123}],164:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj;

var keys = Object.keys;

var arrify = function arrify(o) {
  return o instanceof Object ? !(o instanceof Array) && keys(o).filter(function (k) {
    return k.match(/^-?[0-9.]+$/);
  }).length === keys(o).length ? keys(o).map(function (k) {
    return arrify(o[k]);
  }) : keys(o).reduce(function (o2, k) {
    return obj.patch(o2, k, arrify(o[k]));
  }, {}) : o;
};

var toData = function toData(form) {
  return arrify(Array.from(form.elements)
  // .map(el => (console.log(el.name), el))
  .filter(function (el) {
    return el.name !== undefined && el.name !== '';
  }).reduce(function (o, el) {
    return obj.patch(o, el.name.split('.'), el.type && el.type === 'number' ? Number(el.value) : el.value);
  }, {}));
};

var clear = function clear(form) {
  return Array.from(form.elements).forEach(function (el) {
    return el.value = null;
  });
};

module.exports = {
  toData: toData,
  clear: clear
};

},{"iblokz-data":10}],165:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var time = require('./time');

var parsePad = function parsePad(pad) {
	return pad && {
		axes: pad.axes,
		buttons: pad.buttons.map(function (button) {
			return {
				pressed: button.pressed,
				value: button.value
			};
		}),
		connected: pad.connected,
		id: pad.id,
		index: pad.index,
		mapping: pad.mapping,
		timestamp: pad.timestamp
	} || pad;
};

var list = function list() {
	return Array.from(navigator.getGamepads() || navigator.webkitGetGamepads() || []).map(parsePad);
};

var changes = function changes() {
	return time.frame().map(list).distinctUntilChanged(function (pads) {
		return pads;
	})
	//	pads.reduce((r, pad) => !pad && r || (r + (pad.axes || '') + (pad.buttons || '')), ''))
	.share();
};

module.exports = {
	list: list,
	changes: changes
};

},{"./time":168,"rx":123}],166:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

var numberToNote = function numberToNote(number) {
	return {
		key: keys[number % 12],
		octave: parseInt((number - number % 12) / 12, 10) - 1,
		number: number
	};
};

var noteToNumber = function noteToNumber(note) {
	return keys.indexOf(note.replace(/[0-9]+/, '')) + (parseInt(note.replace(/[A-Z#b]+/, ''), 10) + 1) * 12;
};

var parseMidiMsg = function parseMidiMsg(event) {
	// Mask off the lower nibble (MIDI channel, which we don't care about)

	var status = event.data[0] & 0xf0;
	var binary = event.data[0].toString(2);
	var channel = event.data[0] - status + 1;
	var msg = {};

	switch (binary.slice(0, 4)) {
		// noteoff
		case "1000":
			msg = {
				state: 'noteOff',
				note: numberToNote(event.data[1])
			};
			break;
		// noteon
		case "1001":
			msg = event.data[2] !== 0 ? // if velocity != 0, this is a note-on message
			{
				state: 'noteOn',
				note: numberToNote(event.data[1]),
				velocity: parseFloat((event.data[2] / 127).toFixed(2))
			} : { // if velocity == 0, fall thru: it's a note-off.	MIDI's weird, ya'll.
				state: 'noteOff',
				note: numberToNote(event.data[1])
			};
			break;
		// pitch wheel
		case "1110":
			msg = {
				state: 'pitchBend',
				pitchValue: event.data[2] === 64 ? 0 : parseFloat((event.data[2] / 63.5 - 1).toFixed(2))
			};
			break;
		// controller
		case "1011":
			msg = {
				state: "controller",
				controller: event.data[1],
				value: parseFloat((event.data[2] / 127).toFixed(2))
			};
			break;
		case "1100":
			msg = {
				state: "bankSelect",
				bank: event.data[1]
			};
			break;
		default:
			msg = {
				state: false
			};
			break;
	}

	return _extends({}, msg, {
		binary: binary,
		status: status,
		channel: channel,
		data: event.data
	});
};
//
// const hookUpMIDIInput = midiAccess => {
// 	var haveAtLeastOneDevice = false;
// 	var inputs = midiAccess.inputs.values();
// 	for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
// 		input.value.onmidimessage = MIDIMessageEventHandler;
// 		haveAtLeastOneDevice = true;
// 	}
// };
//
// const onMIDIInit = midi => {
// 	hookUpMIDIInput(midi);
// 	midi.onstatechange = hookUpMIDIInput;
// };
//
// const onMIDIReject = err =>
// 	console.log(err, 'The MIDI system failed to start.');
//
// (navigator.requestMIDIAccess)
// 		&& navigator.requestMIDIAccess().then(onMIDIInit, onMIDIReject);

var parseAccess = function parseAccess(access) {
	var inputs = [];
	var outputs = [];

	// console.log(access);

	access.inputs.forEach(function (input) {
		return inputs.push(input);
	});
	access.outputs.forEach(function (output) {
		return outputs.push(output);
	});
	return { access: access, inputs: inputs, outputs: outputs };
};

var init = function init() {
	var devices$ = new Rx.Subject();
	$.fromPromise(navigator.requestMIDIAccess()).flatMap(function (access) {
		return $.create(function (stream) {
			access.onstatechange = function (connection) {
				return stream.onNext(connection.currentTarget);
			};
		}).startWith(access);
	}).map(parseAccess)
	// .map(data => (console.log('midi access', data), data))
	.subscribe(function (device) {
		return devices$.onNext(device);
	});
	// .share();

	var msg$ = new Rx.Subject();
	devices$.flatMap(function (_ref) {
		var access = _ref.access,
		    inputs = _ref.inputs;
		return inputs.reduce(function (msgStream, input) {
			return msgStream.merge($.fromEventPattern(function (h) {
				input.onmidimessage = h;
			}).map(function (msg) {
				return { access: access, input: input, msg: msg };
			}));
		}, $.empty());
	}).subscribe(function (msg) {
		return msg$.onNext(msg);
	});

	return {
		devices$: devices$,
		msg$: msg$
	};
};

module.exports = {
	init: init,
	numberToNote: numberToNote,
	noteToNumber: noteToNumber,
	parseMidiMsg: parseMidiMsg
};

},{"rx":123}],167:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = void 0;

var reducers$ = new Rx.Subject();
var pocket$ = new Rx.BehaviorSubject({});

reducers$.scan(function (pocket, reduce) {
	return reduce(pocket);
}, {}).subscribe(function (pocket) {
	return pocket$.onNext(pocket);
});

pocket$.subscribe(function (_pocket) {
	// console.log({pocket});
	pocket = _pocket;
});

var put = function put(path, val) {
	return reducers$.onNext(function (pocket) {
		return obj.patch(pocket, path, val);
	});
};
var get = function get(path) {
	return obj.sub(pocket, path);
};

module.exports = {
	put: put,
	get: get,
	reducers$: reducers$,
	stream: pocket$
};

},{"iblokz-data":10,"rx":123}],168:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var raf = require('raf');

var tick = function tick(cb) {
	return raf(function (dt) {
		cb(dt);
		tick(cb);
	});
};

var frame = function frame() {
	return $.create(function (obs) {
		return tick(function (dt) {
			return obs.onNext(dt);
		});
	}).filter(function (dt) {
		return dt !== 0;
	}).share();
};

var loop = function loop(state$, node) {
	return frame(node).withLatestFrom(state$, function (dt, state) {
		return { dt: dt, state: state };
	});
};

module.exports = {
	frame: frame,
	loop: loop
};

},{"raf":109,"rx":123}]},{},[141])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmlsZS1zYXZlci9kaXN0L0ZpbGVTYXZlci5taW4uanMiLCJub2RlX21vZHVsZXMvaHRtbC10YWdzL2h0bWwtdGFncy5qc29uIiwibm9kZV9tb2R1bGVzL2h0bWwtdGFncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9saWIvYXJyLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1kYXRhL2xpYi9mbi5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9saWIvb2JqLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1kYXRhL2xpYi9zdHIuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2guanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2h0bWxkb21hcGkuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2lzLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1zbmFiYmRvbS1oZWxwZXJzL25vZGVfbW9kdWxlcy9zbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvY2xhc3MuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvcHJvcHMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1zbmFiYmRvbS1oZWxwZXJzL25vZGVfbW9kdWxlcy9zbmFiYmRvbS90aHVuay5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otc25hYmJkb20taGVscGVycy9ub2RlX21vZHVsZXMvc25hYmJkb20vdm5vZGUuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvdXRpbC9hdHRycy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRhYmxlLXN0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvQXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1N0cmluZ1JlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0dlbmVyaWNXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2xpZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguYWxsLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9hZ2VudC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcGx1Z2luL3dhdmVzdXJmZXIudGltZWxpbmUubWluLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC93YXZlc3VyZmVyLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL3NyYy9wbHVnaW4vcmVnaW9ucy5qcyIsInNyYy9qcy9hY3Rpb25zL2NvdW50ZXIvaW5kZXguanMiLCJzcmMvanMvYWN0aW9ucy9pbmRleC5qcyIsInNyYy9qcy9hY3Rpb25zL21pZGktbWFwL2luZGV4LmpzIiwic3JjL2pzL2V4dC93cy9yZWdpb25zLmpzIiwic3JjL2pzL2luZGV4LmpzIiwic3JjL2pzL3NlcnZpY2VzL2NvbnRyb2wuanMiLCJzcmMvanMvc2VydmljZXMvbWlkaS5qcyIsInNyYy9qcy9zZXJ2aWNlcy9wYWRzLmpzIiwic3JjL2pzL3NlcnZpY2VzL3NhbXBsZXMuanMiLCJzcmMvanMvc2VydmljZXMvc3R0LmpzIiwic3JjL2pzL3NlcnZpY2VzL3dhdmVzdXJmZXIuanMiLCJzcmMvanMvdWkvYm9hcmQvaW5kZXguanMiLCJzcmMvanMvdWkvaGVhZGVyL2luZGV4LmpzIiwic3JjL2pzL3VpL2luZGV4LmpzIiwic3JjL2pzL3VpL3BhZHMvaW5kZXguanMiLCJzcmMvanMvdWkvcmFjay9pbmRleC5qcyIsInNyYy9qcy91aS9yYWNrL3JldmVyYi9pbmRleC5qcyIsInNyYy9qcy91aS9yYWNrL3ZjZi9pbmRleC5qcyIsInNyYy9qcy91aS93YXZlZGl0b3IvaW5kZXguanMiLCJzcmMvanMvdXRpbC9hcHAuanMiLCJzcmMvanMvdXRpbC9hdWRpby9jb250cm9scy9hZHNyLmpzIiwic3JjL2pzL3V0aWwvYXVkaW8vY29yZS5qcyIsInNyYy9qcy91dGlsL2F1ZGlvL2VmZmVjdHMvbGZvLmpzIiwic3JjL2pzL3V0aWwvYXVkaW8vZWZmZWN0cy9yZXZlcmIuanMiLCJzcmMvanMvdXRpbC9hdWRpby9pbmRleC5qcyIsInNyYy9qcy91dGlsL2F1ZGlvL3NvdXJjZXMvc2FtcGxlci5qcyIsInNyYy9qcy91dGlsL2ZpbGUuanMiLCJzcmMvanMvdXRpbC9mb3JtLmpzIiwic3JjL2pzL3V0aWwvZ2FtZXBhZC5qcyIsInNyYy9qcy91dGlsL21pZGkuanMiLCJzcmMvanMvdXRpbC9wb2NrZXQuanMiLCJzcmMvanMvdXRpbC90aW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FBRUEsUUFBUSxV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QixLQUprQixFQUFOO0FBQUEsQ0FBZDs7QUFNQSxJQUFNLE9BQU8sU0FBUCxJQUFPLENBQUMsTUFBRCxFQUFTLElBQVQ7QUFBQSxRQUFrQixNQUFNLElBQU4sRUFBWSxjQUFaLENBQTJCLE1BQTNCLEVBQW1DLFVBQUMsRUFBRCxFQUFLLEtBQUw7QUFBQSxTQUFnQixFQUFDLE1BQUQsRUFBSyxZQUFMLEVBQWhCO0FBQUEsRUFBbkMsQ0FBbEI7QUFBQSxDQUFiOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNoQixhQURnQjtBQUVoQjtBQUZnQixDQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklpSXNJbVpwYkdVaU9pSmxiWEIwZVM1cWN5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJYWDA9IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiKGZ1bmN0aW9uKGEsYil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxiKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKWIoKTtlbHNle2IoKSxhLkZpbGVTYXZlcj17ZXhwb3J0czp7fX0uZXhwb3J0c319KSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhLGIpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBiP2I9e2F1dG9Cb206ITF9Olwib2JqZWN0XCIhPXR5cGVvZiBiJiYoY29uc29sZS53YXJuKFwiRGVwcmljYXRlZDogRXhwZWN0ZWQgdGhpcmQgYXJndW1lbnQgdG8gYmUgYSBvYmplY3RcIiksYj17YXV0b0JvbTohYn0pLGIuYXV0b0JvbSYmL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYS50eXBlKT9uZXcgQmxvYihbXCJcXHVGRUZGXCIsYV0se3R5cGU6YS50eXBlfSk6YX1mdW5jdGlvbiBjKGIsYyxkKXt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZS5vcGVuKFwiR0VUXCIsYiksZS5yZXNwb25zZVR5cGU9XCJibG9iXCIsZS5vbmxvYWQ9ZnVuY3Rpb24oKXthKGUucmVzcG9uc2UsYyxkKX0sZS5vbmVycm9yPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcImNvdWxkIG5vdCBkb3dubG9hZCBmaWxlXCIpfSxlLnNlbmQoKX1mdW5jdGlvbiBkKGEpe3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYi5vcGVuKFwiSEVBRFwiLGEsITEpLGIuc2VuZCgpLDIwMDw9Yi5zdGF0dXMmJjI5OT49Yi5zdGF0dXN9ZnVuY3Rpb24gZShhKXt0cnl7YS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfWNhdGNoKGMpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7Yi5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsd2luZG93LDAsMCwwLDgwLDIwLCExLCExLCExLCExLDAsbnVsbCksYS5kaXNwYXRjaEV2ZW50KGIpfX12YXIgZj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfHwoNDIsZXZhbCkoXCJ0aGlzXCIpfWNhdGNoKGEpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy53aW5kb3c9PT13aW5kb3c/d2luZG93Olwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLnNlbGY9PT1zZWxmP3NlbGY6XCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsLmdsb2JhbD09PWdsb2JhbD9nbG9iYWw6dGhpc319KCksYT1mLnNhdmVBc3x8XCJvYmplY3RcIiE9dHlwZW9mIHdpbmRvd3x8d2luZG93IT09Zj9mdW5jdGlvbigpe306XCJkb3dubG9hZFwiaW4gSFRNTEFuY2hvckVsZW1lbnQucHJvdG90eXBlP2Z1bmN0aW9uKGIsZyxoKXt2YXIgaT1mLlVSTHx8Zi53ZWJraXRVUkwsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtnPWd8fGIubmFtZXx8XCJkb3dubG9hZFwiLGouZG93bmxvYWQ9ZyxqLnJlbD1cIm5vb3BlbmVyXCIsXCJzdHJpbmdcIj09dHlwZW9mIGI/KGouaHJlZj1iLGoub3JpZ2luPT09bG9jYXRpb24ub3JpZ2luP2Uoaik6ZChqLmhyZWYpP2MoYixnLGgpOmUoaixqLnRhcmdldD1cIl9ibGFua1wiKSk6KGouaHJlZj1pLmNyZWF0ZU9iamVjdFVSTChiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS5yZXZva2VPYmplY3RVUkwoai5ocmVmKX0sNEU0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShqKX0sMCkpfTpcIm1zU2F2ZU9yT3BlbkJsb2JcImluIG5hdmlnYXRvcj9mdW5jdGlvbihmLGcsaCl7aWYoZz1nfHxmLm5hbWV8fFwiZG93bmxvYWRcIixcInN0cmluZ1wiIT10eXBlb2YgZiluYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihiKGYsaCksZyk7ZWxzZSBpZihkKGYpKWMoZixnLGgpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7aS5ocmVmPWYsaS50YXJnZXQ9XCJfYmxhbmtcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShpKX0pfX06ZnVuY3Rpb24oYSxiLGQsZSl7aWYoZT1lfHxvcGVuKFwiXCIsXCJfYmxhbmtcIiksZSYmKGUuZG9jdW1lbnQudGl0bGU9ZS5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD1cImRvd25sb2FkaW5nLi4uXCIpLFwic3RyaW5nXCI9PXR5cGVvZiBhKXJldHVybiBjKGEsYixkKTt2YXIgZz1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiPT09YS50eXBlLGg9L2NvbnN0cnVjdG9yL2kudGVzdChmLkhUTUxFbGVtZW50KXx8Zi5zYWZhcmksaT0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoKGl8fGcmJmgpJiZcIm9iamVjdFwiPT10eXBlb2YgRmlsZVJlYWRlcil7dmFyIGo9bmV3IEZpbGVSZWFkZXI7ai5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXt2YXIgYT1qLnJlc3VsdDthPWk/YTphLnJlcGxhY2UoL15kYXRhOlteO10qOy8sXCJkYXRhOmF0dGFjaG1lbnQvZmlsZTtcIiksZT9lLmxvY2F0aW9uLmhyZWY9YTpsb2NhdGlvbj1hLGU9bnVsbH0sai5yZWFkQXNEYXRhVVJMKGEpfWVsc2V7dmFyIGs9Zi5VUkx8fGYud2Via2l0VVJMLGw9ay5jcmVhdGVPYmplY3RVUkwoYSk7ZT9lLmxvY2F0aW9uPWw6bG9jYXRpb24uaHJlZj1sLGU9bnVsbCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ay5yZXZva2VPYmplY3RVUkwobCl9LDRFNCl9fTtmLnNhdmVBcz1hLnNhdmVBcz1hLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJihtb2R1bGUuZXhwb3J0cz1hKX0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlU2F2ZXIubWluLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPVtcblx0XCJhXCIsXG5cdFwiYWJiclwiLFxuXHRcImFkZHJlc3NcIixcblx0XCJhcmVhXCIsXG5cdFwiYXJ0aWNsZVwiLFxuXHRcImFzaWRlXCIsXG5cdFwiYXVkaW9cIixcblx0XCJiXCIsXG5cdFwiYmFzZVwiLFxuXHRcImJkaVwiLFxuXHRcImJkb1wiLFxuXHRcImJsb2NrcXVvdGVcIixcblx0XCJib2R5XCIsXG5cdFwiYnJcIixcblx0XCJidXR0b25cIixcblx0XCJjYW52YXNcIixcblx0XCJjYXB0aW9uXCIsXG5cdFwiY2l0ZVwiLFxuXHRcImNvZGVcIixcblx0XCJjb2xcIixcblx0XCJjb2xncm91cFwiLFxuXHRcImRhdGFcIixcblx0XCJkYXRhbGlzdFwiLFxuXHRcImRkXCIsXG5cdFwiZGVsXCIsXG5cdFwiZGV0YWlsc1wiLFxuXHRcImRmblwiLFxuXHRcImRpYWxvZ1wiLFxuXHRcImRpdlwiLFxuXHRcImRsXCIsXG5cdFwiZHRcIixcblx0XCJlbVwiLFxuXHRcImVtYmVkXCIsXG5cdFwiZmllbGRzZXRcIixcblx0XCJmaWdjYXB0aW9uXCIsXG5cdFwiZmlndXJlXCIsXG5cdFwiZm9vdGVyXCIsXG5cdFwiZm9ybVwiLFxuXHRcImgxXCIsXG5cdFwiaDJcIixcblx0XCJoM1wiLFxuXHRcImg0XCIsXG5cdFwiaDVcIixcblx0XCJoNlwiLFxuXHRcImhlYWRcIixcblx0XCJoZWFkZXJcIixcblx0XCJoZ3JvdXBcIixcblx0XCJoclwiLFxuXHRcImh0bWxcIixcblx0XCJpXCIsXG5cdFwiaWZyYW1lXCIsXG5cdFwiaW1nXCIsXG5cdFwiaW5wdXRcIixcblx0XCJpbnNcIixcblx0XCJrYmRcIixcblx0XCJrZXlnZW5cIixcblx0XCJsYWJlbFwiLFxuXHRcImxlZ2VuZFwiLFxuXHRcImxpXCIsXG5cdFwibGlua1wiLFxuXHRcIm1haW5cIixcblx0XCJtYXBcIixcblx0XCJtYXJrXCIsXG5cdFwibWF0aFwiLFxuXHRcIm1lbnVcIixcblx0XCJtZW51aXRlbVwiLFxuXHRcIm1ldGFcIixcblx0XCJtZXRlclwiLFxuXHRcIm5hdlwiLFxuXHRcIm5vc2NyaXB0XCIsXG5cdFwib2JqZWN0XCIsXG5cdFwib2xcIixcblx0XCJvcHRncm91cFwiLFxuXHRcIm9wdGlvblwiLFxuXHRcIm91dHB1dFwiLFxuXHRcInBcIixcblx0XCJwYXJhbVwiLFxuXHRcInBpY3R1cmVcIixcblx0XCJwcmVcIixcblx0XCJwcm9ncmVzc1wiLFxuXHRcInFcIixcblx0XCJyYlwiLFxuXHRcInJwXCIsXG5cdFwicnRcIixcblx0XCJydGNcIixcblx0XCJydWJ5XCIsXG5cdFwic1wiLFxuXHRcInNhbXBcIixcblx0XCJzY3JpcHRcIixcblx0XCJzZWN0aW9uXCIsXG5cdFwic2VsZWN0XCIsXG5cdFwic2xvdFwiLFxuXHRcInNtYWxsXCIsXG5cdFwic291cmNlXCIsXG5cdFwic3BhblwiLFxuXHRcInN0cm9uZ1wiLFxuXHRcInN0eWxlXCIsXG5cdFwic3ViXCIsXG5cdFwic3VtbWFyeVwiLFxuXHRcInN1cFwiLFxuXHRcInN2Z1wiLFxuXHRcInRhYmxlXCIsXG5cdFwidGJvZHlcIixcblx0XCJ0ZFwiLFxuXHRcInRlbXBsYXRlXCIsXG5cdFwidGV4dGFyZWFcIixcblx0XCJ0Zm9vdFwiLFxuXHRcInRoXCIsXG5cdFwidGhlYWRcIixcblx0XCJ0aW1lXCIsXG5cdFwidGl0bGVcIixcblx0XCJ0clwiLFxuXHRcInRyYWNrXCIsXG5cdFwidVwiLFxuXHRcInVsXCIsXG5cdFwidmFyXCIsXG5cdFwidmlkZW9cIixcblx0XCJ3YnJcIlxuXVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2h0bWwtdGFncy5qc29uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0b2JqOiByZXF1aXJlKCcuL2xpYi9vYmonKSxcblx0YXJyOiByZXF1aXJlKCcuL2xpYi9hcnInKSxcblx0c3RyOiByZXF1aXJlKCcuL2xpYi9zdHInKSxcblx0Zm46IHJlcXVpcmUoJy4vbGliL2ZuJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFkZCA9IChhcnIsIGl0ZW0pID0+IFtdLmNvbmNhdChhcnIsIFtpdGVtXSk7XG5cbmNvbnN0IHJlbW92ZSA9IChhcnIsIGl0ZW0pID0+IGFyci5pbmRleE9mKGl0ZW0pID4gLTEgPyBbXS5jb25jYXQoXG5cdGFyci5zbGljZSgwLCBhcnIuaW5kZXhPZihpdGVtKSksXG5cdGFyci5zbGljZShhcnIuaW5kZXhPZihpdGVtKSArIDEpXG4pIDogYXJyO1xuXG5jb25zdCB0b2dnbGUgPSAoYXJyLCBpdGVtKSA9PiBhcnIuaW5kZXhPZihpdGVtKSA+IC0xXG5cdD8gcmVtb3ZlKGFyciwgaXRlbSlcblx0OiBhZGQoYXJyLCBpdGVtKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFkZCxcblx0cmVtb3ZlLFxuXHR0b2dnbGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9iaiA9IHJlcXVpcmUoJy4vb2JqJyk7XG5cbi8vICgoKGEsIGIsIOKApiwgbikg4oaSIG8pLCAobyDihpIgcCksIOKApiwgKHgg4oaSIHkpLCAoeSDihpIgeikpIOKGkiAoKGEsIGIsIOKApiwgbikg4oaSIHopXG5jb25zdCBwaXBlID0gKGEsIC4uLmZucykgPT4gKC4uLmFyZ3MpID0+IGZucy5yZWR1Y2UoKHJlcywgZm4pID0+IGZuKHJlcyksIGEoLi4uYXJncykpO1xuXG4vLyAoKHkg4oaSIHopLCAoeCDihpIgeSksIOKApiwgKG8g4oaSIHApLCAoKGEsIGIsIOKApiwgbikg4oaSIG8pKSDihpIgKChhLCBiLCDigKYsIG4pIOKGkiB6KVxuY29uc3QgY29tcG9zZSA9ICguLi5mbnMpID0+IHBpcGUoZm5zLnNsaWNlKC0xKS5wb3AoKSwgLi4uZm5zLnJldmVyc2UoKS5zbGljZSgxKSk7XG5cbi8vIHN3aXRjaCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjb21wb3NlLFxuXHRwaXBlLFxuXHRzd2l0Y2g6IG9iai5zd2l0Y2hcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtleVZhbHVlID0gKGssIHYpID0+IHtcblx0bGV0IG8gPSB7fTtcblx0b1trXSA9IHY7XG5cdHJldHVybiBvO1xufTtcblxuY29uc3QgY2xvbmUgPSBvID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobykgfHwge30pLCBvKTtcblxuY29uc3Qgc3ViID0gKG8sIHApID0+IChwIGluc3RhbmNlb2YgQXJyYXkpXG5cdD8gKHR5cGVvZiBvW3BbMF1dICE9PSAndW5kZWZpbmVkJyAmJiBwLmxlbmd0aCA+IDEpID8gc3ViKG9bcFswXV0sIHAuc2xpY2UoMSkpIDogb1twWzBdXVxuXHQ6IG9bcF07XG5cbmNvbnN0IHBhdGNoID0gKG8sIGssIHYpID0+IE9iamVjdC5hc3NpZ24oY2xvbmUobyksXG5cdChrIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0PyBrZXlWYWx1ZShrWzBdLCAoay5sZW5ndGggPiAxKVxuXHRcdFx0PyBwYXRjaChvW2tbMF1dIHx8IHt9LCBrLnNsaWNlKDEpLCB2KVxuXHRcdFx0OiB0eXBlb2Ygb1trWzBdXSA9PT0gJ29iamVjdCcgJiYgb1trWzBdXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5hc3NpZ24oY2xvbmUob1trWzBdXSksIHYpIHx8IHYpXG5cdFx0OiBrZXlWYWx1ZShrLCB0eXBlb2Ygb1trXSA9PT0gJ29iamVjdCcgJiYgb1trXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5hc3NpZ24oY2xvbmUob1trXSksIHYpIHx8IHYpXG4pO1xuXG5jb25zdCByZWR1Y2UgPSAobywgcmVkdWNlRm4sIGluaXRpYWwpID0+IE9iamVjdC5rZXlzKG8pXG5cdC5yZWR1Y2UoXG5cdFx0KGFjY3VtdWxhdG9yLCBrZXksIGluZGV4KSA9PiByZWR1Y2VGbihhY2N1bXVsYXRvciwga2V5LCBvW2tleV0sIGluZGV4LCBvKSxcblx0XHR0eXBlb2YgaW5pdGlhbCA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdD8gb1tPYmplY3Qua2V5cyhvKVswXV0gLy8gdG8gY29uZmlybSB3aXRoIHRoZSBhcnJheSByZWR1Y2Ugc3BlYyBpbiB0aGlzIGNhc2UgdGhlIGZpcnRzIHByb3BlcnR5IGlzIHVzZWRcblx0XHRcdDogaW5pdGlhbFxuXHQpO1xuXG5jb25zdCBtYXAgPSAobywgbWFwRm4pID0+IHJlZHVjZShvLFxuXHQobzIsIGtleSwgdmFsdWUsIGluZGV4KSA9PiBwYXRjaChvMiwga2V5LCBtYXBGbihrZXksIHZhbHVlLCBpbmRleCwgbykpLFxuXHR7fVxuKTtcblxuY29uc3QgZmlsdGVyID0gKG8sIGZpbHRlckZuKSA9PiByZWR1Y2Uobyxcblx0KG8yLCBrZXksIHZhbHVlLCBpbmRleCkgPT4gZmlsdGVyRm4oa2V5LCB2YWx1ZSwgaW5kZXgsIG8pXG5cdFx0PyBwYXRjaChvMiwga2V5LCB2YWx1ZSlcblx0XHQ6IG8yLFxuXHR7fVxuKTtcblxuY29uc3QgdHJhdmVyc2UgPSAodHJlZSwgZm4pID0+IE9iamVjdC5rZXlzKHRyZWUpLnJlZHVjZSgobywgaykgPT5cblx0cGF0Y2gobywgayxcblx0XHQodHlwZW9mIHRyZWVba10gPT09ICdvYmplY3QnICYmIHRyZWVba10uY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHRcdD8gdHJhdmVyc2UodHJlZVtrXSwgZm4pXG5cdFx0XHQ6IGZuKHRyZWVba10sIGspXG5cdCksIHt9XG4pO1xuXG5jb25zdCBjaGFpbkNhbGwgPSAobywgY2hhaW4pID0+IGNoYWluLnJlZHVjZShcblx0KG8sIGxpbmspID0+ICh0eXBlb2YgbGlua1sxXSA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0PyBvW2xpbmtbMF1dKClcblx0XHQ6IG9bbGlua1swXV0obGlua1sxXSksXG5cdG9cbik7XG5cbmNvbnN0IF9zd2l0Y2ggPSAodmFsdWUsIGNhc2VzKSA9PlxuXHRzdWIoY2FzZXMsIHZhbHVlKSAmJiBzdWIoY2FzZXMsIHZhbHVlKVsnZGVmYXVsdCddIHx8IHN1YihjYXNlcywgdmFsdWUpXG5cdHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdCYmIHZhbHVlLmxlbmd0aCA+IDEgJiYgX3N3aXRjaCh2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSAxKSwgY2FzZXMpXG5cdHx8IGNhc2VzWydkZWZhdWx0J10gfHwgZmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRrZXlWYWx1ZSxcblx0Y2xvbmUsXG5cdHN1Yixcblx0cGF0Y2gsXG5cdHJlZHVjZSxcblx0bWFwLFxuXHRmaWx0ZXIsXG5cdHRyYXZlcnNlLFxuXHRjaGFpbkNhbGwsXG5cdHN3aXRjaDogX3N3aXRjaFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2FwaXRhbGl6ZSA9IGNodW5rID0+IGNodW5rLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2h1bmsuc2xpY2UoMSk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gKHN0ciwgZ2x1ZSA9ICdfJykgPT5cblx0c3RyLnNwbGl0KGdsdWUpXG5cdFx0Lm1hcCgoY2h1bmssIGkpID0+IChpID09PSAwKVxuXHRcdFx0PyBjaHVua1xuXHRcdFx0OiBjYXBpdGFsaXplKGNodW5rKSlcblx0XHQuam9pbignJyk7XG5cbmNvbnN0IGZyb21DYW1lbENhc2UgPSAoc3RyLCBnbHVlID0gJ18nKSA9PlxuXHRzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCAnICQxJylcblx0XHQuc3BsaXQoJyAnKVxuXHRcdC5tYXAoY2h1bmsgPT4gY2h1bmsudG9Mb3dlckNhc2UoKSlcblx0XHQuam9pbihnbHVlKTtcblxuY29uc3Qgc2luZ3VsYXJUb1BsdXJhbCA9IHN0ciA9PlxuXHRzdHIucmVwbGFjZSgveSQvLCAnaWUnKS5jb25jYXQoJ3MnKTtcblxuY29uc3QgcGx1cmFsVG9TaW5ndWxhciA9IHN0ciA9PlxuXHRzdHIucmVwbGFjZSgvaWVzJC8sICd5JykucmVwbGFjZSgvcyQvLCAnJyk7XG5cbmNvbnN0IHRvRG9jdW1lbnRJZCA9IChzdHIsIGdsdWUgPSAnXycsIHN1ZmZpeCA9ICdJZCcsIHByZWZpeCA9ICcnKSA9PlxuXHRwcmVmaXguY29uY2F0KHBsdXJhbFRvU2luZ3VsYXIodG9DYW1lbENhc2Uoc3RyLCBnbHVlKSksIHN1ZmZpeCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjYXBpdGFsaXplLFxuXHR0b0NhbWVsQ2FzZSxcblx0ZnJvbUNhbWVsQ2FzZSxcblx0c2luZ3VsYXJUb1BsdXJhbCxcblx0cGx1cmFsVG9TaW5ndWxhcixcblx0dG9Eb2N1bWVudElkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzbmFiYmRvbSA9IHJlcXVpcmUoJ3NuYWJiZG9tJyk7XG5jb25zdCBoID0gcmVxdWlyZSgnc25hYmJkb20vaCcpLmRlZmF1bHQ7XG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCBodG1sVGFncyA9IHJlcXVpcmUoJ2h0bWwtdGFncycpO1xuXG5jb25zdCBhdHRycyA9IHJlcXVpcmUoJy4vdXRpbC9hdHRycycpO1xuXG5jb25zdCBwYXRjaCA9IHNuYWJiZG9tLmluaXQoWyAvLyBJbml0IHBhdGNoIGZ1bmN0aW9uIHdpdGggY2hvb3NlbiBtb2R1bGVzXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvY2xhc3MnKS5kZWZhdWx0LCAvLyBtYWtlcyBpdCBlYXN5IHRvIHRvZ2dsZSBjbGFzc2VzXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvcHJvcHMnKS5kZWZhdWx0LCAvLyBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIERPTSBlbGVtZW50c1xuXHRyZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMnKS5kZWZhdWx0LCAvLyBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIERPTSBlbGVtZW50c1xuXHRyZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL3N0eWxlJykuZGVmYXVsdCwgLy8gaGFuZGxlcyBzdHlsaW5nIG9uIGVsZW1lbnRzIHdpdGggc3VwcG9ydCBmb3IgYW5pbWF0aW9uc1xuXHRyZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2V2ZW50bGlzdGVuZXJzJykuZGVmYXVsdCAvLyBhdHRhY2hlcyBldmVudCBsaXN0ZW5lcnNcbl0pO1xuXG5jb25zdCBwYXRjaFN0cmVhbSA9IChzdHJlYW0sIGRvbSkgPT4ge1xuXHRkb20gPSAodHlwZW9mIGRvbSA9PT0gJ3N0cmluZycpID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihkb20pIDogZG9tO1xuXHRzdHJlYW0uc2Nhbihcblx0XHQodm5vZGUsIG5ld1Zub2RlKSA9PiBwYXRjaCh2bm9kZSwgbmV3Vm5vZGUpLFxuXHRcdGRvbVxuXHQpLnN1YnNjcmliZSgpO1xufTtcblxuY29uc3QgaHlwZXJIZWxwZXJzID0gaHRtbFRhZ3MucmVkdWNlKFxuXHQobywgdGFnKSA9PiB7XG5cdFx0b1t0YWddID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW0FycmF5LmZyb20oYXJndW1lbnRzKV1cblx0XHRcdFx0Lm1hcChhdHRycy5wcm9jZXNzKVxuXHRcdFx0XHQubWFwKGFyZ3MgPT4gKFxuXHRcdFx0XHRcdC8vIGlzIHRoZSBmaXJzdCBhcmd1bWVudCBhIHNlbGVjdG9yXG5cdFx0XHRcdFx0YXJnc1swXSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgJiYgYXJnc1swXS5tYXRjaCgvXihcXC58IylbYS16QS1aXFwtXzAtOV0rL2lnKSlcblx0XHRcdFx0XHRcdD8gW10uY29uY2F0KHRhZyArIGFyZ3NbMF0sIGFyZ3Muc2xpY2UoMSkpXG5cdFx0XHRcdFx0XHQ6IFt0YWddLmNvbmNhdChhcmdzKSlcblx0XHRcdFx0Lm1hcChhcmdzID0+IGguYXBwbHkodGhpcywgYXJncykpXG5cdFx0XHRcdC5wb3AoKTtcblx0XHR9O1xuXHRcdHJldHVybiBvO1xuXHR9LCB7fVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKFxuXHR7XG5cdFx0aCxcblx0XHRwYXRjaCxcblx0XHRwYXRjaFN0cmVhbVxuXHR9LFxuXHRoeXBlckhlbHBlcnNcbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2bm9kZV8xID0gcmVxdWlyZShcIi4vdm5vZGVcIik7XG52YXIgaXMgPSByZXF1aXJlKFwiLi9pc1wiKTtcbmZ1bmN0aW9uIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWwpIHtcbiAgICBkYXRhLm5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICBpZiAoc2VsICE9PSAnZm9yZWlnbk9iamVjdCcgJiYgY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGREYXRhID0gY2hpbGRyZW5baV0uZGF0YTtcbiAgICAgICAgICAgIGlmIChjaGlsZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFkZE5TKGNoaWxkRGF0YSwgY2hpbGRyZW5baV0uY2hpbGRyZW4sIGNoaWxkcmVuW2ldLnNlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoKHNlbCwgYiwgYykge1xuICAgIHZhciBkYXRhID0ge30sIGNoaWxkcmVuLCB0ZXh0LCBpO1xuICAgIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YSA9IGI7XG4gICAgICAgIGlmIChpcy5hcnJheShjKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShjKSkge1xuICAgICAgICAgICAgdGV4dCA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAmJiBjLnNlbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpcy5hcnJheShiKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShiKSkge1xuICAgICAgICAgICAgdGV4dCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiAmJiBiLnNlbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbYl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzLnByaW1pdGl2ZShjaGlsZHJlbltpXSkpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB2bm9kZV8xLnZub2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsWzBdID09PSAncycgJiYgc2VsWzFdID09PSAndicgJiYgc2VsWzJdID09PSAnZycgJiZcbiAgICAgICAgKHNlbC5sZW5ndGggPT09IDMgfHwgc2VsWzNdID09PSAnLicgfHwgc2VsWzNdID09PSAnIycpKSB7XG4gICAgICAgIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWwpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVfMS52bm9kZShzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCB1bmRlZmluZWQpO1xufVxuZXhwb3J0cy5oID0gaDtcbjtcbmV4cG9ydHMuZGVmYXVsdCA9IGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbn1cbmZ1bmN0aW9uIHRhZ05hbWUoZWxtKSB7XG4gICAgcmV0dXJuIGVsbS50YWdOYW1lO1xufVxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzVGV4dChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDM7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSA4O1xufVxuZXhwb3J0cy5odG1sRG9tQXBpID0ge1xuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gICAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBnZXRUZXh0Q29udGVudDogZ2V0VGV4dENvbnRlbnQsXG4gICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgaXNUZXh0OiBpc1RleHQsXG4gICAgaXNDb21tZW50OiBpc0NvbW1lbnQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5odG1sRG9tQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHRtbGRvbWFwaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gcHJpbWl0aXZlKHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMucHJpbWl0aXZlID0gcHJpbWl0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYm9vbGVhbkF0dHJzID0gW1wiYWxsb3dmdWxsc2NyZWVuXCIsIFwiYXN5bmNcIiwgXCJhdXRvZm9jdXNcIiwgXCJhdXRvcGxheVwiLCBcImNoZWNrZWRcIiwgXCJjb21wYWN0XCIsIFwiY29udHJvbHNcIiwgXCJkZWNsYXJlXCIsXG4gICAgXCJkZWZhdWx0XCIsIFwiZGVmYXVsdGNoZWNrZWRcIiwgXCJkZWZhdWx0bXV0ZWRcIiwgXCJkZWZhdWx0c2VsZWN0ZWRcIiwgXCJkZWZlclwiLCBcImRpc2FibGVkXCIsIFwiZHJhZ2dhYmxlXCIsXG4gICAgXCJlbmFibGVkXCIsIFwiZm9ybW5vdmFsaWRhdGVcIiwgXCJoaWRkZW5cIiwgXCJpbmRldGVybWluYXRlXCIsIFwiaW5lcnRcIiwgXCJpc21hcFwiLCBcIml0ZW1zY29wZVwiLCBcImxvb3BcIiwgXCJtdWx0aXBsZVwiLFxuICAgIFwibXV0ZWRcIiwgXCJub2hyZWZcIiwgXCJub3Jlc2l6ZVwiLCBcIm5vc2hhZGVcIiwgXCJub3ZhbGlkYXRlXCIsIFwibm93cmFwXCIsIFwib3BlblwiLCBcInBhdXNlb25leGl0XCIsIFwicmVhZG9ubHlcIixcbiAgICBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJzY29wZWRcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCIsIFwic29ydGFibGVcIiwgXCJzcGVsbGNoZWNrXCIsIFwidHJhbnNsYXRlXCIsXG4gICAgXCJ0cnVlc3BlZWRcIiwgXCJ0eXBlbXVzdG1hdGNoXCIsIFwidmlzaWJsZVwiXTtcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhtbE5TID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XG52YXIgY29sb25DaGFyID0gNTg7XG52YXIgeENoYXIgPSAxMjA7XG52YXIgYm9vbGVhbkF0dHJzRGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKHZhciBpID0gMCwgbGVuID0gYm9vbGVhbkF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYm9vbGVhbkF0dHJzRGljdFtib29sZWFuQXR0cnNbaV1dID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBrZXksIGVsbSA9IHZub2RlLmVsbSwgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzLCBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnM7XG4gICAgaWYgKCFvbGRBdHRycyAmJiAhYXR0cnMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkQXR0cnMgPT09IGF0dHJzKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkQXR0cnMgPSBvbGRBdHRycyB8fCB7fTtcbiAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgIC8vIHVwZGF0ZSBtb2RpZmllZCBhdHRyaWJ1dGVzLCBhZGQgbmV3IGF0dHJpYnV0ZXNcbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICB2YXIgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgICAgdmFyIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgICAgICAgaWYgKGJvb2xlYW5BdHRyc0RpY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuY2hhckNvZGVBdCgwKSAhPT0geENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5jaGFyQ29kZUF0KDMpID09PSBjb2xvbkNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHhtbCBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZU5TKHhtbE5TLCBrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5jaGFyQ29kZUF0KDUpID09PSBjb2xvbkNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHhsaW5rIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZW1vdmVkIGF0dHJpYnV0ZXNcbiAgICAvLyB1c2UgYGluYCBvcGVyYXRvciBzaW5jZSB0aGUgcHJldmlvdXMgYGZvcmAgaXRlcmF0aW9uIHVzZXMgaXQgKC5pLmUuIGFkZCBldmVuIGF0dHJpYnV0ZXMgd2l0aCB1bmRlZmluZWQgdmFsdWUpXG4gICAgLy8gdGhlIG90aGVyIG9wdGlvbiBpcyB0byByZW1vdmUgYWxsIGF0dHJpYnV0ZXMgd2l0aCB2YWx1ZSA9PSB1bmRlZmluZWRcbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmF0dHJpYnV0ZXNNb2R1bGUgPSB7IGNyZWF0ZTogdXBkYXRlQXR0cnMsIHVwZGF0ZTogdXBkYXRlQXR0cnMgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuYXR0cmlidXRlc01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIG9sZENsYXNzID0gb2xkVm5vZGUuZGF0YS5jbGFzcywga2xhc3MgPSB2bm9kZS5kYXRhLmNsYXNzO1xuICAgIGlmICghb2xkQ2xhc3MgJiYgIWtsYXNzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZENsYXNzID09PSBrbGFzcylcbiAgICAgICAgcmV0dXJuO1xuICAgIG9sZENsYXNzID0gb2xkQ2xhc3MgfHwge307XG4gICAga2xhc3MgPSBrbGFzcyB8fCB7fTtcbiAgICBmb3IgKG5hbWUgaW4gb2xkQ2xhc3MpIHtcbiAgICAgICAgaWYgKCFrbGFzc1tuYW1lXSkge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIGtsYXNzKSB7XG4gICAgICAgIGN1ciA9IGtsYXNzW25hbWVdO1xuICAgICAgICBpZiAoY3VyICE9PSBvbGRDbGFzc1tuYW1lXSkge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdFtjdXIgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2xhc3NNb2R1bGUgPSB7IGNyZWF0ZTogdXBkYXRlQ2xhc3MsIHVwZGF0ZTogdXBkYXRlQ2xhc3MgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuY2xhc3NNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGludm9rZUhhbmRsZXIoaGFuZGxlciwgdm5vZGUsIGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiBoYW5kbGVyXG4gICAgICAgIGhhbmRsZXIuY2FsbCh2bm9kZSwgZXZlbnQsIHZub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gY2FsbCBoYW5kbGVyIHdpdGggYXJndW1lbnRzXG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlclswXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHNpbmdsZSBhcmd1bWVudCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJbMF0uY2FsbCh2bm9kZSwgaGFuZGxlclsxXSwgZXZlbnQsIHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaGFuZGxlci5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlclswXS5hcHBseSh2bm9kZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjYWxsIG11bHRpcGxlIGhhbmRsZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnZva2VIYW5kbGVyKGhhbmRsZXJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQsIHZub2RlKSB7XG4gICAgdmFyIG5hbWUgPSBldmVudC50eXBlLCBvbiA9IHZub2RlLmRhdGEub247XG4gICAgLy8gY2FsbCBldmVudCBoYW5kbGVyKHMpIGlmIGV4aXN0c1xuICAgIGlmIChvbiAmJiBvbltuYW1lXSkge1xuICAgICAgICBpbnZva2VIYW5kbGVyKG9uW25hbWVdLCB2bm9kZSwgZXZlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGhhbmRsZUV2ZW50KGV2ZW50LCBoYW5kbGVyLnZub2RlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlRXZlbnRMaXN0ZW5lcnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiwgb2xkTGlzdGVuZXIgPSBvbGRWbm9kZS5saXN0ZW5lciwgb2xkRWxtID0gb2xkVm5vZGUuZWxtLCBvbiA9IHZub2RlICYmIHZub2RlLmRhdGEub24sIGVsbSA9ICh2bm9kZSAmJiB2bm9kZS5lbG0pLCBuYW1lO1xuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgcmV1c2VkIGltbXV0YWJsZSBoYW5kbGVyc1xuICAgIGlmIChvbGRPbiA9PT0gb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgbGlzdGVuZXJzIHdoaWNoIG5vIGxvbmdlciB1c2VkXG4gICAgaWYgKG9sZE9uICYmIG9sZExpc3RlbmVyKSB7XG4gICAgICAgIC8vIGlmIGVsZW1lbnQgY2hhbmdlZCBvciBkZWxldGVkIHdlIHJlbW92ZSBhbGwgZXhpc3RpbmcgbGlzdGVuZXJzIHVuY29uZGl0aW9uYWxseVxuICAgICAgICBpZiAoIW9uKSB7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXIgaWYgZWxlbWVudCB3YXMgY2hhbmdlZCBvciBleGlzdGluZyBsaXN0ZW5lcnMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIG9sZEVsbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIG9sZExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXIgaWYgZXhpc3RpbmcgbGlzdGVuZXIgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgb2xkTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG5ldyBsaXN0ZW5lcnMgd2hpY2ggaGFzIG5vdCBhbHJlYWR5IGF0dGFjaGVkXG4gICAgaWYgKG9uKSB7XG4gICAgICAgIC8vIHJldXNlIGV4aXN0aW5nIGxpc3RlbmVyIG9yIGNyZWF0ZSBuZXdcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdm5vZGUubGlzdGVuZXIgPSBvbGRWbm9kZS5saXN0ZW5lciB8fCBjcmVhdGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyB1cGRhdGUgdm5vZGUgZm9yIGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyLnZub2RlID0gdm5vZGU7XG4gICAgICAgIC8vIGlmIGVsZW1lbnQgY2hhbmdlZCBvciBhZGRlZCB3ZSBhZGQgYWxsIG5lZWRlZCBsaXN0ZW5lcnMgdW5jb25kaXRpb25hbGx5XG4gICAgICAgIGlmICghb2xkT24pIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBsaXN0ZW5lciBpZiBlbGVtZW50IHdhcyBjaGFuZ2VkIG9yIG5ldyBsaXN0ZW5lcnMgYWRkZWRcbiAgICAgICAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGxpc3RlbmVyIGlmIG5ldyBsaXN0ZW5lciBhZGRlZFxuICAgICAgICAgICAgICAgIGlmICghb2xkT25bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV2ZW50TGlzdGVuZXJzTW9kdWxlID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnMsXG4gICAgdXBkYXRlOiB1cGRhdGVFdmVudExpc3RlbmVycyxcbiAgICBkZXN0cm95OiB1cGRhdGVFdmVudExpc3RlbmVyc1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZXZlbnRMaXN0ZW5lcnNNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudGxpc3RlbmVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5wcm9wcywgcHJvcHMgPSB2bm9kZS5kYXRhLnByb3BzO1xuICAgIGlmICghb2xkUHJvcHMgJiYgIXByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZFByb3BzID09PSBwcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIG9sZFByb3BzID0gb2xkUHJvcHMgfHwge307XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICBpZiAoIXByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbG1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgICAgICBvbGQgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICBpZiAob2xkICE9PSBjdXIgJiYgKGtleSAhPT0gJ3ZhbHVlJyB8fCBlbG1ba2V5XSAhPT0gY3VyKSkge1xuICAgICAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnByb3BzTW9kdWxlID0geyBjcmVhdGU6IHVwZGF0ZVByb3BzLCB1cGRhdGU6IHVwZGF0ZVByb3BzIH07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnByb3BzTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmFmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24gKGZuKSB7IHJhZihmdW5jdGlvbiAoKSB7IHJhZihmbik7IH0pOyB9O1xuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgb2xkU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0eWxlLCBzdHlsZSA9IHZub2RlLmRhdGEuc3R5bGU7XG4gICAgaWYgKCFvbGRTdHlsZSAmJiAhc3R5bGUpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkU3R5bGUgPT09IHN0eWxlKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkU3R5bGUgPSBvbGRTdHlsZSB8fCB7fTtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHZhciBvbGRIYXNEZWwgPSAnZGVsYXllZCcgaW4gb2xkU3R5bGU7XG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICAgIGlmICghc3R5bGVbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChuYW1lWzBdID09PSAnLScgJiYgbmFtZVsxXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGN1ciA9IHN0eWxlW25hbWVdO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2RlbGF5ZWQnICYmIHN0eWxlLmRlbGF5ZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUyIGluIHN0eWxlLmRlbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBzdHlsZS5kZWxheWVkW25hbWUyXTtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZEhhc0RlbCB8fCBjdXIgIT09IG9sZFN0eWxlLmRlbGF5ZWRbbmFtZTJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE5leHRGcmFtZShlbG0uc3R5bGUsIG5hbWUyLCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lICE9PSAncmVtb3ZlJyAmJiBjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAobmFtZVswXSA9PT0gJy0nICYmIG5hbWVbMV0gPT09ICctJykge1xuICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlEZXN0cm95U3R5bGUodm5vZGUpIHtcbiAgICB2YXIgc3R5bGUsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gICAgaWYgKCFzIHx8ICEoc3R5bGUgPSBzLmRlc3Ryb3kpKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGVsbS5zdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5UmVtb3ZlU3R5bGUodm5vZGUsIHJtKSB7XG4gICAgdmFyIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICAgIGlmICghcyB8fCAhcy5yZW1vdmUpIHtcbiAgICAgICAgcm0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBpID0gMCwgY29tcFN0eWxlLCBzdHlsZSA9IHMucmVtb3ZlLCBhbW91bnQgPSAwLCBhcHBsaWVkID0gW107XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGFwcGxpZWQucHVzaChuYW1lKTtcbiAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgfVxuICAgIGNvbXBTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxtKTtcbiAgICB2YXIgcHJvcHMgPSBjb21wU3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS5zcGxpdCgnLCAnKTtcbiAgICBmb3IgKDsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhcHBsaWVkLmluZGV4T2YocHJvcHNbaV0pICE9PSAtMSlcbiAgICAgICAgICAgIGFtb3VudCsrO1xuICAgIH1cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXYudGFyZ2V0ID09PSBlbG0pXG4gICAgICAgICAgICAtLWFtb3VudDtcbiAgICAgICAgaWYgKGFtb3VudCA9PT0gMClcbiAgICAgICAgICAgIHJtKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnN0eWxlTW9kdWxlID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZSxcbiAgICBkZXN0cm95OiBhcHBseURlc3Ryb3lTdHlsZSxcbiAgICByZW1vdmU6IGFwcGx5UmVtb3ZlU3R5bGVcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnN0eWxlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdm5vZGVfMSA9IHJlcXVpcmUoXCIuL3Zub2RlXCIpO1xudmFyIGlzID0gcmVxdWlyZShcIi4vaXNcIik7XG52YXIgaHRtbGRvbWFwaV8xID0gcmVxdWlyZShcIi4vaHRtbGRvbWFwaVwiKTtcbmZ1bmN0aW9uIGlzVW5kZWYocykgeyByZXR1cm4gcyA9PT0gdW5kZWZpbmVkOyB9XG5mdW5jdGlvbiBpc0RlZihzKSB7IHJldHVybiBzICE9PSB1bmRlZmluZWQ7IH1cbnZhciBlbXB0eU5vZGUgPSB2bm9kZV8xLmRlZmF1bHQoJycsIHt9LCBbXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuZnVuY3Rpb24gc2FtZVZub2RlKHZub2RlMSwgdm5vZGUyKSB7XG4gICAgcmV0dXJuIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiYgdm5vZGUxLnNlbCA9PT0gdm5vZGUyLnNlbDtcbn1cbmZ1bmN0aW9uIGlzVm5vZGUodm5vZGUpIHtcbiAgICByZXR1cm4gdm5vZGUuc2VsICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICAgIHZhciBpLCBtYXAgPSB7fSwga2V5LCBjaDtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAgICBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAga2V5ID0gY2gua2V5O1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95JywgJ3ByZScsICdwb3N0J107XG52YXIgaF8xID0gcmVxdWlyZShcIi4vaFwiKTtcbmV4cG9ydHMuaCA9IGhfMS5oO1xudmFyIHRodW5rXzEgPSByZXF1aXJlKFwiLi90aHVua1wiKTtcbmV4cG9ydHMudGh1bmsgPSB0aHVua18xLnRodW5rO1xuZnVuY3Rpb24gaW5pdChtb2R1bGVzLCBkb21BcGkpIHtcbiAgICB2YXIgaSwgaiwgY2JzID0ge307XG4gICAgdmFyIGFwaSA9IGRvbUFwaSAhPT0gdW5kZWZpbmVkID8gZG9tQXBpIDogaHRtbGRvbWFwaV8xLmRlZmF1bHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBob29rID0gbW9kdWxlc1tqXVtob29rc1tpXV07XG4gICAgICAgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKGhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICB2YXIgaWQgPSBlbG0uaWQgPyAnIycgKyBlbG0uaWQgOiAnJztcbiAgICAgICAgdmFyIGMgPSBlbG0uY2xhc3NOYW1lID8gJy4nICsgZWxtLmNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICByZXR1cm4gdm5vZGVfMS5kZWZhdWx0KGFwaS50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSArIGlkICsgYywge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm1DYigpIHtcbiAgICAgICAgICAgIGlmICgtLWxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGFwaS5wYXJlbnROb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50XzEsIGNoaWxkRWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgdmFyIGksIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbiwgc2VsID0gdm5vZGUuc2VsO1xuICAgICAgICBpZiAoc2VsID09PSAnIScpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUudGV4dCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUuZWxtID0gYXBpLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHNlbGVjdG9yXG4gICAgICAgICAgICB2YXIgaGFzaElkeCA9IHNlbC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICB2YXIgZG90SWR4ID0gc2VsLmluZGV4T2YoJy4nLCBoYXNoSWR4KTtcbiAgICAgICAgICAgIHZhciBoYXNoID0gaGFzaElkeCA+IDAgPyBoYXNoSWR4IDogc2VsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkb3QgPSBkb3RJZHggPiAwID8gZG90SWR4IDogc2VsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0YWcgPSBoYXNoSWR4ICE9PSAtMSB8fCBkb3RJZHggIT09IC0xID8gc2VsLnNsaWNlKDAsIE1hdGgubWluKGhhc2gsIGRvdCkpIDogc2VsO1xuICAgICAgICAgICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLm5zKSA/IGFwaS5jcmVhdGVFbGVtZW50TlMoaSwgdGFnKVxuICAgICAgICAgICAgICAgIDogYXBpLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgICAgIGlmIChoYXNoIDwgZG90KVxuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsLnNsaWNlKGhhc2ggKyAxLCBkb3QpKTtcbiAgICAgICAgICAgIGlmIChkb3RJZHggPiAwKVxuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgc2VsLnNsaWNlKGRvdCArIDEpLnJlcGxhY2UoL1xcLi9nLCAnICcpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgICAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmFwcGVuZENoaWxkKGVsbSwgY3JlYXRlRWxtKGNoLCBpbnNlcnRlZFZub2RlUXVldWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaS5pbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGUuZWxtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0oY2gsIGluc2VydGVkVm5vZGVRdWV1ZSksIGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sodm5vZGUpIHtcbiAgICAgICAgdmFyIGksIGosIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgaSh2bm9kZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHZub2RlLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSBudWxsICYmIHR5cGVvZiBpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXMocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgdmFyIGlfMSA9IHZvaWQgMCwgbGlzdGVuZXJzID0gdm9pZCAwLCBybSA9IHZvaWQgMCwgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICAgICAgaWYgKGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2guc2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKGNoLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpXzEgPSAwOyBpXzEgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYnMucmVtb3ZlW2lfMV0oY2gsIHJtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKGlfMSA9IGNoLmRhdGEpICYmIGlzRGVmKGlfMSA9IGlfMS5ob29rKSAmJiBpc0RlZihpXzEgPSBpXzEucmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaV8xKGNoLCBybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50RWxtLCBjaC5lbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIHZhciBvbGRTdGFydElkeCA9IDAsIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgICAgICB2YXIgb2xkS2V5VG9JZHg7XG4gICAgICAgIHZhciBpZHhJbk9sZDtcbiAgICAgICAgdmFyIGVsbVRvTW92ZTtcbiAgICAgICAgdmFyIGJlZm9yZTtcbiAgICAgICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEtleVRvSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeEluT2xkID0gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLnNlbCAhPT0gbmV3U3RhcnRWbm9kZS5zZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIHZhciBpLCBob29rO1xuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEpICYmIGlzRGVmKGhvb2sgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBob29rLnByZXBhdGNoKSkge1xuICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHZub2RlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vaztcbiAgICAgICAgICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKVxuICAgICAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ2ggIT09IGNoKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGhvb2spICYmIGlzRGVmKGkgPSBob29rLnBvc3RwYXRjaCkpIHtcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2gob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIHZhciBpLCBlbG0sIHBhcmVudDtcbiAgICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnByZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGNicy5wcmVbaV0oKTtcbiAgICAgICAgaWYgKCFpc1Zub2RlKG9sZFZub2RlKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgICAgIHBhcmVudCA9IGFwaS5wYXJlbnROb2RlKGVsbSk7XG4gICAgICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnQsIHZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKGVsbSkpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnQsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnNlcnRlZFZub2RlUXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KGluc2VydGVkVm5vZGVRdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5wb3N0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY2JzLnBvc3RbaV0oKTtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH07XG59XG5leHBvcnRzLmluaXQgPSBpbml0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25hYmJkb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaF8xID0gcmVxdWlyZShcIi4vaFwiKTtcbmZ1bmN0aW9uIGNvcHlUb1RodW5rKHZub2RlLCB0aHVuaykge1xuICAgIHRodW5rLmVsbSA9IHZub2RlLmVsbTtcbiAgICB2bm9kZS5kYXRhLmZuID0gdGh1bmsuZGF0YS5mbjtcbiAgICB2bm9kZS5kYXRhLmFyZ3MgPSB0aHVuay5kYXRhLmFyZ3M7XG4gICAgdGh1bmsuZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdGh1bmsuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB0aHVuay50ZXh0ID0gdm5vZGUudGV4dDtcbiAgICB0aHVuay5lbG0gPSB2bm9kZS5lbG07XG59XG5mdW5jdGlvbiBpbml0KHRodW5rKSB7XG4gICAgdmFyIGN1ciA9IHRodW5rLmRhdGE7XG4gICAgdmFyIHZub2RlID0gY3VyLmZuLmFwcGx5KHVuZGVmaW5lZCwgY3VyLmFyZ3MpO1xuICAgIGNvcHlUb1RodW5rKHZub2RlLCB0aHVuayk7XG59XG5mdW5jdGlvbiBwcmVwYXRjaChvbGRWbm9kZSwgdGh1bmspIHtcbiAgICB2YXIgaSwgb2xkID0gb2xkVm5vZGUuZGF0YSwgY3VyID0gdGh1bmsuZGF0YTtcbiAgICB2YXIgb2xkQXJncyA9IG9sZC5hcmdzLCBhcmdzID0gY3VyLmFyZ3M7XG4gICAgaWYgKG9sZC5mbiAhPT0gY3VyLmZuIHx8IG9sZEFyZ3MubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICBjb3B5VG9UaHVuayhjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSwgdGh1bmspO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChvbGRBcmdzW2ldICE9PSBhcmdzW2ldKSB7XG4gICAgICAgICAgICBjb3B5VG9UaHVuayhjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSwgdGh1bmspO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHlUb1RodW5rKG9sZFZub2RlLCB0aHVuayk7XG59XG5leHBvcnRzLnRodW5rID0gZnVuY3Rpb24gdGh1bmsoc2VsLCBrZXksIGZuLCBhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmdzID0gZm47XG4gICAgICAgIGZuID0ga2V5O1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBoXzEuaChzZWwsIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGhvb2s6IHsgaW5pdDogaW5pdCwgcHJlcGF0Y2g6IHByZXBhdGNoIH0sXG4gICAgICAgIGZuOiBmbixcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMudGh1bms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHVuay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHZub2RlKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIGVsbSkge1xuICAgIHZhciBrZXkgPSBkYXRhID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBkYXRhLmtleTtcbiAgICByZXR1cm4geyBzZWw6IHNlbCwgZGF0YTogZGF0YSwgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICB0ZXh0OiB0ZXh0LCBlbG06IGVsbSwga2V5OiBrZXkgfTtcbn1cbmV4cG9ydHMudm5vZGUgPSB2bm9kZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZub2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dm5vZGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IHN0clBhcnNlID0gcyA9PlxuXHRzLm1hdGNoKC9eWzAtOV0rJC8pID8gcGFyc2VJbnQocywgMTApXG5cdDogcy5tYXRjaCgvXlswLTkuXSskLykgPyBwYXJzZUZsb2F0KHMpXG5cdDogcyA9PT0gJ3RydWUnID8gdHJ1ZVxuXHQ6IHMgPT09ICdmYWxzZScgPyBmYWxzZVxuXHQ6IHM7XG5cbmNvbnN0IHByb2Nlc3MgPSBhcmdzID0+IHtcblx0bGV0IG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG5cblx0bGV0IHNlbGVjdG9yID0gbmV3QXJnc1swXSAmJiB0eXBlb2YgbmV3QXJnc1swXSA9PT0gJ3N0cmluZycgJiYgbmV3QXJnc1swXSB8fCAnJztcblx0aWYgKHNlbGVjdG9yICE9PSAnJykgbmV3QXJncyA9IG5ld0FyZ3Muc2xpY2UoMSk7XG5cblx0Y29uc3QgYXR0clJlZ0V4cCA9IC9cXFtbYS16XFwtMC05XSs9KFwiW15cIl0rXCJ8J1teJ10rJ3xbMC05Ll0rfHRydWV8ZmFsc2V8W15cXF1ePV5cIl4nXSspXFxdL2lnO1xuXG5cdGxldCBhdHRycyA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLm1hdGNoKGF0dHJSZWdFeHApO1xuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoYXR0clJlZ0V4cCwgJycpO1xuXG5cdGF0dHJzID0gYXR0cnMgJiYgYXR0cnMubWFwICYmIGF0dHJzXG5cdFx0Lm1hcChjID0+IGMucmVwbGFjZSgvW1tcXF0oXCJ8JyldL2csICcnKS5zcGxpdCgnPScpKVxuXHRcdC5yZWR1Y2UoKG8sIGF0dHIpID0+IG9iai5wYXRjaChvLCBhdHRyWzBdLCBzdHJQYXJzZShhdHRyWzFdKSksIHt9KSB8fCB7fTtcblxuXHRpZiAoYXR0cnMgJiYgT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCA+IDApIHtcblx0XHRpZiAoIW5ld0FyZ3NbMF0gfHwgbmV3QXJnc1swXVxuXHRcdFx0JiYgdHlwZW9mIG5ld0FyZ3NbMF0gPT09ICdvYmplY3QnICYmICEobmV3QXJnc1swXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0YXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdBcmdzWzBdICYmIG5ld0FyZ3NbMF0uYXR0cnMgfHwge30sIGF0dHJzKTtcblx0XHRcdG5ld0FyZ3NbMF0gPSBPYmplY3QuYXNzaWduKHt9LCBuZXdBcmdzWzBdIHx8IHt9LCB7YXR0cnN9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3QXJncyA9IFt7YXR0cnN9XS5jb25jYXQobmV3QXJncyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNlbGVjdG9yICE9PSAnJykgbmV3QXJncyA9IFtzZWxlY3Rvcl0uY29uY2F0KG5ld0FyZ3MpO1xuXG5cdC8vIGNvbnNvbGUubG9nKGFyZ3MsIG5ld0FyZ3MpO1xuXHRyZXR1cm4gbmV3QXJncztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdHJQYXJzZSxcblx0cHJvY2Vzc1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBNdXRhdGlvbiA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG52YXIgc2NoZWR1bGVEcmFpbjtcblxue1xuICBpZiAoTXV0YXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb24obmV4dFRpY2spO1xuICAgIHZhciBlbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5kYXRhID0gKGNhbGxlZCA9ICsrY2FsbGVkICUgMik7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2xvYmFsLnNldEltbWVkaWF0ZSAmJiB0eXBlb2YgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbmV4dFRpY2s7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgnZG9jdW1lbnQnIGluIGdsb2JhbCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0RWwgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKCk7XG5cbiAgICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgIHNjcmlwdEVsID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBkcmFpbmluZztcbnZhciBxdWV1ZSA9IFtdO1xuLy9uYW1lZCBuZXh0VGljayBmb3IgbGVzcyBjb25mdXNpbmcgc3RhY2sgdHJhY2VzXG5mdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgZHJhaW5pbmcgPSB0cnVlO1xuICB2YXIgaSwgb2xkUXVldWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChsZW4pIHtcbiAgICBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG4gICAgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIG9sZFF1ZXVlW2ldKCk7XG4gICAgfVxuICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgfVxuICBkcmFpbmluZyA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGltbWVkaWF0ZTtcbmZ1bmN0aW9uIGltbWVkaWF0ZSh0YXNrKSB7XG4gIGlmIChxdWV1ZS5wdXNoKHRhc2spID09PSAxICYmICFkcmFpbmluZykge1xuICAgIHNjaGVkdWxlRHJhaW4oKTtcbiAgfVxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vIHByaXZhdGUgcHJvcGVydHlcbnZhciBfa2V5U3RyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuXG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGVuY29kaW5nXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoLCByZW1haW5pbmdCeXRlcyA9IGxlbjtcblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmdCeXRlcyA9IGxlbiAtIGk7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgY2hyMiA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dFtpKytdIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICBlbmMzID0gcmVtYWluaW5nQnl0ZXMgPiAxID8gKCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKSA6IDY0O1xuICAgICAgICBlbmM0ID0gcmVtYWluaW5nQnl0ZXMgPiAyID8gKGNocjMgJiA2MykgOiA2NDtcblxuICAgICAgICBvdXRwdXQucHVzaChfa2V5U3RyLmNoYXJBdChlbmMxKSArIF9rZXlTdHIuY2hhckF0KGVuYzIpICsgX2tleVN0ci5jaGFyQXQoZW5jMykgKyBfa2V5U3RyLmNoYXJBdChlbmM0KSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG4vLyBwdWJsaWMgbWV0aG9kIGZvciBkZWNvZGluZ1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgdmFyIGRhdGFVcmxQcmVmaXggPSBcImRhdGE6XCI7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIGRhdGFVcmxQcmVmaXgubGVuZ3RoKSA9PT0gZGF0YVVybFByZWZpeCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgY29tbW9uIGVycm9yOiBwZW9wbGUgZ2l2ZSBhIGRhdGEgdXJsXG4gICAgICAgIC8vIChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1IuLi4pIHdpdGggYSB7YmFzZTY0OiB0cnVlfSBhbmRcbiAgICAgICAgLy8gd29uZGVycyB3aHkgdGhpbmdzIGRvbid0IHdvcmsuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgc3RyaW5nIGlucHV0IGxvb2tzIGxpa2UgYSBkYXRhIHVybCBidXQgd2VcbiAgICAgICAgLy8gKmNhbid0KiBiZSBzdXJlIGl0IGlzIG9uZTogcmVtb3ZpbmcgZXZlcnl0aGluZyB1cCB0byB0aGUgY29tbWEgd291bGRcbiAgICAgICAgLy8gYmUgdG9vIGRhbmdlcm91cy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGl0IGxvb2tzIGxpa2UgYSBkYXRhIHVybC5cIik7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG5cbiAgICB2YXIgdG90YWxMZW5ndGggPSBpbnB1dC5sZW5ndGggKiAzIC8gNDtcbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMikgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZiAodG90YWxMZW5ndGggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIHRvdGFsTGVuZ3RoIGlzIG5vdCBhbiBpbnRlZ2VyLCB0aGUgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGEgdmFsaWRcbiAgICAgICAgLy8gYmFzZTY0IGNvbnRlbnQuIFRoYXQgY2FuIGhhcHBlbiBpZjpcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgbm90IGEgYmFzZTY0IGNvbnRlbnRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgKmFsbW9zdCogYSBiYXNlNjQgY29udGVudCwgd2l0aCBhIGV4dHJhIGNoYXJzIGF0IHRoZVxuICAgICAgICAvLyAgIGJlZ2lubmluZyBvciBhdCB0aGUgZW5kXG4gICAgICAgIC8vIC0gdGhlIGlucHV0IHVzZXMgYSBiYXNlNjQgdmFyaWFudCAoYmFzZTY0dXJsIGZvciBleGFtcGxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgYmFkIGNvbnRlbnQgbGVuZ3RoLlwiKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheSh0b3RhbExlbmd0aHwwKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGVuYzEgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciBEYXRhTGVuZ3RoUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbXByZXNzZWQgb2JqZWN0LCB3aXRoIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGRlY29tcHJlc3MgaXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjcmMzMiB0aGUgY3JjMzIgb2YgdGhlIGRlY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXByZXNzaW9uIHRoZSB0eXBlIG9mIGNvbXByZXNzaW9uLCBzZWUgbGliL2NvbXByZXNzaW9ucy5qcy5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIENvbXByZXNzZWRPYmplY3QoY29tcHJlc3NlZFNpemUsIHVuY29tcHJlc3NlZFNpemUsIGNyYzMyLCBjb21wcmVzc2lvbiwgZGF0YSkge1xuICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBjb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSB1bmNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMuY3JjMzIgPSBjcmMzMjtcbiAgICB0aGlzLmNvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGRhdGE7XG59XG5cbkNvbXByZXNzZWRPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIHVuY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29udGVudFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLnBpcGUodGhpcy5jb21wcmVzc2lvbi51bmNvbXByZXNzV29ya2VyKCkpXG4gICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJkYXRhX2xlbmd0aFwiKSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB3b3JrZXIub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5zdHJlYW1JbmZvWydkYXRhX2xlbmd0aCddICE9PSB0aGF0LnVuY29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIGNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbXByZXNzZWRXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzZWRTaXplXCIsIHRoaXMuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcInVuY29tcHJlc3NlZFNpemVcIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCB0aGlzLmNyYzMyKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCB0aGlzLmNvbXByZXNzaW9uKVxuICAgICAgICA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGFpbiB0aGUgZ2l2ZW4gd29ya2VyIHdpdGggb3RoZXIgd29ya2VycyB0byBjb21wcmVzcyB0aGUgY29udGVudCB3aXRoIHRoZVxuICogZ2l2ZW4gY29tcHJlc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKCcuL2ZsYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4uL3V0ZjgnKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbnMgYWJvdXQgdGhlIGNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtZWRDb250ZW50IGlzIHRoZSBjb250ZW50IHN0cmVhbWVkID9cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtaW5nRW5kZWQgaXMgdGhlIHN0cmVhbSBmaW5pc2hlZCA/XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gbGV0J3MgcHJldGVuZCB3ZSBhcmUgdGhpcyBwbGF0Zm9ybSAoY2hhbmdlIHBsYXRmb3JtIGRlcGVuZGVudHMgZmllbGRzKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgZmlsZSBuYW1lIC8gY29tbWVudC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHppcCBwYXJ0cy5cbiAqL1xudmFyIGdlbmVyYXRlWmlwUGFydHMgPSBmdW5jdGlvbihzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHN0cmVhbWluZ0VuZGVkLCBvZmZzZXQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBmaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLFxuICAgIGNvbXByZXNzaW9uID0gc3RyZWFtSW5mb1snY29tcHJlc3Npb24nXSxcbiAgICB1c2VDdXN0b21FbmNvZGluZyA9IGVuY29kZUZpbGVOYW1lICE9PSB1dGY4LnV0ZjhlbmNvZGUsXG4gICAgZW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoZmlsZS5uYW1lKSksXG4gICAgdXRmRW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGZpbGUubmFtZSkpLFxuICAgIGNvbW1lbnQgPSBmaWxlLmNvbW1lbnQsXG4gICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgdXRmRW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoY29tbWVudCkpLFxuICAgIHVzZVVURjhGb3JGaWxlTmFtZSA9IHV0ZkVuY29kZWRGaWxlTmFtZS5sZW5ndGggIT09IGZpbGUubmFtZS5sZW5ndGgsXG4gICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgIGRvc1RpbWUsXG4gICAgZG9zRGF0ZSxcbiAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID0gXCJcIixcbiAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIGRpciA9IGZpbGUuZGlyLFxuICAgIGRhdGUgPSBmaWxlLmRhdGU7XG5cblxuICAgIHZhciBkYXRhSW5mbyA9IHtcbiAgICAgICAgY3JjMzIgOiAwLFxuICAgICAgICBjb21wcmVzc2VkU2l6ZSA6IDAsXG4gICAgICAgIHVuY29tcHJlc3NlZFNpemUgOiAwXG4gICAgfTtcblxuICAgIC8vIGlmIHRoZSBjb250ZW50IGlzIHN0cmVhbWVkLCB0aGUgc2l6ZXMvY3JjMzIgYXJlIG9ubHkgYXZhaWxhYmxlIEFGVEVSXG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgIGlmICghc3RyZWFtZWRDb250ZW50IHx8IHN0cmVhbWluZ0VuZGVkKSB7XG4gICAgICAgIGRhdGFJbmZvLmNyYzMyID0gc3RyZWFtSW5mb1snY3JjMzInXTtcbiAgICAgICAgZGF0YUluZm8uY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddO1xuICAgICAgICBkYXRhSW5mby51bmNvbXByZXNzZWRTaXplID0gc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddO1xuICAgIH1cblxuICAgIHZhciBiaXRmbGFnID0gMDtcbiAgICBpZiAoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIEJpdCAzOiB0aGUgc2l6ZXMvY3JjMzIgYXJlIHNldCB0byB6ZXJvIGluIHRoZSBsb2NhbCBoZWFkZXIuXG4gICAgICAgIC8vIFRoZSBjb3JyZWN0IHZhbHVlcyBhcmUgcHV0IGluIHRoZSBkYXRhIGRlc2NyaXB0b3IgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gZm9sbG93aW5nIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwMDA4O1xuICAgIH1cbiAgICBpZiAoIXVzZUN1c3RvbUVuY29kaW5nICYmICh1c2VVVEY4Rm9yRmlsZU5hbWUgfHwgdXNlVVRGOEZvckNvbW1lbnQpKSB7XG4gICAgICAgIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDA4MDA7XG4gICAgfVxuXG5cbiAgICB2YXIgZXh0RmlsZUF0dHIgPSAwO1xuICAgIHZhciB2ZXJzaW9uTWFkZUJ5ID0gMDtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIC8vIGRvcyBvciB1bml4LCB3ZSBzZXQgdGhlIGRvcyBkaXIgZmxhZ1xuICAgICAgICBleHRGaWxlQXR0ciB8PSAweDAwMDEwO1xuICAgIH1cbiAgICBpZihwbGF0Zm9ybSA9PT0gXCJVTklYXCIpIHtcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDMxRTsgLy8gVU5JWCwgdmVyc2lvbiAzLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0cihmaWxlLnVuaXhQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9IGVsc2UgeyAvLyBET1Mgb3Igb3RoZXIsIGZhbGxiYWNrIHRvIERPU1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMDE0OyAvLyBET1MsIHZlcnNpb24gMi4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0cihmaWxlLmRvc1Blcm1pc3Npb25zLCBkaXIpO1xuICAgIH1cblxuICAgIC8vIGRhdGVcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNTIvMTMuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82NS8xNi5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY2LzE2Lmh0bWxcblxuICAgIGRvc1RpbWUgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNjtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDU7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ1NlY29uZHMoKSAvIDI7XG5cbiAgICBkb3NEYXRlID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA0O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDU7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCBkYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgIGlmICh1c2VVVEY4Rm9yRmlsZU5hbWUpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuIHVuemlwIG5lZWRzIGF0IGxlYXN0IG9uZSBleHRyYVxuICAgICAgICAvLyBmaWVsZCB0byBjb3JyZWN0bHkgaGFuZGxlIHVuaWNvZGUgcGF0aCwgc28gdXNpbmcgdGhlIHBhdGggaXMgYXMgZ29vZFxuICAgICAgICAvLyBhcyBhbnkgb3RoZXIgaW5mb3JtYXRpb24uIFRoaXMgY291bGQgaW1wcm92ZSB0aGUgc2l0dWF0aW9uIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgYXJjaGl2ZSBtYW5hZ2VycyB0b28uXG4gICAgICAgIC8vIFRoaXMgZmllbGQgaXMgdXN1YWxseSB1c2VkIHdpdGhvdXQgdGhlIHV0ZjggZmxhZywgd2l0aCBhIG5vblxuICAgICAgICAvLyB1bmljb2RlIHBhdGggaW4gdGhlIGhlYWRlciAod2lucmFyLCB3aW56aXApLiBUaGlzIGhlbHBzIChhIGJpdClcbiAgICAgICAgLy8gd2l0aCB0aGUgbWVzc3kgV2luZG93cycgZGVmYXVsdCBjb21wcmVzc2VkIGZvbGRlcnMgZmVhdHVyZSBidXRcbiAgICAgICAgLy8gYnJlYWtzIG9uIHA3emlwIHdoaWNoIGRvZXNuJ3Qgc2VlayB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLlxuICAgICAgICAvLyBTbyBmb3Igbm93LCBVVEYtOCBldmVyeXdoZXJlICFcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZEZpbGVOYW1lKSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZTtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NzBcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlUGF0aEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgaWYodXNlVVRGOEZvckNvbW1lbnQpIHtcblxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gQ29tbWVudENSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkQ29tbWVudCksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkQ29tbWVudDtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NjNcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlQ29tbWVudEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IFwiXCI7XG5cbiAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgaGVhZGVyICs9IFwiXFx4MEFcXHgwMFwiO1xuICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIGhlYWRlciArPSBkZWNUb0hleChiaXRmbGFnLCAyKTtcbiAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBoZWFkZXIgKz0gY29tcHJlc3Npb24ubWFnaWM7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSB0aW1lXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc1RpbWUsIDIpO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NEYXRlLCAyKTtcbiAgICAvLyBjcmMtMzJcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY3JjMzIsIDQpO1xuICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8udW5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChlbmNvZGVkRmlsZU5hbWUubGVuZ3RoLCAyKTtcbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZXh0cmFGaWVsZHMubGVuZ3RoLCAyKTtcblxuXG4gICAgdmFyIGZpbGVSZWNvcmQgPSBzaWduYXR1cmUuTE9DQUxfRklMRV9IRUFERVIgKyBoZWFkZXIgKyBlbmNvZGVkRmlsZU5hbWUgKyBleHRyYUZpZWxkcztcblxuICAgIHZhciBkaXJSZWNvcmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9GSUxFX0hFQURFUiArXG4gICAgICAgIC8vIHZlcnNpb24gbWFkZSBieSAoMDA6IERPUylcbiAgICAgICAgZGVjVG9IZXgodmVyc2lvbk1hZGVCeSwgMikgK1xuICAgICAgICAvLyBmaWxlIGhlYWRlciAoY29tbW9uIHRvIGZpbGUgYW5kIGNlbnRyYWwgZGlyZWN0b3J5KVxuICAgICAgICBoZWFkZXIgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyBkaXNrIG51bWJlciBzdGFydFxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyBUT0RPXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgIGRlY1RvSGV4KGV4dEZpbGVBdHRyLCA0KSArXG4gICAgICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXJcbiAgICAgICAgZGVjVG9IZXgob2Zmc2V0LCA0KSArXG4gICAgICAgIC8vIGZpbGUgbmFtZVxuICAgICAgICBlbmNvZGVkRmlsZU5hbWUgK1xuICAgICAgICAvLyBleHRyYSBmaWVsZFxuICAgICAgICBleHRyYUZpZWxkcyArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVSZWNvcmQ6IGZpbGVSZWNvcmQsXG4gICAgICAgIGRpclJlY29yZDogZGlyUmVjb3JkXG4gICAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIEVPQ0QgcmVjb3JkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVudHJpZXNDb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRyYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBjZW50cmFsIGRpci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGxvY2FsIGRpci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSB6aXAgZmlsZSBjb21tZW50IGFzIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgdGhlIGNvbW1lbnQuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBFT0NEIHJlY29yZC5cbiAqL1xudmFyIGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCA9IGZ1bmN0aW9uIChlbnRyaWVzQ291bnQsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCBjb21tZW50LCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBkaXJFbmQgPSBcIlwiO1xuICAgIHZhciBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKTtcblxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmVcbiAgICBkaXJFbmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoaXMgZGlza1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrXG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChjZW50cmFsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyXG4gICAgICAgIGRlY1RvSGV4KGxvY2FsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4gZGlyRW5kO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkYXRhIGRlc2NyaXB0b3JzIGZvciBhIGZpbGUgZW50cnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCBnZW5lcmF0ZWQgYnkgYSB3b3JrZXIsIGNvbnRhaW5pbmcgaW5mb3JtYXRpb25zXG4gKiBvbiB0aGUgZmlsZSBlbnRyeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRhdGEgZGVzY3JpcHRvcnMuXG4gKi9cbnZhciBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgIGRlc2NyaXB0b3IgPSBzaWduYXR1cmUuREFUQV9ERVNDUklQVE9SICtcbiAgICAgICAgLy8gY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ2NyYzMyJ10sIDQpICtcbiAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ10sIDQpICtcbiAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ3VuY29tcHJlc3NlZFNpemUnXSwgNCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuLyoqXG4gKiBBIHdvcmtlciB0byBjb25jYXRlbmF0ZSBvdGhlciB3b3JrZXJzIHRvIGNyZWF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1GaWxlcyBgdHJ1ZWAgdG8gc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyxcbiAqIGBmYWxzZWAgdG8gYWNjdW11bGF0ZSBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSB0aGUgcGxhdGZvcm0gdG8gdXNlLCBcIlVOSVhcIiBvciBcIkRPU1wiLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAqL1xuZnVuY3Rpb24gWmlwRmlsZVdvcmtlcihzdHJlYW1GaWxlcywgY29tbWVudCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiWmlwRmlsZVdvcmtlclwiKTtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gc28gZmFyLiBUaGlzIGRvZXNuJ3QgY291bnQgYWNjdW11bGF0ZWQgY2h1bmtzLlxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICAvLyBUaGUgY29tbWVudCBvZiB0aGUgemlwIGZpbGVcbiAgICB0aGlzLnppcENvbW1lbnQgPSBjb21tZW50O1xuICAgIC8vIFRoZSBwbGF0Zm9ybSBcImdlbmVyYXRpbmdcIiB0aGUgemlwIGZpbGUuXG4gICAgdGhpcy56aXBQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gICAgdGhpcy5lbmNvZGVGaWxlTmFtZSA9IGVuY29kZUZpbGVOYW1lO1xuICAgIC8vIFNob3VsZCB3ZSBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzID9cbiAgICB0aGlzLnN0cmVhbUZpbGVzID0gc3RyZWFtRmlsZXM7XG4gICAgLy8gSWYgYHN0cmVhbUZpbGVzYCBpcyBmYWxzZSwgd2Ugd2lsbCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgLy8gZmlsZXMgdG8gY2FsY3VsYXRlIHNpemVzIC8gY3JjMzIgKGFuZCB3cml0ZSB0aGVtICpiZWZvcmUqIHRoZSBjb250ZW50KS5cbiAgICAvLyBUaGlzIGJvb2xlYW4gaW5kaWNhdGVzIGlmIHdlIGFyZSBhY2N1bXVsYXRpbmcgY2h1bmtzIChpdCB3aWxsIGNoYW5nZSBhIGxvdFxuICAgIC8vIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyB3b3JrZXIpLlxuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlO1xuICAgIC8vIFRoZSBidWZmZXIgcmVjZWl2aW5nIGNodW5rcyB3aGVuIGFjY3VtdWxhdGluZyBjb250ZW50LlxuICAgIHRoaXMuY29udGVudEJ1ZmZlciA9IFtdO1xuICAgIC8vIFRoZSBsaXN0IG9mIGdlbmVyYXRlZCBkaXJlY3RvcnkgcmVjb3Jkcy5cbiAgICB0aGlzLmRpclJlY29yZHMgPSBbXTtcbiAgICAvLyBUaGUgb2Zmc2V0IChpbiBieXRlcykgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB6aXAgZmlsZSBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IDA7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgemlwIGZpbGUuXG4gICAgdGhpcy5lbnRyaWVzQ291bnQgPSAwO1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGN1cnJlbnRseSBiZWluZyBhZGRlZCwgbnVsbCB3aGVuIGhhbmRsaW5nIHRoZSBlbmQgb2YgdGhlIHppcCBmaWxlLlxuICAgIC8vIFVzZWQgZm9yIHRoZSBlbWl0ZWQgbWV0YWRhdGEuXG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG5cblxuXG4gICAgdGhpcy5fc291cmNlcyA9IFtdO1xufVxudXRpbHMuaW5oZXJpdHMoWmlwRmlsZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnB1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGN1cnJlbnRGaWxlUGVyY2VudCA9IGNodW5rLm1ldGEucGVyY2VudCB8fCAwO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSB0aGlzLmVudHJpZXNDb3VudDtcbiAgICB2YXIgcmVtYWluaW5nRmlsZXMgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcblxuICAgIGlmKHRoaXMuYWNjdW11bGF0ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRCdWZmZXIucHVzaChjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gY2h1bmsuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGRhdGEgOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZSA6IHRoaXMuY3VycmVudEZpbGUsXG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IGVudHJpZXNDb3VudCA/IChjdXJyZW50RmlsZVBlcmNlbnQgKyAxMDAgKiAoZW50cmllc0NvdW50IC0gcmVtYWluaW5nRmlsZXMgLSAxKSkgLyBlbnRyaWVzQ291bnQgOiAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIHN0YXJ0ZWQgYSBuZXcgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIG5ldyBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IHN0cmVhbUluZm9bJ2ZpbGUnXS5uYW1lO1xuXG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG5cbiAgICAvLyBkb24ndCBzdHJlYW0gZm9sZGVycyAoYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgYW55IGNvbnRlbnQpXG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgZmFsc2UsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgd2hvbGUgZmlsZSBiZWZvcmUgcHVzaGluZyBhbnl0aGluZ1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBmaW5pc2hlZCBhIHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBmaW5pc2hlZCBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmNsb3NlZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG4gICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCB0cnVlLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsIHRoaXMuemlwUGxhdGZvcm0sIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5kaXJSZWNvcmRzLnB1c2gocmVjb3JkLmRpclJlY29yZCk7XG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIGFmdGVyIHRoZSBzdHJlYW1lZCBmaWxlLCB3ZSBwdXQgZGF0YSBkZXNjcmlwdG9yc1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzKHN0cmVhbUluZm8pLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgd2Fzbid0IHN0cmVhbWVkLCB3ZSBuZWVkIHRvIHB1c2ggZXZlcnl0aGluZyBub3dcbiAgICAgICAgLy8gZmlyc3QgdGhlIGZpbGUgcmVjb3JkLCB0aGVuIHRoZSBjb250ZW50XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmNvbnRlbnRCdWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsb2NhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRpclJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiB0aGlzLmRpclJlY29yZHNbaV0sXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNlbnRyYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbiAtIGxvY2FsRGlyTGVuZ3RoO1xuXG4gICAgdmFyIGRpckVuZCA9IGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCh0aGlzLmRpclJlY29yZHMubGVuZ3RoLCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgdGhpcy56aXBDb21tZW50LCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBkaXJFbmQsXG4gICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIG5leHQgc291cmNlIHRvIGJlIHJlYWQuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLl9zb3VyY2VzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuZWRTb3VyY2UodGhpcy5wcmV2aW91cy5zdHJlYW1JbmZvKTtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5yZXN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZWdpc3RlclByZXZpb3VzXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXMgPSBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICB0aGlzLl9zb3VyY2VzLnB1c2gocHJldmlvdXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNsb3NlZFNvdXJjZShzZWxmLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgICAgICBpZihzZWxmLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmIHRoaXMuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiAhdGhpcy5fc291cmNlcy5sZW5ndGggJiYgIXRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZXJyb3JcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb3VyY2VzW2ldLmVycm9yKGUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBgZXJyb3JgIGV4cGxvZGVkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5sb2NrXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUubG9jay5jYWxsKHRoaXMpO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VzW2ldLmxvY2soKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcEZpbGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKCcuLi9jb21wcmVzc2lvbnMnKTtcbnZhciBaaXBGaWxlV29ya2VyID0gcmVxdWlyZSgnLi9aaXBGaWxlV29ya2VyJyk7XG5cbi8qKlxuICogRmluZCB0aGUgY29tcHJlc3Npb24gdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgZmlsZSBsZXZlbCwgaWYgYW55LlxuICogQHBhcmFtIHtTdHJpbmd9IHppcENvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBsb2FkKCkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICovXG52YXIgZ2V0Q29tcHJlc3Npb24gPSBmdW5jdGlvbiAoZmlsZUNvbXByZXNzaW9uLCB6aXBDb21wcmVzc2lvbikge1xuXG4gICAgdmFyIGNvbXByZXNzaW9uTmFtZSA9IGZpbGVDb21wcmVzc2lvbiB8fCB6aXBDb21wcmVzc2lvbjtcbiAgICB2YXIgY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbnNbY29tcHJlc3Npb25OYW1lXTtcbiAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wcmVzc2lvbk5hbWUgKyBcIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2VuZXJhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7SlNaaXB9IHppcCB0aGUgSlNaaXAgaW5zdGFuY2UgYXQgdGhlIHJpZ2h0IHJvb3QgbGV2ZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXb3JrZXIgPSBmdW5jdGlvbiAoemlwLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICB2YXIgemlwRmlsZVdvcmtlciA9IG5ldyBaaXBGaWxlV29ya2VyKG9wdGlvbnMuc3RyZWFtRmlsZXMsIGNvbW1lbnQsIG9wdGlvbnMucGxhdGZvcm0sIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUpO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSAwO1xuICAgIHRyeSB7XG5cbiAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgZW50cmllc0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbihmaWxlLm9wdGlvbnMuY29tcHJlc3Npb24sIG9wdGlvbnMuY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uT3B0aW9ucyA9IGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwgb3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZGlyID0gZmlsZS5kaXIsIGRhdGUgPSBmaWxlLmRhdGU7XG5cbiAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJmaWxlXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lIDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgIGRpciA6IGRpcixcbiAgICAgICAgICAgICAgICBkYXRlIDogZGF0ZSxcbiAgICAgICAgICAgICAgICBjb21tZW50IDogZmlsZS5jb21tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogZmlsZS51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBmaWxlLmRvc1Blcm1pc3Npb25zXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoemlwRmlsZVdvcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVudHJpZXNDb3VudCA9IGVudHJpZXNDb3VudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHppcEZpbGVXb3JrZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzwqB1c2VkIHdpdGhvdXTCoGBuZXdgLCBpdMKgYWRkcyBgbmV3YCBiZWZvcmXCoGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU1ppcCgpO1xuICAgIH1cblxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9O1xufVxuSlNaaXAucHJvdG90eXBlID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbkpTWmlwLnByb3RvdHlwZS5sb2FkQXN5bmMgPSByZXF1aXJlKCcuL2xvYWQnKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzIHZlcnNpb24sXG4vLyBhIHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpLnZlcnNpb24gZG9lc24ndCB3b3JrIHdpdGggd2VicGFjaywgc2VlICMzMjdcbkpTWmlwLnZlcnNpb24gPSBcIjMuMS41XCI7XG5cbkpTWmlwLmxvYWRBc3luYyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKU1ppcCgpLmxvYWRBc3luYyhjb250ZW50LCBvcHRpb25zKTtcbn07XG5cbkpTWmlwLmV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEpTWmlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKCcuL3ppcEVudHJpZXMnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod29ya2VyLnN0cmVhbUluZm8uY3JjMzIgIT09IHppcEVudHJ5LmRlY29tcHJlc3NlZC5jcmMzMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICB6aXBFbnRyaWVzLmxvYWQoZGF0YSk7XG4gICAgICAgIHJldHVybiB6aXBFbnRyaWVzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwRW50cmllcyldO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGVja0VudHJ5Q1JDMzIoZmlsZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZXNbaV07XG4gICAgICAgICAgICB6aXAuZmlsZShpbnB1dC5maWxlTmFtZVN0ciwgaW5wdXQuZGVjb21wcmVzc2VkLCB7XG4gICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBpbnB1dC5kYXRlLFxuICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW0ucGF1c2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX3Vwc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLCBSZWFkYWJsZSk7XG5cbi8qKlxuKiBBIG5vZGVqcyBzdHJlYW0gdXNpbmcgYSB3b3JrZXIgYXMgc291cmNlLlxuKiBAc2VlIHRoZSBTb3VyY2VXcmFwcGVyIGluIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbFxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHdyYXBwaW5nIHRoZSB3b3JrZXJcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG5vZGVqcyBzdHJlYW0gb3B0aW9uc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIoaGVscGVyLCBvcHRpb25zLCB1cGRhdGVDYikge1xuICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5faGVscGVyID0gaGVscGVyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGhlbHBlci5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnB1c2goZGF0YSkpIHtcbiAgICAgICAgICAgIHNlbGYuX2hlbHBlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHVwZGF0ZUNiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYihtZXRhKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSlcbiAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgfSk7XG59XG5cblxuTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBydW5uaW5nIGluIE5vZGVqcywgd2lsbCBiZSB1bmRlZmluZWQgaW4gYSBicm93c2VyLlxuICAgICAqIEluIGEgYnJvd3NlciwgYnJvd3NlcmlmeSB3b24ndCBpbmNsdWRlIHRoaXMgZmlsZSBhbmQgdGhlIHdob2xlIG1vZHVsZVxuICAgICAqIHdpbGwgYmUgcmVzb2x2ZWQgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAqL1xuICAgIGlzTm9kZSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgZnJvbSBhbiBleGlzdGluZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIG5ld0J1ZmZlckZyb206IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIC8vIFhYWCBXZSBjYW4ndCB1c2UgYEJ1ZmZlci5mcm9tYCB3aGljaCBjb21lcyBmcm9tIGBVaW50OEFycmF5LmZyb21gXG4gICAgICAgIC8vIGluIG5vZGVqcyB2NCAoPCB2LjQuNSkuIEl0J3Mgbm90IHRoZSBleHBlY3RlZCBpbXBsZW1lbnRhdGlvbiAoYW5kXG4gICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBzaWduYXR1cmUpLlxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84MDUzXG4gICAgICAgIC8vIEEgY29uZGl0aW9uIG9uIG5vZGVqcycgdmVyc2lvbiB3b24ndCBzb2x2ZSB0aGUgaXNzdWUgYXMgd2UgZG9uJ3RcbiAgICAgICAgLy8gY29udHJvbCB0aGUgQnVmZmVyIHBvbHlmaWxscyB0aGF0IG1heSBvciBtYXkgbm90IGJlIHVzZWQuXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jQnVmZmVyOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmFsbG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgQnVmZmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNCdWZmZXIgOiBmdW5jdGlvbihiKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgICB9LFxuXG4gICAgaXNTdHJlYW0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5wYXVzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIFppcE9iamVjdCA9IHJlcXVpcmUoJy4vemlwT2JqZWN0Jyk7XG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIik7XG5cblxuLyoqXG4gKiBBZGQgYSBmaWxlIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbE9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmaWxlLlxuICovXG52YXIgZmlsZUFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuXG4gICAgLypcbiAgICAgKiBDb3JyZWN0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgICB2YXIgbyA9IHV0aWxzLmV4dGVuZChvcmlnaW5hbE9wdGlvbnMgfHwge30sIGRlZmF1bHRzKTtcbiAgICBvLmRhdGUgPSBvLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAoby5jb21wcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gby5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygby51bml4UGVybWlzc2lvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgby51bml4UGVybWlzc2lvbnMgPSBwYXJzZUludChvLnVuaXhQZXJtaXNzaW9ucywgOCk7XG4gICAgfVxuXG4gICAgLy8gVU5YX0lGRElSICAwMDQwMDAwIHNlZSB6aXBpbmZvLmNcbiAgICBpZiAoby51bml4UGVybWlzc2lvbnMgJiYgKG8udW5peFBlcm1pc3Npb25zICYgMHg0MDAwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuICAgIC8vIEJpdCA0ICAgIERpcmVjdG9yeVxuICAgIGlmIChvLmRvc1Blcm1pc3Npb25zICYmIChvLmRvc1Blcm1pc3Npb25zICYgMHgwMDEwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyKSB7XG4gICAgICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG4gICAgfVxuICAgIGlmIChvLmNyZWF0ZUZvbGRlcnMgJiYgKHBhcmVudCA9IHBhcmVudEZvbGRlcihuYW1lKSkpIHtcbiAgICAgICAgZm9sZGVyQWRkLmNhbGwodGhpcywgcGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gZGF0YVR5cGUgPT09IFwic3RyaW5nXCIgJiYgby5iaW5hcnkgPT09IGZhbHNlICYmIG8uYmFzZTY0ID09PSBmYWxzZTtcbiAgICBpZiAoIW9yaWdpbmFsT3B0aW9ucyB8fCB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmJpbmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvLmJpbmFyeSA9ICFpc1VuaWNvZGVTdHJpbmc7XG4gICAgfVxuXG5cbiAgICB2YXIgaXNDb21wcmVzc2VkRW1wdHkgPSAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpICYmIGRhdGEudW5jb21wcmVzc2VkU2l6ZSA9PT0gMDtcblxuICAgIGlmIChpc0NvbXByZXNzZWRFbXB0eSB8fCBvLmRpciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICBvLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gXCJTVE9SRVwiO1xuICAgICAgICBkYXRhVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbnRlbnQgdG8gZml0LlxuICAgICAqL1xuXG4gICAgdmFyIHppcE9iamVjdENvbnRlbnQgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gbmV3IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihuYW1lLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gdXRpbHMucHJlcGFyZUNvbnRlbnQobmFtZSwgZGF0YSwgby5iaW5hcnksIG8ub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvLmJhc2U2NCk7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgemlwT2JqZWN0Q29udGVudCwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICAvKlxuICAgIFRPRE86IHdlIGNhbid0IHRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIHdlIGhhdmUgYXN5bmMgcHJvbWlzZXNcbiAgICAod2UgY2FuIGhhdmUgYSBwcm9taXNlIG9mIGEgRGF0ZSgpIGZvciBleGFtcGxlKSBidXQgcmV0dXJuaW5nIGFcbiAgICBwcm9taXNlIGlzIHVzZWxlc3MgYmVjYXVzZSBmaWxlKG5hbWUsIGRhdGEpIHJldHVybnMgdGhlIEpTWmlwXG4gICAgb2JqZWN0IGZvciBjaGFpbmluZy4gU2hvdWxkIHdlIGJyZWFrIHRoYXQgdG8gYWxsb3cgdGhlIHVzZXJcbiAgICB0byBjYXRjaCB0aGUgZXJyb3IgP1xuXG4gICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBPYmplY3RDb250ZW50KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgICAqL1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gKGxhc3RTbGFzaCA+IDApID8gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggd2l0aCBhIHNsYXNoIGF0IHRoZSBlbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAqL1xudmFyIGZvcmNlVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBDaGVjayB0aGUgbmFtZSBlbmRzIHdpdGggYSAvXG4gICAgaWYgKHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgKHN1YikgZm9sZGVyIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZm9sZGVyJ3MgbmFtZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2NyZWF0ZUZvbGRlcnNdIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHN1YlxuICogIGZvbGRlcnMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZvbGRlci5cbiAqL1xudmFyIGZvbGRlckFkZCA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUZvbGRlcnMpIHtcbiAgICBjcmVhdGVGb2xkZXJzID0gKHR5cGVvZiBjcmVhdGVGb2xkZXJzICE9PSAndW5kZWZpbmVkJykgPyBjcmVhdGVGb2xkZXJzIDogZGVmYXVsdHMuY3JlYXRlRm9sZGVycztcblxuICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG5cbiAgICAvLyBEb2VzIHRoaXMgZm9sZGVyIGFscmVhZHkgZXhpc3Q/XG4gICAgaWYgKCF0aGlzLmZpbGVzW25hbWVdKSB7XG4gICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCB7XG4gICAgICAgICAgICBkaXI6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBjcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlc1tuYW1lXTtcbn07XG5cbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGxvYWRBc3luY1xuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZW50cnkgYXQgdGhpcyBmb2xkZXIgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lLCByZWxhdGl2ZVBhdGgsIGZpbGU7XG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgemlwIGZpbGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzIGFuIGludGVybmFsIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIHN0cmVhbWVkIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0cyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb246IFwiU1RPUkVcIixcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IFwiRE9TXCIsXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICAgZW5jb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGVuY29kZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3B0cy50eXBlID0gb3B0cy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgb3B0cy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJlbmNlIG9mIGEgemlwIHNpZ25hdHVyZSAoNCBieXRlcykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgc2lnbmF0dXJlIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJlbmNlLCAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbGFzdEluZGV4T2ZTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBzaWduYXR1cmUgKDQgYnl0ZXMpIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjb21wYXJlIGl0IHdpdGggc2lnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVhZEFuZENoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGRhdGUuXG4gICAgICogQHJldHVybiB7RGF0ZX0gdGhlIGRhdGUuXG4gICAgICovXG4gICAgcmVhZERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9zdGltZSA9IHRoaXMucmVhZEludCg0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKFxuICAgICAgICAoKGRvc3RpbWUgPj4gMjUpICYgMHg3ZikgKyAxOTgwLCAvLyB5ZWFyXG4gICAgICAgICgoZG9zdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIC8vIG1vbnRoXG4gICAgICAgIChkb3N0aW1lID4+IDE2KSAmIDB4MWYsIC8vIGRheVxuICAgICAgICAoZG9zdGltZSA+PiAxMSkgJiAweDFmLCAvLyBob3VyXG4gICAgICAgIChkb3N0aW1lID4+IDUpICYgMHgzZiwgLy8gbWludXRlXG4gICAgICAgIChkb3N0aW1lICYgMHgxZikgPDwgMSkpOyAvLyBzZWNvbmRcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIE5vZGVCdWZmZXJSZWFkZXIoZGF0YSkge1xuICAgIFVpbnQ4QXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKE5vZGVCdWZmZXJSZWFkZXIsIFVpbnQ4QXJyYXlSZWFkZXIpO1xuXG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5Ob2RlQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZUJ1ZmZlclJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZSgnLi9EYXRhUmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFN0cmluZ1JlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuemVybyArIGkpO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKHNpZykgLSB0aGlzLnplcm87XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnID09PSBkYXRhO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAvLyB0aGlzIHdpbGwgd29yayBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRoZSBcIiYgMHhmZlwiIG1hc2suXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBVaW50OEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoVWludDhBcnJheVJlYWRlciwgQXJyYXlSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuVWludDhBcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIC8vIGluIElFMTAsIHdoZW4gdXNpbmcgc3ViYXJyYXkoaWR4LCBpZHgpLCB3ZSBnZXQgdGhlIGFycmF5IFsweDAwXSBpbnN0ZWFkIG9mIFtdLlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9BcnJheVJlYWRlcicpO1xudmFyIFN0cmluZ1JlYWRlciA9IHJlcXVpcmUoJy4vU3RyaW5nUmVhZGVyJyk7XG52YXIgTm9kZUJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4vTm9kZUJ1ZmZlclJlYWRlcicpO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWFkZXIgYWRhcHRlZCB0byB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIHRvIHJlYWQuXG4gKiBAcmV0dXJuIHtEYXRhUmVhZGVyfSB0aGUgZGF0YSByZWFkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1JlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5XCIsIGRhdGEpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLkxPQ0FMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAzXFx4MDRcIjtcbmV4cG9ydHMuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwMVxceDAyXCI7XG5leHBvcnRzLkNFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNVxceDA2XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSBcIlBLXFx4MDZcXHgwN1wiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDZcXHgwNlwiO1xuZXhwb3J0cy5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXHgwOFwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgY3JjMzIgb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENyYzMyUHJvYmUoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ3JjMzJQcm9iZVwiKTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgMCk7XG59XG51dGlscy5pbmhlcml0cyhDcmMzMlByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNyYzMyUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMuc3RyZWFtSW5mby5jcmMzMiA9IGNyYzMyKGNodW5rLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ3JjMzJQcm9iZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIG5hbWUgdXNlZCB0byBleHBvc2UgdGhlIGxlbmd0aFxuICovXG5mdW5jdGlvbiBEYXRhTGVuZ3RoUHJvYmUocHJvcE5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgcHJvcE5hbWUpO1xuICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKHByb3BOYW1lLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKERhdGFMZW5ndGhQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5EYXRhTGVuZ3RoUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKGNodW5rKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdID0gbGVuZ3RoICsgY2h1bmsuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFMZW5ndGhQcm9iZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLy8gdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjaHVua3Ncbi8vIFRPRE8gZXhwb3NlIHRoaXMgYXMgYSBwdWJsaWMgdmFyaWFibGVcbnZhciBERUZBVUxUX0JMT0NLX1NJWkUgPSAxNiAqIDEwMjQ7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCByZWFkcyBhIGNvbnRlbnQgYW5kIGVtaXRzIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlfSBkYXRhUCB0aGUgcHJvbWlzZSBvZiB0aGUgZGF0YSB0byBzcGxpdFxuICovXG5mdW5jdGlvbiBEYXRhV29ya2VyKGRhdGFQKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YVdvcmtlclwiKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG5cbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBkYXRhUC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YUlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLm1heCA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgc2VsZi50eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICBpZighc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdGlja0FuZFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRGF0YVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSkge1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIHRpY2sgYSBzY2hlZHVsZSBhbiBvdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrQW5kUmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGljaygpO1xuICAgIGlmKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHB1c2ggYSBjaHVuay5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IERFRkFVTFRfQkxPQ0tfU0laRTtcbiAgICB2YXIgZGF0YSA9IG51bGwsIG5leHRJbmRleCA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YnN0cmluZyh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCBwYXNzaW5nIGNodW5rcyB0byB0aGUgbmV4dCBvbmUuIFRoaXMgaXMgbGlrZVxuICogYSBub2RlanMgc3RyZWFtIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXMuIE9uIHRoZSBnb29kIHNpZGUgOlxuICogLSBpdCB3b3JrcyBvbiBJRSA2LTkgd2l0aG91dCBhbnkgaXNzdWUgLyBwb2x5ZmlsbFxuICogLSBpdCB3ZWlnaHRzIGxlc3MgdGhhbiB0aGUgZnVsbCBkZXBlbmRlbmNpZXMgYnVuZGxlZCB3aXRoIGJyb3dzZXJpZnlcbiAqIC0gaXQgZm9yd2FyZHMgZXJyb3JzIChubyBuZWVkIHRvIGRlY2xhcmUgYW4gZXJyb3IgaGFuZGxlciBFVkVSWVdIRVJFKVxuICpcbiAqIEEgY2h1bmsgaXMgYW4gb2JqZWN0IHdpdGggMiBhdHRyaWJ1dGVzIDogYG1ldGFgIGFuZCBgZGF0YWAuIFRoZSBmb3JtZXIgaXMgYW5cbiAqIG9iamVjdCBjb250YWluaW5nIGFueXRoaW5nIChgcGVyY2VudGAgZm9yIGV4YW1wbGUpLCBzZWUgZWFjaCB3b3JrZXIgZm9yIG1vcmVcbiAqIGRldGFpbHMuIFRoZSBsYXR0ZXIgaXMgdGhlIHJlYWwgZGF0YSAoU3RyaW5nLCBVaW50OEFycmF5LCBldGMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSAobWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gR2VuZXJpY1dvcmtlcihuYW1lKSB7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIHdvcmtlclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgdGhlIHdvcmtlcnMgY2hhaW5cbiAgICB0aGlzLnN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyBhbiBlcnJvciB3aGljaCBoYXBwZW5lZCB3aGVuIHRoZSB3b3JrZXIgd2FzIHBhdXNlZFxuICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHRvIGJlIG1lcmdlZCBieSB0aGlzIHdvcmtlciBpbnRvIHRoZSBnZW5lcmFsIG1ldGFkYXRhXG4gICAgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBzdHJ1Y3R1cmUgdXBkYXRlcyAocGlwZSksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAnZGF0YSc6W10sXG4gICAgICAgICdlbmQnOltdLFxuICAgICAgICAnZXJyb3InOltdXG4gICAgfTtcbiAgICAvLyB0aGUgcHJldmlvdXMgd29ya2VyLCBpZiBhbnlcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuR2VuZXJpY1dvcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHVzaCBhIGNodW5rIHRvIHRoZSBuZXh0IHdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwdXNoXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlbmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbSB3aXRoIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGUgdGhlIGVycm9yIHdoaWNoIGNhdXNlZCB0aGUgcHJlbWF0dXJlIGVuZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyIHdpdGggYW4gZXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcnJvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSB3b3JrZXJzIGNoYWluIGV4cGxvZGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYWluLFxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IHdpbGwgZ28gZG93bndhcmQgYnV0IHdlIGFsc28gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgIC8vIHdvcmtlcnMgdXB3YXJkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayBvbiBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW55IHJlZmVyZW5jZXMgd2hlbiBhIHdvcmtlciBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYW5VcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBUaGlzIHdpbGwgY2FsbCByZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggdGhlIHByb3ZpZGVkIGFyZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyB0aGUgYXJndW1lbnQgdG8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICAgKi9cbiAgICBlbWl0IDogZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzW25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdW2ldLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhaW4gYSB3b3JrZXIgd2l0aCBhbiBvdGhlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gbmV4dCB0aGUgd29ya2VyIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybiB7d29ya2VyfSB0aGUgbmV4dCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHBpcGUgOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5yZWdpc3RlclByZXZpb3VzKHRoaXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgcGlwZWAgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBVc2luZyBhbiBBUEkgd2l0aCBgcGlwZShuZXh0KWAgaXMgdmVyeSBlYXN5LlxuICAgICAqIEltcGxlbWVudGluZyB0aGUgQVBJIHdpdGggdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG5leHQgb25lIHJlZ2lzdGVyaW5nXG4gICAgICogYSBzb3VyY2UgaXMgZWFzaWVyLCBzZWUgdGhlIFppcEZpbGVXb3JrZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IHByZXZpb3VzIHRoZSBwcmV2aW91cyB3b3JrZXIsIHNlbmRpbmcgZXZlbnRzIHRvIHRoaXMgb25lXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmlvdXMgOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhcmluZyB0aGUgc3RyZWFtSW5mby4uLlxuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSBwcmV2aW91cy5zdHJlYW1JbmZvO1xuICAgICAgICAvLyAuLi4gYW5kIGFkZGluZyBvdXIgb3duIGJpdHNcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9ICBwcmV2aW91cztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcmV2aW91cy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbSBzbyBpdCBkb2Vzbid0IHNlbmQgZXZlbnRzIGFueW1vcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcGF1c2VkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgYSBwYXVzZWQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHJlc3VtZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIXRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHRydWUsIHRoZSB3b3JrZXIgdHJpZWQgdG8gcmVzdW1lIGJ1dCBmYWlsZWRcbiAgICAgICAgdmFyIHdpdGhFcnJvciA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuZ2VuZXJhdGVkRXJyb3IpO1xuICAgICAgICAgICAgd2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICF3aXRoRXJyb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGbHVzaCBhbnkgcmVtYWluaW5nIGJ5dGVzIGFzIHRoZSBzdHJlYW0gaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGZsdXNoIDogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGNodW5rLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQ2h1bmsgOiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEga2V5L3ZhbHVlIHRvIGJlIGFkZGVkIGluIHRoZSB3b3JrZXJzIGNoYWluIHN0cmVhbUluZm8gb25jZSBhY3RpdmF0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICB3aXRoU3RyZWFtSW5mbyA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGlzIHdvcmtlcidzIHN0cmVhbUluZm8gaW50byB0aGUgY2hhaW4ncyBzdHJlYW1JbmZvLlxuICAgICAqL1xuICAgIG1lcmdlU3RyZWFtSW5mbyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHRyYVN0cmVhbUluZm8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmZvW2tleV0gPSB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIHN0cmVhbSB0byBwcmV2ZW50IGZ1cnRoZXIgdXBkYXRlcyBvbiB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgY2FsbHMgdG8gcGlwZSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByZXR0eSBwcmludCB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lID0gXCJXb3JrZXIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQ29udmVydFdvcmtlciA9IHJlcXVpcmUoJy4vQ29udmVydFdvcmtlcicpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuLi9iYXNlNjQnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWxcIik7XG5cbnZhciBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gbnVsbDtcbmlmIChzdXBwb3J0Lm5vZGVzdHJlYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gcmVxdWlyZSgnLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXInKTtcbiAgICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIGZpbmFsIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBkYXRhLiBJZiB0aGUgdXNlciB3YW50cyBhIEJsb2IgZm9yXG4gKiBleGFtcGxlLCBpdCdzIGVhc2llciB0byB3b3JrIHdpdGggYW4gVThpbnRBcnJheSBhbmQgZmluYWxseSBkbyB0aGVcbiAqIEFycmF5QnVmZmVyL0Jsb2IgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lIG9mIHRoZSBmaW5hbCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gY29udGVudCB0aGUgY29udGVudCB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSBjb250ZW50IGluIHRoZSByaWdodCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVppcE91dHB1dCh0eXBlLCBjb250ZW50LCBtaW1lVHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCIgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm5ld0Jsb2IodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCBjb250ZW50KSwgbWltZVR5cGUpO1xuICAgICAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoY29udGVudCk7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKHR5cGUsIGNvbnRlbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBhcnJheSBvZiBkYXRhIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gZGF0YUFycmF5IHRoZSBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIGNodW5rcyB0byBjb25jYXRlbmF0ZVxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgY29uY2F0ZW5hdGVkIGRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFza2VkIHR5cGUgaXMgdW5zdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0ICh0eXBlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgaSwgaW5kZXggPSAwLCByZXMgPSBudWxsLCB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBkYXRhQXJyYXkuam9pbihcIlwiKTtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkYXRhQXJyYXkpO1xuICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChkYXRhQXJyYXlbaV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGRhdGFBcnJheSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIiAgKyB0eXBlICsgXCInXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICogY29tcGxldGUgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2FsbGJhY2sgYSBjYWxsYmFjayBjYWxsZWQgb24gZWFjaCB1cGRhdGUuIENhbGxlZFxuICogd2l0aCBvbmUgYXJnIDpcbiAqIC0gdGhlIG1ldGFkYXRhIGxpbmtlZCB0byB0aGUgdXBkYXRlIHJlY2VpdmVkLlxuICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlKGhlbHBlciwgdXBkYXRlQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IGhlbHBlci5faW50ZXJuYWxUeXBlLFxuICAgICAgICAgICAgcmVzdWx0VHlwZSA9IGhlbHBlci5fb3V0cHV0VHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gaGVscGVyLl9taW1lVHlwZTtcbiAgICAgICAgaGVscGVyXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FsbGJhY2sobWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1aaXBPdXRwdXQocmVzdWx0VHlwZSwgY29uY2F0KGNodW5rVHlwZSwgZGF0YUFycmF5KSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciB0byBlYXNpbHkgdXNlIHdvcmtlcnMgb3V0c2lkZSBvZiBKU1ppcC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXb3JrZXJ9IHdvcmtlciB0aGUgd29ya2VyIHRvIHdyYXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSB0eXBlIG9mIGRhdGEgZXhwZWN0ZWQgYnkgdGhlIHVzZVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbUhlbHBlcih3b3JrZXIsIG91dHB1dFR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGludGVybmFsVHlwZSA9IG91dHB1dFR5cGU7XG4gICAgc3dpdGNoKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInVpbnQ4YXJyYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gYnVpbGRlci5nZXRCbG9iKCdhcHBsaWNhdGlvbi96aXAnKS5zaXplID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudHJ5IHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSAhIXJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi91dGlscy9zdHJpbmdzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaT0wOyBpPDI1NjsgaSsrKSB7XG4gIF91dGY4bGVuW2ldID0gKGkgPj0gMjUyID8gNiA6IGkgPj0gMjQ4ID8gNSA6IGkgPj0gMjQwID8gNCA6IGkgPj0gMjI0ID8gMyA6IGkgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XT1fdXRmOGxlblsyNTRdPTE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICAgIH1cblxuICAgIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IEFycmF5KGJ1Zl9sZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnRcbiAgICBmb3IgKGk9MCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gICAgdmFyIHBvcztcblxuICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAgIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICAgIHBvcyA9IG1heC0xO1xuICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gICAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAgIC8vIHJldHVybiBtYXggdG9vLlxuICAgIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBzdHIsIGksIG91dCwgYywgY19sZW47XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gICAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gICAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuKjIpO1xuXG4gICAgZm9yIChvdXQ9MCwgaT0wOyBpPGxlbjspIHtcbiAgICAgICAgYyA9IGJ1ZltpKytdO1xuICAgICAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgICAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbi0xOyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgICAgICAgIGNfbGVuLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNocmlua0J1Zih1dGYxNmJ1Ziwgb3V0KVxuICAgIGlmICh1dGYxNmJ1Zi5sZW5ndGggIT09IG91dCkge1xuICAgICAgICBpZih1dGYxNmJ1Zi5zdWJhcnJheSkge1xuICAgICAgICAgICAgdXRmMTZidWYgPSB1dGYxNmJ1Zi5zdWJhcnJheSgwLCBvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmMTZidWYubGVuZ3RoID0gb3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRmMTZidWYpO1xuICAgIHJldHVybiB1dGlscy5hcHBseUZyb21DaGFyQ29kZSh1dGYxNmJ1Zik7XG59O1xuXG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGphdmFzY3JpcHQgc3RyaW5nIGludG8gYW4gYXJyYXkgKHR5cGVkIGlmIHBvc3NpYmxlKSBvZiBieXRlcyxcbiAqIFVURi04IGVuY29kZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhlbmNvZGUgPSBmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oc3RyLCBcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcyYnVmKHN0cik7XG59O1xuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgYnl0ZXMgYXJyYXkgKG9yIGEgcmVwcmVzZW50YXRpb24pIHJlcHJlc2VudGluZyBhbiBVVEYtOCBlbmNvZGVkXG4gKiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gYnVmIHRoZSBkYXRhIGRlIGRlY29kZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGRlY29kZSA9IGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnVmKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsIGJ1ZikudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICBidWYgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgYnVmKTtcblxuICAgIHJldHVybiBidWYyc3RyaW5nKGJ1Zik7XG59O1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGRlY29kZSB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcyBpbnRvIHN0cmluZyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOERlY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBkZWNvZGVcIik7XG4gICAgLy8gdGhlIGxhc3QgYnl0ZXMgaWYgYSBjaHVuayBkaWRuJ3QgZW5kIHdpdGggYSBjb21wbGV0ZSBjb2RlcG9pbnQuXG4gICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RGVjb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGRhdGEgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgY2h1bmsuZGF0YSk7XG5cbiAgICAvLyAxc3Qgc3RlcCwgcmUtdXNlIHdoYXQncyBsZWZ0IG9mIHRoZSBwcmV2aW91cyBjaHVua1xuICAgIGlmICh0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocHJldmlvdXNEYXRhLmxlbmd0aCArIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHRoaXMubGVmdE92ZXIsIDApO1xuICAgICAgICAgICAgZGF0YS5zZXQocHJldmlvdXNEYXRhLCB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWZ0T3Zlci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5leHRCb3VuZGFyeSA9IHV0Zjhib3JkZXIoZGF0YSk7XG4gICAgdmFyIHVzYWJsZURhdGEgPSBkYXRhO1xuICAgIGlmIChuZXh0Qm91bmRhcnkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnN1YmFycmF5KDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zdWJhcnJheShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnNsaWNlKDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zbGljZShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodXNhYmxlRGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZih0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLFxuICAgICAgICAgICAgbWV0YSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5VdGY4RGVjb2RlV29ya2VyID0gVXRmOERlY29kZVdvcmtlcjtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBlbmRjb2RlIHN0cmluZyBjaHVua3MgaW50byB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RW5jb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGVuY29kZVwiKTtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhFbmNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOEVuY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGVuY29kZShjaHVuay5kYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5leHBvcnRzLlV0ZjhFbmNvZGVXb3JrZXIgPSBVdGY4RW5jb2RlV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnY29yZS1qcy9saWJyYXJ5L2ZuL3NldC1pbW1lZGlhdGUnKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9ucyBhbmQgZnVuY3Rpb25zIHRoYXRcbiAqIGNhbiBiZSBvcHRpbWl6ZWQgYnkgdGhlIGJyb3dzZXIgSklUIGNvbXBpbGVyLlxuICovXG52YXIgYXJyYXlUb1N0cmluZ0hlbHBlciA9IHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgaW50IGludG8gYSBzdHJpbmcsIGNodW5rIGJ5IGNodW5rLlxuICAgICAqIFNlZSB0aGUgcGVyZm9ybWFuY2VzIG5vdGVzIG9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY2h1bmsgdGhlIGNodW5rIHNpemUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjaHVuayBpcyB0b28gYmlnIGZvciB0aGUgc3RhY2suXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaHVuazogZnVuY3Rpb24oYXJyYXksIHR5cGUsIGNodW5rKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgayA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgLy8gc2hvcnRjdXRcbiAgICAgICAgaWYgKGxlbiA8PSBjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zbGljZShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnN1YmFycmF5KGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbCBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgaXMgdGhlIG5haXZlIGltcGxlbWVudGF0aW9uLCB3aGljaCBnZW5lcmF0ZSBBIExPVCBvZiBpbnRlcm1lZGlhdGUgc3RyaW5nLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBldmVyeXRoaW5nIGVsc2UgZmFpbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNoYXI6IGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgdmFyIHJlc3VsdFN0ciA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfSxcbiAgICBhcHBseUNhbkJlVXNlZCA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBVaW50OEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB1aW50OGFycmF5IDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQudWludDhhcnJheSAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIG5vZGVqcyBCdWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBub2RlYnVmZmVyIDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZyhhcnJheSkge1xuICAgIC8vIFBlcmZvcm1hbmNlcyBub3RlcyA6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBpcyB0aGUgZmFzdGVzdCwgc2VlXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnZlcnRpbmctYS11aW50OGFycmF5LXRvLWEtc3RyaW5nLzJcbiAgICAvLyBidXQgdGhlIHN0YWNrIGlzIGxpbWl0ZWQgKGFuZCB3ZSBjYW4gZ2V0IGh1Z2UgYXJyYXlzICEpLlxuICAgIC8vXG4gICAgLy8gcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pOyBnZW5lcmF0ZSB0b28gbWFueSBzdHJpbmdzICFcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBpcyBpbnNwaXJlZCBieSBodHRwOi8vanNwZXJmLmNvbS9hcnJheWJ1ZmZlci10by1zdHJpbmctYXBwbHktcGVyZm9ybWFuY2UvMlxuICAgIC8vIFRPRE8gOiB3ZSBub3cgaGF2ZSB3b3JrZXJzIHRoYXQgc3BsaXQgdGhlIHdvcmsuIERvIHdlIHN0aWxsIG5lZWQgdGhhdCA/XG4gICAgdmFyIGNodW5rID0gNjU1MzYsXG4gICAgICAgIHR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihhcnJheSksXG4gICAgICAgIGNhblVzZUFwcGx5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50OGFycmF5XCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQubm9kZWJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoY2FuVXNlQXBwbHkpIHtcbiAgICAgICAgd2hpbGUgKGNodW5rID4gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNodW5rKGFycmF5LCB0eXBlLCBjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBNYXRoLmZsb29yKGNodW5rIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBhcHBseSBvciBjaHVuayBlcnJvciA6IHNsb3cgYW5kIHBhaW5mdWwgYWxnb3JpdGhtXG4gICAgLy8gZGVmYXVsdCBicm93c2VyIG9uIGFuZHJvaWQgNC4qXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaGFyKGFycmF5KTtcbn1cblxuZXhwb3J0cy5hcHBseUZyb21DaGFyQ29kZSA9IGFycmF5TGlrZVRvU3RyaW5nO1xuXG5cbi8qKlxuICogQ29weSB0aGUgZGF0YSBmcm9tIGFuIGFycmF5LWxpa2UgdG8gYW4gb3RoZXIgYXJyYXktbGlrZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5RnJvbSB0aGUgb3JpZ2luIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlUbyB0aGUgZGVzdGluYXRpb24gYXJyYXkgd2hpY2ggd2lsbCBiZSBtdXRhdGVkLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGRlc3RpbmF0aW9uIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5TGlrZShhcnJheUZyb20sIGFycmF5VG8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5RnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVRvW2ldID0gYXJyYXlGcm9tW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUbztcbn1cblxuLy8gYSBtYXRyaXggY29udGFpbmluZyBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtIGV2ZXJ5dGhpbmcgaW50byBldmVyeXRoaW5nLlxudmFyIHRyYW5zZm9ybSA9IHt9O1xuXG4vLyBzdHJpbmcgdG8gP1xudHJhbnNmb3JtW1wic3RyaW5nXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJzdHJpbmdcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5YnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcImFycmF5YnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH0sXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UobmV3IFVpbnQ4QXJyYXkoaW5wdXQpLCBuZXcgQXJyYXkoaW5wdXQuYnl0ZUxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBpZGVudGl0eSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH1cbn07XG5cbi8vIHVpbnQ4YXJyYXkgdG8gP1xudHJhbnNmb3JtW1widWludDhhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gbm9kZWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGlucHV0IGludG8gYW55IHR5cGUuXG4gKiBUaGUgc3VwcG9ydGVkIG91dHB1dCB0eXBlIGFyZSA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBub2RlYnVmZmVyLlxuICogSWYgbm8gb3V0cHV0IHR5cGUgaXMgc3BlY2lmaWVkLCB0aGUgdW5tb2RpZmllZCBpbnB1dCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIG91dHB1dCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGlucHV0IHRoZSBpbnB1dCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIG91dHB1dCB0eXBlLlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgZXRjXG4gICAgICAgIC8vIGFuIGVtcHR5IHN0cmluZyB3b24ndCBoYXJtLlxuICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KG91dHB1dFR5cGUpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihpbnB1dCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVtpbnB1dFR5cGVdW291dHB1dFR5cGVdKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogVGhlIHR5cGUgd2lsbCBiZSBpbiBhIGZvcm1hdCB2YWxpZCBmb3IgSlNaaXAudXRpbHMudHJhbnNmb3JtVG8gOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQgdG8gaWRlbnRpZnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSAobG93ZXJjYXNlKSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0cy5nZXRUeXBlT2YgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBub2RlanNVdGlscy5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFwibm9kZWJ1ZmZlclwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5ICYmIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJ1aW50OGFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LmFycmF5YnVmZmVyICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgdHlwZS5cbiAqL1xuZXhwb3J0cy5jaGVja1N1cHBvcnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLk1BWF9WQUxVRV8xNkJJVFMgPSA2NTUzNTtcbmV4cG9ydHMuTUFYX1ZBTFVFXzMyQklUUyA9IC0xOyAvLyB3ZWxsLCBcIlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcIiBpcyBwYXJzZWQgYXMgLTFcblxuLyoqXG4gKiBQcmV0dGlmeSBhIHN0cmluZyByZWFkIGFzIGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBwcmV0dGlmeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gYSBwcmV0dHkgc3RyaW5nLlxuICovXG5leHBvcnRzLnByZXR0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciByZXMgPSAnJyxcbiAgICAgICAgY29kZSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgKHN0ciB8fCBcIlwiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJlcyArPSAnXFxcXHgnICsgKGNvZGUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYXN5bmNocm9ub3VzbHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gZ2l2ZSB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydHMuZGVsYXkgPSBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgc2VsZikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYgfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgYSBwcm90b3R5cGUgd2l0aCBhbiBvdGhlciwgd2l0aG91dCBjYWxsaW5nIGEgY29uc3RydWN0b3Igd2l0aFxuICogc2lkZSBlZmZlY3RzLiBJbnNwaXJlZCBieSBub2RlanMnIGB1dGlscy5pbmhlcml0c2BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgdGhlIGNvbnN0cnVjdG9yIHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ3RvciB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHRvIHVzZVxuICovXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIHZhciBPYmogPSBmdW5jdGlvbigpIHt9O1xuICAgIE9iai5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IE9iaigpO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0aGUgb2JqZWN0cyBwYXNzZWQgYXMgcGFyYW1ldGVycyBpbnRvIGEgbmV3IG9uZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgQWxsIG9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRoIHRoZSBkYXRhIG9mIHRoZSBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpLCBhdHRyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgLy8gYXJndW1lbnRzIGlzIG5vdCBlbnVtZXJhYmxlIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgZm9yIChhdHRyIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiB0eXBlb2YgcmVzdWx0W2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2F0dHJdID0gYXJndW1lbnRzW2ldW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhcmJpdHJhcnkgY29udGVudCBpbnRvIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSBmb3IgdGhlIGNvbnRlbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YSB0aGUgY29udGVudCB0byBwcm9jZXNzLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSB0cnVlIGlmIHRoZSBjb250ZW50IGlzIG5vdCBhbiB1bmljb2RlIHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpc09wdGltaXplZEJpbmFyeVN0cmluZyB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBvbmx5IGhhcyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0Jhc2U2NCB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBpcyBlbmNvZGVkIHdpdGggYmFzZTY0LlxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIGluIGEgZm9ybWF0IHVzYWJsZSBieSBKU1ppcC5cbiAqL1xuZXhwb3J0cy5wcmVwYXJlQ29udGVudCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0RGF0YSwgaXNCaW5hcnksIGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nLCBpc0Jhc2U2NCkge1xuXG4gICAgLy8gaWYgaW5wdXREYXRhIGlzIGFscmVhZHkgYSBwcm9taXNlLCB0aGlzIGZsYXR0ZW4gaXQuXG4gICAgdmFyIHByb21pc2UgPSBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoaW5wdXREYXRhKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaXNCbG9iID0gc3VwcG9ydC5ibG9iICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBbJ1tvYmplY3QgRmlsZV0nLCAnW29iamVjdCBCbG9iXSddLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSAhPT0gLTEpO1xuXG4gICAgICAgIGlmIChpc0Jsb2IgJiYgdHlwZW9mIEZpbGVSZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGFUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiQ2FuJ3QgcmVhZCB0aGUgZGF0YSBvZiAnXCIgKyBuYW1lICsgXCInLiBJcyBpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gYSBzdXBwb3J0ZWQgSmF2YVNjcmlwdCB0eXBlIChTdHJpbmcsIEJsb2IsIEFycmF5QnVmZmVyLCBldGMpID9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIDogaXQncyB3YXkgZWFzaWVyIHRvIHdvcmsgd2l0aCBVaW50OEFycmF5IHRoYW4gd2l0aCBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgICAgZGF0YSA9IGV4cG9ydHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCB3aXRoIGEgMHhGRiBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdGhhdCB0aGlzIGlzIGEgY29ycmVjdCBcImJpbmFyeSBzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyaW5nMmJpbmFyeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoJy4vcmVhZGVyL3JlYWRlckZvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHNpZyA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKCcuL3ppcEVudHJ5Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSBcIiArIFwiKFwiICsgdXRpbHMucHJldHR5KHNpZ25hdHVyZSkgKyBcIiwgZXhwZWN0ZWQgXCIgKyB1dGlscy5wcmV0dHkoZXhwZWN0ZWRTaWduYXR1cmUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGlzIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNrZWRJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBoZXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTaWduYXR1cmU6IGZ1bmN0aW9uKGFza2VkSW5kZXgsIGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoYXNrZWRJbmRleCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2lnbmF0dXJlID09PSBleHBlY3RlZFNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEJsb2NrRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIHRoaXMuemlwQ29tbWVudExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIC8vIHdhcm5pbmcgOiB0aGUgZW5jb2RpbmcgZGVwZW5kcyBvZiB0aGUgc3lzdGVtIGxvY2FsZVxuICAgICAgICAvLyBPbiBhIGxpbnV4IG1hY2hpbmUgd2l0aCBMQU5HPWVuX1VTLnV0ZjgsIHRoaXMgZmllbGQgaXMgdXRmOCBlbmNvZGVkLlxuICAgICAgICAvLyBPbiBhIHdpbmRvd3MgbWFjaGluZSwgdGhpcyBmaWVsZCBpcyBlbmNvZGVkIHdpdGggdGhlIGxvY2FsaXplZCB3aW5kb3dzIGNvZGUgcGFnZS5cbiAgICAgICAgdmFyIHppcENvbW1lbnQgPSB0aGlzLnJlYWRlci5yZWFkRGF0YSh0aGlzLnppcENvbW1lbnRMZW5ndGgpO1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIC8vIFRvIGdldCBjb25zaXN0ZW50IGJlaGF2aW9yIHdpdGggdGhlIGdlbmVyYXRpb24gcGFydCwgd2Ugd2lsbCBhc3N1bWUgdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIHV0ZjggZW5jb2RlZCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGRlY29kZUNvbnRlbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHppcENvbW1lbnQpO1xuICAgICAgICB0aGlzLnppcENvbW1lbnQgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGRlY29kZUNvbnRlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICogTm90IG1lcmdlZCB3aXRoIHRoZSBtZXRob2QgcmVhZEVuZE9mQ2VudHJhbCA6XG4gICAgICogVGhlIGVuZCBvZiBjZW50cmFsIGNhbiBjb2V4aXN0IHdpdGggaXRzIFppcDY0IGJyb3RoZXIsXG4gICAgICogSSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIHdyb25nIG51bWJlciBvZiBieXRlcyAhXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMucmVhZGVyLnNraXAoNCk7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk1hZGVCeSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcblxuICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGV4dHJhRGF0YVNpemUgPSB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSAtIDQ0LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZXh0cmFEYXRhU2l6ZSkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gdGhpcy5yZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yLlxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2tzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aS12b2x1bWVzIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgZmlsZXMsIGJhc2VkIG9uIHRoZSBvZmZzZXQgcmVhZCBpbiB0aGUgY2VudHJhbCBwYXJ0LlxuICAgICAqL1xuICAgIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGZpbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGZpbGUubG9jYWxIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuICAgICAgICAgICAgZmlsZS5yZWFkTG9jYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlVVRGOCgpO1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzQXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWxlO1xuXG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICBmaWxlID0gbmV3IFppcEVudHJ5KHtcbiAgICAgICAgICAgICAgICB6aXA2NDogdGhpcy56aXA2NFxuICAgICAgICAgICAgfSwgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICBmaWxlLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSAwICYmIHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0ZWQgc29tZSByZWNvcmRzIGJ1dCBjb3VsZG4ndCBmaW5kIEFOWS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlYWxseSBzdXNwaWNpb3VzLCBhcyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBzb21lIHJlY29yZHMgYnV0IG5vdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGlzIHdyb25nIGJ1dCB3ZSBnb3Qgc29tZXRoaW5nIGZvciB0aGUgdXNlcjogbm8gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJleHBlY3RlZFwiLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzLCBcInJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdFwiLCB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgYSB0cnVuY2F0ZWQgemlwIG9yIGNvbXBsZXRlIGdhcmJhZ2UuXG4gICAgICAgICAgICAvLyBBIFwiTE9DQUxfRklMRV9IRUFERVJcIiBpcyBub3QgcmVxdWlyZWQgYXQgdGhlIGJlZ2lubmluZyAoYXV0b1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlibGUgemlwIGZvciBleGFtcGxlKSBidXQgaXQgY2FuIGdpdmUgYSBnb29kIGhpbnQuXG4gICAgICAgICAgICAvLyBJZiBhbiBhamF4IHJlcXVlc3Qgd2FzIHVzZWQgd2l0aG91dCByZXNwb25zZVR5cGUsIHdlIHdpbGwgYWxzb1xuICAgICAgICAgICAgLy8gZ2V0IHVucmVhZGFibGUgZGF0YS5cbiAgICAgICAgICAgIHZhciBpc0dhcmJhZ2UgPSAhdGhpcy5pc1NpZ25hdHVyZSgwLCBzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNHYXJiYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgOiBpcyB0aGlzIGEgemlwIGZpbGUgPyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFTY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB0aGUgemlwNjQgRU9DRCByZWNvcmRcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NpZ25hdHVyZSh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIsIHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IG5vdCB3aGVyZSBleHBlY3RlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIGNyYzMyZm4gPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb25zJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xudmFyIGZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGNvbXByZXNzaW9ucykge1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9ucy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb25zIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IFwiICsgXCIoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXByZXNzaW9uID0gZmluZENvbXByZXNzaW9uKHRoaXMuY29tcHJlc3Npb25NZXRob2QpO1xuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IG51bGwpIHsgLy8gbm8gY29tcHJlc3Npb24gZm91bmRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIiArIHV0aWxzLnByZXR0eSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKSArIFwiIHVua25vd24gKGlubmVyIGZpbGUgOiBcIiArIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMuZmlsZU5hbWUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gbmV3IENvbXByZXNzZWRPYmplY3QodGhpcy5jb21wcmVzc2VkU2l6ZSwgdGhpcy51bmNvbXByZXNzZWRTaXplLCB0aGlzLmNyYzMyLCBjb21wcmVzc2lvbiwgcmVhZGVyLnJlYWREYXRhKHRoaXMuY29tcHJlc3NlZFNpemUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB0aGlzLnZlcnNpb25NYWRlQnkgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgcmVhZGVyLnNraXAoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmJpdEZsYWcgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICB0aGlzLmRhdGUgPSByZWFkZXIucmVhZERhdGUoKTtcbiAgICAgICAgdGhpcy5jcmMzMiA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB2YXIgZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50TGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IHJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aWxsIGJlIHJlYWQgaW4gdGhlIGxvY2FsIHBhcnQsIHNlZSB0aGUgY29tbWVudHMgdGhlcmVcbiAgICAgICAgcmVhZGVyLnNraXAoZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICB0aGlzLnJlYWRFeHRyYUZpZWxkcyhyZWFkZXIpO1xuICAgICAgICB0aGlzLnBhcnNlWklQNjRFeHRyYUZpZWxkKHJlYWRlcik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnQgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlQ29tbWVudExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgYW5kIGdldCB0aGUgdW5peC9kb3MgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdmFyIG1hZGVCeSA9IHRoaXMudmVyc2lvbk1hZGVCeSA+PiA4O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIERPUyBkaXJlY3RvcnkgZmxhZyBzZXQuXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGl0IGluIHRoZSBET1MgYW5kIFVOSVggcGVybWlzc2lvbnNcbiAgICAgICAgLy8gYnV0IHNvbWUgdW5rbm93biBwbGF0Zm9ybSBjb3VsZCBzZXQgaXQgYXMgYSBjb21wYXRpYmlsaXR5IGZsYWcuXG4gICAgICAgIHRoaXMuZGlyID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgwMDEwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9ET1MpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IDYgYml0cyAoMCB0byA1KVxuICAgICAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4M0Y7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfVU5JWCkge1xuICAgICAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSAodGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAgICAgICAgIC8vIHRoZSBvY3RhbCBwZXJtaXNzaW9ucyBhcmUgaW4gKHRoaXMudW5peFBlcm1pc3Npb25zICYgMHgwMUZGKS50b1N0cmluZyg4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWwgc2FmZSA6IGlmIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC8gaXQgcHJvYmFibHkgbWVhbnMgYSBmb2xkZXJcbiAgICAgICAgaWYgKCF0aGlzLmRpciAmJiB0aGlzLmZpbGVOYW1lU3RyLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLmRpciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIFpJUDY0IGV4dHJhIGZpZWxkIGFuZCBtZXJnZSB0aGUgaW5mbyBpbiB0aGUgY3VycmVudCBaaXBFbnRyeS5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwYXJzZVpJUDY0RXh0cmFGaWVsZDogZnVuY3Rpb24ocmVhZGVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBiZSBzb21ldGhpbmcsIHByZXBhcmluZyB0aGUgZXh0cmEgcmVhZGVyXG4gICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0udmFsdWUpO1xuXG4gICAgICAgIC8vIEkgcmVhbGx5IGhvcGUgdGhhdCB0aGVzZSA2NGJpdHMgaW50ZWdlciBjYW4gZml0IGluIDMyIGJpdHMgaW50ZWdlciwgYmVjYXVzZSBqc1xuICAgICAgICAvLyB3b24ndCBsZXQgdXMgaGF2ZSBtb3JlLlxuICAgICAgICBpZiAodGhpcy51bmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5pbmRleCArIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlYWRlci5pbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLnNldEltbWVkaWF0ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuMy4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG4gIHZhciBkaWN0O1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0ID0gZGljdGlvbmFyeTtcbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbmZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcbiIsIi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbnZhciBTVFJfQVBQTFlfT0sgPSB0cnVlO1xudmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFsgMCBdKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX09LID0gZmFsc2U7IH1cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gdXNlIGZhbGxiYWNrIGZvciBiaWcgYXJyYXlzIHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93XG4gIGlmIChsZW4gPCA2NTUzNykge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSByZXF1aXJlKCdpbW1lZGlhdGUnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSU5URVJOQUwpO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcbiAgICB1bndyYXAocHJvbWlzZSwgcmVzb2x2ZXIsIHRoaXMub3V0Y29tZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcbmZ1bmN0aW9uIFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkO1xuICAgIHRoaXMuY2FsbEZ1bGZpbGxlZCA9IHRoaXMub3RoZXJDYWxsRnVsZmlsbGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQ7XG4gICAgdGhpcy5jYWxsUmVqZWN0ZWQgPSB0aGlzLm90aGVyQ2FsbFJlamVjdGVkO1xuICB9XG59XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVzb2x2ZSh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uRnVsZmlsbGVkLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vblJlamVjdGVkLCB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB1bndyYXAocHJvbWlzZSwgZnVuYywgdmFsdWUpIHtcbiAgaW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlKTtcbiAgICB9XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBwcm9taXNlKSB7XG4gICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignQ2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuaGFuZGxlcnMucmVzb2x2ZSA9IGZ1bmN0aW9uIChzZWxmLCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZ2V0VGhlbiwgdmFsdWUpO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBoYW5kbGVycy5yZWplY3Qoc2VsZiwgcmVzdWx0LnZhbHVlKTtcbiAgfVxuICB2YXIgdGhlbmFibGUgPSByZXN1bHQudmFsdWU7XG5cbiAgaWYgKHRoZW5hYmxlKSB7XG4gICAgc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnN0YXRlID0gRlVMRklMTEVEO1xuICAgIHNlbGYub3V0Y29tZSA9IHZhbHVlO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIHNlbGYucXVldWVbaV0uY2FsbEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbmhhbmRsZXJzLnJlamVjdCA9IGZ1bmN0aW9uIChzZWxmLCBlcnJvcikge1xuICBzZWxmLnN0YXRlID0gUkVKRUNURUQ7XG4gIHNlbGYub3V0Y29tZSA9IGVycm9yO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBzZWxmLnF1ZXVlW2ldLmNhbGxSZWplY3RlZChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhY2Nlc3MgdGhlIGFjY2Vzc29yIG9uY2UgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWNcbiAgdmFyIHRoZW4gPSBvYmogJiYgb2JqLnRoZW47XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcHlUaGVuKCkge1xuICAgICAgdGhlbi5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpIHtcbiAgLy8gRWl0aGVyIGZ1bGZpbGwsIHJlamVjdCBvciByZWplY3Qgd2l0aCBlcnJvclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uRXJyb3IodmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVqZWN0KHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VjY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvVW53cmFwKCkge1xuICAgIHRoZW5hYmxlKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godHJ5VG9VbndyYXApO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIG9uRXJyb3IocmVzdWx0LnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYXRjaChmdW5jLCB2YWx1ZSkge1xuICB2YXIgb3V0ID0ge307XG4gIHRyeSB7XG4gICAgb3V0LnZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgb3V0LnN0YXR1cyA9ICdzdWNjZXNzJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dC5zdGF0dXMgPSAnZXJyb3InO1xuICAgIG91dC52YWx1ZSA9IGU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgdGhpcyhJTlRFUk5BTCksIHZhbHVlKTtcbn1cblxuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIHJlc29sdmVkID0gMDtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFsbFJlc29sdmVyKGl0ZXJhYmxlW2ldLCBpKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gYWxsUmVzb2x2ZXIodmFsdWUsIGkpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZUZyb21BbGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbUFsbChvdXRWYWx1ZSkge1xuICAgICAgdmFsdWVzW2ldID0gb3V0VmFsdWU7XG4gICAgICBpZiAoKytyZXNvbHZlZCA9PT0gbGVuICYmICFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzb2x2ZXIoaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiByZXNvbHZlcih2YWx1ZSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHJvb3Q7XG4gIH1cbiAgb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICBvYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTtcblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LCBBbGwgcmlnaHRzIHJlc2VydmVkLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0dsb2JhbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgdmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKSA/IGV4cG9ydHMgOiBudWxsO1xuICB2YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSkgPyBtb2R1bGUgOiBudWxsO1xuICB2YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcbiAgdmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuICB2YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG4gIHZhciBtb2R1bGVFeHBvcnRzID0gKGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykgPyBmcmVlRXhwb3J0cyA6IG51bGw7XG4gIHZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICB2YXIgUnggPSB7XG4gICAgaW50ZXJuYWxzOiB7fSxcbiAgICBjb25maWc6IHtcbiAgICAgIFByb21pc2U6IHJvb3QuUHJvbWlzZVxuICAgIH0sXG4gICAgaGVscGVyczogeyB9XG4gIH07XG5cbiAgLy8gRGVmYXVsdHNcbiAgdmFyIG5vb3AgPSBSeC5oZWxwZXJzLm5vb3AgPSBmdW5jdGlvbiAoKSB7IH0sXG4gICAgaWRlbnRpdHkgPSBSeC5oZWxwZXJzLmlkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAgZGVmYXVsdE5vdyA9IFJ4LmhlbHBlcnMuZGVmYXVsdE5vdyA9IERhdGUubm93LFxuICAgIGRlZmF1bHRDb21wYXJlciA9IFJ4LmhlbHBlcnMuZGVmYXVsdENvbXBhcmVyID0gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGlzRXF1YWwoeCwgeSk7IH0sXG4gICAgZGVmYXVsdFN1YkNvbXBhcmVyID0gUnguaGVscGVycy5kZWZhdWx0U3ViQ29tcGFyZXIgPSBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA+IHkgPyAxIDogKHggPCB5ID8gLTEgOiAwKTsgfSxcbiAgICBkZWZhdWx0S2V5U2VyaWFsaXplciA9IFJ4LmhlbHBlcnMuZGVmYXVsdEtleVNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9LFxuICAgIGRlZmF1bHRFcnJvciA9IFJ4LmhlbHBlcnMuZGVmYXVsdEVycm9yID0gZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgaXNQcm9taXNlID0gUnguaGVscGVycy5pc1Byb21pc2UgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gISFwICYmIHR5cGVvZiBwLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nOyB9LFxuICAgIGlzRnVuY3Rpb24gPSBSeC5oZWxwZXJzLmlzRnVuY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICB2YXIgaXNGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAvLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgIGlmIChpc0ZuKC94LykpIHtcbiAgICAgICAgaXNGbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0ZuO1xuICAgIH0oKSk7XG5cbiAgZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHsgZm9yKHZhciBhID0gW10sIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgYS5wdXNoKGFycltpXSk7IH0gcmV0dXJuIGE7fVxuXG4gIHZhciBlcnJvck9iaiA9IHtlOiB7fX07XG4gIFxuICBmdW5jdGlvbiB0cnlDYXRjaGVyR2VuKHRyeUNhdGNoVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyeUNhdGNoID0gUnguaW50ZXJuYWxzLnRyeUNhdGNoID0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZuIG11c3QgYmUgYSBmdW5jdGlvbicpOyB9XG4gICAgcmV0dXJuIHRyeUNhdGNoZXJHZW4oZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgIHRocm93IGU7XG4gIH1cblxuICBSeC5jb25maWcubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuICB2YXIgaGFzU3RhY2tzID0gZmFsc2UsIHN0YWNrcyA9IHRyeUNhdGNoKGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCk7IH0pKCk7XG4gIGhhc1N0YWNrcyA9ICEhc3RhY2tzLmUgJiYgISFzdGFja3MuZS5zdGFjaztcblxuICAvLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWQgYnkgUnhKU1xuICB2YXIgclN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCksIHJGaWxlTmFtZTtcblxuICB2YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSAnRnJvbSBwcmV2aW91cyBldmVudDonO1xuXG4gIGZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgb2JzZXJ2YWJsZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFJ4SlNcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBvYnNlcnZhYmxlYC5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIG9ic2VydmFibGUuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFjayAmJlxuICAgICAgICBlcnJvci5zdGFjay5pbmRleE9mKFNUQUNLX0pVTVBfU0VQQVJBVE9SKSA9PT0gLTFcbiAgICApIHtcbiAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgIGZvciAodmFyIG8gPSBvYnNlcnZhYmxlOyAhIW87IG8gPSBvLnNvdXJjZSkge1xuICAgICAgICBpZiAoby5zdGFjaykge1xuICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KG8uc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKCdcXG4nICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyAnXFxuJyk7XG4gICAgICBlcnJvci5zdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KCdcXG4nKSwgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdLCBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSByRmlsZU5hbWUgJiZcbiAgICAgIGxpbmVOdW1iZXIgPj0gclN0YXJ0aW5nTGluZSAmJlxuICAgICAgbGluZU51bWJlciA8PSByRW5kaW5nTGluZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZignKG1vZHVsZS5qczonKSAhPT0gLTEgfHxcbiAgICAgIHN0YWNrTGluZS5pbmRleE9mKCcobm9kZS5qczonKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykgeyByZXR1cm47IH1cblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKCdAJykgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7IHJldHVybjsgfVxuXG4gICAgICByRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6ICdhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKSdcbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7IHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldOyB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiAnYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXInXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MikgeyByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTsgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogJ2Z1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXInXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MykgeyByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTsgfVxuICB9XG5cbiAgdmFyIEVtcHR5RXJyb3IgPSBSeC5FbXB0eUVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1NlcXVlbmNlIGNvbnRhaW5zIG5vIGVsZW1lbnRzLic7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgRW1wdHlFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIEVtcHR5RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRW1wdHlFcnJvcic7XG5cbiAgdmFyIE9iamVjdERpc3Bvc2VkRXJyb3IgPSBSeC5PYmplY3REaXNwb3NlZEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ09iamVjdCBoYXMgYmVlbiBkaXNwb3NlZCc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgT2JqZWN0RGlzcG9zZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIE9iamVjdERpc3Bvc2VkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnT2JqZWN0RGlzcG9zZWRFcnJvcic7XG5cbiAgdmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gUnguQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ0FyZ3VtZW50IG91dCBvZiByYW5nZSc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvci5wcm90b3R5cGUubmFtZSA9ICdBcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG5cbiAgdmFyIE5vdFN1cHBvcnRlZEVycm9yID0gUnguTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIE5vdFN1cHBvcnRlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgTm90U3VwcG9ydGVkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnTm90U3VwcG9ydGVkRXJyb3InO1xuXG4gIHZhciBOb3RJbXBsZW1lbnRlZEVycm9yID0gUnguTm90SW1wbGVtZW50ZWRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhpcyBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBOb3RJbXBsZW1lbnRlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgTm90SW1wbGVtZW50ZWRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdOb3RJbXBsZW1lbnRlZEVycm9yJztcblxuICB2YXIgbm90SW1wbGVtZW50ZWQgPSBSeC5oZWxwZXJzLm5vdEltcGxlbWVudGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH07XG5cbiAgdmFyIG5vdFN1cHBvcnRlZCA9IFJ4LmhlbHBlcnMubm90U3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICB9O1xuXG4gIC8vIFNoaW0gaW4gaXRlcmF0b3Igc3VwcG9ydFxuICB2YXIgJGl0ZXJhdG9yJCA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcikgfHxcbiAgICAnX2VzNnNoaW1faXRlcmF0b3JfJztcbiAgLy8gQnVnIGZvciBtb3ppbGxhIHZlcnNpb25cbiAgaWYgKHJvb3QuU2V0ICYmIHR5cGVvZiBuZXcgcm9vdC5TZXQoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgJGl0ZXJhdG9yJCA9ICdAQGl0ZXJhdG9yJztcbiAgfVxuXG4gIHZhciBkb25lRW51bWVyYXRvciA9IFJ4LmRvbmVFbnVtZXJhdG9yID0geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cbiAgdmFyIGlzSXRlcmFibGUgPSBSeC5oZWxwZXJzLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIG9bJGl0ZXJhdG9yJF0gIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgaXNBcnJheUxpa2UgPSBSeC5oZWxwZXJzLmlzQXJyYXlMaWtlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBvLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFJ4LmhlbHBlcnMuaXRlcmF0b3IgPSAkaXRlcmF0b3IkO1xuXG4gIHZhciBiaW5kQ2FsbGJhY2sgPSBSeC5pbnRlcm5hbHMuYmluZENhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzQXJnID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZnVuYzsgfVxuICAgIHN3aXRjaChhcmdDb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKVxuICAgICAgICB9O1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmcpO1xuICAgICAgICB9O1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIGRvbnRFbnVtcyA9IFsndG9TdHJpbmcnLFxuICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgJ3ZhbHVlT2YnLFxuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ2NvbnN0cnVjdG9yJ10sXG4gIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXMgfHwgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGhhc0RvbnRFbnVtQnVnID0gISh7IHRvU3RyaW5nOiBudWxsIH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuICAgICAgICBkb250RW51bXMgPSBbXG4gICAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICAgICAgXSxcbiAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgcHJvcCwgaTtcblxuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSgpKTtcblxuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9PSBvdGhMZW5ndGggJiYgIWlzTG9vc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoLCBrZXk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB2YXIgc2tpcEN0b3IgPSBpc0xvb3NlO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSA6IHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAoIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChvYmpDdG9yICE9PSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gK29iamVjdCA9PT0gK290aGVyO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgcmV0dXJuIChvYmplY3QgIT09ICtvYmplY3QpID9cbiAgICAgICAgb3RoZXIgIT09ICtvdGhlciA6XG4gICAgICAgIG9iamVjdCA9PT0gK290aGVyO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSAob3RoZXIgKyAnJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaXNPYmplY3QgPSBSeC5pbnRlcm5hbHMuaXNPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcblxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbnZhciBpc0hvc3RPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0KHsgJ3RvU3RyaW5nJzogMCB9ICsgJycpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiAodmFsdWUgKyAnJykgPT09ICdzdHJpbmcnO1xuICB9O1xufSgpKTtcblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBhcnJheVRhZztcbn07XG5cbmZ1bmN0aW9uIGFycmF5U29tZSAoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKGlzTG9vc2UpIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICBpZiAob2JqVGFnID09PSBhcmdzVGFnKSB7XG4gICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgfSBlbHNlIGlmIChvYmpUYWcgIT09IG9iamVjdFRhZykge1xuICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgIGlmIChvdGhUYWcgPT09IGFyZ3NUYWcpIHtcbiAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICB9XG4gIH1cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgIShvYmpJc0FyciB8fCBvYmpJc09iaikpIHtcbiAgICByZXR1cm4gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcpO1xuICB9XG4gIGlmICghaXNMb29zZSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsIG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PT0gb2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT09IG90aGVyO1xuICAgIH1cbiAgfVxuICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBzdGFja0EucHVzaChvYmplY3QpO1xuICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcblxuICBzdGFja0EucG9wKCk7XG4gIHN0YWNrQi5wb3AoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xufVxuXG52YXIgaXNFcXVhbCA9IFJ4LmludGVybmFscy5pc0VxdWFsID0gZnVuY3Rpb24gKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn07XG5cbiAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIHZhciBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG4gIH07XG5cbiAgdmFyIGFkZFByb3BlcnRpZXMgPSBSeC5pbnRlcm5hbHMuYWRkUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IodmFyIHNvdXJjZXMgPSBbXSwgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxuID0gc291cmNlcy5sZW5ndGg7IGlkeCA8IGxuOyBpZHgrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaWR4XTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUnggVXRpbHNcbiAgdmFyIGFkZFJlZiA9IFJ4LmludGVybmFscy5hZGRSZWYgPSBmdW5jdGlvbiAoeHMsIHIpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoci5nZXREaXNwb3NhYmxlKCksIHhzLnN1YnNjcmliZShvYnNlcnZlcikpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFycmF5SW5pdGlhbGl6ZShjb3VudCwgZmFjdG9yeSkge1xuICAgIHZhciBhID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGFbaV0gPSBmYWN0b3J5KCk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgZnVuY3Rpb24gSW5kZXhlZEl0ZW0oaWQsIHZhbHVlKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIEluZGV4ZWRJdGVtLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgYyA9IHRoaXMudmFsdWUuY29tcGFyZVRvKG90aGVyLnZhbHVlKTtcbiAgICBjID09PSAwICYmIChjID0gdGhpcy5pZCAtIG90aGVyLmlkKTtcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICB2YXIgUHJpb3JpdHlRdWV1ZSA9IFJ4LmludGVybmFscy5Qcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheShjYXBhY2l0eSk7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIHZhciBwcmlvcml0eVByb3RvID0gUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGU7XG4gIHByaW9yaXR5UHJvdG8uaXNIaWdoZXJQcmlvcml0eSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2xlZnRdLmNvbXBhcmVUbyh0aGlzLml0ZW1zW3JpZ2h0XSkgPCAwO1xuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8ucGVyY29sYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoIHx8IGluZGV4IDwgMCkgeyByZXR1cm47IH1cbiAgICB2YXIgcGFyZW50ID0gaW5kZXggLSAxID4+IDE7XG4gICAgaWYgKHBhcmVudCA8IDAgfHwgcGFyZW50ID09PSBpbmRleCkgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5pc0hpZ2hlclByaW9yaXR5KGluZGV4LCBwYXJlbnQpKSB7XG4gICAgICB2YXIgdGVtcCA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB0aGlzLml0ZW1zW3BhcmVudF07XG4gICAgICB0aGlzLml0ZW1zW3BhcmVudF0gPSB0ZW1wO1xuICAgICAgdGhpcy5wZXJjb2xhdGUocGFyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5oZWFwaWZ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgK2luZGV4IHx8IChpbmRleCA9IDApO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHsgcmV0dXJuOyB9XG4gICAgdmFyIGxlZnQgPSAyICogaW5kZXggKyAxLFxuICAgICAgICByaWdodCA9IDIgKiBpbmRleCArIDIsXG4gICAgICAgIGZpcnN0ID0gaW5kZXg7XG4gICAgaWYgKGxlZnQgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLmlzSGlnaGVyUHJpb3JpdHkobGVmdCwgZmlyc3QpKSB7XG4gICAgICBmaXJzdCA9IGxlZnQ7XG4gICAgfVxuICAgIGlmIChyaWdodCA8IHRoaXMubGVuZ3RoICYmIHRoaXMuaXNIaWdoZXJQcmlvcml0eShyaWdodCwgZmlyc3QpKSB7XG4gICAgICBmaXJzdCA9IHJpZ2h0O1xuICAgIH1cbiAgICBpZiAoZmlyc3QgIT09IGluZGV4KSB7XG4gICAgICB2YXIgdGVtcCA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB0aGlzLml0ZW1zW2ZpcnN0XTtcbiAgICAgIHRoaXMuaXRlbXNbZmlyc3RdID0gdGVtcDtcbiAgICAgIHRoaXMuaGVhcGlmeShmaXJzdCk7XG4gICAgfVxuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8ucGVlayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlbXNbMF0udmFsdWU7IH07XG5cbiAgcHJpb3JpdHlQcm90by5yZW1vdmVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdGhpcy5pdGVtc1stLXRoaXMubGVuZ3RoXTtcbiAgICB0aGlzLml0ZW1zW3RoaXMubGVuZ3RoXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlYXBpZnkoKTtcbiAgfTtcblxuICBwcmlvcml0eVByb3RvLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgIHRoaXMucmVtb3ZlQXQoMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBwcmlvcml0eVByb3RvLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5pdGVtc1tpbmRleF0gPSBuZXcgSW5kZXhlZEl0ZW0oUHJpb3JpdHlRdWV1ZS5jb3VudCsrLCBpdGVtKTtcbiAgICB0aGlzLnBlcmNvbGF0ZShpbmRleCk7XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaXRlbXNbaV0udmFsdWUgPT09IGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgUHJpb3JpdHlRdWV1ZS5jb3VudCA9IDA7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBncm91cCBvZiBkaXNwb3NhYmxlIHJlc291cmNlcyB0aGF0IGFyZSBkaXNwb3NlZCB0b2dldGhlci5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgQ29tcG9zaXRlRGlzcG9zYWJsZSA9IFJ4LkNvbXBvc2l0ZURpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSwgbGVuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBhcmdzO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUgPSBDb21wb3NpdGVEaXNwb3NhYmxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQWRkcyBhIGRpc3Bvc2FibGUgdG8gdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUgb3IgZGlzcG9zZXMgdGhlIGRpc3Bvc2FibGUgaWYgdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUgaXMgZGlzcG9zZWQuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gRGlzcG9zYWJsZSB0byBhZGQuXG4gICAqL1xuICBDb21wb3NpdGVEaXNwb3NhYmxlUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgaXRlbS5kaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZXMucHVzaChpdGVtKTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuZCBkaXNwb3NlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIGRpc3Bvc2FibGUgZnJvbSB0aGUgQ29tcG9zaXRlRGlzcG9zYWJsZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gaXRlbSBEaXNwb3NhYmxlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgZm91bmQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgc2hvdWxkRGlzcG9zZSA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5kaXNwb3NhYmxlcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgc2hvdWxkRGlzcG9zZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkRGlzcG9zZTtcbiAgfTtcblxuICAvKipcbiAgICogIERpc3Bvc2VzIGFsbCBkaXNwb3NhYmxlcyBpbiB0aGUgZ3JvdXAgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBncm91cC5cbiAgICovXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRpc3Bvc2FibGVzLmxlbmd0aCwgY3VycmVudERpc3Bvc2FibGVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgY3VycmVudERpc3Bvc2FibGVzW2ldID0gdGhpcy5kaXNwb3NhYmxlc1tpXTsgfVxuICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY3VycmVudERpc3Bvc2FibGVzW2ldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgc2V0IG9mIHN0YXRpYyBtZXRob2RzIGZvciBjcmVhdGluZyBEaXNwb3NhYmxlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcG9zZSBBY3Rpb24gdG8gcnVuIGR1cmluZyB0aGUgZmlyc3QgY2FsbCB0byBkaXNwb3NlLiBUaGUgYWN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgcnVuIGF0IG1vc3Qgb25jZS5cbiAgICovXG4gIHZhciBEaXNwb3NhYmxlID0gUnguRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbiB8fCBub29wO1xuICB9O1xuXG4gIC8qKiBQZXJmb3JtcyB0aGUgdGFzayBvZiBjbGVhbmluZyB1cCByZXNvdXJjZXMuICovXG4gIERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuYWN0aW9uKCk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRpc3Bvc2FibGUgb2JqZWN0IHRoYXQgaW52b2tlcyB0aGUgc3BlY2lmaWVkIGFjdGlvbiB3aGVuIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwb3NlIEFjdGlvbiB0byBydW4gZHVyaW5nIHRoZSBmaXJzdCBjYWxsIHRvIGRpc3Bvc2UuIFRoZSBhY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBiZSBydW4gYXQgbW9zdCBvbmNlLlxuICAgKiBAcmV0dXJuIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdGhhdCBydW5zIHRoZSBnaXZlbiBhY3Rpb24gdXBvbiBkaXNwb3NhbC5cbiAgICovXG4gIHZhciBkaXNwb3NhYmxlQ3JlYXRlID0gRGlzcG9zYWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXcgRGlzcG9zYWJsZShhY3Rpb24pOyB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkaXNwb3NhYmxlIHRoYXQgZG9lcyBub3RoaW5nIHdoZW4gZGlzcG9zZWQuXG4gICAqL1xuICB2YXIgZGlzcG9zYWJsZUVtcHR5ID0gRGlzcG9zYWJsZS5lbXB0eSA9IHsgZGlzcG9zZTogbm9vcCB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgZGlzcG9zYWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIHRlc3Qgd2hldGhlciBpdCBoYXMgYSBkaXNwb3NlIG1ldGhvZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGRpc3Bvc2FibGUgb2JqZWN0LCBlbHNlIGZhbHNlLlxuICAgKi9cbiAgdmFyIGlzRGlzcG9zYWJsZSA9IERpc3Bvc2FibGUuaXNEaXNwb3NhYmxlID0gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZCAmJiBpc0Z1bmN0aW9uKGQuZGlzcG9zZSk7XG4gIH07XG5cbiAgdmFyIGNoZWNrRGlzcG9zZWQgPSBEaXNwb3NhYmxlLmNoZWNrRGlzcG9zZWQgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgIGlmIChkaXNwb3NhYmxlLmlzRGlzcG9zZWQpIHsgdGhyb3cgbmV3IE9iamVjdERpc3Bvc2VkRXJyb3IoKTsgfVxuICB9O1xuXG4gIHZhciBkaXNwb3NhYmxlRml4dXAgPSBEaXNwb3NhYmxlLl9maXh1cCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gaXNEaXNwb3NhYmxlKHJlc3VsdCkgPyByZXN1bHQgOiBkaXNwb3NhYmxlRW1wdHk7XG4gIH07XG5cbiAgLy8gU2luZ2xlIGFzc2lnbm1lbnRcbiAgdmFyIFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlID0gUnguU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgfTtcbiAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUucHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcbiAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUucHJvdG90eXBlLnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7IHRocm93IG5ldyBFcnJvcignRGlzcG9zYWJsZSBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkJyk7IH1cbiAgICB2YXIgc2hvdWxkRGlzcG9zZSA9IHRoaXMuaXNEaXNwb3NlZDtcbiAgICAhc2hvdWxkRGlzcG9zZSAmJiAodGhpcy5jdXJyZW50ID0gdmFsdWUpO1xuICAgIHNob3VsZERpc3Bvc2UgJiYgdmFsdWUgJiYgdmFsdWUuZGlzcG9zZSgpO1xuICB9O1xuICBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgb2xkICYmIG9sZC5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE11bHRpcGxlIGFzc2lnbm1lbnQgZGlzcG9zYWJsZVxuICB2YXIgU2VyaWFsRGlzcG9zYWJsZSA9IFJ4LlNlcmlhbERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgfTtcbiAgU2VyaWFsRGlzcG9zYWJsZS5wcm90b3R5cGUuZ2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuICBTZXJpYWxEaXNwb3NhYmxlLnByb3RvdHlwZS5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHNob3VsZERpc3Bvc2UgPSB0aGlzLmlzRGlzcG9zZWQ7XG4gICAgaWYgKCFzaG91bGREaXNwb3NlKSB7XG4gICAgICB2YXIgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgICAgdGhpcy5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIG9sZCAmJiBvbGQuZGlzcG9zZSgpO1xuICAgIHNob3VsZERpc3Bvc2UgJiYgdmFsdWUgJiYgdmFsdWUuZGlzcG9zZSgpO1xuICB9O1xuICBTZXJpYWxEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgdmFyIG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIG9sZCAmJiBvbGQuZGlzcG9zZSgpO1xuICB9O1xuXG4gIHZhciBCaW5hcnlEaXNwb3NhYmxlID0gUnguQmluYXJ5RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgdGhpcy5fZmlyc3QgPSBmaXJzdDtcbiAgICB0aGlzLl9zZWNvbmQgPSBzZWNvbmQ7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH07XG5cbiAgQmluYXJ5RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBvbGQxID0gdGhpcy5fZmlyc3Q7XG4gICAgICB0aGlzLl9maXJzdCA9IG51bGw7XG4gICAgICBvbGQxICYmIG9sZDEuZGlzcG9zZSgpO1xuICAgICAgdmFyIG9sZDIgPSB0aGlzLl9zZWNvbmQ7XG4gICAgICB0aGlzLl9zZWNvbmQgPSBudWxsO1xuICAgICAgb2xkMiAmJiBvbGQyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIE5BcnlEaXNwb3NhYmxlID0gUnguTkFyeURpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZXMpIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IGRpc3Bvc2FibGVzO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9O1xuXG4gIE5BcnlEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2Rpc3Bvc2FibGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzW2ldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSB0aGF0IG9ubHkgZGlzcG9zZXMgaXRzIHVuZGVybHlpbmcgZGlzcG9zYWJsZSByZXNvdXJjZSB3aGVuIGFsbCBkZXBlbmRlbnQgZGlzcG9zYWJsZSBvYmplY3RzIGhhdmUgYmVlbiBkaXNwb3NlZC5cbiAgICovXG4gIHZhciBSZWZDb3VudERpc3Bvc2FibGUgPSBSeC5SZWZDb3VudERpc3Bvc2FibGUgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24gSW5uZXJEaXNwb3NhYmxlKGRpc3Bvc2FibGUpIHtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGU7XG4gICAgICB0aGlzLmRpc3Bvc2FibGUuY291bnQrKztcbiAgICAgIHRoaXMuaXNJbm5lckRpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgSW5uZXJEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCAmJiAhdGhpcy5pc0lubmVyRGlzcG9zZWQpIHtcbiAgICAgICAgdGhpcy5pc0lubmVyRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUuY291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zYWJsZS5jb3VudCA9PT0gMCAmJiB0aGlzLmRpc3Bvc2FibGUuaXNQcmltYXJ5RGlzcG9zZWQpIHtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXNwb3NhYmxlLnVuZGVybHlpbmdEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUmVmQ291bnREaXNwb3NhYmxlIHdpdGggdGhlIHNwZWNpZmllZCBkaXNwb3NhYmxlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gZGlzcG9zYWJsZSBVbmRlcmx5aW5nIGRpc3Bvc2FibGUuXG4gICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50RGlzcG9zYWJsZShkaXNwb3NhYmxlKSB7XG4gICAgICB0aGlzLnVuZGVybHlpbmdEaXNwb3NhYmxlID0gZGlzcG9zYWJsZTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZSBvbmx5IHdoZW4gYWxsIGRlcGVuZGVudCBkaXNwb3NhYmxlcyBoYXZlIGJlZW4gZGlzcG9zZWRcbiAgICAgKi9cbiAgICBSZWZDb3VudERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCAmJiAhdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzUHJpbWFyeURpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudW5kZXJseWluZ0Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkZXBlbmRlbnQgZGlzcG9zYWJsZSB0aGF0IHdoZW4gZGlzcG9zZWQgZGVjcmVhc2VzIHRoZSByZWZjb3VudCBvbiB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRlcGVuZGVudCBkaXNwb3NhYmxlIGNvbnRyaWJ1dGluZyB0byB0aGUgcmVmZXJlbmNlIGNvdW50IHRoYXQgbWFuYWdlcyB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlJ3MgbGlmZXRpbWUuXG4gICAgICovXG4gICAgUmVmQ291bnREaXNwb3NhYmxlLnByb3RvdHlwZS5nZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNEaXNwb3NlZCA/IGRpc3Bvc2FibGVFbXB0eSA6IG5ldyBJbm5lckRpc3Bvc2FibGUodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZWZDb3VudERpc3Bvc2FibGU7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gU2NoZWR1bGVkRGlzcG9zYWJsZShzY2hlZHVsZXIsIGRpc3Bvc2FibGUpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLmRpc3Bvc2FibGUgPSBkaXNwb3NhYmxlO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVJdGVtKHMsIHNlbGYpIHtcbiAgICBpZiAoIXNlbGYuaXNEaXNwb3NlZCkge1xuICAgICAgc2VsZi5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHNlbGYuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgU2NoZWR1bGVkRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBzY2hlZHVsZUl0ZW0pO1xuICB9O1xuXG4gIHZhciBTY2hlZHVsZWRJdGVtID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlZEl0ZW0gPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBzdGF0ZSwgYWN0aW9uLCBkdWVUaW1lLCBjb21wYXJlcikge1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlciB8fCBkZWZhdWx0U3ViQ29tcGFyZXI7XG4gICAgdGhpcy5kaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gIH07XG5cbiAgU2NoZWR1bGVkSXRlbS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKHRoaXMuaW52b2tlQ29yZSgpKTtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlcih0aGlzLmR1ZVRpbWUsIG90aGVyLmR1ZVRpbWUpO1xuICB9O1xuXG4gIFNjaGVkdWxlZEl0ZW0ucHJvdG90eXBlLmlzQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZDtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5pbnZva2VDb3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwb3NhYmxlRml4dXAodGhpcy5hY3Rpb24odGhpcy5zY2hlZHVsZXIsIHRoaXMuc3RhdGUpKTtcbiAgfTtcblxuICAvKiogUHJvdmlkZXMgYSBzZXQgb2Ygc3RhdGljIHByb3BlcnRpZXMgdG8gYWNjZXNzIGNvbW1vbmx5IHVzZWQgc2NoZWR1bGVycy4gKi9cbiAgdmFyIFNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7IH1cblxuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHNjaGVkdWxlciAqL1xuICAgIFNjaGVkdWxlci5pc1NjaGVkdWxlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcyBpbnN0YW5jZW9mIFNjaGVkdWxlcjtcbiAgICB9O1xuXG4gICAgdmFyIHNjaGVkdWxlclByb3RvID0gU2NoZWR1bGVyLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGR1ZVRpbWUuXG4gICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgUmVsYXRpdmUgdGltZSBhZnRlciB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdmFyIGR0ID0gZHVlVGltZTtcbiAgICAgIGR0IGluc3RhbmNlb2YgRGF0ZSAmJiAoZHQgPSBkdCAtIHRoaXMubm93KCkpO1xuICAgICAgZHQgPSBTY2hlZHVsZXIubm9ybWFsaXplKGR0KTtcblxuICAgICAgaWYgKGR0ID09PSAwKSB7IHJldHVybiB0aGlzLnNjaGVkdWxlKHN0YXRlLCBhY3Rpb24pOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZUZ1dHVyZShzdGF0ZSwgZHQsIGFjdGlvbik7XG4gICAgfTtcblxuICAgIHNjaGVkdWxlclByb3RvLl9zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG5cbiAgICAvKiogR2V0cyB0aGUgY3VycmVudCB0aW1lIGFjY29yZGluZyB0byB0aGUgbG9jYWwgbWFjaGluZSdzIHN5c3RlbSBjbG9jay4gKi9cbiAgICBTY2hlZHVsZXIubm93ID0gZGVmYXVsdE5vdztcblxuICAgIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbCBtYWNoaW5lJ3Mgc3lzdGVtIGNsb2NrLiAqL1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUubm93ID0gZGVmYXVsdE5vdztcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBUaW1lU3BhbiB2YWx1ZSB0byBhIHBvc2l0aXZlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBUaGUgdGltZSBzcGFuIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3BlY2lmaWVkIFRpbWVTcGFuIHZhbHVlIGlmIGl0IGlzIHplcm8gb3IgcG9zaXRpdmU7IG90aGVyd2lzZSwgMFxuICAgICAqL1xuICAgIFNjaGVkdWxlci5ub3JtYWxpemUgPSBmdW5jdGlvbiAodGltZVNwYW4pIHtcbiAgICAgIHRpbWVTcGFuIDwgMCAmJiAodGltZVNwYW4gPSAwKTtcbiAgICAgIHJldHVybiB0aW1lU3BhbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjaGVkdWxlcjtcbiAgfSgpKTtcblxuICB2YXIgbm9ybWFsaXplVGltZSA9IFNjaGVkdWxlci5ub3JtYWxpemUsIGlzU2NoZWR1bGVyID0gU2NoZWR1bGVyLmlzU2NoZWR1bGVyO1xuXG4gIChmdW5jdGlvbiAoc2NoZWR1bGVyUHJvdG8pIHtcblxuICAgIGZ1bmN0aW9uIGludm9rZVJlY0ltbWVkaWF0ZShzY2hlZHVsZXIsIHBhaXIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHBhaXJbMF0sIGFjdGlvbiA9IHBhaXJbMV0sIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGFjdGlvbihzdGF0ZSwgaW5uZXJBY3Rpb24pO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuXG4gICAgICBmdW5jdGlvbiBpbm5lckFjdGlvbihzdGF0ZTIpIHtcbiAgICAgICAgdmFyIGlzQWRkZWQgPSBmYWxzZSwgaXNEb25lID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGQgPSBzY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUyLCBzY2hlZHVsZVdvcmspO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIGdyb3VwLmFkZChkKTtcbiAgICAgICAgICBpc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhfLCBzdGF0ZTMpIHtcbiAgICAgICAgICBpZiAoaXNBZGRlZCkge1xuICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb24oc3RhdGUzLCBpbm5lckFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZVJlY0RhdGUoc2NoZWR1bGVyLCBwYWlyKSB7XG4gICAgICB2YXIgc3RhdGUgPSBwYWlyWzBdLCBhY3Rpb24gPSBwYWlyWzFdLCBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBhY3Rpb24oc3RhdGUsIGlubmVyQWN0aW9uKTtcbiAgICAgIHJldHVybiBncm91cDtcblxuICAgICAgZnVuY3Rpb24gaW5uZXJBY3Rpb24oc3RhdGUyLCBkdWVUaW1lMSkge1xuICAgICAgICB2YXIgaXNBZGRlZCA9IGZhbHNlLCBpc0RvbmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZCA9IHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShzdGF0ZTIsIGR1ZVRpbWUxLCBzY2hlZHVsZVdvcmspO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIGdyb3VwLmFkZChkKTtcbiAgICAgICAgICBpc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhfLCBzdGF0ZTMpIHtcbiAgICAgICAgICBpZiAoaXNBZGRlZCkge1xuICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb24oc3RhdGUzLCBpbm5lckFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgcmVjdXJzaXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBleGVjdXRlIHJlY3Vyc2l2ZWx5LiBUaGUgbGFzdCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBhY3Rpb24gaXMgdXNlZCB0byB0cmlnZ2VyIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nIG9mIHRoZSBhY3Rpb24sIHBhc3NpbmcgaW4gcmVjdXJzaXZlIGludm9jYXRpb24gc3RhdGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUmVjdXJzaXZlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKFtzdGF0ZSwgYWN0aW9uXSwgaW52b2tlUmVjSW1tZWRpYXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCByZWN1cnNpdmVseSBhZnRlciBhIHNwZWNpZmllZCByZWxhdGl2ZSBvciBhYnNvbHV0ZSBkdWUgdGltZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGV4ZWN1dGUgcmVjdXJzaXZlbHkuIFRoZSBsYXN0IHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGFjdGlvbiBpcyB1c2VkIHRvIHRyaWdnZXIgcmVjdXJzaXZlIHNjaGVkdWxpbmcgb2YgdGhlIGFjdGlvbiwgcGFzc2luZyBpbiB0aGUgcmVjdXJzaXZlIGR1ZSB0aW1lIGFuZCBpbnZvY2F0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyIHwgRGF0ZX0gZHVlVGltZSBSZWxhdGl2ZSBvciBhYnNvbHV0ZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlRnV0dXJlKFtzdGF0ZSwgYWN0aW9uXSwgZHVlVGltZSwgaW52b2tlUmVjRGF0ZSk7XG4gICAgfTtcblxuICB9KFNjaGVkdWxlci5wcm90b3R5cGUpKTtcblxuICAoZnVuY3Rpb24gKHNjaGVkdWxlclByb3RvKSB7XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBwZXJpb2RpYyBwaWVjZSBvZiB3b3JrIGJ5IGR5bmFtaWNhbGx5IGRpc2NvdmVyaW5nIHRoZSBzY2hlZHVsZXIncyBjYXBhYmlsaXRpZXMuIFRoZSBwZXJpb2RpYyB0YXNrIHdpbGwgYmUgc2NoZWR1bGVkIHVzaW5nIHdpbmRvdy5zZXRJbnRlcnZhbCBmb3IgdGhlIGJhc2UgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB1cG9uIHRoZSBmaXJzdCBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZCBQZXJpb2QgZm9yIHJ1bm5pbmcgdGhlIHdvcmsgcGVyaW9kaWNhbGx5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQsIHBvdGVudGlhbGx5IHVwZGF0aW5nIHRoZSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVjdXJyaW5nIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUGVyaW9kaWMgPSBmdW5jdGlvbihzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2Ygcm9vdC5zZXRJbnRlcnZhbCA9PT0gJ3VuZGVmaW5lZCcpIHsgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCk7IH1cbiAgICAgIHBlcmlvZCA9IG5vcm1hbGl6ZVRpbWUocGVyaW9kKTtcbiAgICAgIHZhciBzID0gc3RhdGUsIGlkID0gcm9vdC5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHMgPSBhY3Rpb24ocyk7IH0sIHBlcmlvZCk7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7IHJvb3QuY2xlYXJJbnRlcnZhbChpZCk7IH0pO1xuICAgIH07XG5cbiAgfShTY2hlZHVsZXIucHJvdG90eXBlKSk7XG5cbiAgKGZ1bmN0aW9uIChzY2hlZHVsZXJQcm90bykge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzY2hlZHVsZXIgdGhhdCB3cmFwcyB0aGUgb3JpZ2luYWwgc2NoZWR1bGVyLCBhZGRpbmcgZXhjZXB0aW9uIGhhbmRsaW5nIGZvciBzY2hlZHVsZWQgYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEhhbmRsZXIgdGhhdCdzIHJ1biBpZiBhbiBleGNlcHRpb24gaXMgY2F1Z2h0LiBUaGUgZXhjZXB0aW9uIHdpbGwgYmUgcmV0aHJvd24gaWYgdGhlIGhhbmRsZXIgcmV0dXJucyBmYWxzZS5cbiAgICAgKiBAcmV0dXJucyB7U2NoZWR1bGVyfSBXcmFwcGVyIGFyb3VuZCB0aGUgb3JpZ2luYWwgc2NoZWR1bGVyLCBlbmZvcmNpbmcgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLmNhdGNoRXJyb3IgPSBzY2hlZHVsZXJQcm90b1snY2F0Y2gnXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gbmV3IENhdGNoU2NoZWR1bGVyKHRoaXMsIGhhbmRsZXIpO1xuICAgIH07XG4gIH0oU2NoZWR1bGVyLnByb3RvdHlwZSkpO1xuXG4gIHZhciBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRpY2soc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRpY2soY29tbWFuZCwgcmVjdXJzZSkge1xuICAgICAgICByZWN1cnNlKDAsIHNlbGYuX3BlcmlvZCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRyeUNhdGNoKHNlbGYuX2FjdGlvbikoc2VsZi5fc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgc2VsZi5fY2FuY2VsLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aHJvd2VyKHN0YXRlLmUpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX3N0YXRlID0gc3RhdGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUoc2NoZWR1bGVyLCBzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuXG4gICAgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgdGhpcy5fY2FuY2VsID0gZDtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUoMCwgdGhpcy5fcGVyaW9kLCBjcmVhdGVUaWNrKHRoaXMpKSk7XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZTtcbiAgfSgpKTtcblxuICAvKiogR2V0cyBhIHNjaGVkdWxlciB0aGF0IHNjaGVkdWxlcyB3b3JrIGltbWVkaWF0ZWx5IG9uIHRoZSBjdXJyZW50IHRocmVhZC4gKi9cbiAgIHZhciBJbW1lZGlhdGVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEltbWVkaWF0ZVNjaGVkdWxlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbW1lZGlhdGVTY2hlZHVsZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbW1lZGlhdGVTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRml4dXAoYWN0aW9uKHRoaXMsIHN0YXRlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbW1lZGlhdGVTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgdmFyIGltbWVkaWF0ZVNjaGVkdWxlciA9IFNjaGVkdWxlci5pbW1lZGlhdGUgPSBuZXcgSW1tZWRpYXRlU2NoZWR1bGVyKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzY2hlZHVsZXIgdGhhdCBzY2hlZHVsZXMgd29yayBhcyBzb29uIGFzIHBvc3NpYmxlIG9uIHRoZSBjdXJyZW50IHRocmVhZC5cbiAgICovXG4gIHZhciBDdXJyZW50VGhyZWFkU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICB2YXIgcXVldWU7XG5cbiAgICBmdW5jdGlvbiBydW5UcmFtcG9saW5lICgpIHtcbiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAhaXRlbS5pc0NhbmNlbGxlZCgpICYmIGl0ZW0uaW52b2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoQ3VycmVudFRocmVhZFNjaGVkdWxlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDdXJyZW50VGhyZWFkU2NoZWR1bGVyKCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ3VycmVudFRocmVhZFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgdmFyIHNpID0gbmV3IFNjaGVkdWxlZEl0ZW0odGhpcywgc3RhdGUsIGFjdGlvbiwgdGhpcy5ub3coKSk7XG5cbiAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSg0KTtcbiAgICAgICAgcXVldWUuZW5xdWV1ZShzaSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJ1blRyYW1wb2xpbmUpKCk7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgdGhyb3dlcihyZXN1bHQuZSk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlLmVucXVldWUoc2kpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpLmRpc3Bvc2FibGU7XG4gICAgfTtcblxuICAgIEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlUmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhcXVldWU7IH07XG5cbiAgICByZXR1cm4gQ3VycmVudFRocmVhZFNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICB2YXIgY3VycmVudFRocmVhZFNjaGVkdWxlciA9IFNjaGVkdWxlci5jdXJyZW50VGhyZWFkID0gbmV3IEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIoKTtcblxuICB2YXIgc2NoZWR1bGVNZXRob2QsIGNsZWFyTWV0aG9kO1xuXG4gIHZhciBsb2NhbFRpbWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG9jYWxTZXRUaW1lb3V0LCBsb2NhbENsZWFyVGltZW91dCA9IG5vb3A7XG4gICAgaWYgKCEhcm9vdC5zZXRUaW1lb3V0KSB7XG4gICAgICBsb2NhbFNldFRpbWVvdXQgPSByb290LnNldFRpbWVvdXQ7XG4gICAgICBsb2NhbENsZWFyVGltZW91dCA9IHJvb3QuY2xlYXJUaW1lb3V0O1xuICAgIH0gZWxzZSBpZiAoISFyb290LldTY3JpcHQpIHtcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xuICAgICAgICByb290LldTY3JpcHQuU2xlZXAodGltZSk7XG4gICAgICAgIGZuKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2V0VGltZW91dDogbG9jYWxTZXRUaW1lb3V0LFxuICAgICAgY2xlYXJUaW1lb3V0OiBsb2NhbENsZWFyVGltZW91dFxuICAgIH07XG4gIH0oKSk7XG4gIHZhciBsb2NhbFNldFRpbWVvdXQgPSBsb2NhbFRpbWVyLnNldFRpbWVvdXQsXG4gICAgbG9jYWxDbGVhclRpbWVvdXQgPSBsb2NhbFRpbWVyLmNsZWFyVGltZW91dDtcblxuICAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxLCB0YXNrc0J5SGFuZGxlID0ge30sIGN1cnJlbnRseVJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIGNsZWFyTWV0aG9kID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhoYW5kbGUpIHtcbiAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nKSB7XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJ1blRhc2soaGFuZGxlKTsgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGFzaykoKTtcbiAgICAgICAgICBjbGVhck1ldGhvZChoYW5kbGUpO1xuICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyB0aHJvd2VyKHJlc3VsdC5lKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlTmF0aXZlID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICB2YXIgc2V0SW1tZWRpYXRlID0gdHlwZW9mIChzZXRJbW1lZGlhdGUgPSBmcmVlR2xvYmFsICYmIG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5zZXRJbW1lZGlhdGUpID09ICdmdW5jdGlvbicgJiZcbiAgICAgICFyZU5hdGl2ZS50ZXN0KHNldEltbWVkaWF0ZSkgJiYgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgKCkge1xuICAgICAgLy8gRW5zdXJlIG5vdCBpbiBhIHdvcmtlclxuICAgICAgaWYgKCFyb290LnBvc3RNZXNzYWdlIHx8IHJvb3QuaW1wb3J0U2NyaXB0cykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHZhciBpc0FzeW5jID0gZmFsc2UsIG9sZEhhbmRsZXIgPSByb290Lm9ubWVzc2FnZTtcbiAgICAgIC8vIFRlc3QgZm9yIGFzeW5jXG4gICAgICByb290Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHsgaXNBc3luYyA9IHRydWU7IH07XG4gICAgICByb290LnBvc3RNZXNzYWdlKCcnLCAnKicpO1xuICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBvbGRIYW5kbGVyO1xuXG4gICAgICByZXR1cm4gaXNBc3luYztcbiAgICB9XG5cbiAgICAvLyBVc2UgaW4gb3JkZXIsIHNldEltbWVkaWF0ZSwgbmV4dFRpY2ssIHBvc3RNZXNzYWdlLCBNZXNzYWdlQ2hhbm5lbCwgc2NyaXB0IHJlYWR5c3RhdGVjaGFuZ2VkLCBzZXRUaW1lb3V0XG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0SW1tZWRpYXRlKSkge1xuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7IHJ1blRhc2soaWQpOyB9KTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5UYXNrKGlkKTsgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBvc3RNZXNzYWdlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHZhciBNU0dfUFJFRklYID0gJ21zLnJ4LnNjaGVkdWxlJyArIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgIHZhciBvbkdsb2JhbFBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE9ubHkgaWYgd2UncmUgYSBtYXRjaCB0byBhdm9pZCBhbnkgb3RoZXIgZ2xvYmFsIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnICYmIGV2ZW50LmRhdGEuc3Vic3RyaW5nKDAsIE1TR19QUkVGSVgubGVuZ3RoKSA9PT0gTVNHX1BSRUZJWCkge1xuICAgICAgICAgIHJ1blRhc2soZXZlbnQuZGF0YS5zdWJzdHJpbmcoTVNHX1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25HbG9iYWxQb3N0TWVzc2FnZSwgZmFsc2UpO1xuXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcbiAgICAgICAgcm9vdC5wb3N0TWVzc2FnZShNU0dfUFJFRklYICsgaWQsICcqJyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghIXJvb3QuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IHJvb3QuTWVzc2FnZUNoYW5uZWwoKTtcblxuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkgeyBydW5UYXNrKGUuZGF0YSk7IH07XG5cbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGlkKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gcm9vdCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiByb290LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgc2NyaXB0RWxlbWVudCA9IHJvb3QuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG5cbiAgICAgICAgc2NyaXB0RWxlbWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcnVuVGFzayhpZCk7XG4gICAgICAgICAgc2NyaXB0RWxlbWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgIHNjcmlwdEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICAgICAgICBzY3JpcHRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcm9vdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcnVuVGFzayhpZCk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfVxuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgc2NoZWR1bGVyIHRoYXQgc2NoZWR1bGVzIHdvcmsgdmlhIGEgdGltZWQgY2FsbGJhY2sgYmFzZWQgdXBvbiBwbGF0Zm9ybS5cbiAgICovXG4gICB2YXIgRGVmYXVsdFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgIGluaGVyaXRzKERlZmF1bHRTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG4gICAgIGZ1bmN0aW9uIERlZmF1bHRTY2hlZHVsZXIoKSB7XG4gICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgIH1cblxuICAgICBmdW5jdGlvbiBzY2hlZHVsZUFjdGlvbihkaXNwb3NhYmxlLCBhY3Rpb24sIHNjaGVkdWxlciwgc3RhdGUpIHtcbiAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgICAgICBkaXNwb3NhYmxlLnNldERpc3Bvc2FibGUoRGlzcG9zYWJsZS5fZml4dXAoYWN0aW9uKHNjaGVkdWxlciwgc3RhdGUpKSk7XG4gICAgICAgfTtcbiAgICAgfVxuXG4gICAgIGZ1bmN0aW9uIENsZWFyRGlzcG9zYWJsZShpZCkge1xuICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgIH1cblxuICAgICBDbGVhckRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICBjbGVhck1ldGhvZCh0aGlzLl9pZCk7XG4gICAgICAgfVxuICAgICB9O1xuXG4gICAgIGZ1bmN0aW9uIExvY2FsQ2xlYXJEaXNwb3NhYmxlKGlkKSB7XG4gICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgfVxuXG4gICAgIExvY2FsQ2xlYXJEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGhpcy5faWQpO1xuICAgICAgIH1cbiAgICAgfTtcblxuICAgIERlZmF1bHRTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgICAgaWQgPSBzY2hlZHVsZU1ldGhvZChzY2hlZHVsZUFjdGlvbihkaXNwb3NhYmxlLCBhY3Rpb24sIHRoaXMsIHN0YXRlKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoZGlzcG9zYWJsZSwgbmV3IENsZWFyRGlzcG9zYWJsZShpZCkpO1xuICAgIH07XG5cbiAgICBEZWZhdWx0U2NoZWR1bGVyLnByb3RvdHlwZS5fc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgaWYgKGR1ZVRpbWUgPT09IDApIHsgcmV0dXJuIHRoaXMuc2NoZWR1bGUoc3RhdGUsIGFjdGlvbik7IH1cbiAgICAgIHZhciBkaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgICAgaWQgPSBsb2NhbFNldFRpbWVvdXQoc2NoZWR1bGVBY3Rpb24oZGlzcG9zYWJsZSwgYWN0aW9uLCB0aGlzLCBzdGF0ZSksIGR1ZVRpbWUpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGRpc3Bvc2FibGUsIG5ldyBMb2NhbENsZWFyRGlzcG9zYWJsZShpZCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUxvbmdSdW5uaW5nKHN0YXRlLCBhY3Rpb24sIGRpc3Bvc2FibGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGFjdGlvbihzdGF0ZSwgZGlzcG9zYWJsZSk7IH07XG4gICAgfVxuXG4gICAgRGVmYXVsdFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVMb25nUnVubmluZyA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVDcmVhdGUobm9vcCk7XG4gICAgICBzY2hlZHVsZU1ldGhvZChzY2hlZHVsZUxvbmdSdW5uaW5nKHN0YXRlLCBhY3Rpb24sIGRpc3Bvc2FibGUpKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVmYXVsdFNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICB2YXIgZGVmYXVsdFNjaGVkdWxlciA9IFNjaGVkdWxlclsnZGVmYXVsdCddID0gU2NoZWR1bGVyLmFzeW5jID0gbmV3IERlZmF1bHRTY2hlZHVsZXIoKTtcblxuICB2YXIgQ2F0Y2hTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENhdGNoU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQ2F0Y2hTY2hlZHVsZXIoc2NoZWR1bGVyLCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZU9yaWdpbmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZVdyYXBwZXIgPSBudWxsO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHRoaXMuX3dyYXAoYWN0aW9uKSk7XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgZHVlVGltZSwgdGhpcy5fd3JhcChhY3Rpb24pKTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5ub3coKTsgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2F0Y2hTY2hlZHVsZXIoc2NoZWR1bGVyLCB0aGlzLl9oYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYsIHN0YXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaChhY3Rpb24pKHBhcmVudC5fZ2V0UmVjdXJzaXZlV3JhcHBlcihzZWxmKSwgc3RhdGUpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikge1xuICAgICAgICAgIGlmICghcGFyZW50Ll9oYW5kbGVyKHJlcy5lKSkgeyB0aHJvd2VyKHJlcy5lKTsgfVxuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVGaXh1cChyZXMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl9nZXRSZWN1cnNpdmVXcmFwcGVyID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgaWYgKHRoaXMuX3JlY3Vyc2l2ZU9yaWdpbmFsICE9PSBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlT3JpZ2luYWwgPSBzY2hlZHVsZXI7XG4gICAgICAgIHZhciB3cmFwcGVyID0gdGhpcy5fY2xvbmUoc2NoZWR1bGVyKTtcbiAgICAgICAgd3JhcHBlci5fcmVjdXJzaXZlT3JpZ2luYWwgPSBzY2hlZHVsZXI7XG4gICAgICAgIHdyYXBwZXIuX3JlY3Vyc2l2ZVdyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVXcmFwcGVyID0gd3JhcHBlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZWN1cnNpdmVXcmFwcGVyO1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVQZXJpb2RpYyA9IGZ1bmN0aW9uIChzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgZmFpbGVkID0gZmFsc2UsIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgZC5zZXREaXNwb3NhYmxlKHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVBlcmlvZGljKHN0YXRlLCBwZXJpb2QsIGZ1bmN0aW9uIChzdGF0ZTEpIHtcbiAgICAgICAgaWYgKGZhaWxlZCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2goYWN0aW9uKShzdGF0ZTEpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVyKHJlcy5lKSkgeyB0aHJvd2VyKHJlcy5lKTsgfVxuICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2F0Y2hTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXByZXNlbnRzIGEgbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxuICAgKi9cbiAgdmFyIE5vdGlmaWNhdGlvbiA9IFJ4Lk5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKCkge1xuXG4gICAgfVxuXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcblxuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdE9ic2VydmVyID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGRlbGVnYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5vdGlmaWNhdGlvbiBvciB0aGUgb2JzZXJ2ZXIncyBtZXRob2QgY29ycmVzcG9uZGluZyB0byB0aGUgbm90aWZpY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBwcm9kdWNlZCByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbiB8IE9ic2VydmVyfSBvYnNlcnZlck9yT25OZXh0IEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgYW4gT25OZXh0IG5vdGlmaWNhdGlvbiBvciBPYnNlcnZlciB0byBpbnZva2UgdGhlIG5vdGlmaWNhdGlvbiBvbi4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBGdW5jdGlvbiB0byBpbnZva2UgZm9yIGFuIE9uRXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgYW4gT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBbnl9IFJlc3VsdCBwcm9kdWNlZCBieSB0aGUgb2JzZXJ2YXRpb24uXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlck9yT25OZXh0ICYmIHR5cGVvZiBvYnNlcnZlck9yT25OZXh0ID09PSAnb2JqZWN0JyA/XG4gICAgICAgIHRoaXMuX2FjY2VwdE9ic2VydmVyKG9ic2VydmVyT3JPbk5leHQpIDpcbiAgICAgICAgdGhpcy5fYWNjZXB0KG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIE5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHNlbmQgb3V0IHRoZSBub3RpZmljYXRpb24gY2FsbHMgb24uXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc3VyZmFjZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBub3RpZmljYXRpb24gdXBvbiBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoc2VsZiwgZnVuY3Rpb24gKF8sIG5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbi5fYWNjZXB0T2JzZXJ2ZXIobyk7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLmtpbmQgPT09ICdOJyAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBOb3RpZmljYXRpb247XG4gIH0pKCk7XG5cbiAgdmFyIE9uTmV4dE5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25OZXh0Tm90aWZpY2F0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uTmV4dE5vdGlmaWNhdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5raW5kID0gJ04nO1xuICAgIH1cblxuICAgIE9uTmV4dE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIChvbk5leHQpIHtcbiAgICAgIHJldHVybiBvbk5leHQodGhpcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIE9uTmV4dE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdE9ic2VydmVyID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLm9uTmV4dCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgT25OZXh0Tm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnT25OZXh0KCcgKyB0aGlzLnZhbHVlICsgJyknO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25OZXh0Tm90aWZpY2F0aW9uO1xuICB9KE5vdGlmaWNhdGlvbikpO1xuXG4gIHZhciBPbkVycm9yTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPbkVycm9yTm90aWZpY2F0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JOb3RpZmljYXRpb24oZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIHRoaXMua2luZCA9ICdFJztcbiAgICB9XG5cbiAgICBPbkVycm9yTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvcikge1xuICAgICAgcmV0dXJuIG9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgfTtcblxuICAgIE9uRXJyb3JOb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHRPYnNlcnZlciA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5vbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgIH07XG5cbiAgICBPbkVycm9yTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnT25FcnJvcignICsgdGhpcy5lcnJvciArICcpJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9uRXJyb3JOb3RpZmljYXRpb247XG4gIH0oTm90aWZpY2F0aW9uKSk7XG5cbiAgdmFyIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbiwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbigpIHtcbiAgICAgIHRoaXMua2luZCA9ICdDJztcbiAgICB9XG5cbiAgICBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm4gb25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgT25Db21wbGV0ZWROb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHRPYnNlcnZlciA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ09uQ29tcGxldGVkKCknO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25Db21wbGV0ZWROb3RpZmljYXRpb247XG4gIH0oTm90aWZpY2F0aW9uKSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBPbk5leHQgbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxuICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25OZXh0IG5vdGlmaWNhdGlvbiBjb250YWluaW5nIHRoZSB2YWx1ZS5cbiAgICovXG4gIHZhciBub3RpZmljYXRpb25DcmVhdGVPbk5leHQgPSBOb3RpZmljYXRpb24uY3JlYXRlT25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPbk5leHROb3RpZmljYXRpb24odmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gT25FcnJvciBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7QW55fSBlcnJvciBUaGUgZXhjZXB0aW9uIGNvbnRhaW5lZCBpbiB0aGUgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25FcnJvciBub3RpZmljYXRpb24gY29udGFpbmluZyB0aGUgZXhjZXB0aW9uLlxuICAgKi9cbiAgdmFyIG5vdGlmaWNhdGlvbkNyZWF0ZU9uRXJyb3IgPSBOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBuZXcgT25FcnJvck5vdGlmaWNhdGlvbihlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIHtOb3RpZmljYXRpb259IFRoZSBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24uXG4gICAqL1xuICB2YXIgbm90aWZpY2F0aW9uQ3JlYXRlT25Db21wbGV0ZWQgPSBOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdXBwb3J0cyBwdXNoLXN0eWxlIGl0ZXJhdGlvbiBvdmVyIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqL1xuICB2YXIgT2JzZXJ2ZXIgPSBSeC5PYnNlcnZlciA9IGZ1bmN0aW9uICgpIHsgfTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBub3RpZmljYXRpb24gY2FsbGJhY2sgZnJvbSBhbiBvYnNlcnZlci5cbiAgICogQHJldHVybnMgVGhlIGFjdGlvbiB0aGF0IGZvcndhcmRzIGl0cyBpbnB1dCBub3RpZmljYXRpb24gdG8gdGhlIHVuZGVybHlpbmcgb2JzZXJ2ZXIuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUudG9Ob3RpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAobikgeyByZXR1cm4gbi5hY2NlcHQob2JzZXJ2ZXIpOyB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiAgSGlkZXMgdGhlIGlkZW50aXR5IG9mIGFuIG9ic2VydmVyLlxuICAgKiBAcmV0dXJucyBBbiBvYnNlcnZlciB0aGF0IGhpZGVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3BlY2lmaWVkIG9ic2VydmVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmFzT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2ZXIoXG4gICAgICBmdW5jdGlvbiAoeCkgeyBzZWxmLm9uTmV4dCh4KTsgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5vbkVycm9yKGVycik7IH0sXG4gICAgICBmdW5jdGlvbiAoKSB7IHNlbGYub25Db21wbGV0ZWQoKTsgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDaGVja3MgYWNjZXNzIHRvIHRoZSBvYnNlcnZlciBmb3IgZ3JhbW1hciB2aW9sYXRpb25zLiBUaGlzIGluY2x1ZGVzIGNoZWNraW5nIGZvciBtdWx0aXBsZSBPbkVycm9yIG9yIE9uQ29tcGxldGVkIGNhbGxzLCBhcyB3ZWxsIGFzIHJlZW50cmFuY3kgaW4gYW55IG9mIHRoZSBvYnNlcnZlciBtZXRob2RzLlxuICAgKiAgSWYgYSB2aW9sYXRpb24gaXMgZGV0ZWN0ZWQsIGFuIEVycm9yIGlzIHRocm93biBmcm9tIHRoZSBvZmZlbmRpbmcgb2JzZXJ2ZXIgbWV0aG9kIGNhbGwuXG4gICAqIEByZXR1cm5zIEFuIG9ic2VydmVyIHRoYXQgY2hlY2tzIGNhbGxiYWNrcyBpbnZvY2F0aW9ucyBhZ2FpbnN0IHRoZSBvYnNlcnZlciBncmFtbWFyIGFuZCwgaWYgdGhlIGNoZWNrcyBwYXNzLCBmb3J3YXJkcyB0aG9zZSB0byB0aGUgc3BlY2lmaWVkIG9ic2VydmVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmNoZWNrZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ2hlY2tlZE9ic2VydmVyKHRoaXMpOyB9O1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhbiBvYnNlcnZlciBmcm9tIHRoZSBzcGVjaWZpZWQgT25OZXh0LCBhbG9uZyB3aXRoIG9wdGlvbmFsIE9uRXJyb3IsIGFuZCBPbkNvbXBsZXRlZCBhY3Rpb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25OZXh0XSBPYnNlcnZlcidzIE9uTmV4dCBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBPYnNlcnZlcidzIE9uRXJyb3IgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Db21wbGV0ZWRdIE9ic2VydmVyJ3MgT25Db21wbGV0ZWQgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2ZXJ9IFRoZSBvYnNlcnZlciBvYmplY3QgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIGdpdmVuIGFjdGlvbnMuXG4gICAqL1xuICB2YXIgb2JzZXJ2ZXJDcmVhdGUgPSBPYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgIG9uTmV4dCB8fCAob25OZXh0ID0gbm9vcCk7XG4gICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvcik7XG4gICAgb25Db21wbGV0ZWQgfHwgKG9uQ29tcGxldGVkID0gbm9vcCk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZlcihvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgZnJvbSBhIG5vdGlmaWNhdGlvbiBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBBY3Rpb24gdGhhdCBoYW5kbGVzIGEgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHRoYXQgaW52b2tlcyB0aGUgc3BlY2lmaWVkIGhhbmRsZXIgdXNpbmcgYSBub3RpZmljYXRpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG1lc3NhZ2UgaXQgcmVjZWl2ZXMuXG4gICAqL1xuICBPYnNlcnZlci5mcm9tTm90aWZpZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgdGhpc0FyZykge1xuICAgIHZhciBjYiA9IGJpbmRDYWxsYmFjayhoYW5kbGVyLCB0aGlzQXJnLCAxKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gY2Iobm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0KHgpKTtcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGNiKG5vdGlmaWNhdGlvbkNyZWF0ZU9uRXJyb3IoZSkpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYihub3RpZmljYXRpb25DcmVhdGVPbkNvbXBsZXRlZCgpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVzIHRoZSBpbnZvY2F0aW9uIG9mIG9ic2VydmVyIG1ldGhvZHMgb24gdGhlIGdpdmVuIHNjaGVkdWxlci5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gc2NoZWR1bGUgb2JzZXJ2ZXIgbWVzc2FnZXMgb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZlcn0gT2JzZXJ2ZXIgd2hvc2UgbWVzc2FnZXMgYXJlIHNjaGVkdWxlZCBvbiB0aGUgZ2l2ZW4gc2NoZWR1bGVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLm5vdGlmeU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2ZU9uT2JzZXJ2ZXIoc2NoZWR1bGVyLCB0aGlzKTtcbiAgfTtcblxuICBPYnNlcnZlci5wcm90b3R5cGUubWFrZVNhZmUgPSBmdW5jdGlvbihkaXNwb3NhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTYWZlT2JzZXJ2ZXIodGhpcy5fb25OZXh0LCB0aGlzLl9vbkVycm9yLCB0aGlzLl9vbkNvbXBsZXRlZCwgZGlzcG9zYWJsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgT2JzZXJ2ZXIgY2xhc3MuXG4gICAqIFRoaXMgYmFzZSBjbGFzcyBlbmZvcmNlcyB0aGUgZ3JhbW1hciBvZiBvYnNlcnZlcnMgd2hlcmUgT25FcnJvciBhbmQgT25Db21wbGV0ZWQgYXJlIHRlcm1pbmFsIG1lc3NhZ2VzLlxuICAgKi9cbiAgdmFyIEFic3RyYWN0T2JzZXJ2ZXIgPSBSeC5pbnRlcm5hbHMuQWJzdHJhY3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQWJzdHJhY3RPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JzZXJ2ZXIgaW4gYSBub24tc3RvcHBlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdE9ic2VydmVyKCkge1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IG90aGVyIG9ic2VydmVyc1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBub3RJbXBsZW1lbnRlZDtcbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IG5vdEltcGxlbWVudGVkO1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIG9ic2VydmVyIG9mIGEgbmV3IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBOZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm9uTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMubmV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBvYnNlcnZlciB0aGF0IGFuIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQuXG4gICAgICogQHBhcmFtIHtBbnl9IGVycm9yIFRoZSBlcnJvciB0aGF0IGhhcyBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBvYnNlcnZlciBvZiB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgb2JzZXJ2ZXIsIGNhdXNpbmcgaXQgdG8gdHJhbnNpdGlvbiB0byB0aGUgc3RvcHBlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmlzU3RvcHBlZCA9IHRydWU7IH07XG5cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3RPYnNlcnZlcjtcbiAgfShPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDbGFzcyB0byBjcmVhdGUgYW4gT2JzZXJ2ZXIgaW5zdGFuY2UgZnJvbSBkZWxlZ2F0ZS1iYXNlZCBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIG9uKiBtZXRob2RzLlxuICAgKi9cbiAgdmFyIEFub255bW91c09ic2VydmVyID0gUnguQW5vbnltb3VzT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEFub255bW91c09ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZlciBmcm9tIHRoZSBzcGVjaWZpZWQgT25OZXh0LCBPbkVycm9yLCBhbmQgT25Db21wbGV0ZWQgYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0FueX0gb25OZXh0IE9ic2VydmVyJ3MgT25OZXh0IGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gb25FcnJvciBPYnNlcnZlcidzIE9uRXJyb3IgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSBvbkNvbXBsZXRlZCBPYnNlcnZlcidzIE9uQ29tcGxldGVkIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNPYnNlcnZlcihvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTmV4dCA9IG9uTmV4dDtcbiAgICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgdGhpcy5fb25Db21wbGV0ZWQgPSBvbkNvbXBsZXRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgb25OZXh0IGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgTmV4dCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBBbm9ueW1vdXNPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5fb25OZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG9uRXJyb3IgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSBlcnJvciBUaGUgZXJyb3IgdGhhdCBoYXMgb2NjdXJyZWQuXG4gICAgICovXG4gICAgQW5vbnltb3VzT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB0aGlzLl9vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIENhbGxzIHRoZSBvbkNvbXBsZXRlZCBhY3Rpb24uXG4gICAgICovXG4gICAgQW5vbnltb3VzT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBbm9ueW1vdXNPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIENoZWNrZWRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ2hlY2tlZE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tlZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLl9zdGF0ZSA9IDA7IC8vIDAgLSBpZGxlLCAxIC0gYnVzeSwgMiAtIGRvbmVcbiAgICB9XG5cbiAgICB2YXIgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlID0gQ2hlY2tlZE9ic2VydmVyLnByb3RvdHlwZTtcblxuICAgIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZS5vbk5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuY2hlY2tBY2Nlc3MoKTtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYnNlcnZlci5vbk5leHQpLmNhbGwodGhpcy5fb2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICAgIHJlcyA9PT0gZXJyb3JPYmogJiYgdGhyb3dlcihyZXMuZSk7XG4gICAgfTtcblxuICAgIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdGhpcy5jaGVja0FjY2VzcygpO1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29ic2VydmVyLm9uRXJyb3IpLmNhbGwodGhpcy5fb2JzZXJ2ZXIsIGVycik7XG4gICAgICB0aGlzLl9zdGF0ZSA9IDI7XG4gICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgIH07XG5cbiAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNoZWNrQWNjZXNzKCk7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fb2JzZXJ2ZXIub25Db21wbGV0ZWQpLmNhbGwodGhpcy5fb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fc3RhdGUgPSAyO1xuICAgICAgcmVzID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlcy5lKTtcbiAgICB9O1xuXG4gICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLmNoZWNrQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAxKSB7IHRocm93IG5ldyBFcnJvcignUmUtZW50cmFuY3kgZGV0ZWN0ZWQnKTsgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAyKSB7IHRocm93IG5ldyBFcnJvcignT2JzZXJ2ZXIgY29tcGxldGVkJyk7IH1cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMCkgeyB0aGlzLl9zdGF0ZSA9IDE7IH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENoZWNrZWRPYnNlcnZlcjtcbiAgfShPYnNlcnZlcikpO1xuXG4gIHZhciBTY2hlZHVsZWRPYnNlcnZlciA9IFJ4LmludGVybmFscy5TY2hlZHVsZWRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2NoZWR1bGVkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTY2hlZHVsZWRPYnNlcnZlcihzY2hlZHVsZXIsIG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5pc0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0ZhdWx0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZU5leHQob2JzZXJ2ZXIsIHgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgb2JzZXJ2ZXIub25OZXh0KHgpOyB9OyB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUVycm9yKG9ic2VydmVyLCBlKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IG9ic2VydmVyLm9uRXJyb3IoZSk7IH07IH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29tcGxldGVkKG9ic2VydmVyKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IG9ic2VydmVyLm9uQ29tcGxldGVkKCk7IH07IH1cblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaChlbnF1ZXVlTmV4dCh0aGlzLm9ic2VydmVyLCB4KSk7XG4gICAgfTtcblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZW5xdWV1ZUVycm9yKHRoaXMub2JzZXJ2ZXIsIGUpKTtcbiAgICB9O1xuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaChlbnF1ZXVlQ29tcGxldGVkKHRoaXMub2JzZXJ2ZXIpKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgdmFyIHdvcms7XG4gICAgICBpZiAoc3RhdGUucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB3b3JrID0gc3RhdGUucXVldWUuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmlzQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHdvcmspKCk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IFtdO1xuICAgICAgICBzdGF0ZS5oYXNGYXVsdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRocm93ZXIocmVzLmUpO1xuICAgICAgfVxuICAgICAgcmVjdXJzZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmVuc3VyZUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc093bmVyID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuaGFzRmF1bHRlZCAmJiB0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXNPd25lciA9ICF0aGlzLmlzQWNxdWlyZWQ7XG4gICAgICAgIHRoaXMuaXNBY3F1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpc093bmVyICYmXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHRoaXMsIHNjaGVkdWxlTWV0aG9kKSk7XG4gICAgfTtcblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZWR1bGVkT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBPYnNlcnZlT25PYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT2JzZXJ2ZU9uT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZlT25PYnNlcnZlcihzY2hlZHVsZXIsIG9ic2VydmVyLCBjYW5jZWwpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIHNjaGVkdWxlciwgb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fY2FuY2VsID0gY2FuY2VsO1xuICAgIH1cblxuICAgIE9ic2VydmVPbk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xuICAgIH07XG5cbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpO1xuICAgICAgdGhpcy5lbnN1cmVBY3RpdmUoKTtcbiAgICB9O1xuXG4gICAgT2JzZXJ2ZU9uT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuY29tcGxldGVkLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xuICAgIH07XG5cbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fY2FuY2VsICYmIHRoaXMuX2NhbmNlbC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYW5jZWwgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JzZXJ2ZU9uT2JzZXJ2ZXI7XG4gIH0pKFNjaGVkdWxlZE9ic2VydmVyKTtcblxuICB2YXIgb2JzZXJ2YWJsZVByb3RvO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcHVzaC1zdHlsZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgdmFyIE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIG1ha2VTdWJzY3JpYmUoc2VsZiwgc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIG9sZE9uRXJyb3IgPSBvLm9uRXJyb3I7XG4gICAgICAgIG8ub25FcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGUsIHNlbGYpO1xuICAgICAgICAgIG9sZE9uRXJyb3IuY2FsbChvLCBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlLmNhbGwoc2VsZiwgbyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG4gICAgICBpZiAoUnguY29uZmlnLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHZhciBvbGRTdWJzY3JpYmUgPSB0aGlzLl9zdWJzY3JpYmU7XG4gICAgICAgIHZhciBlID0gdHJ5Q2F0Y2godGhyb3dlcikobmV3IEVycm9yKCkpLmU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoJ1xcbicpICsgMSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IG1ha2VTdWJzY3JpYmUodGhpcywgb2xkU3Vic2NyaWJlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYnNlcnZhYmxlUHJvdG8gPSBPYnNlcnZhYmxlLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gT2JzZXJ2YWJsZVxuICAgICogQHBhcmFtIHtBbnl9IEFuIG9iamVjdCB0byBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBhbiBPYnNlcnZhYmxlXG4gICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBhbiBPYnNlcnZhYmxlLCBlbHNlIGZhbHNlLlxuICAgICovXG4gICAgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8gJiYgaXNGdW5jdGlvbihvLnN1YnNjcmliZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBTdWJzY3JpYmVzIGFuIG8gdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogIEBwYXJhbSB7TWl4ZWR9IFtvT3JPbk5leHRdIFRoZSBvYmplY3QgdGhhdCBpcyB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb3IgYW4gYWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQWN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Db21wbGV0ZWRdIEFjdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiAgQHJldHVybnMge0RpcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZSA9IG9ic2VydmFibGVQcm90by5mb3JFYWNoID0gZnVuY3Rpb24gKG9Pck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUodHlwZW9mIG9Pck9uTmV4dCA9PT0gJ29iamVjdCcgP1xuICAgICAgICBvT3JPbk5leHQgOlxuICAgICAgICBvYnNlcnZlckNyZWF0ZShvT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIG5leHQgdmFsdWUgaW4gdGhlIHNlcXVlbmNlIHdpdGggYW4gb3B0aW9uYWwgXCJ0aGlzXCIgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb24gZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRpc3Bvc2FibGUgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT25OZXh0ID0gZnVuY3Rpb24gKG9uTmV4dCwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlckNyZWF0ZSh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcgPyBmdW5jdGlvbih4KSB7IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgpOyB9IDogb25OZXh0KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gYW4gZXhjZXB0aW9uYWwgY29uZGl0aW9uIGluIHRoZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIFwidGhpc1wiIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRpc3Bvc2FibGUgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT25FcnJvciA9IGZ1bmN0aW9uIChvbkVycm9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKG9ic2VydmVyQ3JlYXRlKG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKGUpIHsgb25FcnJvci5jYWxsKHRoaXNBcmcsIGUpOyB9IDogb25FcnJvcikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIFwidGhpc1wiIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uQ29tcGxldGVkID0gZnVuY3Rpb24gKG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKG9ic2VydmVyQ3JlYXRlKG51bGwsIG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKCkgeyBvbkNvbXBsZXRlZC5jYWxsKHRoaXNBcmcpOyB9IDogb25Db21wbGV0ZWQpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG4gIH0pKCk7XG5cbiAgdmFyIE9ic2VydmFibGVCYXNlID0gUnguT2JzZXJ2YWJsZUJhc2UgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9ic2VydmFibGVCYXNlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gZml4U3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlciAmJiBpc0Z1bmN0aW9uKHN1YnNjcmliZXIuZGlzcG9zZSkgPyBzdWJzY3JpYmVyIDpcbiAgICAgICAgaXNGdW5jdGlvbihzdWJzY3JpYmVyKSA/IGRpc3Bvc2FibGVDcmVhdGUoc3Vic2NyaWJlcikgOiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGlzcG9zYWJsZShzLCBzdGF0ZSkge1xuICAgICAgdmFyIGFkbyA9IHN0YXRlWzBdLCBzZWxmID0gc3RhdGVbMV07XG4gICAgICB2YXIgc3ViID0gdHJ5Q2F0Y2goc2VsZi5zdWJzY3JpYmVDb3JlKS5jYWxsKHNlbGYsIGFkbyk7XG4gICAgICBpZiAoc3ViID09PSBlcnJvck9iaiAmJiAhYWRvLmZhaWwoZXJyb3JPYmouZSkpIHsgdGhyb3dlcihlcnJvck9iai5lKTsgfVxuICAgICAgYWRvLnNldERpc3Bvc2FibGUoZml4U3Vic2NyaWJlcihzdWIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlQmFzZSgpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE9ic2VydmFibGVCYXNlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhZG8gPSBuZXcgQXV0b0RldGFjaE9ic2VydmVyKG8pLCBzdGF0ZSA9IFthZG8sIHRoaXNdO1xuXG4gICAgICBpZiAoY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlcXVpcmVkKCkpIHtcbiAgICAgICAgY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgc2V0RGlzcG9zYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREaXNwb3NhYmxlKG51bGwsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZG87XG4gICAgfTtcblxuICAgIE9ic2VydmFibGVCYXNlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZUJhc2U7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG52YXIgRmxhdE1hcE9ic2VydmFibGUgPSBSeC5GbGF0TWFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcblxuICAgIGluaGVyaXRzKEZsYXRNYXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRmxhdE1hcE9ic2VydmFibGUoc291cmNlLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSA/IHJlc3VsdFNlbGVjdG9yIDogbnVsbDtcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBiaW5kQ2FsbGJhY2soaXNGdW5jdGlvbihzZWxlY3RvcikgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZWN0b3I7IH0sIHRoaXNBcmcsIDMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGbGF0TWFwT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIobywgdGhpcy5zZWxlY3RvciwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcykpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKG9ic2VydmVyLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHNvdXJjZSkge1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5vID0gb2JzZXJ2ZXI7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuX3dyYXBSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHQsIHgsIGkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdFNlbGVjdG9yID9cbiAgICAgICAgcmVzdWx0Lm1hcChmdW5jdGlvbih5LCBpMikgeyByZXR1cm4gdGhpcy5yZXN1bHRTZWxlY3Rvcih4LCB5LCBpLCBpMik7IH0sIHRoaXMpIDpcbiAgICAgICAgcmVzdWx0O1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGkgPSB0aGlzLmkrKztcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLnNlbGVjdG9yKSh4LCBpLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG5cbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAoaXNBcnJheUxpa2UocmVzdWx0KSB8fCBpc0l0ZXJhYmxlKHJlc3VsdCkpICYmIChyZXN1bHQgPSBPYnNlcnZhYmxlLmZyb20ocmVzdWx0KSk7XG4gICAgICB0aGlzLm8ub25OZXh0KHRoaXMuX3dyYXBSZXN1bHQocmVzdWx0LCB4LCBpKSk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkgeyB0aGlzLm8ub25FcnJvcihlKTsgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkgeyB0aGlzLm8ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBGbGF0TWFwT2JzZXJ2YWJsZTtcblxufShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFbnVtZXJhYmxlID0gUnguaW50ZXJuYWxzLkVudW1lcmFibGUgPSBmdW5jdGlvbiAoKSB7IH07XG5cbiAgZnVuY3Rpb24gSXNEaXNwb3NlZERpc3Bvc2FibGUoc3RhdGUpIHtcbiAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICBJc0Rpc3Bvc2VkRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3MuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIGlmIChzdGF0ZS5pc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxuICAgICAgdmFyIGN1cnJlbnRJdGVtID0gdHJ5Q2F0Y2goc3RhdGUuZS5uZXh0KS5jYWxsKHN0YXRlLmUpO1xuICAgICAgaWYgKGN1cnJlbnRJdGVtID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKGN1cnJlbnRJdGVtLmUpOyB9XG4gICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkgeyByZXR1cm4gc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgIGlzUHJvbWlzZShjdXJyZW50VmFsdWUpICYmIChjdXJyZW50VmFsdWUgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoY3VycmVudFZhbHVlKSk7XG5cbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBzdGF0ZS5zdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShjdXJyZW50VmFsdWUuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgIH1cblxuICAgIENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBpc0Rpc3Bvc2VkOiBmYWxzZSxcbiAgICAgICAgbzogbyxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgICAgIGU6IHRoaXMuc291cmNlc1skaXRlcmF0b3IkXSgpXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2FuY2VsYWJsZSA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSwgbmV3IElzRGlzcG9zZWREaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zdGF0ZS5vLm9uRXJyb3IoZSk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZWN1cnNlKHRoaXMuX3N0YXRlKTsgfTtcblxuICAgIHJldHVybiBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIEVudW1lcmFibGUucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBDYXRjaEVycm9yT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBmdW5jdGlvbiBDYXRjaEVycm9yT2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoQ2F0Y2hFcnJvck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmlzRGlzcG9zZWQpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgY3VycmVudEl0ZW0gPSB0cnlDYXRjaChzdGF0ZS5lLm5leHQpLmNhbGwoc3RhdGUuZSk7XG4gICAgICBpZiAoY3VycmVudEl0ZW0gPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IoY3VycmVudEl0ZW0uZSk7IH1cbiAgICAgIGlmIChjdXJyZW50SXRlbS5kb25lKSB7IHJldHVybiBzdGF0ZS5sYXN0RXJyb3IgIT09IG51bGwgPyBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUubGFzdEVycm9yKSA6IHN0YXRlLm8ub25Db21wbGV0ZWQoKTsgfVxuXG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudEl0ZW0udmFsdWU7XG4gICAgICBpc1Byb21pc2UoY3VycmVudFZhbHVlKSAmJiAoY3VycmVudFZhbHVlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkpKTtcbiAgICB9XG5cbiAgICBDYXRjaEVycm9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIGU6IHRoaXMuc291cmNlc1skaXRlcmF0b3IkXSgpLFxuICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbixcbiAgICAgICAgbGFzdEVycm9yOiBudWxsLFxuICAgICAgICBvOiBvXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2FuY2VsYWJsZSA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSwgbmV3IElzRGlzcG9zZWREaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zdGF0ZS5sYXN0RXJyb3IgPSBlOyB0aGlzLl9yZWN1cnNlKHRoaXMuX3N0YXRlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3N0YXRlLm8ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBDYXRjaEVycm9yT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIEVudW1lcmFibGUucHJvdG90eXBlLmNhdGNoRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDYXRjaEVycm9yT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgUmVwZWF0RW51bWVyYWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVwZWF0RW51bWVyYWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZXBlYXRFbnVtZXJhYmxlKHYsIGMpIHtcbiAgICAgIHRoaXMudiA9IHY7XG4gICAgICB0aGlzLmMgPSBjID09IG51bGwgPyAtMSA6IGM7XG4gICAgfVxuXG4gICAgUmVwZWF0RW51bWVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcGVhdEVudW1lcmF0b3IodGhpcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlcGVhdEVudW1lcmF0b3IocCkge1xuICAgICAgdGhpcy52ID0gcC52O1xuICAgICAgdGhpcy5sID0gcC5jO1xuICAgIH1cblxuICAgIFJlcGVhdEVudW1lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5sID09PSAwKSB7IHJldHVybiBkb25lRW51bWVyYXRvcjsgfVxuICAgICAgaWYgKHRoaXMubCA+IDApIHsgdGhpcy5sLS07IH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy52IH07XG4gICAgfTtcblxuICAgIHJldHVybiBSZXBlYXRFbnVtZXJhYmxlO1xuICB9KEVudW1lcmFibGUpKTtcblxuICB2YXIgZW51bWVyYWJsZVJlcGVhdCA9IEVudW1lcmFibGUucmVwZWF0ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBlYXRDb3VudCkge1xuICAgIHJldHVybiBuZXcgUmVwZWF0RW51bWVyYWJsZSh2YWx1ZSwgcmVwZWF0Q291bnQpO1xuICB9O1xuXG4gIHZhciBPZkVudW1lcmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT2ZFbnVtZXJhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9mRW51bWVyYWJsZShzLCBmbiwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zID0gcztcbiAgICAgIHRoaXMuZm4gPSBmbiA/IGJpbmRDYWxsYmFjayhmbiwgdGhpc0FyZywgMykgOiBudWxsO1xuICAgIH1cbiAgICBPZkVudW1lcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBPZkVudW1lcmF0b3IodGhpcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIE9mRW51bWVyYXRvcihwKSB7XG4gICAgICB0aGlzLmkgPSAtMTtcbiAgICAgIHRoaXMucyA9IHAucztcbiAgICAgIHRoaXMubCA9IHRoaXMucy5sZW5ndGg7XG4gICAgICB0aGlzLmZuID0gcC5mbjtcbiAgICB9XG5cbiAgICBPZkVudW1lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgIHJldHVybiArK3RoaXMuaSA8IHRoaXMubCA/XG4gICAgICAgeyBkb25lOiBmYWxzZSwgdmFsdWU6ICF0aGlzLmZuID8gdGhpcy5zW3RoaXMuaV0gOiB0aGlzLmZuKHRoaXMuc1t0aGlzLmldLCB0aGlzLmksIHRoaXMucykgfSA6XG4gICAgICAgZG9uZUVudW1lcmF0b3I7XG4gICAgfTtcblxuICAgIHJldHVybiBPZkVudW1lcmFibGU7XG4gIH0oRW51bWVyYWJsZSkpO1xuXG4gIHZhciBlbnVtZXJhYmxlT2YgPSBFbnVtZXJhYmxlLm9mID0gZnVuY3Rpb24gKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IE9mRW51bWVyYWJsZShzb3VyY2UsIHNlbGVjdG9yLCB0aGlzQXJnKTtcbiAgfTtcblxudmFyIE9ic2VydmVPbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICBpbmhlcml0cyhPYnNlcnZlT25PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICBmdW5jdGlvbiBPYnNlcnZlT25PYnNlcnZhYmxlKHNvdXJjZSwgcykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX3MgPSBzO1xuICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgT2JzZXJ2ZU9uT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uT2JzZXJ2ZXIodGhpcy5fcywgbykpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZlT25PYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gICAvKipcbiAgICogIFdyYXBzIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaW4gb3JkZXIgdG8gcnVuIGl0cyBvYnNlcnZlciBjYWxsYmFja3Mgb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqXG4gICAqICBUaGlzIG9ubHkgaW52b2tlcyBvYnNlcnZlciBjYWxsYmFja3Mgb24gYSBzY2hlZHVsZXIuIEluIGNhc2UgdGhlIHN1YnNjcmlwdGlvbiBhbmQvb3IgdW5zdWJzY3JpcHRpb24gYWN0aW9ucyBoYXZlIHNpZGUtZWZmZWN0c1xuICAgKiAgdGhhdCByZXF1aXJlIHRvIGJlIHJ1biBvbiBhIHNjaGVkdWxlciwgdXNlIHN1YnNjcmliZU9uLlxuICAgKlxuICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gbm90aWZ5IG9ic2VydmVycyBvbi5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdob3NlIG9ic2VydmF0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ub2JzZXJ2ZU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2ZU9uT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTdWJzY3JpYmVPbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN1YnNjcmliZU9uT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVPbk9ic2VydmFibGUoc291cmNlLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc2NoZWR1bGVyLCBzdGF0ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlWzBdLCBkID0gc3RhdGVbMV0sIG8gPSBzdGF0ZVsyXTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShuZXcgU2NoZWR1bGVkRGlzcG9zYWJsZShzY2hlZHVsZXIsIHNvdXJjZS5zdWJzY3JpYmUobykpKTtcbiAgICB9XG5cbiAgICBTdWJzY3JpYmVPbk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSwgZCA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUobSk7XG4gICAgICBtLnNldERpc3Bvc2FibGUodGhpcy5fcy5zY2hlZHVsZShbdGhpcy5zb3VyY2UsIGQsIG9dLCBzY2hlZHVsZU1ldGhvZCkpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJzY3JpYmVPbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAgLyoqXG4gICAqICBXcmFwcyB0aGUgc291cmNlIHNlcXVlbmNlIGluIG9yZGVyIHRvIHJ1biBpdHMgc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiBsb2dpYyBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci4gVGhpcyBvcGVyYXRpb24gaXMgbm90IGNvbW1vbmx5IHVzZWQ7XG4gICAqICBzZWUgdGhlIHJlbWFya3Mgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBzdWJzY3JpYmVPbiBhbmQgb2JzZXJ2ZU9uLlxuXG4gICAqICBUaGlzIG9ubHkgcGVyZm9ybXMgdGhlIHNpZGUtZWZmZWN0cyBvZiBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLiBJbiBvcmRlciB0byBpbnZva2Ugb2JzZXJ2ZXJcbiAgICogIGNhbGxiYWNrcyBvbiBhIHNjaGVkdWxlciwgdXNlIG9ic2VydmVPbi5cblxuICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcGVyZm9ybSBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIGFjdGlvbnMgb24uXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSB3aG9zZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMgaGFwcGVuIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlT25PYnNlcnZhYmxlKHRoaXMsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIEZyb21Qcm9taXNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGcm9tUHJvbWlzZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRnJvbVByb21pc2VPYnNlcnZhYmxlKHAsIHMpIHtcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU5leHQocywgc3RhdGUpIHtcbiAgICAgIHZhciBvID0gc3RhdGVbMF0sIGRhdGEgPSBzdGF0ZVsxXTtcbiAgICAgIG8ub25OZXh0KGRhdGEpO1xuICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRXJyb3Iocywgc3RhdGUpIHtcbiAgICAgIHZhciBvID0gc3RhdGVbMF0sIGVyciA9IHN0YXRlWzFdO1xuICAgICAgby5vbkVycm9yKGVycik7XG4gICAgfVxuXG4gICAgRnJvbVByb21pc2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBzZWxmID0gdGhpcywgcCA9IHRoaXMuX3A7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHApKSB7XG4gICAgICAgIHAgPSB0cnlDYXRjaChwKSgpO1xuICAgICAgICBpZiAocCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICBvLm9uRXJyb3IocC5lKTtcbiAgICAgICAgICByZXR1cm4gc2FkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzZWxmLl9zLnNjaGVkdWxlKFtvLCBkYXRhXSwgc2NoZWR1bGVOZXh0KSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzZWxmLl9zLnNjaGVkdWxlKFtvLCBlcnJdLCBzY2hlZHVsZUVycm9yKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2FkO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbVByb21pc2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogQ29udmVydHMgYSBQcm9taXNlIHRvIGFuIE9ic2VydmFibGUgc2VxdWVuY2VcbiAgKiBAcGFyYW0ge1Byb21pc2V9IEFuIEVTNiBDb21wbGlhbnQgcHJvbWlzZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCB3cmFwcyB0aGUgZXhpc3RpbmcgcHJvbWlzZSBzdWNjZXNzIGFuZCBmYWlsdXJlLlxuICAqL1xuICB2YXIgb2JzZXJ2YWJsZUZyb21Qcm9taXNlID0gT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzY2hlZHVsZXIpIHtcbiAgICBzY2hlZHVsZXIgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbVByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgLypcbiAgICogQ29udmVydHMgYW4gZXhpc3Rpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBFUzYgQ29tcGF0aWJsZSBQcm9taXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwcm9taXNlID0gUnguT2JzZXJ2YWJsZS5yZXR1cm4oNDIpLnRvUHJvbWlzZShSU1ZQLlByb21pc2UpO1xuICAgKlxuICAgKiAvLyBXaXRoIGNvbmZpZ1xuICAgKiBSeC5jb25maWcuUHJvbWlzZSA9IFJTVlAuUHJvbWlzZTtcbiAgICogdmFyIHByb21pc2UgPSBSeC5PYnNlcnZhYmxlLnJldHVybig0MikudG9Qcm9taXNlKCk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9taXNlQ3Rvcl0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwcm9taXNlLiBJZiBub3QgcHJvdmlkZWQsIGl0IGxvb2tzIGZvciBpdCBpbiBSeC5jb25maWcuUHJvbWlzZS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEFuIEVTNiBjb21wYXRpYmxlIHByb21pc2Ugd2l0aCB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlQ3Rvcikge1xuICAgIHByb21pc2VDdG9yIHx8IChwcm9taXNlQ3RvciA9IFJ4LmNvbmZpZy5Qcm9taXNlKTtcbiAgICBpZiAoIXByb21pc2VDdG9yKSB7IHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignUHJvbWlzZSB0eXBlIG5vdCBwcm92aWRlZCBub3IgaW4gUnguY29uZmlnLlByb21pc2UnKTsgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gTm8gY2FuY2VsbGF0aW9uIGNhbiBiZSBkb25lXG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhbHVlID0gdjtcbiAgICAgIH0sIHJlamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBUb0FycmF5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb0FycmF5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUb0FycmF5T2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9BcnJheU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5hID0gW107XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIFxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLmEucHVzaCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuby5vbkVycm9yKGUpOyAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuby5vbk5leHQodGhpcy5hKTsgdGhpcy5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gVG9BcnJheU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBhIGxpc3QgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICovXG4gIG9ic2VydmFibGVQcm90by50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVG9BcnJheU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBhIHNwZWNpZmllZCBzdWJzY3JpYmUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB9ICk7XG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBSeC5EaXNwb3NhYmxlLmVtcHR5OyB9ICk7XG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IH0gKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIEltcGxlbWVudGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSdzIHN1YnNjcmliZSBtZXRob2QsIHJldHVybmluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB3cmFwcGVkIGluIGEgRGlzcG9zYWJsZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFN1YnNjcmliZSBtZXRob2QuXG4gICAqL1xuICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUsIHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShzdWJzY3JpYmUsIHBhcmVudCk7XG4gIH07XG5cbiAgdmFyIERlZmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlZmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlZmVyKGZhY3RvcnkpIHtcbiAgICAgIHRoaXMuX2YgPSBmYWN0b3J5O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVmZXIucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2YpKCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gb2JzZXJ2YWJsZVRocm93KHJlc3VsdC5lKS5zdWJzY3JpYmUobyk7fVxuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgIHJldHVybiByZXN1bHQuc3Vic2NyaWJlKG8pO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVmZXI7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGludm9rZXMgdGhlIHNwZWNpZmllZCBmYWN0b3J5IGZ1bmN0aW9uIHdoZW5ldmVyIGEgbmV3IG9ic2VydmVyIHN1YnNjcmliZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLmZyb21BcnJheShbMSwyLDNdKTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ic2VydmFibGVGYWN0b3J5IE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggb2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2Ugb3IgUHJvbWlzZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2Ugb2JzZXJ2ZXJzIHRyaWdnZXIgYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gb2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVEZWZlciA9IE9ic2VydmFibGUuZGVmZXIgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IERlZmVyKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgfTtcblxuICB2YXIgRW1wdHlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEVtcHR5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEVtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHNpbmsgPSBuZXcgRW1wdHlTaW5rKG9ic2VydmVyLCB0aGlzLnNjaGVkdWxlcik7XG4gICAgICByZXR1cm4gc2luay5ydW4oKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRW1wdHlTaW5rKG9ic2VydmVyLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzdGF0ZSkge1xuICAgICAgc3RhdGUub25Db21wbGV0ZWQoKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgRW1wdHlTaW5rLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgP1xuICAgICAgICBzY2hlZHVsZUl0ZW0obnVsbCwgc3RhdGUpIDpcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNjaGVkdWxlSXRlbSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRU1QVFlfT0JTRVJWQUJMRSA9IG5ldyBFbXB0eU9ic2VydmFibGUoaW1tZWRpYXRlU2NoZWR1bGVyKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gZW1wdHkgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIHNpbmdsZSBPbkNvbXBsZXRlZCBtZXNzYWdlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKTtcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmVtcHR5KFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBzZW5kIHRoZSB0ZXJtaW5hdGlvbiBjYWxsIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIG5vIGVsZW1lbnRzLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVFbXB0eSA9IE9ic2VydmFibGUuZW1wdHkgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgPyBFTVBUWV9PQlNFUlZBQkxFIDogbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGcm9tT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGcm9tT2JzZXJ2YWJsZShpdGVyYWJsZSwgZm4sIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTY2hlZHVsZU1ldGhvZChvLCBpdCwgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wUmVjdXJzaXZlKGksIHJlY3Vyc2UpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0cnlDYXRjaChpdC5uZXh0KS5jYWxsKGl0KTtcbiAgICAgICAgaWYgKG5leHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IobmV4dC5lKTsgfVxuICAgICAgICBpZiAobmV4dC5kb25lKSB7IHJldHVybiBvLm9uQ29tcGxldGVkKCk7IH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dC52YWx1ZTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaChmbikocmVzdWx0LCBpKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgcmVjdXJzZShpICsgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMuX2l0ZXJhYmxlKSxcbiAgICAgICAgICBpdCA9IGdldEl0ZXJhYmxlKGxpc3QpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKDAsIGNyZWF0ZVNjaGVkdWxlTWV0aG9kKG8sIGl0LCB0aGlzLl9mbikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhYmxlKHMpIHtcbiAgICB0aGlzLl9zID0gcztcbiAgfVxuXG4gIFN0cmluZ0l0ZXJhYmxlLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKHRoaXMuX3MpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKHMpIHtcbiAgICB0aGlzLl9zID0gcztcbiAgICB0aGlzLl9sID0gcy5sZW5ndGg7XG4gICAgdGhpcy5faSA9IDA7XG4gIH1cblxuICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2kgPCB0aGlzLl9sID8geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3MuY2hhckF0KHRoaXMuX2krKykgfSA6IGRvbmVFbnVtZXJhdG9yO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFycmF5SXRlcmFibGUoYSkge1xuICAgIHRoaXMuX2EgPSBhO1xuICB9XG5cbiAgQXJyYXlJdGVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKHRoaXMuX2EpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoYSkge1xuICAgIHRoaXMuX2EgPSBhO1xuICAgIHRoaXMuX2wgPSB0b0xlbmd0aChhKTtcbiAgICB0aGlzLl9pID0gMDtcbiAgfVxuXG4gIEFycmF5SXRlcmF0b3IucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2kgPCB0aGlzLl9sID8geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX2FbdGhpcy5faSsrXSB9IDogZG9uZUVudW1lcmF0b3I7XG4gIH07XG5cbiAgZnVuY3Rpb24gbnVtYmVySXNGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByb290LmlzRmluaXRlKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmFuKG4pIHtcbiAgICByZXR1cm4gbiAhPT0gbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhYmxlKG8pIHtcbiAgICB2YXIgaSA9IG9bJGl0ZXJhdG9yJF0sIGl0O1xuICAgIGlmICghaSAmJiB0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGl0ID0gbmV3IFN0cmluZ0l0ZXJhYmxlKG8pO1xuICAgICAgcmV0dXJuIGl0WyRpdGVyYXRvciRdKCk7XG4gICAgfVxuICAgIGlmICghaSAmJiBvLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdCA9IG5ldyBBcnJheUl0ZXJhYmxlKG8pO1xuICAgICAgcmV0dXJuIGl0WyRpdGVyYXRvciRdKCk7XG4gICAgfVxuICAgIGlmICghaSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGl0ZXJhYmxlJyk7IH1cbiAgICByZXR1cm4gb1skaXRlcmF0b3IkXSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbih2YWx1ZSkge1xuICAgIHZhciBudW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKG51bWJlciA9PT0gMCkgeyByZXR1cm4gbnVtYmVyOyB9XG4gICAgaWYgKGlzTmFOKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgIHJldHVybiBudW1iZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9MZW5ndGgobykge1xuICAgIHZhciBsZW4gPSArby5sZW5ndGg7XG4gICAgaWYgKGlzTmFOKGxlbikpIHsgcmV0dXJuIDA7IH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7IHJldHVybiBsZW47IH1cbiAgICBsZW4gPSBzaWduKGxlbikgKiBNYXRoLmZsb29yKE1hdGguYWJzKGxlbikpO1xuICAgIGlmIChsZW4gPD0gMCkgeyByZXR1cm4gMDsgfVxuICAgIGlmIChsZW4gPiBtYXhTYWZlSW50ZWdlcikgeyByZXR1cm4gbWF4U2FmZUludGVnZXI7IH1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLyoqXG4gICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYW4gYXJyYXktbGlrZSBvciBpdGVyYWJsZSBvYmplY3QuXG4gICogQHBhcmFtIHtBbnl9IGFycmF5TGlrZSBBbiBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdCB0byBjb252ZXJ0IHRvIGFuIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW21hcEZuXSBNYXAgZnVuY3Rpb24gdG8gY2FsbCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIFRoZSBjb250ZXh0IHRvIHVzZSBjYWxsaW5nIHRoZSBtYXBGbiBpZiBwcm92aWRlZC5cbiAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gT3B0aW9uYWwgc2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZy4gIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQuXG4gICovXG4gIHZhciBvYnNlcnZhYmxlRnJvbSA9IE9ic2VydmFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgbWFwRm4sIHRoaXNBcmcsIHNjaGVkdWxlcikge1xuICAgIGlmIChpdGVyYWJsZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhYmxlIGNhbm5vdCBiZSBudWxsLicpXG4gICAgfVxuICAgIGlmIChtYXBGbiAmJiAhaXNGdW5jdGlvbihtYXBGbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFwRm4gd2hlbiBwcm92aWRlZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgaWYgKG1hcEZuKSB7XG4gICAgICB2YXIgbWFwcGVyID0gYmluZENhbGxiYWNrKG1hcEZuLCB0aGlzQXJnLCAyKTtcbiAgICB9XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShpdGVyYWJsZSwgbWFwcGVyLCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgdmFyIEZyb21BcnJheU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRnJvbUFycmF5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGcm9tQXJyYXlPYnNlcnZhYmxlKGFyZ3MsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChvLCBhcmdzKSB7XG4gICAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZSAoaSwgcmVjdXJzZSkge1xuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIG8ub25OZXh0KGFyZ3NbaV0pO1xuICAgICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBGcm9tQXJyYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoMCwgc2NoZWR1bGVNZXRob2QobywgdGhpcy5fYXJncykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbUFycmF5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqICBDb252ZXJ0cyBhbiBhcnJheSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyBhbiBvcHRpb25hbCBzY2hlZHVsZXIgdG8gZW51bWVyYXRlIHRoZSBhcnJheS5cbiAgKiBAZGVwcmVjYXRlZCB1c2UgT2JzZXJ2YWJsZS5mcm9tIG9yIE9ic2VydmFibGUub2ZcbiAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgcHVsbGVkIGZyb20gdGhlIGdpdmVuIGVudW1lcmFibGUgc2VxdWVuY2UuXG4gICovXG4gIHZhciBvYnNlcnZhYmxlRnJvbUFycmF5ID0gT2JzZXJ2YWJsZS5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKVxuICB9O1xuXG4gIHZhciBHZW5lcmF0ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEdlbmVyYXRlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZU9ic2VydmFibGUoc3RhdGUsIGNuZEZuLCBpdHJGbiwgcmVzRm4sIHMpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxTdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fY25kRm4gPSBjbmRGbjtcbiAgICAgIHRoaXMuX2l0ckZuID0gaXRyRm47XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmZpcnN0KSB7XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5uZXdTdGF0ZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2l0ckZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5uZXdTdGF0ZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5uZXdTdGF0ZS5lKTsgfVxuICAgICAgfVxuICAgICAgdmFyIGhhc1Jlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2NuZEZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICBpZiAoaGFzUmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKGhhc1Jlc3VsdC5lKTsgfVxuICAgICAgaWYgKGhhc1Jlc3VsdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fcmVzRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgICAgc3RhdGUuby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgcmVjdXJzZShzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VuZXJhdGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgIG5ld1N0YXRlOiB0aGlzLl9pbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fcy5zY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgc2NoZWR1bGVSZWN1cnNpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gR2VuZXJhdGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBydW5uaW5nIGEgc3RhdGUtZHJpdmVuIGxvb3AgcHJvZHVjaW5nIHRoZSBzZXF1ZW5jZSdzIGVsZW1lbnRzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmdlbmVyYXRlKDAsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IDwgMTA7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZ2VuZXJhdGUoMCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPCAxMDsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsU3RhdGUgSW5pdGlhbCBzdGF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIENvbmRpdGlvbiB0byB0ZXJtaW5hdGUgZ2VuZXJhdGlvbiAodXBvbiByZXR1cm5pbmcgZmFsc2UpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiBmb3IgcmVzdWx0cyBwcm9kdWNlZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuY3VycmVudFRocmVhZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBPYnNlcnZhYmxlLmdlbmVyYXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmF0ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVPZiAoc2NoZWR1bGVyLCBhcnJheSkge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIC8qKlxuICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IE9ic2VydmFibGUgaW5zdGFuY2Ugd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIHJlZ2FyZGxlc3Mgb2YgbnVtYmVyIG9yIHR5cGUgb2YgdGhlIGFyZ3VtZW50cy5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHB1bGxlZCBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICovXG4gIE9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcmdzLCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKipcbiAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIGluc3RhbmNlIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mIG51bWJlciBvciB0eXBlIG9mIHRoZSBhcmd1bWVudHMuXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBBIHNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmcgdGhlIGFyZ3VtZW50cy5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHB1bGxlZCBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICovXG4gIE9ic2VydmFibGUub2ZXaXRoU2NoZWR1bGVyID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgeyBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcmdzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBjaGFuZ2VzIHRvIGFuIGFycmF5IHVzaW5nIEFycmF5Lm9ic2VydmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFuIGFycmF5IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBjaGFuZ2VzIHRvIGFuIGFycmF5IGZyb20gQXJyYXkub2JzZXJ2ZS5cbiAgICovXG4gIE9ic2VydmFibGUub2ZBcnJheUNoYW5nZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkub2JzZXJ2ZSBvbmx5IGFjY2VwdHMgYXJyYXlzLicpOyB9XG4gICAgaWYgKHR5cGVvZiBBcnJheS5vYnNlcnZlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBBcnJheS51bm9ic2VydmUgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkub2JzZXJ2ZSBpcyBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgcGxhdGZvcm0nKSB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICBmdW5jdGlvbiBvYnNlcnZlckZuKGNoYW5nZXMpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChjaGFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBBcnJheS5vYnNlcnZlKGFycmF5LCBvYnNlcnZlckZuKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQXJyYXkudW5vYnNlcnZlKGFycmF5LCBvYnNlcnZlckZuKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGNoYW5nZXMgdG8gYW4gb2JqZWN0IHVzaW5nIE9iamVjdC5vYnNlcnZlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIEFuIG9iamVjdCB0byBvYnNlcnZlIGNoYW5nZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgY2hhbmdlcyB0byBhbiBvYmplY3QgZnJvbSBPYmplY3Qub2JzZXJ2ZS5cbiAgICovXG4gIE9ic2VydmFibGUub2ZPYmplY3RDaGFuZ2VzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKTsgfVxuICAgIGlmICh0eXBlb2YgT2JqZWN0Lm9ic2VydmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC51bm9ic2VydmUgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0Lm9ic2VydmUgaXMgbm90IHN1cHBvcnRlZCBvbiB5b3VyIHBsYXRmb3JtJykgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgZnVuY3Rpb24gb2JzZXJ2ZXJGbihjaGFuZ2VzKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGNoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoY2hhbmdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0Lm9ic2VydmUob2JqLCBvYnNlcnZlckZuKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LnVub2JzZXJ2ZShvYmosIG9ic2VydmVyRm4pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgTmV2ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE5ldmVyT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBOZXZlck9ic2VydmFibGUoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBOZXZlck9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfTtcblxuICAgIHJldHVybiBOZXZlck9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTkVWRVJfT0JTRVJWQUJMRSA9IG5ldyBOZXZlck9ic2VydmFibGUoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5vbi10ZXJtaW5hdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZW5vdGUgYW4gaW5maW5pdGUgZHVyYXRpb24gKGUuZy4gd2hlbiB1c2luZyByZWFjdGl2ZSBqb2lucykuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIG9ic2VydmVycyB3aWxsIG5ldmVyIGdldCBjYWxsZWQuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZU5ldmVyID0gT2JzZXJ2YWJsZS5uZXZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTkVWRVJfT0JTRVJWQUJMRTtcbiAgfTtcblxuICB2YXIgUGFpcnNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYWlyc09ic2VydmFibGUobywgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2tleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKG8sIG9iaiwga2V5cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgICBpZiAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgby5vbk5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICAgICAgICByZWN1cnNlKGkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgUGFpcnNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoMCwgc2NoZWR1bGVNZXRob2QobywgdGhpcy5fbywgdGhpcy5fa2V5cykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGFpcnNPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMgZnJvbSB0aGUgb2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5wYWlycyA9IGZ1bmN0aW9uIChvYmosIHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlciB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBQYWlyc09ic2VydmFibGUob2JqLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gICAgdmFyIFJhbmdlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSYW5nZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLnJhbmdlQ291bnQgPSBjb3VudDtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZShzdGFydCwgY291bnQsIG8pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wIChpLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChpIDwgY291bnQpIHtcbiAgICAgICAgICBvLm9uTmV4dChzdGFydCArIGkpO1xuICAgICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKFxuICAgICAgICAwLFxuICAgICAgICBsb29wUmVjdXJzaXZlKHRoaXMuc3RhcnQsIHRoaXMucmFuZ2VDb3VudCwgbylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBSYW5nZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgaW50ZWdyYWwgbnVtYmVycyB3aXRoaW4gYSBzcGVjaWZpZWQgcmFuZ2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludGVnZXIgaW4gdGhlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHNlcXVlbnRpYWwgaW50ZWdlcnMgdG8gZ2VuZXJhdGUuXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuY3VycmVudFRocmVhZC5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIGEgcmFuZ2Ugb2Ygc2VxdWVudGlhbCBpbnRlZ3JhbCBudW1iZXJzLlxuICAqL1xuICBPYnNlcnZhYmxlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBSYW5nZU9ic2VydmFibGUoc3RhcnQsIGNvdW50LCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBSZXBlYXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlcGVhdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVwZWF0T2JzZXJ2YWJsZSh2YWx1ZSwgcmVwZWF0Q291bnQsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5yZXBlYXRDb3VudCA9IHJlcGVhdENvdW50ID09IG51bGwgPyAtMSA6IHJlcGVhdENvdW50O1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZXBlYXRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgc2luayA9IG5ldyBSZXBlYXRTaW5rKG9ic2VydmVyLCB0aGlzKTtcbiAgICAgIHJldHVybiBzaW5rLnJ1bigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIGZ1bmN0aW9uIFJlcGVhdFNpbmsob2JzZXJ2ZXIsIHBhcmVudCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuXG4gIFJlcGVhdFNpbmsucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLCB2YWx1ZSA9IHRoaXMucGFyZW50LnZhbHVlO1xuICAgIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgaWYgKGkgPT09IC0xIHx8IGkgPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIGkgPiAwICYmIGktLTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSAwKSB7IHJldHVybiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICByZWN1cnNlKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcmVudC5zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUodGhpcy5wYXJlbnQucmVwZWF0Q291bnQsIGxvb3BSZWN1cnNpdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgRWxlbWVudCB0byByZXBlYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRDb3VudCBbT3B0aW9uYV0gTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCwgcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgcHJvZHVjZXIgbG9vcCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5yZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFJlcGVhdE9ic2VydmFibGUodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBKdXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhKdXN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBKdXN0T2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSnVzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0gW3RoaXMuX3ZhbHVlLCBvXTtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIgPT09IGltbWVkaWF0ZVNjaGVkdWxlciA/XG4gICAgICAgIHNjaGVkdWxlSXRlbShudWxsLCBzdGF0ZSkgOlxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNjaGVkdWxlSXRlbSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzdGF0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGVbMF0sIG9ic2VydmVyID0gc3RhdGVbMV07XG4gICAgICBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEp1c3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBhIHNpbmdsZSBlbGVtZW50LCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogIFRoZXJlIGlzIGFuIGFsaWFzIGNhbGxlZCAnanVzdCcgb3IgYnJvd3NlcnMgPElFOS5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgU2luZ2xlIGVsZW1lbnQgaW4gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBzZW5kIHRoZSBzaW5nbGUgZWxlbWVudCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgc2luZ2xlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVSZXR1cm4gPSBPYnNlcnZhYmxlWydyZXR1cm4nXSA9IE9ic2VydmFibGUuanVzdCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEp1c3RPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBUaHJvd09ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGhyb3dPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRocm93T2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGhyb3dPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IFt0aGlzLl9lcnJvciwgb107XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgP1xuICAgICAgICBzY2hlZHVsZUl0ZW0obnVsbCwgc3RhdGUpIDpcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzY2hlZHVsZUl0ZW0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUl0ZW0ocywgc3RhdGUpIHtcbiAgICAgIHZhciBlID0gc3RhdGVbMF0sIG8gPSBzdGF0ZVsxXTtcbiAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRocm93T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgdGVybWluYXRlcyB3aXRoIGFuIGV4Y2VwdGlvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIHNpbmdsZSBvbkVycm9yIG1lc3NhZ2UuXG4gICAqICBUaGVyZSBpcyBhbiBhbGlhcyB0byB0aGlzIG1ldGhvZCBjYWxsZWQgJ3Rocm93RXJyb3InIGZvciBicm93c2VycyA8SUU5LlxuICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBBbiBvYmplY3QgdXNlZCBmb3IgdGhlIHNlcXVlbmNlJ3MgdGVybWluYXRpb24uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHNlbmQgdGhlIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIGNhbGwgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5pbW1lZGlhdGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseSB3aXRoIHRoZSBzcGVjaWZpZWQgZXhjZXB0aW9uIG9iamVjdC5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlVGhyb3cgPSBPYnNlcnZhYmxlWyd0aHJvdyddID0gZnVuY3Rpb24gKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGhyb3dPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBVc2luZ09ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFVzaW5nT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBVc2luZ09ic2VydmFibGUocmVzRm4sIG9ic0ZuKSB7XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fb2JzRm4gPSBvYnNGbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFVzaW5nT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIHZhciByZXNvdXJjZSA9IHRyeUNhdGNoKHRoaXMuX3Jlc0ZuKSgpO1xuICAgICAgaWYgKHJlc291cmNlID09PSBlcnJvck9iaikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUob2JzZXJ2YWJsZVRocm93KHJlc291cmNlLmUpLnN1YnNjcmliZShvKSwgZGlzcG9zYWJsZSk7XG4gICAgICB9XG4gICAgICByZXNvdXJjZSAmJiAoZGlzcG9zYWJsZSA9IHJlc291cmNlKTtcbiAgICAgIHZhciBzb3VyY2UgPSB0cnlDYXRjaCh0aGlzLl9vYnNGbikocmVzb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKG9ic2VydmFibGVUaHJvdyhzb3VyY2UuZSkuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFVzaW5nT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBkZXBlbmRzIG9uIGEgcmVzb3VyY2Ugb2JqZWN0LCB3aG9zZSBsaWZldGltZSBpcyB0aWVkIHRvIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSdzIGxpZmV0aW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvdXJjZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiB0byBvYnRhaW4gYSByZXNvdXJjZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ic2VydmFibGVGYWN0b3J5IEZhY3RvcnkgZnVuY3Rpb24gdG8gb2J0YWluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBkZXBlbmRzIG9uIHRoZSBvYnRhaW5lZCByZXNvdXJjZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgbGlmZXRpbWUgY29udHJvbHMgdGhlIGxpZmV0aW1lIG9mIHRoZSBkZXBlbmRlbnQgcmVzb3VyY2Ugb2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS51c2luZyA9IGZ1bmN0aW9uIChyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBVc2luZ09ic2VydmFibGUocmVzb3VyY2VGYWN0b3J5LCBvYnNlcnZhYmxlRmFjdG9yeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHJlYWN0cyBmaXJzdC5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodFNvdXJjZSBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzdXJmYWNlcyBlaXRoZXIgb2YgdGhlIGdpdmVuIHNlcXVlbmNlcywgd2hpY2hldmVyIHJlYWN0ZWQgZmlyc3QuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYW1iID0gZnVuY3Rpb24gKHJpZ2h0U291cmNlKSB7XG4gICAgdmFyIGxlZnRTb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBjaG9pY2UsXG4gICAgICAgIGxlZnRDaG9pY2UgPSAnTCcsIHJpZ2h0Q2hvaWNlID0gJ1InLFxuICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIGlzUHJvbWlzZShyaWdodFNvdXJjZSkgJiYgKHJpZ2h0U291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJpZ2h0U291cmNlKSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNob2ljZUwoKSB7XG4gICAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgICAgY2hvaWNlID0gbGVmdENob2ljZTtcbiAgICAgICAgICByaWdodFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hvaWNlUigpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgICAgICBjaG9pY2UgPSByaWdodENob2ljZTtcbiAgICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdFN1YnNjcmliZSA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25OZXh0KGxlZnQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHZhciByaWdodFN1YnNjcmliZSA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICBjaG9pY2VSKCk7XG4gICAgICAgICAgY2hvaWNlID09PSByaWdodENob2ljZSAmJiBvYnNlcnZlci5vbk5leHQocmlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNob2ljZVIoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IHJpZ2h0Q2hvaWNlICYmIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjaG9pY2VSKCk7XG4gICAgICAgICAgY2hvaWNlID09PSByaWdodENob2ljZSAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBsZWZ0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUobGVmdFNvdXJjZS5zdWJzY3JpYmUobGVmdFN1YnNjcmliZSkpO1xuICAgICAgcmlnaHRTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShyaWdodFNvdXJjZS5zdWJzY3JpYmUocmlnaHRTdWJzY3JpYmUpKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGxlZnRTdWJzY3JpcHRpb24sIHJpZ2h0U3Vic2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBhbWIocCwgYykgeyByZXR1cm4gcC5hbWIoYyk7IH1cblxuICAvKipcbiAgICogUHJvcGFnYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgcmVhY3RzIGZpcnN0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHN1cmZhY2VzIGFueSBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2VzLCB3aGljaGV2ZXIgcmVhY3RlZCBmaXJzdC5cbiAgICovXG4gIE9ic2VydmFibGUuYW1iID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBvYnNlcnZhYmxlTmV2ZXIoKSwgaXRlbXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgaXRlbXMgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaXRlbXMgPSBuZXcgQXJyYXkoaXRlbXMpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGl0ZW1zW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYWNjID0gYW1iKGFjYywgaXRlbXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIHZhciBDYXRjaE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENhdGNoT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDYXRjaE9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkMSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZDEpO1xuICAgICAgZDEuc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IENhdGNoT2JzZXJ2ZXIobywgc3Vic2NyaXB0aW9uLCB0aGlzLl9mbikpKTtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQ2F0Y2hPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDYXRjaE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENhdGNoT2JzZXJ2ZXIobywgcywgZm4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX28ub25OZXh0KHgpOyB9O1xuICAgIENhdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcbiAgICBDYXRjaE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG5cbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9zLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUocmVzdWx0LnN1YnNjcmliZSh0aGlzLl9vKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGhhbmRsZXJPclNlY29uZCBFeGNlcHRpb24gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBnaXZlbiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UsIG9yIGEgc2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IHNlcXVlbmNlJ3MgZWxlbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50cyBvZiB0aGUgaGFuZGxlciBzZXF1ZW5jZSBpbiBjYXNlIGFuIGV4Y2VwdGlvbiBvY2N1cnJlZC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90b1snY2F0Y2gnXSA9IGZ1bmN0aW9uIChoYW5kbGVyT3JTZWNvbmQpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihoYW5kbGVyT3JTZWNvbmQpID8gbmV3IENhdGNoT2JzZXJ2YWJsZSh0aGlzLCBoYW5kbGVyT3JTZWNvbmQpIDogb2JzZXJ2YWJsZUNhdGNoKFt0aGlzLCBoYW5kbGVyT3JTZWNvbmRdKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIHVzZSBhcyB0aGUgbmV4dCBzZXF1ZW5jZSBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgZWxlbWVudHMgZnJvbSBjb25zZWN1dGl2ZSBzb3VyY2Ugc2VxdWVuY2VzIHVudGlsIGEgc291cmNlIHNlcXVlbmNlIHRlcm1pbmF0ZXMgc3VjY2Vzc2Z1bGx5LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVDYXRjaCA9IE9ic2VydmFibGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGl0ZW1zID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGl0ZW1zID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgaXRlbXNbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgcmV0dXJuIGVudW1lcmFibGVPZihpdGVtcykuY2F0Y2hFcnJvcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbnkgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIFByb21pc2VzIHByb2R1Y2VzIGFuIGVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGluIHRoZSBmb3JtIG9mIGFuIGFyZ3VtZW50IGxpc3Qgb2Ygb2JzZXJ2YWJsZXMgb3IgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDEgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qob2JzMSwgb2JzMiwgb2JzMywgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XG4gICAqIDIgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb21iaW5lTGF0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgYXJnc1swXS51bnNoaWZ0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlKHBhcmFtcywgY2IpIHtcbiAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5fcGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaGFzVmFsdWU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgIGhhc1ZhbHVlQWxsOiBmYWxzZSxcbiAgICAgICAgaXNEb25lOiBhcnJheUluaXRpYWxpemUobGVuLCBmYWxzZUZhY3RvcnkpLFxuICAgICAgICB2YWx1ZXM6IG5ldyBBcnJheShsZW4pXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9wYXJhbXNbaV0sIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zW2ldID0gc2FkO1xuICAgICAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIob2JzZXJ2ZXIsIGksIHRoaXMuX2NiLCBzdGF0ZSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvbWJpbmVMYXRlc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29tYmluZUxhdGVzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RPYnNlcnZlcihvLCBpLCBjYiwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9PSBpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fc3RhdGUudmFsdWVzW3RoaXMuX2ldID0geDtcbiAgICAgIHRoaXMuX3N0YXRlLmhhc1ZhbHVlW3RoaXMuX2ldID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZS5oYXNWYWx1ZUFsbCB8fCAodGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwgPSB0aGlzLl9zdGF0ZS5oYXNWYWx1ZS5ldmVyeShpZGVudGl0eSkpKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9jYikuYXBwbHkobnVsbCwgdGhpcy5fc3RhdGUudmFsdWVzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUuaXNEb25lLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgQ29tYmluZUxhdGVzdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0RvbmVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhdGUuaXNEb25lLmV2ZXJ5KGlkZW50aXR5KSAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFueSBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgUHJvbWlzZXMgcHJvZHVjZXMgYW4gZWxlbWVudC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogMSAtIG9icyA9IFJ4Lk9ic2VydmFibGUuY29tYmluZUxhdGVzdChvYnMxLCBvYnMyLCBvYnMzLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgKiAyIC0gb2JzID0gUnguT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KFtvYnMxLCBvYnMyLCBvYnMzXSwgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgKi9cbiAgdmFyIGNvbWJpbmVMYXRlc3QgPSBPYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG4gICAgcmV0dXJuIG5ldyBDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzLiAgVGhpcyB0YWtlcyBpbiBlaXRoZXIgYW4gYXJyYXkgb3IgdmFyaWFibGUgYXJndW1lbnRzIHRvIGNvbmNhdGVuYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdpdmVuIHNlcXVlbmNlLCBpbiBzZXF1ZW50aWFsIG9yZGVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IodmFyIGFyZ3MgPSBbXSwgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUNvbmNhdC5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgQ29uY2F0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29uY2F0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0T2JzZXJ2ZXIocywgZm4pIHtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENvbmNhdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcy5vLm9uTmV4dCh4KTsgfTtcbiAgICBDb25jYXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm8ub25FcnJvcihlKTsgfTtcbiAgICBDb25jYXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zLmkrKzsgdGhpcy5fZm4odGhpcy5fcyk7IH07XG5cbiAgICByZXR1cm4gQ29uY2F0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBDb25jYXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbmNhdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0T2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlIChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgIGlmIChzdGF0ZS5pID09PSBzdGF0ZS5zb3VyY2VzLmxlbmd0aCkgeyByZXR1cm4gc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBzdGF0ZS5zb3VyY2VzW3N0YXRlLmldO1xuICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHN0YXRlLnN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUobmV3IENvbmNhdE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgIH1cblxuICAgIENvbmNhdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gZGlzcG9zYWJsZUNyZWF0ZShub29wKTtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgaTogMCxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgICAgIGRpc3Bvc2FibGU6IGRpc3Bvc2FibGUsXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXNcbiAgICAgIH07XG5cbiAgICAgIHZhciBjYW5jZWxhYmxlID0gaW1tZWRpYXRlU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtzdWJzY3JpcHRpb24sIGRpc3Bvc2FibGUsIGNhbmNlbGFibGVdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbmNhdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIGNvbmNhdCB0byB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgZWFjaCBnaXZlbiBzZXF1ZW5jZSwgaW4gc2VxdWVudGlhbCBvcmRlci5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlQ29uY2F0ID0gT2JzZXJ2YWJsZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29uY2F0T2JzZXJ2YWJsZShhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggb2JzZXJ2ZWQgaW5uZXIgc2VxdWVuY2UsIGluIHNlcXVlbnRpYWwgb3JkZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29uY2F0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlKDEpO1xuICB9O1xuXG4gIHZhciBNZXJnZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1lcmdlT2JzZXJ2YWJsZShzb3VyY2UsIG1heENvbmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5tYXhDb25jdXJyZW50ID0gbWF4Q29uY3VycmVudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE1lcmdlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBnLmFkZCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHRoaXMubWF4Q29uY3VycmVudCwgZykpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VPYnNlcnZhYmxlO1xuXG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTWVyZ2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VPYnNlcnZlcihvLCBtYXgsIGcpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgIHRoaXMuZyA9IGc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucSA9IFtdO1xuICAgICAgdGhpcy5hY3RpdmVDb3VudCA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhNZXJnZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUuaGFuZGxlU3Vic2NyaWJlID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICB2YXIgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmcuYWRkKHNhZCk7XG4gICAgICBpc1Byb21pc2UoeHMpICYmICh4cyA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh4cykpO1xuICAgICAgc2FkLnNldERpc3Bvc2FibGUoeHMuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMsIHNhZCkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xuICAgICAgaWYodGhpcy5hY3RpdmVDb3VudCA8IHRoaXMubWF4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ291bnQrKztcbiAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpYmUoaW5uZXJTb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xLnB1c2goaW5uZXJTb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLm8ub25FcnJvcihlKTsgfTtcbiAgICBNZXJnZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZG9uZSA9IHRydWU7IHRoaXMuYWN0aXZlQ291bnQgPT09IDAgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHBhcmVudCwgc2FkKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuc2FkID0gc2FkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLnBhcmVudC5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMucGFyZW50Lm8ub25FcnJvcihlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhcmVudC5nLnJlbW92ZSh0aGlzLnNhZCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQucS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmhhbmRsZVN1YnNjcmliZSh0aGlzLnBhcmVudC5xLnNoaWZ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWN0aXZlQ291bnQtLTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZG9uZSAmJiB0aGlzLnBhcmVudC5hY3RpdmVDb3VudCA9PT0gMCAmJiB0aGlzLnBhcmVudC5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNZXJnZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBNZXJnZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBzdWJzY3JpcHRpb25zIHRvIGlubmVyIHNlcXVlbmNlcy5cbiAgKiBPciBtZXJnZXMgdHdvIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcGFyYW0ge01peGVkfSBbbWF4Q29uY3VycmVudE9yT3RoZXJdIE1heGltdW0gbnVtYmVyIG9mIGlubmVyIG9ic2VydmFibGUgc2VxdWVuY2VzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5IG9yIHRoZSBzZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBtZXJnZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBzZXF1ZW5jZXMuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tZXJnZSA9IGZ1bmN0aW9uIChtYXhDb25jdXJyZW50T3JPdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgbWF4Q29uY3VycmVudE9yT3RoZXIgIT09ICdudW1iZXInID9cbiAgICAgIG9ic2VydmFibGVNZXJnZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcikgOlxuICAgICAgbmV3IE1lcmdlT2JzZXJ2YWJsZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogVGhlIHNjaGVkdWxlciBpcyBvcHRpb25hbCBhbmQgaWYgbm90IHNwZWNpZmllZCwgdGhlIGltbWVkaWF0ZSBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgbWVyZ2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZU1lcmdlID0gT2JzZXJ2YWJsZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZWR1bGVyLCBzb3VyY2VzID0gW10sIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcbiAgICAgIGZvcihpID0gMTsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXMucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgfSBlbHNlIGlmIChpc1NjaGVkdWxlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IoaSA9IDE7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXI7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VzWzBdKSkge1xuICAgICAgc291cmNlcyA9IHNvdXJjZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlT2Yoc2NoZWR1bGVyLCBzb3VyY2VzKS5tZXJnZUFsbCgpO1xuICB9O1xuXG4gIHZhciBNZXJnZUFsbE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlQWxsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTWVyZ2VBbGxPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSwgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgZy5hZGQobSk7XG4gICAgICBtLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZUFsbE9ic2VydmVyKG8sIGcpKSk7XG4gICAgICByZXR1cm4gZztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlQWxsT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBNZXJnZUFsbE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbE9ic2VydmVyKG8sIGcpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmcgPSBnO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhNZXJnZUFsbE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgTWVyZ2VBbGxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGlubmVyU291cmNlKSB7XG4gICAgICB2YXIgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmcuYWRkKHNhZCk7XG4gICAgICBpc1Byb21pc2UoaW5uZXJTb3VyY2UpICYmIChpbm5lclNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShpbm5lclNvdXJjZSkpO1xuICAgICAgc2FkLnNldERpc3Bvc2FibGUoaW5uZXJTb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMsIHNhZCkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VBbGxPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIE1lcmdlQWxsT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLmcubGVuZ3RoID09PSAxICYmIHRoaXMuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHBhcmVudCwgc2FkKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuc2FkID0gc2FkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5wYXJlbnQuby5vbk5leHQoeCk7XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnBhcmVudC5vLm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhcmVudC5nLnJlbW92ZSh0aGlzLnNhZCk7XG4gICAgICB0aGlzLnBhcmVudC5kb25lICYmIHRoaXMucGFyZW50LmcubGVuZ3RoID09PSAxICYmIHRoaXMucGFyZW50Lm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlQWxsT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIE1lcmdlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBtZXJnZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBzZXF1ZW5jZXMuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tZXJnZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE1lcmdlQWxsT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgQ29tcG9zaXRlRXJyb3IgPSBSeC5Db21wb3NpdGVFcnJvciA9IGZ1bmN0aW9uKGVycm9ycykge1xuICAgIHRoaXMuaW5uZXJFcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1RoaXMgY29udGFpbnMgbXVsdGlwbGUgZXJyb3JzLiBDaGVjayB0aGUgaW5uZXJFcnJvcnMnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIENvbXBvc2l0ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgQ29tcG9zaXRlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQ29tcG9zaXRlRXJyb3InO1xuXG4gIHZhciBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlRGVsYXlFcnJvck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxuICAgICAgICBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHN0YXRlID0geyBpc1N0b3BwZWQ6IGZhbHNlLCBlcnJvcnM6IFtdLCBvOiBvIH07XG5cbiAgICAgIGdyb3VwLmFkZChtKTtcbiAgICAgIG0uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlRGVsYXlFcnJvck9ic2VydmVyKGdyb3VwLCBzdGF0ZSkpKTtcblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBNZXJnZURlbGF5RXJyb3JPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhNZXJnZURlbGF5RXJyb3JPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNZXJnZURlbGF5RXJyb3JPYnNlcnZlcihncm91cCwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q29tcGxldGlvbihvLCBlcnJvcnMpIHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBvLm9uRXJyb3IoZXJyb3JzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ub25FcnJvcihuZXcgQ29tcG9zaXRlRXJyb3IoZXJyb3JzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9ncm91cC5hZGQoaW5uZXIpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZXMgc3VwcG9ydFxuICAgICAgaXNQcm9taXNlKHgpICYmICh4ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHgpKTtcbiAgICAgIGlubmVyLnNldERpc3Bvc2FibGUoeC5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIoaW5uZXIsIHRoaXMuX2dyb3VwLCB0aGlzLl9zdGF0ZSkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmVycm9ycy5wdXNoKGUpO1xuICAgICAgdGhpcy5fc3RhdGUuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2dyb3VwLmxlbmd0aCA9PT0gMSAmJiBzZXRDb21wbGV0aW9uKHRoaXMuX3N0YXRlLm8sIHRoaXMuX3N0YXRlLmVycm9ycyk7XG4gICAgfTtcblxuICAgIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKGlubmVyLCBncm91cCwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX2lubmVyID0gaW5uZXI7XG4gICAgICB0aGlzLl9ncm91cCA9IGdyb3VwO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9zdGF0ZS5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5lcnJvcnMucHVzaChlKTtcbiAgICAgIHRoaXMuX2dyb3VwLnJlbW92ZSh0aGlzLl9pbm5lcik7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgJiYgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2dyb3VwLnJlbW92ZSh0aGlzLl9pbm5lcik7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgJiYgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBGbGF0dGVucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMgaW50byBvbmUgT2JzZXJ2YWJsZSwgaW4gYSB3YXkgdGhhdCBhbGxvd3MgYW4gT2JzZXJ2ZXIgdG9cbiAgKiByZWNlaXZlIGFsbCBzdWNjZXNzZnVsbHkgZW1pdHRlZCBpdGVtcyBmcm9tIGFsbCBvZiB0aGUgc291cmNlIE9ic2VydmFibGVzIHdpdGhvdXQgYmVpbmcgaW50ZXJydXB0ZWQgYnlcbiAgKiBhbiBlcnJvciBub3RpZmljYXRpb24gZnJvbSBvbmUgb2YgdGhlbS5cbiAgKlxuICAqIFRoaXMgYmVoYXZlcyBsaWtlIE9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlQWxsIGV4Y2VwdCB0aGF0IGlmIGFueSBvZiB0aGUgbWVyZ2VkIE9ic2VydmFibGVzIG5vdGlmeSBvZiBhblxuICAqIGVycm9yIHZpYSB0aGUgT2JzZXJ2ZXIncyBvbkVycm9yLCBtZXJnZURlbGF5RXJyb3Igd2lsbCByZWZyYWluIGZyb20gcHJvcGFnYXRpbmcgdGhhdFxuICAqIGVycm9yIG5vdGlmaWNhdGlvbiB1bnRpbCBhbGwgb2YgdGhlIG1lcmdlZCBPYnNlcnZhYmxlcyBoYXZlIGZpbmlzaGVkIGVtaXR0aW5nIGl0ZW1zLlxuICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIG1lcmdlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIG9mIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBPYnNlcnZhYmxlcyBlbWl0dGVkIGJ5IHRoZSBPYnNlcnZhYmxlXG4gICovXG4gIE9ic2VydmFibGUubWVyZ2VEZWxheUVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIH1cbiAgICB2YXIgc291cmNlID0gb2JzZXJ2YWJsZU9mKG51bGwsIGFyZ3MpO1xuICAgIHJldHVybiBuZXcgTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZShzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgbm9ybWFsbHkgb3IgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzZWNvbmQgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgYWZ0ZXIgdGhlIGZpcnN0IHNlcXVlbmNlIHRlcm1pbmF0ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29uY2F0ZW5hdGVzIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHNlcXVlbmNlLCBldmVuIGlmIHRoZSBmaXJzdCBzZXF1ZW5jZSB0ZXJtaW5hdGVzIGV4Y2VwdGlvbmFsbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ub25FcnJvclJlc3VtZU5leHQgPSBmdW5jdGlvbiAoc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHsgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgb2JzZXJ2YWJsZSBpcyByZXF1aXJlZCcpOyB9XG4gICAgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0KFt0aGlzLCBzZWNvbmRdKTtcbiAgfTtcblxuICB2YXIgT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUoc291cmNlcykge1xuICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzdGF0ZS5zb3VyY2VzW3N0YXRlLnBvcysrXTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnQpICYmIChjdXJyZW50ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnQpKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICAgIGQuc2V0RGlzcG9zYWJsZShjdXJyZW50LnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgICAgc3RhdGUgPSB7cG9zOiAwLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiwgbzogbywgc291cmNlczogdGhpcy5zb3VyY2VzIH0sXG4gICAgICAgICAgY2FuY2VsbGFibGUgPSBpbW1lZGlhdGVTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsbGFibGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25FcnJvclJlc3VtZU5leHRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlY3Vyc2UodGhpcy5fc3RhdGUpOyB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVjdXJzZSh0aGlzLl9zdGF0ZSk7IH07XG5cbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbnRpbnVlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGVybWluYXRlZCBub3JtYWxseSBvciBieSBhbiBleGNlcHRpb24gd2l0aCB0aGUgbmV4dCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbmNhdGVuYXRlcyB0aGUgc291cmNlIHNlcXVlbmNlcywgZXZlbiBpZiBhIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseS5cbiAgICovXG4gIHZhciBvbkVycm9yUmVzdW1lTmV4dCA9IE9ic2VydmFibGUub25FcnJvclJlc3VtZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzb3VyY2VzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHNvdXJjZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlKHNvdXJjZXMpO1xuICB9O1xuXG4gIHZhciBTa2lwVW50aWxPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPYnNlcnZhYmxlKHNvdXJjZSwgb3RoZXIpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9vID0gaXNQcm9taXNlKG90aGVyKSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikgOiBvdGhlcjtcbiAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbGVmdFN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgbGVmdFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHRoaXMuX3Muc3Vic2NyaWJlKG5ldyBTa2lwVW50aWxTb3VyY2VPYnNlcnZlcihvLCB0aGlzKSkpO1xuXG4gICAgICBpc1Byb21pc2UodGhpcy5fbykgJiYgKHRoaXMuX28gPSBvYnNlcnZhYmxlRnJvbVByb21pc2UodGhpcy5fbykpO1xuXG4gICAgICB2YXIgcmlnaHRTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5fby5zdWJzY3JpYmUobmV3IFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIobywgdGhpcywgcmlnaHRTdWJzY3JpcHRpb24pKSk7XG5cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShsZWZ0U3Vic2NyaXB0aW9uLCByaWdodFN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbFNvdXJjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9wLl9vcGVuICYmIHRoaXMuX28ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuXG4gICAgU2tpcFVudGlsU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcC5fb3BlbiAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxTb3VyY2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsT3RoZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPdGhlck9ic2VydmVyKG8sIHAsIHIpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9yID0gcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wLl9vcGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3IuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxPdGhlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxPdGhlck9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3IuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFVudGlsT3RoZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvbmx5IGFmdGVyIHRoZSBvdGhlciBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2VzIGEgdmFsdWUuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZSB8IFByb21pc2V9IG90aGVyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB0cmlnZ2VycyBwcm9wYWdhdGlvbiBvZiBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHN0YXJ0aW5nIGZyb20gdGhlIHBvaW50IHRoZSBvdGhlciBzZXF1ZW5jZSB0cmlnZ2VyZWQgcHJvcGFnYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFVudGlsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBTa2lwVW50aWxPYnNlcnZhYmxlKHRoaXMsIG90aGVyKTtcbiAgfTtcblxuICB2YXIgU3dpdGNoT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGlubmVyID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSwgcyA9IHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoT2JzZXJ2ZXIobywgaW5uZXIpKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzLCBpbm5lcik7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKFN3aXRjaE9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPYnNlcnZlcihvLCBpbm5lcikge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXRlc3QgPSAwO1xuICAgICAgdGhpcy5oYXNMYXRlc3QgPSBmYWxzZTtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSwgaWQgPSArK3RoaXMubGF0ZXN0O1xuICAgICAgdGhpcy5oYXNMYXRlc3QgPSB0cnVlO1xuICAgICAgdGhpcy5pbm5lci5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgaXNQcm9taXNlKGlubmVyU291cmNlKSAmJiAoaW5uZXJTb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoaW5uZXJTb3VyY2UpKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShpbm5lclNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIodGhpcywgaWQpKSk7XG4gICAgfTtcblxuICAgIFN3aXRjaE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU3dpdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAhdGhpcy5oYXNMYXRlc3QgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIocGFyZW50LCBpZCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5wYXJlbnQubGF0ZXN0ID09PSB0aGlzLmlkICYmIHRoaXMucGFyZW50Lm8ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnBhcmVudC5sYXRlc3QgPT09IHRoaXMuaWQgJiYgdGhpcy5wYXJlbnQuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQubGF0ZXN0ID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmhhc0xhdGVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmVudC5zdG9wcGVkICYmIHRoaXMucGFyZW50Lm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFN3aXRjaE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiBUcmFuc2Zvcm1zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGF0IGFueSBwb2ludCBpbiB0aW1lIHByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgbW9zdCByZWNlbnQgaW5uZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ3N3aXRjaCddID0gb2JzZXJ2YWJsZVByb3RvLnN3aXRjaExhdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN3aXRjaE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFRha2VVbnRpbE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVVudGlsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFRha2VVbnRpbE9ic2VydmFibGUoc291cmNlLCBvdGhlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm90aGVyID0gaXNQcm9taXNlKG90aGVyKSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikgOiBvdGhlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VVbnRpbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShvKSxcbiAgICAgICAgdGhpcy5vdGhlci5zdWJzY3JpYmUobmV3IFRha2VVbnRpbE9ic2VydmVyKG8pKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VVbnRpbE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZVVudGlsT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVVudGlsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlVW50aWxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgVGFrZVVudGlsT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGVycik7XG4gICAgfTtcblxuICAgIFRha2VVbnRpbE9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IG5vb3A7XG5cbiAgICByZXR1cm4gVGFrZVVudGlsT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdW50aWwgdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlIHwgUHJvbWlzZX0gb3RoZXIgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgdGVybWluYXRlcyBwcm9wYWdhdGlvbiBvZiBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHVwIHRvIHRoZSBwb2ludCB0aGUgb3RoZXIgc2VxdWVuY2UgaW50ZXJydXB0ZWQgZnVydGhlciBwcm9wYWdhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlVW50aWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFRha2VVbnRpbE9ic2VydmFibGUodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIFdpdGhMYXRlc3RGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlKHNvdXJjZSwgc291cmNlcywgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zcyA9IHNvdXJjZXM7XG4gICAgICB0aGlzLl9jYiA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9zcy5sZW5ndGg7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGhhc1ZhbHVlOiBhcnJheUluaXRpYWxpemUobGVuLCBmYWxzZUZhY3RvcnkpLFxuICAgICAgICBoYXNWYWx1ZUFsbDogZmFsc2UsXG4gICAgICAgIHZhbHVlczogbmV3IEFycmF5KGxlbilcbiAgICAgIH07XG5cbiAgICAgIHZhciBuID0gdGhpcy5fc3MubGVuZ3RoLCBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHRoaXMuX3NzW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG5ldyBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIobywgaSwgc3RhdGUpKSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRlclNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgb3V0ZXJTYWQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zLnN1YnNjcmliZShuZXcgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlcihvLCB0aGlzLl9jYiwgc3RhdGUpKSk7XG4gICAgICBzdWJzY3JpcHRpb25zW25dID0gb3V0ZXJTYWQ7XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyKG8sIGksIHN0YXRlKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zdGF0ZS52YWx1ZXNbdGhpcy5faV0gPSB4O1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwgPSB0aGlzLl9zdGF0ZS5oYXNWYWx1ZS5ldmVyeShpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IG5vb3A7XG5cbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyKG8sIGNiLCBzdGF0ZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFdpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGFsbFZhbHVlcyA9IFt4XS5jb25jYXQodGhpcy5fc3RhdGUudmFsdWVzKTtcbiAgICAgIGlmICghdGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fY2IpLmFwcGx5KG51bGwsIGFsbFZhbHVlcyk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICB9O1xuXG4gICAgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogTWVyZ2VzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gb25seSB3aGVuIHRoZSAoZmlyc3QpIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2VzIGFuIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2l0aExhdGVzdEZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cycpOyB9XG5cbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihhcmdzW2xlbiAtIDFdKSA/IGFyZ3MucG9wKCkgOiBhcmd1bWVudHNUb0FycmF5O1xuICAgIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgKGFyZ3MgPSBhcmdzWzBdKTtcblxuICAgIHJldHVybiBuZXcgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlKHRoaXMsIGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmYWxzZUZhY3RvcnkoKSB7IHJldHVybiBmYWxzZTsgfVxuICBmdW5jdGlvbiBlbXB0eUFycmF5RmFjdG9yeSgpIHsgcmV0dXJuIFtdOyB9XG5cbiAgdmFyIFppcE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoWmlwT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBaaXBPYnNlcnZhYmxlKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl9zID0gc291cmNlcztcbiAgICAgIHRoaXMuX2NiID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBaaXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5fcy5sZW5ndGgsXG4gICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBkb25lID0gYXJyYXlJbml0aWFsaXplKG4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgICAgcSA9IGFycmF5SW5pdGlhbGl6ZShuLCBlbXB0eUFycmF5RmFjdG9yeSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9zW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uc1tpXSA9IHNhZDtcbiAgICAgICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShuZXcgWmlwT2JzZXJ2ZXIob2JzZXJ2ZXIsIGksIHRoaXMsIHEsIGRvbmUpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBaaXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFppcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhaaXBPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBaaXBPYnNlcnZlcihvLCBpLCBwLCBxLCBkKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9xID0gcTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90RW1wdHkoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9XG4gICAgZnVuY3Rpb24gc2hpZnRFYWNoKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfVxuICAgIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9PSBpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBaaXBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9xW3RoaXMuX2ldLnB1c2goeCk7XG4gICAgICBpZiAodGhpcy5fcS5ldmVyeShub3RFbXB0eSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlZFZhbHVlcyA9IHRoaXMuX3EubWFwKHNoaWZ0RWFjaCk7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9wLl9jYikuYXBwbHkobnVsbCwgcXVldWVkVmFsdWVzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZC5maWx0ZXIobm90VGhlU2FtZSh0aGlzLl9pKSkuZXZlcnkoaWRlbnRpdHkpKSB7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWmlwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgWmlwT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2RbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fZC5ldmVyeShpZGVudGl0eSkgJiYgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWmlwT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbGwgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIGFuIGFycmF5IGhhdmUgcHJvZHVjZWQgYW4gZWxlbWVudCBhdCBhIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gICAqIFRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGFyZ3VtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHNlcmllcyBvZiBlbGVtZW50cyBhdCBjb3JyZXNwb25kaW5nIGluZGV4ZXMgaW4gdGhlIGFyZ3MuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIGFyZ3MgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uemlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudHMnKTsgfVxuXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICBhcmdzLnVuc2hpZnQocGFyZW50KTtcblxuICAgIHJldHVybiBuZXcgWmlwT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFsbCBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGF2ZSBwcm9kdWNlZCBhbiBlbGVtZW50IGF0IGEgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICogQHBhcmFtIGFyZ3VtZW50cyBPYnNlcnZhYmxlIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBzb3VyY2VzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS56aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzID0gaXNGdW5jdGlvbihhcmdzWzFdKSA/IGFyZ3NbMF0uY29uY2F0KGFyZ3NbMV0pIDogYXJnc1swXTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gYXJncy5zaGlmdCgpO1xuICAgIHJldHVybiBmaXJzdC56aXAuYXBwbHkoZmlyc3QsIGFyZ3MpO1xuICB9O1xuXG5mdW5jdGlvbiBmYWxzZUZhY3RvcnkoKSB7IHJldHVybiBmYWxzZTsgfVxuZnVuY3Rpb24gZW1wdHlBcnJheUZhY3RvcnkoKSB7IHJldHVybiBbXTsgfVxuZnVuY3Rpb24gYXJndW1lbnRzVG9BcnJheSgpIHtcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbnZhciBaaXBJdGVyYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gIGluaGVyaXRzKFppcEl0ZXJhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gWmlwSXRlcmFibGVPYnNlcnZhYmxlKHNvdXJjZXMsIGNiKSB7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLl9jYiA9IGNiO1xuICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgWmlwSXRlcmFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuc291cmNlcywgbGVuID0gc291cmNlcy5sZW5ndGgsIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHE6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGVtcHR5QXJyYXlGYWN0b3J5KSxcbiAgICAgIGRvbmU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICBjYjogdGhpcy5fY2IsXG4gICAgICBvOiBvXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXSwgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIChpc0FycmF5TGlrZShzb3VyY2UpIHx8IGlzSXRlcmFibGUoc291cmNlKSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tKHNvdXJjZSkpO1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobmV3IFppcEl0ZXJhYmxlT2JzZXJ2ZXIoc3RhdGUsIGkpKSk7XG4gICAgICB9KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBaaXBJdGVyYWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVCYXNlKSk7XG5cbnZhciBaaXBJdGVyYWJsZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgaW5oZXJpdHMoWmlwSXRlcmFibGVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gWmlwSXRlcmFibGVPYnNlcnZlcihzLCBpKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5faSA9IGk7XG4gICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RFbXB0eSh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH1cbiAgZnVuY3Rpb24gc2hpZnRFYWNoKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfVxuICBmdW5jdGlvbiBub3RUaGVTYW1lKGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGopIHtcbiAgICAgIHJldHVybiBqICE9PSBpO1xuICAgIH07XG4gIH1cblxuICBaaXBJdGVyYWJsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9zLnFbdGhpcy5faV0ucHVzaCh4KTtcbiAgICBpZiAodGhpcy5fcy5xLmV2ZXJ5KG5vdEVtcHR5KSkge1xuICAgICAgdmFyIHF1ZXVlZFZhbHVlcyA9IHRoaXMuX3MucS5tYXAoc2hpZnRFYWNoKSxcbiAgICAgICAgICByZXMgPSB0cnlDYXRjaCh0aGlzLl9zLmNiKS5hcHBseShudWxsLCBxdWV1ZWRWYWx1ZXMpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX3Muby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5fcy5vLm9uTmV4dChyZXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcy5kb25lLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcblxuICBaaXBJdGVyYWJsZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuXG4gIFppcEl0ZXJhYmxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zLmRvbmVbdGhpcy5faV0gPSB0cnVlO1xuICAgIHRoaXMuX3MuZG9uZS5ldmVyeShpZGVudGl0eSkgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gIH07XG5cbiAgcmV0dXJuIFppcEl0ZXJhYmxlT2JzZXJ2ZXI7XG59KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbGwgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIGFuIGFycmF5IGhhdmUgcHJvZHVjZWQgYW4gZWxlbWVudCBhdCBhIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gKiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBhcmd1bWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBhcmdzLlxuICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgYXJncyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAqL1xub2JzZXJ2YWJsZVByb3RvLnppcEl0ZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzJyk7IH1cblxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKGFyZ3NbbGVuIC0gMV0pID8gYXJncy5wb3AoKSA6IGFyZ3VtZW50c1RvQXJyYXk7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG4gIGFyZ3MudW5zaGlmdChwYXJlbnQpO1xuICByZXR1cm4gbmV3IFppcEl0ZXJhYmxlT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG59O1xuXG4gIGZ1bmN0aW9uIGFzT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3Vic2NyaWJlKG8pIHsgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobyk7IH07XG4gIH1cblxuICAvKipcbiAgICogIEhpZGVzIHRoZSBpZGVudGl0eSBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhpZGVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoYXNPYnNlcnZhYmxlKHRoaXMpLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0FycmF5KHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9XG4gIGZ1bmN0aW9uIG5vdEVtcHR5KHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgYnVmZmVycyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gZWxlbWVudCBjb3VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IExlbmd0aCBvZiBlYWNoIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIGJ1ZmZlcnMuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gdGhlIGNvdW50LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhDb3VudCA9IG9ic2VydmFibGVQcm90by5idWZmZXJDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgc2tpcCkge1xuICAgIHR5cGVvZiBza2lwICE9PSAnbnVtYmVyJyAmJiAoc2tpcCA9IGNvdW50KTtcbiAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoQ291bnQoY291bnQsIHNraXApXG4gICAgICAuZmxhdE1hcCh0b0FycmF5KVxuICAgICAgLmZpbHRlcihub3RFbXB0eSk7XG4gIH07XG5cbiAgdmFyIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGVtYXRlcmlhbGl6ZU9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIERlbWF0ZXJpYWxpemVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVtYXRlcmlhbGl6ZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRGVtYXRlcmlhbGl6ZU9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgeC5hY2NlcHQodGhpcy5fbyk7IH07XG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIERlbWF0ZXJpYWxpemVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERlbWF0ZXJpYWxpemVzIHRoZSBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgaW1wbGljaXQgbm90aWZpY2F0aW9ucy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZXhoaWJpdGluZyB0aGUgYmVoYXZpb3IgY29ycmVzcG9uZGluZyB0byB0aGUgc291cmNlIHNlcXVlbmNlJ3Mgbm90aWZpY2F0aW9uIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kZW1hdGVyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZhYmxlKHNvdXJjZSwga2V5Rm4sIGNvbXBhcmVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMua2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyKG8sIHRoaXMua2V5Rm4sIHRoaXMuY29tcGFyZXIpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlcihvLCBrZXlGbiwgY29tcGFyZXIpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmtleUZuID0ga2V5Rm47XG4gICAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXI7XG4gICAgICB0aGlzLmhhc0N1cnJlbnRLZXkgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudEtleSA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrZXkgPSB4LCBjb21wYXJlckVxdWFscztcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMua2V5Rm4pKSB7XG4gICAgICAgIGtleSA9IHRyeUNhdGNoKHRoaXMua2V5Rm4pKHgpO1xuICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNDdXJyZW50S2V5KSB7XG4gICAgICAgIGNvbXBhcmVyRXF1YWxzID0gdHJ5Q2F0Y2godGhpcy5jb21wYXJlcikodGhpcy5jdXJyZW50S2V5LCBrZXkpO1xuICAgICAgICBpZiAoY29tcGFyZXJFcXVhbHMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLm8ub25FcnJvcihjb21wYXJlckVxdWFscy5lKTsgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmhhc0N1cnJlbnRLZXkgfHwgIWNvbXBhcmVyRXF1YWxzKSB7XG4gICAgICAgIHRoaXMuaGFzQ3VycmVudEtleSA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudEtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBvbmx5IGRpc3RpbmN0IGNvbnRpZ3VvdXMgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBrZXlGbiBhbmQgdGhlIGNvbXBhcmVyLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtrZXlGbl0gQSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBjb21wYXJpc29uIGtleSBmb3IgZWFjaCBlbGVtZW50LiBJZiBub3QgcHJvdmlkZWQsIGl0IHByb2plY3RzIHRoZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIEVxdWFsaXR5IGNvbXBhcmVyIGZvciBjb21wdXRlZCBrZXkgdmFsdWVzLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGFuIGVxdWFsaXR5IGNvbXBhcmVyIGZ1bmN0aW9uLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgY29udGFpbmluZyB0aGUgZGlzdGluY3QgY29udGlndW91cyBlbGVtZW50cywgYmFzZWQgb24gYSBjb21wdXRlZCBrZXkgdmFsdWUsIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZnVuY3Rpb24gKGtleUZuLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUodGhpcywga2V5Rm4sIGNvbXBhcmVyKTtcbiAgfTtcblxuICB2YXIgVGFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYXBPYnNlcnZhYmxlLF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFwT2JzZXJ2YWJsZShzb3VyY2UsIG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX29OID0gb2JzZXJ2ZXJPck9uTmV4dDtcbiAgICAgIHRoaXMuX29FID0gb25FcnJvcjtcbiAgICAgIHRoaXMuX29DID0gb25Db21wbGV0ZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMudCA9ICFwLl9vTiB8fCBpc0Z1bmN0aW9uKHAuX29OKSA/XG4gICAgICAgIG9ic2VydmVyQ3JlYXRlKHAuX29OIHx8IG5vb3AsIHAuX29FIHx8IG5vb3AsIHAuX29DIHx8IG5vb3ApIDpcbiAgICAgICAgcC5fb047XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMudC5vbk5leHQpLmNhbGwodGhpcy50LCB4KTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy50Lm9uRXJyb3IpLmNhbGwodGhpcy50LCBlcnIpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMudC5vbkNvbXBsZXRlZCkuY2FsbCh0aGlzLnQpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIGludm9rZXMgYW4gYWN0aW9uIHVwb24gZ3JhY2VmdWwgb3IgZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JzZXJ2ZXJ9IG9ic2VydmVyT3JPbk5leHQgQWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIGFuIG8uXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdICBBY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuIFVzZWQgaWYgb25seSB0aGUgb2JzZXJ2ZXJPck9uTmV4dCBwYXJhbWV0ZXIgaXMgYWxzbyBhIGZ1bmN0aW9uLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlZF0gIEFjdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVXNlZCBpZiBvbmx5IHRoZSBvYnNlcnZlck9yT25OZXh0IHBhcmFtZXRlciBpcyBhbHNvIGEgZnVuY3Rpb24uXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvWydkbyddID0gb2JzZXJ2YWJsZVByb3RvLnRhcCA9IG9ic2VydmFibGVQcm90by5kb0FjdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgIHJldHVybiBuZXcgVGFwT2JzZXJ2YWJsZSh0aGlzLCBvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCk7XG4gIH07XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgQWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uTmV4dCA9IG9ic2VydmFibGVQcm90by50YXBPbk5leHQgPSBmdW5jdGlvbiAob25OZXh0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICh4KSB7IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgpOyB9IDogb25OZXh0KTtcbiAgfTtcblxuICAvKipcbiAgKiAgSW52b2tlcyBhbiBhY3Rpb24gdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZywgbG9nZ2luZywgZXRjLiBvZiBxdWVyeSBiZWhhdmlvciBieSBpbnRlcmNlcHRpbmcgdGhlIG1lc3NhZ2Ugc3RyZWFtIHRvIHJ1biBhcmJpdHJhcnkgYWN0aW9ucyBmb3IgbWVzc2FnZXMgb24gdGhlIHBpcGVsaW5lLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQWN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uRXJyb3IgPSBvYnNlcnZhYmxlUHJvdG8udGFwT25FcnJvciA9IGZ1bmN0aW9uIChvbkVycm9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIChlKSB7IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlKTsgfSA6IG9uRXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAqICBJbnZva2VzIGFuIGFjdGlvbiB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nLCBsb2dnaW5nLCBldGMuIG9mIHF1ZXJ5IGJlaGF2aW9yIGJ5IGludGVyY2VwdGluZyB0aGUgbWVzc2FnZSBzdHJlYW0gdG8gcnVuIGFyYml0cmFyeSBhY3Rpb25zIGZvciBtZXNzYWdlcyBvbiB0aGUgcGlwZWxpbmUuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgQWN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uQ29tcGxldGVkID0gb2JzZXJ2YWJsZVByb3RvLnRhcE9uQ29tcGxldGVkID0gZnVuY3Rpb24gKG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICgpIHsgb25Db21wbGV0ZWQuY2FsbCh0aGlzQXJnKTsgfSA6IG9uQ29tcGxldGVkKTtcbiAgfTtcblxuICB2YXIgRmluYWxseU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZpbmFsbHlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlPYnNlcnZhYmxlKHNvdXJjZSwgZm4sIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBiaW5kQ2FsbGJhY2soZm4sIHRoaXNBcmcsIDApO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmluYWxseU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGQgPSB0cnlDYXRjaCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUpLmNhbGwodGhpcy5zb3VyY2UsIG8pO1xuICAgICAgaWYgKGQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX2ZuKCk7XG4gICAgICAgIHRocm93ZXIoZC5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBGaW5hbGx5RGlzcG9zYWJsZShkLCB0aGlzLl9mbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZpbmFsbHlEaXNwb3NhYmxlKHMsIGZuKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICB9XG4gICAgRmluYWxseURpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fcy5kaXNwb3NlKS5jYWxsKHRoaXMuX3MpO1xuICAgICAgICB0aGlzLl9mbigpO1xuICAgICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmluYWxseU9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgSW52b2tlcyBhIHNwZWNpZmllZCBhY3Rpb24gYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZ3JhY2VmdWxseSBvciBleGNlcHRpb25hbGx5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5hbGx5QWN0aW9uIEFjdGlvbiB0byBpbnZva2UgYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgYWN0aW9uLWludm9raW5nIHRlcm1pbmF0aW9uIGJlaGF2aW9yIGFwcGxpZWQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ2ZpbmFsbHknXSA9IGZ1bmN0aW9uIChhY3Rpb24sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZpbmFsbHlPYnNlcnZhYmxlKHRoaXMsIGFjdGlvbiwgdGhpc0FyZyk7XG4gIH07XG5cbiAgdmFyIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJZ25vcmVFbGVtZW50c09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c09ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUub25OZXh0ID0gbm9vcDtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vLm9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBJZ25vcmVFbGVtZW50c09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIElnbm9yZXMgYWxsIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgbGVhdmluZyBvbmx5IHRoZSB0ZXJtaW5hdGlvbiBtZXNzYWdlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIGVtcHR5IG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaWduYWxzIHRlcm1pbmF0aW9uLCBzdWNjZXNzZnVsIG9yIGV4Y2VwdGlvbmFsLCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmlnbm9yZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSWdub3JlRWxlbWVudHNPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBNYXRlcmlhbGl6ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1hdGVyaWFsaXplT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbGl6ZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNYXRlcmlhbGl6ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTWF0ZXJpYWxpemVPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXRlcmlhbGl6ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTWF0ZXJpYWxpemVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWF0ZXJpYWxpemVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0KHgpKSB9O1xuICAgIE1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25FcnJvcihlKSk7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcbiAgICBNYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkKCkpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gTWF0ZXJpYWxpemVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBNYXRlcmlhbGl6ZXMgdGhlIGltcGxpY2l0IG5vdGlmaWNhdGlvbnMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBtYXRlcmlhbGl6ZWQgbm90aWZpY2F0aW9uIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWF0ZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRlcmlhbGl6ZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBSZXBlYXRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIHJlcGVhdCBjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc2VxdWVuY2UgcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVwZWF0Q291bnRdICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzZXF1ZW5jZS4gSWYgbm90IHByb3ZpZGVkLCByZXBlYXRzIHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBwcm9kdWNpbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzZXF1ZW5jZSByZXBlYXRlZGx5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIChyZXBlYXRDb3VudCkge1xuICAgIHJldHVybiBlbnVtZXJhYmxlUmVwZWF0KHRoaXMsIHJlcGVhdENvdW50KS5jb25jYXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJlcGVhdHMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIG9yIHVudGlsIGl0IHN1Y2Nlc3NmdWxseSB0ZXJtaW5hdGVzLiBJZiB0aGUgcmV0cnkgY291bnQgaXMgbm90IHNwZWNpZmllZCwgaXQgcmV0cmllcyBpbmRlZmluaXRlbHkuXG4gICAqICBOb3RlIGlmIHlvdSBlbmNvdW50ZXIgYW4gZXJyb3IgYW5kIHdhbnQgaXQgdG8gcmV0cnkgb25jZSwgdGhlbiB5b3UgbXVzdCB1c2UgLnJldHJ5KDIpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHJldHJpZWQgPSByZXRyeS5yZXBlYXQoKTtcbiAgICogIHZhciByZXMgPSByZXRyaWVkID0gcmV0cnkucmVwZWF0KDIpO1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3JldHJ5Q291bnRdICBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgdGhlIHNlcXVlbmNlLiBJZiBub3QgcHJvdmlkZWQsIHJldHJ5IHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNlcXVlbmNlIHJlcGVhdGVkbHkgdW50aWwgaXQgdGVybWluYXRlcyBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmV0cnkgPSBmdW5jdGlvbiAocmV0cnlDb3VudCkge1xuICAgIHJldHVybiBlbnVtZXJhYmxlUmVwZWF0KHRoaXMsIHJldHJ5Q291bnQpLmNhdGNoRXJyb3IoKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAaXRlcmF0b3InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIFJldHJ5V2hlbk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGlzcG9zYWJsZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5PYnNlcnZhYmxlKHNvdXJjZSwgbm90aWZpZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fbm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFJldHJ5V2hlbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBSZXRyeVdoZW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBleGNlcHRpb25zID0gbmV3IFN1YmplY3QoKSxcbiAgICAgICAgbm90aWZpZXIgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBoYW5kbGVkID0gdGhpcy5fbm90aWZpZXIoZXhjZXB0aW9ucyksXG4gICAgICAgIG5vdGlmaWNhdGlvbkRpc3Bvc2FibGUgPSBoYW5kbGVkLnN1YnNjcmliZShub3RpZmllcik7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zb3VyY2VbJ0BAaXRlcmF0b3InXSgpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB7IGlzRGlzcG9zZWQ6IGZhbHNlIH0sXG4gICAgICAgIGxhc3RFcnJvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShudWxsLCBmdW5jdGlvbiAoXywgcmVjdXJzZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gZS5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHtcbiAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IobGFzdEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG5ldyBCaW5hcnlEaXNwb3NhYmxlKGlubmVyLCBvdXRlcikpO1xuICAgICAgICBvdXRlci5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24oeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7XG4gICAgICAgICAgICBpbm5lci5zZXREaXNwb3NhYmxlKG5vdGlmaWVyLnN1YnNjcmliZShyZWN1cnNlLCBmdW5jdGlvbihleCkge1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZXhjZXB0aW9ucy5vbk5leHQoZXhuKTtcbiAgICAgICAgICAgIG91dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvLm9uQ29tcGxldGVkKCk7IH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtub3RpZmljYXRpb25EaXNwb3NhYmxlLCBzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXRyeVdoZW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgb2JzZXJ2YWJsZVByb3RvLnJldHJ5V2hlbiA9IGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgIHJldHVybiBuZXcgUmV0cnlXaGVuT2JzZXJ2YWJsZShyZXBlYXQodGhpcyksIG5vdGlmaWVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAaXRlcmF0b3InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIFJlcGVhdFdoZW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVwZWF0V2hlbk9ic2VydmFibGUoc291cmNlLCBub3RpZmllcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoUmVwZWF0V2hlbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBSZXBlYXRXaGVuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgY29tcGxldGlvbnMgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBub3RpZmllciA9IG5ldyBTdWJqZWN0KCksXG4gICAgICAgIGhhbmRsZWQgPSB0aGlzLl9ub3RpZmllcihjb21wbGV0aW9ucyksXG4gICAgICAgIG5vdGlmaWNhdGlvbkRpc3Bvc2FibGUgPSBoYW5kbGVkLnN1YnNjcmliZShub3RpZmllcik7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zb3VyY2VbJ0BAaXRlcmF0b3InXSgpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB7IGlzRGlzcG9zZWQ6IGZhbHNlIH0sXG4gICAgICAgIGxhc3RFcnJvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShudWxsLCBmdW5jdGlvbiAoXywgcmVjdXJzZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gZS5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHtcbiAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IobGFzdEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG5ldyBCaW5hcnlEaXNwb3NhYmxlKGlubmVyLCBvdXRlcikpO1xuICAgICAgICBvdXRlci5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24oeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7IG8ub25FcnJvcihleG4pOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZShub3RpZmllci5zdWJzY3JpYmUocmVjdXJzZSwgZnVuY3Rpb24oZXgpIHtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGV4KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNvbXBsZXRpb25zLm9uTmV4dChudWxsKTtcbiAgICAgICAgICAgIG91dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbbm90aWZpY2F0aW9uRGlzcG9zYWJsZSwgc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlLCBjcmVhdGVEaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0V2hlbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBvYnNlcnZhYmxlUHJvdG8ucmVwZWF0V2hlbiA9IGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgIHJldHVybiBuZXcgUmVwZWF0V2hlbk9ic2VydmFibGUocmVwZWF0KHRoaXMpLCBub3RpZmllcik7XG4gIH07XG5cbiAgdmFyIFNjYW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNjYW5PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNjYW5PYnNlcnZhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTY2FuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNjYW5PYnNlcnZlcihvLHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjYW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNjYW5PYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2Nhbk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNjYW5PYnNlcnZlcihvLCBwYXJlbnQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHBhcmVudDtcbiAgICAgIHRoaXMuX2ZuID0gcGFyZW50LmFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5faHMgPSBwYXJlbnQuaGFzU2VlZDtcbiAgICAgIHRoaXMuX3MgPSBwYXJlbnQuc2VlZDtcbiAgICAgIHRoaXMuX2hhID0gZmFsc2U7XG4gICAgICB0aGlzLl9hID0gbnVsbDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNjYW5PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAhdGhpcy5faHYgJiYgKHRoaXMuX2h2ID0gdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5faGEpIHtcbiAgICAgICAgdGhpcy5fYSA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9hLCB4LCB0aGlzLl9pLCB0aGlzLl9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2EgPSB0aGlzLl9ocyA/IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9zLCB4LCB0aGlzLl9pLCB0aGlzLl9wKSA6IHg7XG4gICAgICAgIHRoaXMuX2hhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX2EuZSk7IH1cbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX2EpO1xuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG5cbiAgICBTY2FuT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU2Nhbk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAhdGhpcy5faHYgJiYgdGhpcy5faHMgJiYgdGhpcy5fby5vbk5leHQodGhpcy5fcyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2FuT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqICBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgcmV0dXJucyBlYWNoIGludGVybWVkaWF0ZSByZXN1bHQuIFRoZSBvcHRpb25hbCBzZWVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICogIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIG5vIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5hZ2dyZWdhdGUuXG4gICogQHBhcmFtIHtNaXhlZH0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGFjY3VtdWxhdGVkIHZhbHVlcy5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNjYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZSwgc2VlZCwgYWNjdW11bGF0b3IgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgICAgc2VlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTY2FuT2JzZXJ2YWJsZSh0aGlzLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCk7XG4gIH07XG5cbiAgdmFyIFNraXBMYXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0T2JzZXJ2YWJsZShzb3VyY2UsIGMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcExhc3RPYnNlcnZlcihvLCB0aGlzLl9jKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwTGFzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcExhc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwTGFzdE9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkpO1xuICAgIH07XG5cbiAgICBTa2lwTGFzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFNraXBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgQnlwYXNzZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgdGhlIGZpcnN0IGBjb3VudGAgZWxlbWVudHMuIEFzIG1vcmUgZWxlbWVudHMgYXJlXG4gICAqICByZWNlaXZlZCwgZWxlbWVudHMgYXJlIHRha2VuIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZC5cbiAgICogQHBhcmFtIGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byBieXBhc3MgYXQgdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UgZWxlbWVudHMgZXhjZXB0IGZvciB0aGUgYnlwYXNzZWQgb25lcyBhdCB0aGUgZW5kLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBMYXN0ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgU2tpcExhc3RPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICAvKipcbiAgICogIFByZXBlbmRzIGEgc2VxdWVuY2Ugb2YgdmFsdWVzIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBzY2hlZHVsZXIgYW5kIGFuIGFyZ3VtZW50IGxpc3Qgb2YgdmFsdWVzIHRvIHByZXBlbmQuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zdGFydFdpdGgoMSwgMiwgMyk7XG4gICAqICB2YXIgcmVzID0gc291cmNlLnN0YXJ0V2l0aChSeC5TY2hlZHVsZXIudGltZW91dCwgMSwgMiwgMyk7XG4gICAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmdzIFRoZSBzcGVjaWZpZWQgdmFsdWVzIHRvIHByZXBlbmQgdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2UgcHJlcGVuZGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3RhcnRXaXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMsIHNjaGVkdWxlciwgc3RhcnQgPSAwO1xuICAgIGlmICghIWFyZ3VtZW50cy5sZW5ndGggJiYgaXNTY2hlZHVsZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXI7XG4gICAgfVxuICAgIGZvcih2YXIgYXJncyA9IFtdLCBpID0gc3RhcnQsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlQ29uY2F0LmFwcGx5KG51bGwsIFtvYnNlcnZhYmxlRnJvbUFycmF5KGFyZ3MsIHNjaGVkdWxlciksIHRoaXNdKTtcbiAgfTtcblxuICB2YXIgVGFrZUxhc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdE9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9xLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVGFrZUxhc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCkgeyB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkpOyB9XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlTGFzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNvbnRpZ3VvdXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIGJ1ZmZlciB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyBjb3VudCBlbGVtZW50cy4gVXBvbiBjb21wbGV0aW9uIG9mXG4gICAqICB0aGUgc291cmNlIHNlcXVlbmNlLCB0aGlzIGJ1ZmZlciBpcyBkcmFpbmVkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBkZWxheWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RPYnNlcnZlcihvLCBjb3VudCkpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RCdWZmZXJPYnNlcnZlcihvLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fcSA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZUxhc3RCdWZmZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9xLnB1c2goeCk7XG4gICAgICB0aGlzLl9xLmxlbmd0aCA+IHRoaXMuX2MgJiYgdGhpcy5fcS5zaGlmdCgpO1xuICAgIH07XG5cbiAgICBUYWtlTGFzdEJ1ZmZlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3EpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZUxhc3RCdWZmZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgYnVmZmVyIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGNvdW50IGVsZW1lbnRzLiBVcG9uIGNvbXBsZXRpb24gb2YgdGhlXG4gICAqICBzb3VyY2Ugc2VxdWVuY2UsIHRoaXMgYnVmZmVyIGlzIHByb2R1Y2VkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZSBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VMYXN0QnVmZmVyID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIobywgY291bnQpKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gZWxlbWVudCBjb3VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IExlbmd0aCBvZiBlYWNoIHdpbmRvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIHdpbmRvd3MuIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBjb3VudC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoQ291bnQgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93Q291bnQgPSBmdW5jdGlvbiAoY291bnQsIHNraXApIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICArY291bnQgfHwgKGNvdW50ID0gMCk7XG4gICAgTWF0aC5hYnMoY291bnQpID09PSBJbmZpbml0eSAmJiAoY291bnQgPSAwKTtcbiAgICBpZiAoY291bnQgPD0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHNraXAgPT0gbnVsbCAmJiAoc2tpcCA9IGNvdW50KTtcbiAgICArc2tpcCB8fCAoc2tpcCA9IDApO1xuICAgIE1hdGguYWJzKHNraXApID09PSBJbmZpbml0eSAmJiAoc2tpcCA9IDApO1xuXG4gICAgaWYgKHNraXAgPD0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUobSksXG4gICAgICAgIG4gPSAwLFxuICAgICAgICBxID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyAoKSB7XG4gICAgICAgIHZhciBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgcS5wdXNoKHMpO1xuICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVXaW5kb3coKTtcblxuICAgICAgbS5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbk5leHQoeCk7IH1cbiAgICAgICAgICB2YXIgYyA9IG4gLSBjb3VudCArIDE7XG4gICAgICAgICAgYyA+PSAwICYmIGMgJSBza2lwID09PSAwICYmIHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICsrbiAlIHNraXAgPT09IDAgJiYgY3JlYXRlV2luZG93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkgeyBxLnNoaWZ0KCkub25FcnJvcihlKTsgfVxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7IHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29uY2F0TWFwKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgc2VsZWN0b3JGdW5jID0gYmluZENhbGxiYWNrKHNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gc291cmNlLm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlbGVjdG9yRnVuYyh4LCBpLCBzb3VyY2UpO1xuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgIChpc0FycmF5TGlrZShyZXN1bHQpIHx8IGlzSXRlcmFibGUocmVzdWx0KSkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tKHJlc3VsdCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KS5jb25jYXRBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgT25lIG9mIHRoZSBGb2xsb3dpbmc6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBtZXJnZXMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5jb25jYXRNYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUucmFuZ2UoMCwgeCk7IH0pO1xuICAgKiAgT3I6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCBpbnZva2VzIHRoZSByZXN1bHQgc2VsZWN0b3IgZm9yIHRoZSBzb3VyY2UgZWxlbWVudCBhbmQgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZyBpbm5lciBzZXF1ZW5jZSdzIGVsZW1lbnRzLCBhbmQgbWVyZ2VzIHRoZSByZXN1bHRzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqICB2YXIgcmVzID0gc291cmNlLmNvbmNhdE1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5yYW5nZSgwLCB4KTsgfSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggKyB5OyB9KTtcbiAgICogIE9yOlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byB0aGUgb3RoZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogIHZhciByZXMgPSBzb3VyY2UuY29uY2F0TWFwKFJ4Lk9ic2VydmFibGUuZnJvbUFycmF5KFsxLDIsM10pKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50IG9yIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gcHJvamVjdCBlYWNoIGVsZW1lbnQgZnJvbSB0aGVcbiAgICogc291cmNlIHNlcXVlbmNlIG9udG8gd2hpY2ggY291bGQgYmUgZWl0aGVyIGFuIG9ic2VydmFibGUgb3IgUHJvbWlzZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc3VsdFNlbGVjdG9yXSAgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnRlcm1lZGlhdGUgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29sbGVjdGlvblNlbGVjdG9yIG9uIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UgYW5kIHRoZW4gbWFwcGluZyBlYWNoIG9mIHRob3NlIHNlcXVlbmNlIGVsZW1lbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHNvdXJjZSBlbGVtZW50IHRvIGEgcmVzdWx0IGVsZW1lbnQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0Q29uY2F0ID0gb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE1hcCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikgJiYgaXNGdW5jdGlvbihyZXN1bHRTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmNhdE1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgc2VsZWN0b3JSZXN1bHQgPSBzZWxlY3Rvcih4LCBpKTtcbiAgICAgICAgaXNQcm9taXNlKHNlbGVjdG9yUmVzdWx0KSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc2VsZWN0b3JSZXN1bHQpKTtcbiAgICAgICAgKGlzQXJyYXlMaWtlKHNlbGVjdG9yUmVzdWx0KSB8fCBpc0l0ZXJhYmxlKHNlbGVjdG9yUmVzdWx0KSkgJiYgKHNlbGVjdG9yUmVzdWx0ID0gb2JzZXJ2YWJsZUZyb20oc2VsZWN0b3JSZXN1bHQpKTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3JSZXN1bHQubWFwKGZ1bmN0aW9uICh5LCBpMikge1xuICAgICAgICAgIHJldHVybiByZXN1bHRTZWxlY3Rvcih4LCB5LCBpLCBpMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICBjb25jYXRNYXAodGhpcywgc2VsZWN0b3IsIHRoaXNBcmcpIDpcbiAgICAgIGNvbmNhdE1hcCh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3RvcjsgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGVhY2ggbm90aWZpY2F0aW9uIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgY29uY2F0cyB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uTmV4dCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQ7IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgd2hlbiB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaXMgcmVhY2hlZC5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBcInRoaXNcIiB0byB1c2UgdG8gaW52b2tlIGVhY2ggdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgb25lLXRvLW1hbnkgdHJhbnNmb3JtIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBub3RpZmljYXRpb24gaW4gdGhlIGlucHV0IHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE1hcE9ic2VydmVyID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdENvbmNhdE9ic2VydmVyID0gZnVuY3Rpb24ob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCwgdGhpc0FyZykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLFxuICAgICAgICBvbk5leHRGdW5jID0gYmluZENhbGxiYWNrKG9uTmV4dCwgdGhpc0FyZywgMiksXG4gICAgICAgIG9uRXJyb3JGdW5jID0gYmluZENhbGxiYWNrKG9uRXJyb3IsIHRoaXNBcmcsIDEpLFxuICAgICAgICBvbkNvbXBsZXRlZEZ1bmMgPSBiaW5kQ2FsbGJhY2sob25Db21wbGV0ZWQsIHRoaXNBcmcsIDApO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvbk5leHRGdW5jKHgsIGluZGV4KyspO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvbkVycm9yRnVuYyhlcnIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uQ29tcGxldGVkRnVuYygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcykuY29uY2F0QWxsKCk7XG4gIH07XG5cbiAgdmFyIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVmYXVsdElmRW1wdHlPYnNlcnZlcihvLCBkKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fZiA9IGZhbHNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVmYXVsdElmRW1wdHlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9mID0gdHJ1ZTtcbiAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBEZWZhdWx0SWZFbXB0eU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICF0aGlzLl9mICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX2QpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHNlcXVlbmNlIG9yIHRoZSBzcGVjaWZpZWQgdmFsdWUgaW4gYSBzaW5nbGV0b24gc2VxdWVuY2UgaWYgdGhlIHNlcXVlbmNlIGlzIGVtcHR5LlxuICAgKlxuICAgKiAgdmFyIHJlcyA9IG9icyA9IHhzLmRlZmF1bHRJZkVtcHR5KCk7XG4gICAqICAyIC0gb2JzID0geHMuZGVmYXVsdElmRW1wdHkoZmFsc2UpO1xuICAgKlxuICAgKiBAbWVtYmVyT2YgT2JzZXJ2YWJsZSNcbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS4gSWYgbm90IHByb3ZpZGVkLCB0aGlzIGRlZmF1bHRzIHRvIG51bGwuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBkZWZhdWx0IHZhbHVlIGlmIHRoZSBzb3VyY2UgaXMgZW1wdHk7IG90aGVyd2lzZSwgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2UgaXRzZWxmLlxuICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uZGVmYXVsdElmRW1wdHkgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICAgIGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIChkZWZhdWx0VmFsdWUgPSBudWxsKTtcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVmYXVsdElmRW1wdHlPYnNlcnZlcihvLCBkZWZhdWx0VmFsdWUpKTtcbiAgICAgIH0sIHNvdXJjZSk7XG4gICAgfTtcblxuICAvLyBTd2FwIG91dCBmb3IgQXJyYXkuZmluZEluZGV4XG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZkNvbXBhcmVyKGFycmF5LCBpdGVtLCBjb21wYXJlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNvbXBhcmVyKGFycmF5W2ldLCBpdGVtKSkgeyByZXR1cm4gaTsgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBIYXNoU2V0KGNvbXBhcmVyKSB7XG4gICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xuICAgIHRoaXMuc2V0ID0gW107XG4gIH1cbiAgSGFzaFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJldFZhbHVlID0gYXJyYXlJbmRleE9mQ29tcGFyZXIodGhpcy5zZXQsIHZhbHVlLCB0aGlzLmNvbXBhcmVyKSA9PT0gLTE7XG4gICAgcmV0VmFsdWUgJiYgdGhpcy5zZXQucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldFZhbHVlO1xuICB9O1xuXG4gIHZhciBEaXN0aW5jdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdE9ic2VydmFibGUoc291cmNlLCBrZXlGbiwgY21wRm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fa2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuX2NtcEZuID0gY21wRm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEaXN0aW5jdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGlzdGluY3RPYnNlcnZlcihvLCB0aGlzLl9rZXlGbiwgdGhpcy5fY21wRm4pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEaXN0aW5jdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEaXN0aW5jdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0T2JzZXJ2ZXIobywga2V5Rm4sIGNtcEZuKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2tleUZuID0ga2V5Rm47XG4gICAgICB0aGlzLl9oID0gbmV3IEhhc2hTZXQoY21wRm4pO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGlzdGluY3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIga2V5ID0geDtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2tleUZuKSkge1xuICAgICAgICBrZXkgPSB0cnlDYXRjaCh0aGlzLl9rZXlGbikoeCk7XG4gICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oLnB1c2goa2V5KSAmJiB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICB9O1xuXG4gICAgRGlzdGluY3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgRGlzdGluY3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gRGlzdGluY3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBvbmx5IGRpc3RpbmN0IGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUga2V5U2VsZWN0b3IgYW5kIHRoZSBjb21wYXJlci5cbiAgICogIFVzYWdlIG9mIHRoaXMgb3BlcmF0b3Igc2hvdWxkIGJlIGNvbnNpZGVyZWQgY2FyZWZ1bGx5IGR1ZSB0byB0aGUgbWFpbnRlbmFuY2Ugb2YgYW4gaW50ZXJuYWwgbG9va3VwIHN0cnVjdHVyZSB3aGljaCBjYW4gZ3JvdyBsYXJnZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBvYnMgPSB4cy5kaXN0aW5jdCgpO1xuICAgKiAgMiAtIG9icyA9IHhzLmRpc3RpbmN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcbiAgICogIDIgLSBvYnMgPSB4cy5kaXN0aW5jdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSwgZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSA9PT0gYjsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtrZXlTZWxlY3Rvcl0gIEEgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgY29tcGFyaXNvbiBrZXkgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAgVXNlZCB0byBjb21wYXJlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvbmx5IGNvbnRhaW5pbmcgdGhlIGRpc3RpbmN0IGVsZW1lbnRzLCBiYXNlZCBvbiBhIGNvbXB1dGVkIGtleSB2YWx1ZSwgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRpc3RpbmN0ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBEaXN0aW5jdE9ic2VydmFibGUodGhpcywga2V5U2VsZWN0b3IsIGNvbXBhcmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIEdyb3VwcyB0aGUgZWxlbWVudHMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gYSBzcGVjaWZpZWQga2V5IHNlbGVjdG9yIGZ1bmN0aW9uIGFuZCBjb21wYXJlciBhbmQgc2VsZWN0cyB0aGUgcmVzdWx0aW5nIGVsZW1lbnRzIGJ5IHVzaW5nIGEgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IG9ic2VydmFibGUuZ3JvdXBCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSk7XG4gICAqICAyIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSk7XG4gICAqICAzIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcoKTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gZXh0cmFjdCB0aGUga2V5IGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbGVtZW50U2VsZWN0b3JdICBBIGZ1bmN0aW9uIHRvIG1hcCBlYWNoIHNvdXJjZSBlbGVtZW50IHRvIGFuIGVsZW1lbnQgaW4gYW4gb2JzZXJ2YWJsZSBncm91cC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEEgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBncm91cHMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlLCBjb250YWluaW5nIGFsbCBlbGVtZW50cyB0aGF0IHNoYXJlIHRoYXQgc2FtZSBrZXkgdmFsdWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZ3JvdXBCeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBCeVVudGlsKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIG9ic2VydmFibGVOZXZlcik7XG4gIH07XG5cbiAgICAvKipcbiAgICAgKiAgR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBrZXkgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAgICogIEEgZHVyYXRpb24gc2VsZWN0b3IgZnVuY3Rpb24gaXMgdXNlZCB0byBjb250cm9sIHRoZSBsaWZldGltZSBvZiBncm91cHMuIFdoZW4gYSBncm91cCBleHBpcmVzLCBpdCByZWNlaXZlcyBhbiBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24uIFdoZW4gYSBuZXcgZWxlbWVudCB3aXRoIHRoZSBzYW1lXG4gICAgICogIGtleSB2YWx1ZSBhcyBhIHJlY2xhaW1lZCBncm91cCBvY2N1cnMsIHRoZSBncm91cCB3aWxsIGJlIHJlYm9ybiB3aXRoIGEgbmV3IGxpZmV0aW1lIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgcmVzID0gb2JzZXJ2YWJsZS5ncm91cEJ5VW50aWwoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0sIG51bGwsICBmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLm5ldmVyKCk7IH0pO1xuICAgICAqICAyIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSwgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUubmV2ZXIoKTsgfSk7XG4gICAgICogIDMgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9LCAgZnVuY3Rpb24gKCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5uZXZlcigpOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9KTtcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBBIGZ1bmN0aW9uIHRvIGV4dHJhY3QgdGhlIGtleSBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzaWduYWwgdGhlIGV4cGlyYXRpb24gb2YgYSBncm91cC5cbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX1cbiAgICAgKiAgQSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIGdyb3VwcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUsIGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIHRoYXQgc2hhcmUgdGhhdCBzYW1lIGtleSB2YWx1ZS5cbiAgICAgKiAgSWYgYSBncm91cCdzIGxpZmV0aW1lIGV4cGlyZXMsIGEgbmV3IGdyb3VwIHdpdGggdGhlIHNhbWUga2V5IHZhbHVlIGNhbiBiZSBjcmVhdGVkIG9uY2UgYW4gZWxlbWVudCB3aXRoIHN1Y2ggYSBrZXkgdmFsdWUgaXMgZW5jb3V0ZXJlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9ic2VydmFibGVQcm90by5ncm91cEJ5VW50aWwgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgICAgICBncm91cERpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxuICAgICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKSxcbiAgICAgICAgICBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBmdW5jdGlvbiAoaXRlbSkgeyBpdGVtLm9uRXJyb3IoZSk7IH07IH07XG5cbiAgICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChcbiAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdHJ5Q2F0Y2goa2V5U2VsZWN0b3IpKHgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgbWFwLmZvckVhY2goaGFuZGxlRXJyb3Ioa2V5LmUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihrZXkuZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaXJlTmV3TWFwRW50cnkgPSBmYWxzZSwgd3JpdGVyID0gbWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHdyaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB3cml0ZXIpO1xuICAgICAgICAgICAgICBmaXJlTmV3TWFwRW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyZU5ld01hcEVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBHcm91cGVkT2JzZXJ2YWJsZShrZXksIHdyaXRlciwgcmVmQ291bnREaXNwb3NhYmxlKSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbkdyb3VwID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2goZHVyYXRpb25TZWxlY3RvcikoZHVyYXRpb25Hcm91cCk7XG4gICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBtYXAuZm9yRWFjaChoYW5kbGVFcnJvcihkdXJhdGlvbi5lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG8ub25OZXh0KGdyb3VwKTtcblxuICAgICAgICAgICAgICB2YXIgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChtZCk7XG5cbiAgICAgICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBtYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFwWydkZWxldGUnXShrZXkpKSB7IHdyaXRlci5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgICAgICAgICAgICBncm91cERpc3Bvc2FibGUucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0geDtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGVsZW1lbnRTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgZWxlbWVudCA9IHRyeUNhdGNoKGVsZW1lbnRTZWxlY3RvcikoeCk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGVsZW1lbnQuZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvLm9uRXJyb3IoZWxlbWVudC5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cml0ZXIub25OZXh0KGVsZW1lbnQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyBpdGVtLm9uQ29tcGxldGVkKCk7IH0pO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIE1hcE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1hcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBNYXBPYnNlcnZhYmxlKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IGJpbmRDYWxsYmFjayhzZWxlY3RvciwgdGhpc0FyZywgMyk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbm5lck1hcChzZWxlY3Rvciwgc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBpLCBvKSB7IHJldHVybiBzZWxlY3Rvci5jYWxsKHRoaXMsIHNlbGYuc2VsZWN0b3IoeCwgaSwgbyksIGksIG8pOyB9O1xuICAgIH1cblxuICAgIE1hcE9ic2VydmFibGUucHJvdG90eXBlLmludGVybmFsTWFwID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcE9ic2VydmFibGUodGhpcy5zb3VyY2UsIGlubmVyTWFwKHNlbGVjdG9yLCB0aGlzKSwgdGhpc0FyZyk7XG4gICAgfTtcblxuICAgIE1hcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzLnNlbGVjdG9yLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgc2VsZWN0b3IsIHNvdXJjZSkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuc2VsZWN0b3IpKHgsIHRoaXMuaSsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICB0aGlzLm8ub25OZXh0KHJlc3VsdCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gYSBuZXcgZm9ybSBieSBpbmNvcnBvcmF0aW5nIHRoZSBlbGVtZW50J3MgaW5kZXguXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBzb3VyY2UgZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBzb3VyY2UuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tYXAgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNlbGVjdG9yRm4gPSB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RvciA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yOyB9O1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgTWFwT2JzZXJ2YWJsZSA/XG4gICAgICB0aGlzLmludGVybmFsTWFwKHNlbGVjdG9yRm4sIHRoaXNBcmcpIDpcbiAgICAgIG5ldyBNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yRm4sIHRoaXNBcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBsdWNrZXIoYXJncywgbGVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcHBlcih4KSB7XG4gICAgICB2YXIgY3VycmVudFByb3AgPSB4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IGN1cnJlbnRQcm9wW2FyZ3NbaV1dO1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3VycmVudFByb3AgPSBwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50UHJvcDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluXG4gICAqIHRoZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0FyZ3VtZW50c30gYXJndW1lbnRzIFRoZSBuZXN0ZWQgcHJvcGVydGllcyB0byBwbHVjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGx1Y2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBpZiAobGVuID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignTGlzdCBvZiBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBlbXB0eS4nKTsgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIHRoaXMubWFwKHBsdWNrZXIoYXJncywgbGVuKSk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnkgPSBvYnNlcnZhYmxlUHJvdG8ubWVyZ2VNYXAgPSBmdW5jdGlvbihzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykubWVyZ2VBbGwoKTtcbn07XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGVhY2ggbm90aWZpY2F0aW9uIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyByZWFjaGVkLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIFwidGhpc1wiIHRvIHVzZSB0byBpbnZva2UgZWFjaCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG5vdGlmaWNhdGlvbiBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcE9ic2VydmVyID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnlPYnNlcnZlciA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25OZXh0LmNhbGwodGhpc0FyZywgeCwgaW5kZXgrKyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlcnIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9LCBzb3VyY2UpLm1lcmdlQWxsKCk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwTGF0ZXN0ID0gb2JzZXJ2YWJsZVByb3RvLnN3aXRjaE1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5zd2l0Y2hMYXRlc3QoKTtcbn07XG5cbiAgdmFyIFNraXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBPYnNlcnZhYmxlKHNvdXJjZSwgY291bnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBPYnNlcnZlcihvLCB0aGlzLl9jb3VudCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBTa2lwT2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9yID0gYztcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhTa2lwT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuXG4gICAgU2tpcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9yIDw9IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yLS07XG4gICAgICB9XG4gICAgfTtcbiAgICBTa2lwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbigpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIEJ5cGFzc2VzIGEgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCB0aGVuIHJldHVybnMgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIHRoYXQgb2NjdXIgYWZ0ZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFNraXBPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICB2YXIgU2tpcFdoaWxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdoaWxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBXaGlsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdoaWxlT2JzZXJ2ZXIobywgdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFdoaWxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwV2hpbGVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdoaWxlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9yID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXRoaXMuX3IpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3AuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3ApO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICB0aGlzLl9yID0gIXJlcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3IgJiYgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgfTtcbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcFdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBXaGlsZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIEJ5cGFzc2VzIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgbG9uZyBhcyBhIHNwZWNpZmllZCBjb25kaXRpb24gaXMgdHJ1ZSBhbmQgdGhlbiByZXR1cm5zIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gICAqICBUaGUgZWxlbWVudCdzIGluZGV4IGlzIHVzZWQgaW4gdGhlIGxvZ2ljIG9mIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqICB2YXIgcmVzID0gc291cmNlLnNraXBXaGlsZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlIDwgMTA7IH0pO1xuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5za2lwV2hpbGUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gdmFsdWUgPCAxMCB8fCBpbmRleCA8IDEwOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2Ugc3RhcnRpbmcgYXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpbmVhciBzZXJpZXMgdGhhdCBkb2VzIG5vdCBwYXNzIHRoZSB0ZXN0IHNwZWNpZmllZCBieSBwcmVkaWNhdGUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFdoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU2tpcFdoaWxlT2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIFRha2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VPYnNlcnZhYmxlKHNvdXJjZSwgY291bnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VPYnNlcnZlcihvLCB0aGlzLl9jb3VudCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBUYWtlT2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHRoaXMuX3IgPSBjO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFRha2VPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBUYWtlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX3ItLSA+IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIHRoaXMuX3IgPD0gMCAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRha2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGFrZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUYWtlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciBmb3IgdGhlIGVkZ2UgY2FzZSBvZiB0YWtlKDApLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdXNlZCB0byBwcm9kdWNlIGFuIE9uQ29tcGxldGVkIG1lc3NhZ2UgaW4gY2FzZSA8cGFyYW1yZWYgbmFtZT1cImNvdW50IGNvdW50PC9wYXJhbXJlZj4gaXMgc2V0IHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2UgPSBmdW5jdGlvbiAoY291bnQsIHNjaGVkdWxlcikge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICBpZiAoY291bnQgPT09IDApIHsgcmV0dXJuIG9ic2VydmFibGVFbXB0eShzY2hlZHVsZXIpOyB9XG4gICAgcmV0dXJuIG5ldyBUYWtlT2JzZXJ2YWJsZSh0aGlzLCBjb3VudCk7XG4gIH07XG5cbiAgdmFyIFRha2VXaGlsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaGlsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlV2hpbGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VXaGlsZU9ic2VydmVyKG8sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VXaGlsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZVdoaWxlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaGlsZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fciA9IHRydWU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlV2hpbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fcikge1xuICAgICAgICB0aGlzLl9yID0gdHJ5Q2F0Y2godGhpcy5fcC5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcCk7XG4gICAgICAgIGlmICh0aGlzLl9yID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX3IuZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgVGFrZVdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFRha2VXaGlsZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUYWtlV2hpbGVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGVsZW1lbnRzIGZyb20gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBsb25nIGFzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbiBpcyB0cnVlLlxuICAgKiAgVGhlIGVsZW1lbnQncyBpbmRleCBpcyB1c2VkIGluIHRoZSBsb2dpYyBvZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb247IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBzZXF1ZW5jZSB0aGF0IG9jY3VyIGJlZm9yZSB0aGUgZWxlbWVudCBhdCB3aGljaCB0aGUgdGVzdCBubyBsb25nZXIgcGFzc2VzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFRha2VXaGlsZU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIHZhciBGaWx0ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaWx0ZXJPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRmlsdGVyT2JzZXJ2YWJsZShzb3VyY2UsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlsdGVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8sIHRoaXMucHJlZGljYXRlLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlubmVyUHJlZGljYXRlKHByZWRpY2F0ZSwgc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgsIGksIG8pIHsgcmV0dXJuIHNlbGYucHJlZGljYXRlKHgsIGksIG8pICYmIHByZWRpY2F0ZS5jYWxsKHRoaXMsIHgsIGksIG8pOyB9XG4gICAgfVxuXG4gICAgRmlsdGVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW50ZXJuYWxGaWx0ZXIgPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBuZXcgRmlsdGVyT2JzZXJ2YWJsZSh0aGlzLnNvdXJjZSwgaW5uZXJQcmVkaWNhdGUocHJlZGljYXRlLCB0aGlzKSwgdGhpc0FyZyk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgcHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHNob3VsZFlpZWxkID0gdHJ5Q2F0Y2godGhpcy5wcmVkaWNhdGUpKHgsIHRoaXMuaSsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAoc2hvdWxkWWllbGQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm8ub25FcnJvcihzaG91bGRZaWVsZC5lKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFlpZWxkICYmIHRoaXMuby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbHRlck9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqICBGaWx0ZXJzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIG9uIGEgcHJlZGljYXRlIGJ5IGluY29ycG9yYXRpbmcgdGhlIGVsZW1lbnQncyBpbmRleC5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggc291cmNlIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2UgdGhhdCBzYXRpc2Z5IHRoZSBjb25kaXRpb24uXG4gICovXG4gIG9ic2VydmFibGVQcm90by5maWx0ZXIgPSBvYnNlcnZhYmxlUHJvdG8ud2hlcmUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBGaWx0ZXJPYnNlcnZhYmxlID8gdGhpcy5pbnRlcm5hbEZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIDpcbiAgICAgIG5ldyBGaWx0ZXJPYnNlcnZhYmxlKHRoaXMsIHByZWRpY2F0ZSwgdGhpc0FyZyk7XG4gIH07XG5cbiAgdmFyIEV4dHJlbWFCeU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV4dHJlbWFCeU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXh0cmVtYUJ5T2JzZXJ2YWJsZShzb3VyY2UsIGssIGMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fayA9IGs7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV4dHJlbWFCeU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRXh0cmVtYUJ5T2JzZXJ2ZXIobywgdGhpcy5faywgdGhpcy5fYykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXh0cmVtYUJ5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFeHRyZW1hQnlPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXh0cmVtYUJ5T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXh0cmVtYUJ5T2JzZXJ2ZXIobywgaywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fdiA9IG51bGw7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5fbCA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXh0cmVtYUJ5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGtleSA9IHRyeUNhdGNoKHRoaXMuX2spKHgpO1xuICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihrZXkuZSk7IH1cbiAgICAgIHZhciBjb21wYXJpc29uID0gMDtcbiAgICAgIGlmICghdGhpcy5faHYpIHtcbiAgICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgICB0aGlzLl92ID0ga2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGFyaXNvbiA9IHRyeUNhdGNoKHRoaXMuX2MpKGtleSwgdGhpcy5fdik7XG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGNvbXBhcmlzb24uZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJpc29uID4gMCkge1xuICAgICAgICB0aGlzLl92ID0ga2V5O1xuICAgICAgICB0aGlzLl9sID0gW107XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyaXNvbiA+PSAwKSB7IHRoaXMuX2wucHVzaCh4KTsgfVxuICAgIH07XG5cbiAgICBFeHRyZW1hQnlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBFeHRyZW1hQnlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fbCk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHRyZW1hQnlPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgZnVuY3Rpb24gZmlyc3RPbmx5KHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVtcHR5RXJyb3IoKTsgfVxuICAgIHJldHVybiB4WzBdO1xuICB9XG5cbiAgdmFyIFJlZHVjZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVkdWNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VPYnNlcnZhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZWR1Y2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFJlZHVjZU9ic2VydmVyKG9ic2VydmVyLHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlZHVjZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgUmVkdWNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlZHVjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFJlZHVjZU9ic2VydmVyKG8sIHBhcmVudCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fZm4gPSBwYXJlbnQuYWNjdW11bGF0b3I7XG4gICAgICB0aGlzLl9ocyA9IHBhcmVudC5oYXNTZWVkO1xuICAgICAgdGhpcy5fcyA9IHBhcmVudC5zZWVkO1xuICAgICAgdGhpcy5faGEgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2EgPSBudWxsO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUmVkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgIXRoaXMuX2h2ICYmICh0aGlzLl9odiA9IHRydWUpO1xuICAgICAgaWYgKHRoaXMuX2hhKSB7XG4gICAgICAgIHRoaXMuX2EgPSB0cnlDYXRjaCh0aGlzLl9mbikodGhpcy5fYSwgeCwgdGhpcy5faSwgdGhpcy5fcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hID0gdGhpcy5faHMgPyB0cnlDYXRjaCh0aGlzLl9mbikodGhpcy5fcywgeCwgdGhpcy5faSwgdGhpcy5fcCkgOiB4O1xuICAgICAgICB0aGlzLl9oYSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcih0aGlzLl9hLmUpOyB9XG4gICAgICB0aGlzLl9pKys7XG4gICAgfTtcblxuICAgIFJlZHVjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFJlZHVjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9odiAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9hKTtcbiAgICAgICF0aGlzLl9odiAmJiB0aGlzLl9ocyAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9zKTtcbiAgICAgICF0aGlzLl9odiAmJiAhdGhpcy5faHMgJiYgdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVkdWNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgYWdncmVnYXRpb24gYXMgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgcmVzdWx0IHNlcXVlbmNlLiBUaGUgc3BlY2lmaWVkIHNlZWQgdmFsdWUgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgKiBGb3IgYWdncmVnYXRpb24gYmVoYXZpb3Igd2l0aCBpbmNyZW1lbnRhbCBpbnRlcm1lZGlhdGUgcmVzdWx0cywgc2VlIE9ic2VydmFibGUuc2Nhbi5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY2N1bXVsYXRvciBBbiBhY2N1bXVsYXRvciBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIGVhY2ggZWxlbWVudC5cbiAgKiBAcGFyYW0ge0FueX0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBmaW5hbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzU2VlZCA9IGZhbHNlLCBzZWVkLCBhY2N1bXVsYXRvciA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaGFzU2VlZCA9IHRydWU7XG4gICAgICBzZWVkID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZHVjZU9ic2VydmFibGUodGhpcywgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpO1xuICB9O1xuXG4gIHZhciBTb21lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU29tZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU29tZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU29tZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU29tZU9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU29tZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU29tZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTb21lT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTb21lT2JzZXJ2ZXIobywgZm4sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTb21lT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlmIChCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNvbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU29tZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dChmYWxzZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTb21lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW55IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBzYXRpc2ZpZXMgYSBjb25kaXRpb24gaWYgcHJlc2VudCwgZWxzZSBpZiBhbnkgaXRlbXMgYXJlIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV0gQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCBkZXRlcm1pbmluZyB3aGV0aGVyIGFueSBlbGVtZW50cyBpbiB0aGUgc291cmNlIHNlcXVlbmNlIHBhc3MgdGhlIHRlc3QgaW4gdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUgaWYgZ2l2ZW4sIGVsc2UgaWYgYW55IGl0ZW1zIGFyZSBpbiB0aGUgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc29tZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFNvbWVPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgSXNFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKElzRW1wdHlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJc0VtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJc0VtcHR5T2JzZXJ2ZXIobykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSXNFbXB0eU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgSXNFbXB0eU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKElzRW1wdHlPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJc0VtcHR5T2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJc0VtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dChmYWxzZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcbiAgICBJc0VtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIElzRW1wdHlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBJc0VtcHR5T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpcyBlbXB0eS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyBlbXB0eS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSXNFbXB0eU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIEV2ZXJ5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXZlcnlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV2ZXJ5T2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFdmVyeU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRXZlcnlPYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZXJ5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFdmVyeU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFdmVyeU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRXZlcnlPYnNlcnZlcihvLCBmbiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV2ZXJ5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlmICghQm9vbGVhbihyZXN1bHQpKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRXZlcnlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgRXZlcnlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBFdmVyeU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFsbCBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHNhdGlzZnkgYSBjb25kaXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGVdIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UgcGFzcyB0aGUgdGVzdCBpbiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5ldmVyeSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IEV2ZXJ5T2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIEluY2x1ZGVzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW5jbHVkZXNPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluY2x1ZGVzT2JzZXJ2YWJsZShzb3VyY2UsIGVsZW0sIGlkeCkge1xuICAgICAgdmFyIG4gPSAraWR4IHx8IDA7XG4gICAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcblxuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5jbHVkZXNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9uIDwgMCkge1xuICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5jbHVkZXNPYnNlcnZlcihvLCB0aGlzLl9lbGVtLCB0aGlzLl9uKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbmNsdWRlc09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgSW5jbHVkZXNPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW5jbHVkZXNPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbmNsdWRlc09ic2VydmVyKG8sIGVsZW0sIG4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZXIoYSwgYikge1xuICAgICAgcmV0dXJuIChhID09PSAwICYmIGIgPT09IDApIHx8IChhID09PSBiIHx8IChpc05hTihhKSAmJiBpc05hTihiKSkpO1xuICAgIH1cblxuICAgIEluY2x1ZGVzT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2krKyA+PSB0aGlzLl9uICYmIGNvbXBhcmVyKHgsIHRoaXMuX2VsZW0pKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbmNsdWRlc09ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBJbmNsdWRlc09ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KGZhbHNlKTsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIEluY2x1ZGVzT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbmNsdWRlcyBhIHNwZWNpZmllZCBlbGVtZW50IHdpdGggYW4gb3B0aW9uYWwgZXF1YWxpdHkgY29tcGFyZXIuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSB2YWx1ZSB0byBsb2NhdGUgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIEFuIGVxdWFsaXR5IGNvbXBhcmVyIHRvIGNvbXBhcmUgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaW5jbHVkZXMgYW4gZWxlbWVudCB0aGF0IGhhcyB0aGUgc3BlY2lmaWVkIHZhbHVlIGZyb20gdGhlIGdpdmVuIGluZGV4LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmluY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiBuZXcgSW5jbHVkZXNPYnNlcnZhYmxlKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH07XG5cbiAgdmFyIENvdW50T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ291bnRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvdW50T2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb3VudE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgQ291bnRPYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvdW50T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBDb3VudE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb3VudE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQ291bnRPYnNlcnZlcihvLCBmbiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX2MgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ291bnRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICBCb29sZWFuKHJlc3VsdCkgJiYgKHRoaXMuX2MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jKys7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb3VudE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBDb3VudE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9jKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvdW50T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBob3cgbWFueSBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2Ugc2F0aXNmeSBhIGNvbmRpdGlvbiBpZiBwcm92aWRlZCwgZWxzZSB0aGUgY291bnQgb2YgaXRlbXMuXG4gICAqIEBleGFtcGxlXG4gICAqIHJlcyA9IHNvdXJjZS5jb3VudCgpO1xuICAgKiByZXMgPSBzb3VyY2UuY291bnQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAzOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV1BIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyBob3cgbWFueSBlbGVtZW50cyBpbiB0aGUgaW5wdXQgc2VxdWVuY2Ugc2F0aXNmeSB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaWYgcHJvdmlkZWQsIGVsc2UgdGhlIGNvdW50IG9mIGl0ZW1zIGluIHRoZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb3VudCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IENvdW50T2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIEluZGV4T2ZPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmRleE9mT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbmRleE9mT2JzZXJ2YWJsZShzb3VyY2UsIGUsIG4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEluZGV4T2ZPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9uIDwgMCkge1xuICAgICAgICBvLm9uTmV4dCgtMSk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5kZXhPZk9ic2VydmVyKG8sIHRoaXMuX2UsIHRoaXMuX24pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEluZGV4T2ZPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEluZGV4T2ZPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW5kZXhPZk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluZGV4T2ZPYnNlcnZlcihvLCBlLCBuKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5fbiA9IG47XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9uICYmIHggPT09IHRoaXMuX2UpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5faSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuICAgIEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgSW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KC0xKTsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIEluZGV4T2ZPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0FueX0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4XSBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5pbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIG4gPSArZnJvbUluZGV4IHx8IDA7XG4gICAgTWF0aC5hYnMobikgPT09IEluZmluaXR5ICYmIChuID0gMCk7XG4gICAgcmV0dXJuIG5ldyBJbmRleE9mT2JzZXJ2YWJsZSh0aGlzLCBzZWFyY2hFbGVtZW50LCBuKTtcbiAgfTtcblxuICB2YXIgU3VtT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3VtT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTdW1PYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN1bU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3VtT2JzZXJ2ZXIobywgdGhpcy5fZm4sIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdW1PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFN1bU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdW1PYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFN1bU9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fYyA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTdW1PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICB0aGlzLl9jICs9IHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2MgKz0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFN1bU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTdW1PYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fYyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdW1PYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgYSBzZXF1ZW5jZSBvZiB2YWx1ZXMgdGhhdCBhcmUgb2J0YWluZWQgYnkgaW52b2tpbmcgYW4gb3B0aW9uYWwgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UsIGVsc2UgaWYgbm90IHNwZWNpZmllZCBjb21wdXRlcyB0aGUgc3VtIG9uIGVhY2ggaXRlbSBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3VtID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIGZuID0gYmluZENhbGxiYWNrKGtleVNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFN1bU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50cyBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIG1pbmltdW0ga2V5IHZhbHVlIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbXBhcmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbkJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9KTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5taW5CeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC52YWx1ZTsgfSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggLSB5OyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgS2V5IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBrZXkgdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgbGlzdCBvZiB6ZXJvIG9yIG1vcmUgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWluaW11bSBrZXkgdmFsdWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWluQnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGNvbXBhcmVyKSB7XG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdFN1YkNvbXBhcmVyKTtcbiAgICByZXR1cm4gbmV3IEV4dHJlbWFCeU9ic2VydmFibGUodGhpcywga2V5U2VsZWN0b3IsIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlcih4LCB5KSAqIC0xOyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBlbGVtZW50IGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25hbCBjb21wYXJlciBlbHNlIGEgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVzcyB0aGFuIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbigpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbihmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC52YWx1ZSAtIHkudmFsdWU7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBlbGVtZW50cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1pbiA9IGZ1bmN0aW9uIChjb21wYXJlcikge1xuICAgIHJldHVybiB0aGlzLm1pbkJ5KGlkZW50aXR5LCBjb21wYXJlcikubWFwKGZpcnN0T25seSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgbWF4aW11bSAga2V5IHZhbHVlIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbXBhcmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLm1heEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9KTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXhCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC52YWx1ZTsgfSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggLSB5OzsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEtleSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAgQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGtleSB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHplcm8gb3IgbW9yZSBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXhpbXVtIGtleSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5tYXhCeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgY29tcGFyZXIpIHtcbiAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0U3ViQ29tcGFyZXIpO1xuICAgIHJldHVybiBuZXcgRXh0cmVtYUJ5T2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgY29tcGFyZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWF4KCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UubWF4KGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlIC0geS52YWx1ZTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgbWF4aW11bSBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWF4ID0gZnVuY3Rpb24gKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QnkoaWRlbnRpdHksIGNvbXBhcmVyKS5tYXAoZmlyc3RPbmx5KTtcbiAgfTtcblxuICB2YXIgQXZlcmFnZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEF2ZXJhZ2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEF2ZXJhZ2VPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEF2ZXJhZ2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IEF2ZXJhZ2VPYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF2ZXJhZ2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEF2ZXJhZ2VPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBdmVyYWdlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQXZlcmFnZU9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2MgPSAwO1xuICAgICAgdGhpcy5fdCA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBBdmVyYWdlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYodGhpcy5fZm4pIHtcbiAgICAgICAgdmFyIHIgPSB0cnlDYXRjaCh0aGlzLl9mbikoeCwgdGhpcy5fYysrLCB0aGlzLl9zKTtcbiAgICAgICAgaWYgKHIgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioci5lKTsgfVxuICAgICAgICB0aGlzLl90ICs9IHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jKys7XG4gICAgICAgIHRoaXMuX3QgKz0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIEF2ZXJhZ2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgQXZlcmFnZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fYyA9PT0gMCkgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpOyB9XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl90IC8gdGhpcy5fYyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBdmVyYWdlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgYXZlcmFnZSBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgc2VxdWVuY2Ugb3Igb2J0YWluZWQgYnkgaW52b2tpbmcgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSBpZiBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBhdmVyYWdlIG9mIHRoZSBzZXF1ZW5jZSBvZiB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYXZlcmFnZSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBmbjtcbiAgICBpZiAoaXNGdW5jdGlvbihrZXlTZWxlY3RvcikpIHtcbiAgICAgIGZuID0gYmluZENhbGxiYWNrKGtleVNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBdmVyYWdlT2JzZXJ2YWJsZShzb3VyY2UsIGZuKTtcbiAgfTtcblxuICAvKipcbiAgICogIERldGVybWluZXMgd2hldGhlciB0d28gc2VxdWVuY2VzIGFyZSBlcXVhbCBieSBjb21wYXJpbmcgdGhlIGVsZW1lbnRzIHBhaXJ3aXNlIHVzaW5nIGEgc3BlY2lmaWVkIGVxdWFsaXR5IGNvbXBhcmVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoWzEsMiwzXSk7XG4gICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2Uuc2VxdWVuY2VFcXVhbChbeyB2YWx1ZTogNDIgfV0sIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlID09PSB5LnZhbHVlOyB9KTtcbiAgICogMyAtIHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFJ4Lk9ic2VydmFibGUucmV0dXJuVmFsdWUoNDIpKTtcbiAgICogNCAtIHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFJ4Lk9ic2VydmFibGUucmV0dXJuVmFsdWUoeyB2YWx1ZTogNDIgfSksIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlID09PSB5LnZhbHVlOyB9KTtcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzZWNvbmQgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgYXJyYXkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYm90aCBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgYSBzaW5nbGUgZWxlbWVudCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciBib3RoIHNlcXVlbmNlcyBhcmUgb2YgZXF1YWwgbGVuZ3RoIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGFyZSBlcXVhbCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBlcXVhbGl0eSBjb21wYXJlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zZXF1ZW5jZUVxdWFsID0gZnVuY3Rpb24gKHNlY29uZCwgY29tcGFyZXIpIHtcbiAgICB2YXIgZmlyc3QgPSB0aGlzO1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZG9uZWwgPSBmYWxzZSwgZG9uZXIgPSBmYWxzZSwgcWwgPSBbXSwgcXIgPSBbXTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24xID0gZmlyc3Quc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChxci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHYgPSBxci5zaGlmdCgpO1xuICAgICAgICAgIHZhciBlcXVhbCA9IHRyeUNhdGNoKGNvbXBhcmVyKSh2LCB4KTtcbiAgICAgICAgICBpZiAoZXF1YWwgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZXF1YWwuZSk7IH1cbiAgICAgICAgICBpZiAoIWVxdWFsKSB7XG4gICAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmVyKSB7XG4gICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxbC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlKSB7IG8ub25FcnJvcihlKTsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lbCA9IHRydWU7XG4gICAgICAgIGlmIChxbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAocXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9uZXIpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KHRydWUpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIChpc0FycmF5TGlrZShzZWNvbmQpIHx8IGlzSXRlcmFibGUoc2Vjb25kKSkgJiYgKHNlY29uZCA9IG9ic2VydmFibGVGcm9tKHNlY29uZCkpO1xuICAgICAgaXNQcm9taXNlKHNlY29uZCkgJiYgKHNlY29uZCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzZWNvbmQpKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24yID0gc2Vjb25kLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAocWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB2ID0gcWwuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgZXF1YWwgPSB0cnlDYXRjaChjb21wYXJlcikodiwgeCk7XG4gICAgICAgICAgaWYgKGVxdWFsID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGVxdWFsLmUpOyB9XG4gICAgICAgICAgaWYgKCFlcXVhbCkge1xuICAgICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkb25lbCkge1xuICAgICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXIucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oZSkgeyBvLm9uRXJyb3IoZSk7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZXIgPSB0cnVlO1xuICAgICAgICBpZiAocXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvbmVsKSB7XG4gICAgICAgICAgICBvLm9uTmV4dCh0cnVlKTtcbiAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbjEsIHN1YnNjcmlwdGlvbjIpO1xuICAgIH0sIGZpcnN0KTtcbiAgfTtcblxuICB2YXIgRWxlbWVudEF0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRWxlbWVudEF0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50QXRPYnNlcnZhYmxlKHNvdXJjZSwgaSwgZCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9pID0gaTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRWxlbWVudEF0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBFbGVtZW50QXRPYnNlcnZlcihvLCB0aGlzLl9pLCB0aGlzLl9kKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFbGVtZW50QXRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEVsZW1lbnRBdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFbGVtZW50QXRPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIEVsZW1lbnRBdE9ic2VydmVyKG8sIGksIGQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEVsZW1lbnRBdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pLS0gPT09IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnRBdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBFbGVtZW50QXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9vLm9uRXJyb3IobmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fZCk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEVsZW1lbnRBdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleCBpbiBhIHNlcXVlbmNlIG9yIGRlZmF1bHQgdmFsdWUgaWYgbm90IGZvdW5kLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0cmlldmUuXG4gICAqIEBwYXJhbSB7QW55fSBbZGVmYXVsdFZhbHVlXSBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgZWxlbWVudEF0IGRvZXMgbm90IGZpbmQgYSB2YWx1ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZWxlbWVudEF0ID0gIGZ1bmN0aW9uIChpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGluZGV4IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudEF0T2JzZXJ2YWJsZSh0aGlzLCBpbmRleCwgZGVmYXVsdFZhbHVlKTtcbiAgfTtcblxuICB2YXIgU2luZ2xlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2luZ2xlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2luZ2xlT2JzZXJ2ZXIobywgb2JqLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5fdiA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTaW5nbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgc2hvdWxkWWllbGQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYmoucHJlZGljYXRlKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICBCb29sZWFuKHJlcykgJiYgKHNob3VsZFlpZWxkID0gdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHNob3VsZFlpZWxkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRZaWVsZCkge1xuICAgICAgICBpZiAodGhpcy5faHYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fby5vbkVycm9yKG5ldyBFcnJvcignU2VxdWVuY2UgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBtYXRjaGluZyBlbGVtZW50JykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2h2ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdiA9IHg7XG4gICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2luZ2xlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX29iai5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTaW5nbGVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9ubHkgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIG9wdGlvbmFsIHByZWRpY2F0ZSwgYW5kIHJlcG9ydHMgYW4gZXhjZXB0aW9uIGlmIHRoZXJlIGlzIG5vdCBleGFjdGx5IG9uZSBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnNpbmdsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBvYmogPSB7fSwgc291cmNlID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSB7XG4gICAgICAgICAgcHJlZGljYXRlOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgdGhpc0FyZzogYXJndW1lbnRzWzFdLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbiAob2JqLnByZWRpY2F0ZSkpIHtcbiAgICAgICAgdmFyIGZuID0gb2JqLnByZWRpY2F0ZTtcbiAgICAgICAgb2JqLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhmbiwgb2JqLnRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTaW5nbGVPYnNlcnZlcihvLCBvYmosIHNvdXJjZSkpO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9O1xuXG4gIHZhciBGaXJzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZpcnN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGaXJzdE9ic2VydmFibGUoc291cmNlLCBvYmopIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlyc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IEZpcnN0T2JzZXJ2ZXIobywgdGhpcy5fb2JqLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmlyc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEZpcnN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmlyc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGaXJzdE9ic2VydmVyKG8sIG9iaiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlyc3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fb2JqLnByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fb2JqLnByZWRpY2F0ZSkoeCwgdGhpcy5faSsrLCB0aGlzLl9zKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgaWYgKEJvb2xlYW4ocmVzKSkge1xuICAgICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fb2JqLnByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX29iai5kZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9vLm9uRXJyb3IobmV3IEVtcHR5RXJyb3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9vYmouZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmlyc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgaWYgcHJlc2VudCBlbHNlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlIGlmIHByb3ZpZGVkLCBlbHNlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5maXJzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge30sIHNvdXJjZSA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IHtcbiAgICAgICAgcHJlZGljYXRlOiBhcmd1bWVudHNbMF0sXG4gICAgICAgIHRoaXNBcmc6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uIChvYmoucHJlZGljYXRlKSkge1xuICAgICAgdmFyIGZuID0gb2JqLnByZWRpY2F0ZTtcbiAgICAgIG9iai5wcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2soZm4sIG9iai50aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaXJzdE9ic2VydmFibGUodGhpcywgb2JqKTtcbiAgfTtcblxuICB2YXIgTGFzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKExhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIExhc3RPYnNlcnZhYmxlKHNvdXJjZSwgb2JqKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIExhc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IExhc3RPYnNlcnZlcihvLCB0aGlzLl9vYmosIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMYXN0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBMYXN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTGFzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIExhc3RPYnNlcnZlcihvLCBvYmosIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIExhc3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgc2hvdWxkWWllbGQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYmoucHJlZGljYXRlKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICBCb29sZWFuKHJlcykgJiYgKHNob3VsZFlpZWxkID0gdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHNob3VsZFlpZWxkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRZaWVsZCkge1xuICAgICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3YgPSB4O1xuICAgICAgfVxuICAgIH07XG4gICAgTGFzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX29iai5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMYXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgaWYgc3BlY2lmaWVkLCBlbHNlIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHt9LCBzb3VyY2UgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgb2JqID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHByZWRpY2F0ZTogYXJndW1lbnRzWzBdLFxuICAgICAgICB0aGlzQXJnOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogYXJndW1lbnRzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbiAob2JqLnByZWRpY2F0ZSkpIHtcbiAgICAgIHZhciBmbiA9IG9iai5wcmVkaWNhdGU7XG4gICAgICBvYmoucHJlZGljYXRlID0gYmluZENhbGxiYWNrKGZuLCBvYmoudGhpc0FyZywgMyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGFzdE9ic2VydmFibGUodGhpcywgb2JqKTtcbiAgfTtcblxuICB2YXIgRmluZFZhbHVlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmluZFZhbHVlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRmluZFZhbHVlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHNvdXJjZSwgY2FsbGJhY2ssIHlpZWxkSW5kZXgpIHtcbiAgICAgIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jYiA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5feSA9IHlpZWxkSW5kZXg7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEZpbmRWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaG91bGRSdW4gPSB0cnlDYXRjaCh0aGlzLl9jYikoeCwgdGhpcy5faSwgdGhpcy5fcyk7XG4gICAgICBpZiAoc2hvdWxkUnVuID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHNob3VsZFJ1bi5lKTsgfVxuICAgICAgaWYgKHNob3VsZFJ1bikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl95ID8gdGhpcy5faSA6IHgpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pKys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEZpbmRWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIEZpbmRWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl95ICYmIHRoaXMuX28ub25OZXh0KC0xKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbmRWYWx1ZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICBmdW5jdGlvbiBmaW5kVmFsdWUgKHNvdXJjZSwgcHJlZGljYXRlLCB0aGlzQXJnLCB5aWVsZEluZGV4KSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluZFZhbHVlT2JzZXJ2ZXIobywgc291cmNlLCBjYWxsYmFjaywgeWllbGRJbmRleCkpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBvY2N1cnJlbmNlIHdpdGhpbiB0aGUgZW50aXJlIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRoYXQgZGVmaW5lcyB0aGUgY29uZGl0aW9ucyBvZiB0aGUgZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSBwcmVkaWNhdGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGlmIGZvdW5kOyBvdGhlcndpc2UsIHVuZGVmaW5lZC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5maW5kID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmaW5kVmFsdWUodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgY29uZGl0aW9ucyBkZWZpbmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJlZGljYXRlLCBhbmQgcmV0dXJuc1xuICAgKiBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugd2l0aGluIHRoZSBlbnRpcmUgT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdGhhdCBkZWZpbmVzIHRoZSBjb25kaXRpb25zIG9mIHRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgY29uZGl0aW9ucyBkZWZpbmVkIGJ5IG1hdGNoLCBpZiBmb3VuZDsgb3RoZXJ3aXNlLCDigJMxLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZmluZEluZGV4ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmaW5kVmFsdWUodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnLCB0cnVlKTtcbiAgfTtcblxuICB2YXIgVG9TZXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb1NldE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9TZXRPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb1NldE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVG9TZXRPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb1NldE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVG9TZXRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVG9TZXRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUb1NldE9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IG5ldyByb290LlNldCgpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9TZXRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zLmFkZCh4KTtcbiAgICB9O1xuXG4gICAgVG9TZXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUb1NldE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9zKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvU2V0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIFNldCBpZiBpdCBleGlzdHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgdmFsdWUgb2YgYSBTZXQgY29udGFpbmluZyB0aGUgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udG9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiByb290LlNldCA9PT0gJ3VuZGVmaW5lZCcpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyB9XG4gICAgcmV0dXJuIG5ldyBUb1NldE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFRvTWFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVG9NYXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvTWFwT2JzZXJ2YWJsZShzb3VyY2UsIGssIGUpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fayA9IGs7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRvTWFwT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUb01hcE9ic2VydmVyKG8sIHRoaXMuX2ssIHRoaXMuX2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvTWFwT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUb01hcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb01hcE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvTWFwT2JzZXJ2ZXIobywgaywgZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5fbSA9IG5ldyByb290Lk1hcCgpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9NYXBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIga2V5ID0gdHJ5Q2F0Y2godGhpcy5faykoeCk7XG4gICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGtleS5lKTsgfVxuICAgICAgdmFyIGVsZW0gPSB4O1xuICAgICAgaWYgKHRoaXMuX2UpIHtcbiAgICAgICAgZWxlbSA9IHRyeUNhdGNoKHRoaXMuX2UpKHgpO1xuICAgICAgICBpZiAoZWxlbSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihlbGVtLmUpOyB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX20uc2V0KGtleSwgZWxlbSk7XG4gICAgfTtcblxuICAgIFRvTWFwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVG9NYXBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fbSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb01hcE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBDb252ZXJ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIE1hcCBpZiBpdCBleGlzdHMuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgQSBmdW5jdGlvbiB3aGljaCBwcm9kdWNlcyB0aGUga2V5IGZvciB0aGUgTWFwLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbGVtZW50U2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIHRoZSBlbGVtZW50IGZvciB0aGUgTWFwLiBJZiBub3QgcHJlc2VudCwgZGVmYXVsdHMgdG8gdGhlIHZhbHVlIGZyb20gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSB2YWx1ZSBvZiBhIE1hcCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRvTWFwID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpIHtcbiAgICBpZiAodHlwZW9mIHJvb3QuTWFwID09PSAndW5kZWZpbmVkJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFRvTWFwT2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yKTtcbiAgfTtcblxuICB2YXIgU2xpY2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTbGljZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2xpY2VPYnNlcnZhYmxlKHNvdXJjZSwgYiwgZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9iID0gYjtcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2xpY2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNsaWNlT2JzZXJ2ZXIobywgdGhpcy5fYiwgdGhpcy5fZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2xpY2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNsaWNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNsaWNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTbGljZU9ic2VydmVyKG8sIGIsIGUpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2xpY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9iKSB7XG4gICAgICAgIGlmICh0aGlzLl9lID09PSB0aGlzLl9pKSB7XG4gICAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pKys7XG4gICAgfTtcbiAgICBTbGljZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTbGljZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBTbGljZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKlxuICAqIFRoZSBzbGljZSgpIG1ldGhvZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhbiBPYnNlcnZhYmxlIGludG8gYSBuZXcgT2JzZXJ2YWJsZSBvYmplY3QuXG4gICogVW5saWtlIHRoZSBhcnJheSB2ZXJzaW9uLCB0aGlzIGRvZXMgbm90IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVycyBmb3IgYmVpbmcgb3IgZW5kLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW5dIFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gYmVnaW4gZXh0cmFjdGlvbi4gSWYgb21pdHRlZCwgdGhpcyB3aWxsIGRlZmF1bHQgdG8gemVyby5cbiAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBlbmQgZXh0cmFjdGlvbi4gc2xpY2UgZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLlxuICAqIElmIG9taXR0ZWQsIHRoaXMgd2lsbCBlbWl0IHRoZSByZXN0IG9mIHRoZSBPYnNlcnZhYmxlIG9iamVjdC5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIGFuIE9ic2VydmFibGUgaW50byBhIG5ldyBPYnNlcnZhYmxlIG9iamVjdC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNsaWNlID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc3RhcnQgPSBiZWdpbiB8fCAwO1xuICAgIGlmIChzdGFydCA8IDApIHsgdGhyb3cgbmV3IFJ4LkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiYgZW5kIDwgc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBSeC5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlT2JzZXJ2YWJsZSh0aGlzLCBzdGFydCwgZW5kKTtcbiAgfTtcblxuICB2YXIgTGFzdEluZGV4T2ZPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhMYXN0SW5kZXhPZk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTGFzdEluZGV4T2ZPYnNlcnZhYmxlKHNvdXJjZSwgZSwgbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdEluZGV4T2ZPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9uIDwgMCkge1xuICAgICAgICBvLm9uTmV4dCgtMSk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTGFzdEluZGV4T2ZPYnNlcnZlcihvLCB0aGlzLl9lLCB0aGlzLl9uKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMYXN0SW5kZXhPZk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTGFzdEluZGV4T2ZPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTGFzdEluZGV4T2ZPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBMYXN0SW5kZXhPZk9ic2VydmVyKG8sIGUsIG4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIHRoaXMuX3YgPSAwO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9uICYmIHggPT09IHRoaXMuX2UpIHtcbiAgICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgICB0aGlzLl92ID0gdGhpcy5faTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuICAgIExhc3RJbmRleE9mT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIExhc3RJbmRleE9mT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KC0xKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RJbmRleE9mT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0FueX0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4XSBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIG4gPSArZnJvbUluZGV4IHx8IDA7XG4gICAgTWF0aC5hYnMobikgPT09IEluZmluaXR5ICYmIChuID0gMCk7XG4gICAgcmV0dXJuIG5ldyBMYXN0SW5kZXhPZk9ic2VydmFibGUodGhpcywgc2VhcmNoRWxlbWVudCwgbik7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS53cmFwID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZSgpIHtcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLnNwYXduLmNhbGwodGhpcywgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlT2JzZXJ2YWJsZS5fX2dlbmVyYXRvckZ1bmN0aW9uX18gPSBmbjtcbiAgICByZXR1cm4gY3JlYXRlT2JzZXJ2YWJsZTtcbiAgfTtcblxuICB2YXIgc3Bhd24gPSBPYnNlcnZhYmxlLnNwYXduID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBhcmd1bWVudHNbMF0sIHNlbGYgPSB0aGlzLCBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGdlbikpIHsgZ2VuID0gZ2VuLmFwcGx5KHNlbGYsIGFyZ3MpOyB9XG4gICAgICBpZiAoIWdlbiB8fCAhaXNGdW5jdGlvbihnZW4ubmV4dCkpIHtcbiAgICAgICAgby5vbk5leHQoZ2VuKTtcbiAgICAgICAgcmV0dXJuIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyYXRvcihyZXMpIHtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGdlbi5uZXh0KS5jYWxsKGdlbiwgcmVzKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXQuZSk7IH1cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzR2VuZXJhdG9yKCk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChnZW4ubmV4dCkuY2FsbChnZW4sIGVycik7XG4gICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmV0LmUpOyB9XG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dChyZXQpIHtcbiAgICAgICAgaWYgKHJldC5kb25lKSB7XG4gICAgICAgICAgby5vbk5leHQocmV0LnZhbHVlKTtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYnMgPSB0b09ic2VydmFibGUuY2FsbChzZWxmLCByZXQudmFsdWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG9icykpIHtcbiAgICAgICAgICBnLmFkZChvYnMuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG4gICAgICAgICAgfSwgb25FcnJvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYXNWYWx1ZSAmJiBwcm9jZXNzR2VuZXJhdG9yKHZhbHVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25FcnJvcihuZXcgVHlwZUVycm9yKCd0eXBlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9PYnNlcnZhYmxlKG9iaikge1xuICAgIGlmICghb2JqKSB7IHJldHVybiBvYmo7IH1cbiAgICBpZiAoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob2JqKSkgeyByZXR1cm4gb2JqOyB9XG4gICAgaWYgKGlzUHJvbWlzZShvYmopKSB7IHJldHVybiBPYnNlcnZhYmxlLmZyb21Qcm9taXNlKG9iaik7IH1cbiAgICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbihvYmopIHx8IGlzR2VuZXJhdG9yKG9iaikpIHsgcmV0dXJuIHNwYXduLmNhbGwodGhpcywgb2JqKTsgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpIHsgcmV0dXJuIHRodW5rVG9PYnNlcnZhYmxlLmNhbGwodGhpcywgb2JqKTsgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopIHx8IGlzSXRlcmFibGUob2JqKSkgeyByZXR1cm4gYXJyYXlUb09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmopOyB9XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtyZXR1cm4gb2JqZWN0VG9PYnNlcnZhYmxlLmNhbGwodGhpcywgb2JqKTt9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5VG9PYnNlcnZhYmxlIChvYmopIHtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5mcm9tKG9iaikuY29uY2F0TWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmKE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG8pIHx8IGlzT2JqZWN0KG8pKSB7XG4gICAgICAgIHJldHVybiB0b09ic2VydmFibGUuY2FsbChudWxsLCBvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmp1c3Qobyk7XG4gICAgICB9XG4gICAgfSkudG9BcnJheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0VG9PYnNlcnZhYmxlIChvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBvYmouY29uc3RydWN0b3IoKSwga2V5cyA9IE9iamVjdC5rZXlzKG9iaiksIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0b09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmpba2V5XSk7XG5cbiAgICAgIGlmKG9ic2VydmFibGUgJiYgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob2JzZXJ2YWJsZSkpIHtcbiAgICAgICAgZGVmZXIob2JzZXJ2YWJsZSwga2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYnNlcnZhYmxlLmZvcmtKb2luLmFwcGx5KE9ic2VydmFibGUsIG9ic2VydmFibGVzKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcblxuXG4gICAgZnVuY3Rpb24gZGVmZXIgKG9ic2VydmFibGUsIGtleSkge1xuICAgICAgcmVzdWx0c1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgb2JzZXJ2YWJsZXMucHVzaChvYnNlcnZhYmxlLm1hcChmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXN1bHRzW2tleV0gPSBuZXh0O1xuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRodW5rVG9PYnNlcnZhYmxlKGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgZm4uY2FsbChzZWxmLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF0sIHJlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gby5vbkVycm9yKGVycik7IH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3MucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgICAgICAgcmVzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBvLm9uTmV4dChyZXMpO1xuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzR2VuZXJhdG9yKG9iaikge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uIChvYmoubmV4dCkgJiYgaXNGdW5jdGlvbiAob2JqWyd0aHJvdyddKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgaWYgKCFjdG9yKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjdG9yLm5hbWUgPT09ICdHZW5lcmF0b3JGdW5jdGlvbicgfHwgY3Rvci5kaXNwbGF5TmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJykgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJldHVybiBpc0dlbmVyYXRvcihjdG9yLnByb3RvdHlwZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0ID09IHZhbC5jb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIsIHN1cmZhY2luZyB0aGUgcmVzdWx0IHRocm91Z2ggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuc3RhcnQoZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnaGVsbG8nKTsgfSk7XG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnN0YXJ0KGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2hlbGxvJyk7IH0sIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuc3RhcnQoZnVuY3Rpb24gKCkgeyB0aGlzLmxvZygnaGVsbG8nKTsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQsIGNvbnNvbGUpO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHRvIHJ1biBhc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSBmdW5jdGlvbiBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEBwYXJhbSBbY29udGV4dF0gIFRoZSBjb250ZXh0IGZvciB0aGUgZnVuYyBwYXJhbWV0ZXIgdG8gYmUgZXhlY3V0ZWQuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGV4cG9zaW5nIHRoZSBmdW5jdGlvbidzIHJlc3VsdCB2YWx1ZSwgb3IgYW4gZXhjZXB0aW9uLlxuICAgKlxuICAgKiBSZW1hcmtzXG4gICAqICogVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwgbm90IGR1cmluZyB0aGUgc3Vic2NyaXB0aW9uIG9mIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UuXG4gICAqICogTXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgcmVzdWx0aW5nIHNlcXVlbmNlIGNhbiBvYnNlcnZlIHRoZSBmdW5jdGlvbidzIHJlc3VsdC5cbiAgICovXG4gIE9ic2VydmFibGUuc3RhcnQgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVUb0FzeW5jKGZ1bmMsIGNvbnRleHQsIHNjaGVkdWxlcikoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGZ1bmN0aW9uIGludG8gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLiBFYWNoIGludm9jYXRpb24gb2YgdGhlIHJlc3VsdGluZyBhc3luY2hyb25vdXMgZnVuY3Rpb24gY2F1c2VzIGFuIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiBGdW5jdGlvbiB0byBjb252ZXJ0IHRvIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGZ1bmN0aW9uIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cbiAgICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHRdIFRoZSBjb250ZXh0IGZvciB0aGUgZnVuYyBwYXJhbWV0ZXIgdG8gYmUgZXhlY3V0ZWQuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQXN5bmNocm9ub3VzIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVUb0FzeW5jID0gT2JzZXJ2YWJsZS50b0FzeW5jID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3QoKTtcblxuICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc3ViamVjdC5vbkVycm9yKGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJqZWN0Lm9uTmV4dChyZXN1bHQpO1xuICAgICAgICBzdWJqZWN0Lm9uQ29tcGxldGVkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gIH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNiT2JzZXJ2YWJsZShmbiwgY3R4LCBzZWxlY3RvciwgYXJncykge1xuICB2YXIgbyA9IG5ldyBBc3luY1N1YmplY3QoKTtcblxuICBhcmdzLnB1c2goY3JlYXRlQ2JIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpKTtcbiAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcblxuICByZXR1cm4gby5hc09ic2VydmFibGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2JIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIgKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN1bHRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHJlc3VsdHNbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgcmVzdWx0cyA9IHRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseShjdHgsIHJlc3VsdHMpO1xuICAgICAgaWYgKHJlc3VsdHMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0cy5lKTsgfVxuICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgby5vbkNvbXBsZXRlZCgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvIGNvbnZlcnQgdG8gYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjdHhdIFRoZSBjb250ZXh0IGZvciB0aGUgZnVuYyBwYXJhbWV0ZXIgdG8gYmUgZXhlY3V0ZWQuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIEEgc2VsZWN0b3Igd2hpY2ggdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBjYWxsYmFjayB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiwgd2hlbiBleGVjdXRlZCB3aXRoIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIG1pbnVzIHRoZSBjYWxsYmFjaywgcHJvZHVjZXMgYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIHZhbHVlIG9mIHRoZSBhcmd1bWVudHMgdG8gdGhlIGNhbGxiYWNrIGFzIGFuIGFycmF5LlxuICovXG5PYnNlcnZhYmxlLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmbiwgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHR5cGVvZiBjdHggPT09ICd1bmRlZmluZWQnICYmIChjdHggPSB0aGlzKTsgXG5cbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gY3JlYXRlQ2JPYnNlcnZhYmxlKGZuLCBjdHgsIHNlbGVjdG9yLCBhcmdzKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVPYnNlcnZhYmxlKGZuLCBjdHgsIHNlbGVjdG9yLCBhcmdzKSB7XG4gIHZhciBvID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuXG4gIGFyZ3MucHVzaChjcmVhdGVOb2RlSGFuZGxlcihvLCBjdHgsIHNlbGVjdG9yKSk7XG4gIGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgcmV0dXJuIG8uYXNPYnNlcnZhYmxlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIgKCkge1xuICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGVycikgeyByZXR1cm4gby5vbkVycm9yKGVycik7IH1cblxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN1bHRzID0gW107XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7IHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldOyB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KGN0eCwgcmVzdWx0cyk7XG4gICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgby5vbk5leHQocmVzdWx0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvLm9uQ29tcGxldGVkKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBOb2RlLmpzIGNhbGxiYWNrIHN0eWxlIGZ1bmN0aW9uIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuICBUaGlzIG11c3QgYmUgaW4gZnVuY3Rpb24gKGVyciwgLi4uKSBmb3JtYXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtNaXhlZH0gW2N0eF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGNhbGxiYWNrIG1pbnVzIHRoZSBlcnJvciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggd2hlbiBhcHBsaWVkLCByZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgY2FsbGJhY2sgYXJndW1lbnRzIGFzIGFuIGFycmF5LlxuICovXG5PYnNlcnZhYmxlLmZyb21Ob2RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4sIGN0eCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0eXBlb2YgY3R4ID09PSAndW5kZWZpbmVkJyAmJiAoY3R4ID0gdGhpcyk7IFxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gY3JlYXRlTm9kZU9ic2VydmFibGUoZm4sIGN0eCwgc2VsZWN0b3IsIGFyZ3MpO1xuICB9O1xufTtcblxuICBmdW5jdGlvbiBpc05vZGVMaXN0KGVsKSB7XG4gICAgaWYgKHJvb3QuU3RhdGljTm9kZUxpc3QpIHtcbiAgICAgIC8vIElFOCBTcGVjaWZpY1xuICAgICAgLy8gaW5zdGFuY2VvZiBpcyBzbG93ZXIgdGhhbiBPYmplY3QjdG9TdHJpbmcsIGJ1dCBPYmplY3QjdG9TdHJpbmcgd2lsbCBub3Qgd29yayBhcyBpbnRlbmRlZCBpbiBJRThcbiAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIHJvb3QuU3RhdGljTm9kZUxpc3QgfHwgZWwgaW5zdGFuY2VvZiByb290Lk5vZGVMaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBMaXN0ZW5EaXNwb3NhYmxlKGUsIG4sIGZuKSB7XG4gICAgdGhpcy5fZSA9IGU7XG4gICAgdGhpcy5fbiA9IG47XG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9lLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fbiwgdGhpcy5fZm4sIGZhbHNlKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgfVxuICBMaXN0ZW5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLl9lLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fbiwgdGhpcy5fZm4sIGZhbHNlKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXIgKGVsLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB2YXIgZGlzcG9zYWJsZXMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuXG4gICAgLy8gQXN1bWUgTm9kZUxpc3Qgb3IgSFRNTENvbGxlY3Rpb25cbiAgICB2YXIgZWxlbVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsKTtcbiAgICBpZiAoaXNOb2RlTGlzdChlbCkgfHwgZWxlbVRvU3RyaW5nID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZGlzcG9zYWJsZXMuYWRkKGNyZWF0ZUV2ZW50TGlzdGVuZXIoZWwuaXRlbShpKSwgZXZlbnROYW1lLCBoYW5kbGVyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgZGlzcG9zYWJsZXMuYWRkKG5ldyBMaXN0ZW5EaXNwb3NhYmxlKGVsLCBldmVudE5hbWUsIGhhbmRsZXIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzcG9zYWJsZXM7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBvcHRpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIG5hdGl2ZSBldmVudHMgb25seVxuICAgKi9cbiAgUnguY29uZmlnLnVzZU5hdGl2ZUV2ZW50cyA9IGZhbHNlO1xuXG4gIHZhciBFdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXZlbnRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV2ZW50T2JzZXJ2YWJsZShlbCwgbmFtZSwgZm4pIHtcbiAgICAgIHRoaXMuX2VsID0gZWw7XG4gICAgICB0aGlzLl9uID0gbmFtZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKG8sIGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICByZXN1bHRzID0gdHJ5Q2F0Y2goZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdHMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0cy5lKTsgfVxuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBFdmVudE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHRoaXMuX2VsLFxuICAgICAgICB0aGlzLl9uLFxuICAgICAgICBjcmVhdGVIYW5kbGVyKG8sIHRoaXMuX2ZuKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFdmVudE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGFkZGluZyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWF0Y2hpbmcgRE9NRWxlbWVudCBvciBlYWNoIGl0ZW0gaW4gdGhlIE5vZGVMaXN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBUaGUgRE9NRWxlbWVudCBvciBOb2RlTGlzdCB0byBhdHRhY2ggYSBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBhdHRhY2ggdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgdG8gcHJvZHVjZSBhIHNpbmdsZSBpdGVtIHRvIHlpZWxkIG9uIG5leHQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGV2ZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBhbmQgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICovXG4gIE9ic2VydmFibGUuZnJvbUV2ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IpIHtcbiAgICAvLyBOb2RlLmpzIHNwZWNpZmljXG4gICAgaWYgKGVsZW1lbnQuYWRkTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmcm9tRXZlbnRQYXR0ZXJuKFxuICAgICAgICBmdW5jdGlvbiAoaCkgeyBlbGVtZW50LmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaCk7IH0sXG4gICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBoKTsgfSxcbiAgICAgICAgc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8vIFVzZSBvbmx5IGlmIG5vbi1uYXRpdmUgZXZlbnRzIGFyZSBhbGxvd2VkXG4gICAgaWYgKCFSeC5jb25maWcudXNlTmF0aXZlRXZlbnRzKSB7XG4gICAgICAvLyBIYW5kbGVzIGpxLCBBbmd1bGFyLmpzLCBaZXB0bywgTWFyaW9uZXR0ZSwgRW1iZXIuanNcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZWxlbWVudC5vZmYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZyb21FdmVudFBhdHRlcm4oXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5vbihldmVudE5hbWUsIGgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQub2ZmKGV2ZW50TmFtZSwgaCk7IH0sXG4gICAgICAgICAgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRXZlbnRPYnNlcnZhYmxlKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IpLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIHZhciBFdmVudFBhdHRlcm5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV2ZW50UGF0dGVybk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGQsIGRlbCwgZm4pIHtcbiAgICAgIHRoaXMuX2FkZCA9IGFkZDtcbiAgICAgIHRoaXMuX2RlbCA9IGRlbDtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKG8sIGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICByZXN1bHRzID0gdHJ5Q2F0Y2goZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdHMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0cy5lKTsgfVxuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBFdmVudFBhdHRlcm5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBmbiA9IGNyZWF0ZUhhbmRsZXIobywgdGhpcy5fZm4pO1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdGhpcy5fYWRkKGZuKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZSh0aGlzLl9kZWwsIGZuLCByZXR1cm5WYWx1ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEV2ZW50UGF0dGVybkRpc3Bvc2FibGUoZGVsLCBmbiwgcmV0KSB7XG4gICAgICB0aGlzLl9kZWwgPSBkZWw7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcmV0ID0gcmV0O1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgaXNGdW5jdGlvbih0aGlzLl9kZWwpICYmIHRoaXMuX2RlbCh0aGlzLl9mbiwgdGhpcy5fcmV0KTtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50UGF0dGVybk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYW4gZXZlbnQgZW1pdHRlciB2aWEgYW4gYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyIHBhaXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFkZEhhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGFkZCBhIGhhbmRsZXIgdG8gdGhlIGVtaXR0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZW1vdmVIYW5kbGVyXSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gcmVtb3ZlIGEgaGFuZGxlciBmcm9tIGFuIGVtaXR0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgdG8gcHJvZHVjZSBhIHNpbmdsZSBpdGVtIHRvIHlpZWxkIG9uIG5leHQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHdyYXBzIGFuIGV2ZW50IGZyb20gYW4gZXZlbnQgZW1pdHRlclxuICAgKi9cbiAgdmFyIGZyb21FdmVudFBhdHRlcm4gPSBPYnNlcnZhYmxlLmZyb21FdmVudFBhdHRlcm4gPSBmdW5jdGlvbiAoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50UGF0dGVybk9ic2VydmFibGUoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24sIHN1cmZhY2luZyB0aGUgcmVzdWx0IHRocm91Z2ggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25Bc3luYyBBc3luY2hyb25vdXMgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UgdG8gcnVuLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBleHBvc2luZyB0aGUgZnVuY3Rpb24ncyByZXN1bHQgdmFsdWUsIG9yIGFuIGV4Y2VwdGlvbi5cbiAgICovXG4gIE9ic2VydmFibGUuc3RhcnRBc3luYyA9IGZ1bmN0aW9uIChmdW5jdGlvbkFzeW5jKSB7XG4gICAgdmFyIHByb21pc2UgPSB0cnlDYXRjaChmdW5jdGlvbkFzeW5jKSgpO1xuICAgIGlmIChwcm9taXNlID09PSBlcnJvck9iaikgeyByZXR1cm4gb2JzZXJ2YWJsZVRocm93KHByb21pc2UuZSk7IH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHByb21pc2UpO1xuICB9O1xuXG4gIHZhciBQYXVzYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzYWJsZU9ic2VydmFibGUoc291cmNlLCBwYXVzZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKHBhdXNlciAmJiBwYXVzZXIuc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyLm1lcmdlKHBhdXNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdXNlciA9IHRoaXMuY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUGF1c2FibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjb25uID0gdGhpcy5zb3VyY2UucHVibGlzaCgpLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBjb25uLnN1YnNjcmliZShvKSxcbiAgICAgICAgY29ubmVjdGlvbiA9IGRpc3Bvc2FibGVFbXB0eTtcblxuICAgICAgdmFyIHBhdXNhYmxlID0gdGhpcy5wYXVzZXIuc3RhcnRXaXRoKCF0aGlzLnBhdXNlZCkuZGlzdGluY3RVbnRpbENoYW5nZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBjb25uZWN0aW9uID0gY29ubi5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgY29ubmVjdGlvbiA9IGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgY29ubmVjdGlvbiwgcGF1c2FibGVdKTtcbiAgICB9O1xuXG4gICAgUGF1c2FibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBQYXVzYWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KHRydWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF1c2FibGVPYnNlcnZhYmxlO1xuXG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIHVuZGVybHlpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBiYXNlZCB1cG9uIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHlpZWxkcyB0cnVlL2ZhbHNlLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGF1c2VyID0gbmV3IFJ4LlN1YmplY3QoKTtcbiAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwKS5wYXVzYWJsZShwYXVzZXIpO1xuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHBhdXNlciBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHBhdXNlIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgcGF1c2VkIGJhc2VkIHVwb24gdGhlIHBhdXNlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wYXVzYWJsZSA9IGZ1bmN0aW9uIChwYXVzZXIpIHtcbiAgICByZXR1cm4gbmV3IFBhdXNhYmxlT2JzZXJ2YWJsZSh0aGlzLCBwYXVzZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3RTb3VyY2Uoc291cmNlLCBzdWJqZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGhhc1ZhbHVlID0gW2ZhbHNlLCBmYWxzZV0sXG4gICAgICAgIGhhc1ZhbHVlQWxsID0gZmFsc2UsXG4gICAgICAgIGlzRG9uZSA9IGZhbHNlLFxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkoMiksXG4gICAgICAgIGVycjtcblxuICAgICAgZnVuY3Rpb24gbmV4dCh4LCBpKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHg7XG4gICAgICAgIGhhc1ZhbHVlW2ldID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc1ZhbHVlQWxsIHx8IChoYXNWYWx1ZUFsbCA9IGhhc1ZhbHVlLmV2ZXJ5KGlkZW50aXR5KSkpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBvLm9uRXJyb3IoZXJyKTsgfVxuICAgICAgICAgIHZhciByZXMgPSB0cnlDYXRjaChyZXN1bHRTZWxlY3RvcikuYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICAgIG8ub25OZXh0KHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNEb25lICYmIHZhbHVlc1sxXSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgbmV4dCh4LCAwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzWzFdKSB7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWVzWzFdICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgc3ViamVjdC5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIG5leHQoeCwgMSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQodHJ1ZSwgMSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgdmFyIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZShzb3VyY2UsIHBhdXNlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gICAgICBpZiAocGF1c2VyICYmIHBhdXNlci5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXIubWVyZ2UocGF1c2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgcSA9IFtdLCBwcmV2aW91c1Nob3VsZEZpcmU7XG5cbiAgICAgIGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7IHdoaWxlIChxLmxlbmd0aCA+IDApIHsgby5vbk5leHQocS5zaGlmdCgpKTsgfSB9XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPVxuICAgICAgICBjb21iaW5lTGF0ZXN0U291cmNlKFxuICAgICAgICAgIHRoaXMuc291cmNlLFxuICAgICAgICAgIHRoaXMucGF1c2VyLnN0YXJ0V2l0aCghdGhpcy5wYXVzZWQpLmRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgICAgZnVuY3Rpb24gKGRhdGEsIHNob3VsZEZpcmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHNob3VsZEZpcmU6IHNob3VsZEZpcmUgfTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICBpZiAocHJldmlvdXNTaG91bGRGaXJlICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0cy5zaG91bGRGaXJlICE9PSBwcmV2aW91c1Nob3VsZEZpcmUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Nob3VsZEZpcmUgPSByZXN1bHRzLnNob3VsZEZpcmU7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIGluIHNob3VsZEZpcmVcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5zaG91bGRGaXJlKSB7IGRyYWluUXVldWUoKTsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkRmlyZSA9IHJlc3VsdHMuc2hvdWxkRmlyZTtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLnNob3VsZEZpcmUpIHtcbiAgICAgICAgICAgICAgICAgIG8ub25OZXh0KHJlc3VsdHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHEucHVzaChyZXN1bHRzLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRyYWluUXVldWUoKTtcbiAgICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uOyAgICAgIFxuICAgIH07XG5cbiAgICBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KGZhbHNlKTtcbiAgICB9O1xuXG4gICAgUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KHRydWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIHVwb24gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggeWllbGRzIHRydWUvZmFsc2UsXG4gICAqIGFuZCB5aWVsZHMgdGhlIHZhbHVlcyB0aGF0IHdlcmUgYnVmZmVyZWQgd2hpbGUgcGF1c2VkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGF1c2VyID0gbmV3IFJ4LlN1YmplY3QoKTtcbiAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwKS5wYXVzYWJsZUJ1ZmZlcmVkKHBhdXNlcik7XG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcGF1c2VyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHVzZWQgdG8gcGF1c2UgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhdXNhYmxlQnVmZmVyZWQgPSBmdW5jdGlvbiAocGF1c2VyKSB7XG4gICAgcmV0dXJuIG5ldyBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZSh0aGlzLCBwYXVzZXIpO1xuICB9O1xuXG4gIHZhciBDb250cm9sbGVkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29udHJvbGxlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29udHJvbGxlZE9ic2VydmFibGUgKHNvdXJjZSwgZW5hYmxlUXVldWUsIHNjaGVkdWxlcikge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnN1YmplY3QgPSBuZXcgQ29udHJvbGxlZFN1YmplY3QoZW5hYmxlUXVldWUsIHNjaGVkdWxlcik7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZS5tdWx0aWNhc3QodGhpcy5zdWJqZWN0KS5yZWZDb3VudCgpO1xuICAgIH1cblxuICAgIENvbnRyb2xsZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobyk7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG51bWJlck9mSXRlbXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YmplY3QucmVxdWVzdChudW1iZXJPZkl0ZW1zID09IG51bGwgPyAtMSA6IG51bWJlck9mSXRlbXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29udHJvbGxlZE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIENvbnRyb2xsZWRTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb250cm9sbGVkU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb250cm9sbGVkU3ViamVjdChlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICBlbmFibGVRdWV1ZSA9PSBudWxsICYmIChlbmFibGVRdWV1ZSA9IHRydWUpO1xuXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICB0aGlzLmVuYWJsZVF1ZXVlID0gZW5hYmxlUXVldWU7XG4gICAgICB0aGlzLnF1ZXVlID0gZW5hYmxlUXVldWUgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLnJlcXVlc3RlZENvdW50ID0gMDtcbiAgICAgIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMuaGFzRmFpbGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXIgfHwgY3VycmVudFRocmVhZFNjaGVkdWxlcjtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKENvbnRyb2xsZWRTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmplY3Quc3Vic2NyaWJlKG8pO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVF1ZXVlIHx8IHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5zdWJqZWN0Lm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlQ3VycmVudFJlcXVlc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goTm90aWZpY2F0aW9uLmNyZWF0ZU9uQ29tcGxldGVkKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFzRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUXVldWUgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnN1YmplY3Qub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlQ3VycmVudFJlcXVlc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goTm90aWZpY2F0aW9uLmNyZWF0ZU9uRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RlZENvdW50IDw9IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZVF1ZXVlICYmIHRoaXMucXVldWUucHVzaChOb3RpZmljYXRpb24uY3JlYXRlT25OZXh0KHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHRoaXMucmVxdWVzdGVkQ291bnQtLSA9PT0gMCkgJiYgdGhpcy5kaXNwb3NlQ3VycmVudFJlcXVlc3QoKTtcbiAgICAgICAgICB0aGlzLnN1YmplY3Qub25OZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9wcm9jZXNzUmVxdWVzdDogZnVuY3Rpb24gKG51bWJlck9mSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUXVldWUpIHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIChudW1iZXJPZkl0ZW1zID4gMCB8fCB0aGlzLnF1ZXVlWzBdLmtpbmQgIT09ICdOJykpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGZpcnN0LmFjY2VwdCh0aGlzLnN1YmplY3QpO1xuICAgICAgICAgICAgaWYgKGZpcnN0LmtpbmQgPT09ICdOJykge1xuICAgICAgICAgICAgICBudW1iZXJPZkl0ZW1zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlck9mSXRlbXM7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUobnVtYmVyLFxuICAgICAgICBmdW5jdGlvbihzLCBpKSB7XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHNlbGYuX3Byb2Nlc3NSZXF1ZXN0KGkpO1xuICAgICAgICAgIHZhciBzdG9wcGVkID0gc2VsZi5oYXNDb21wbGV0ZWQgfHwgc2VsZi5oYXNGYWlsZWQ7XG4gICAgICAgICAgaWYgKCFzdG9wcGVkICYmIHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdGVkQ291bnQgPSByZW1haW5pbmc7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gU2NoZWR1bGVkIGl0ZW0gaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuIFJldHVybiBhIG5ld1xuICAgICAgICAgICAgICAvLyBkaXNwb3NhYmxlIHRvIGFsbG93IHRoZSByZXF1ZXN0IHRvIGJlIGludGVycnVwdGVkXG4gICAgICAgICAgICAgIC8vIHZpYSBkaXNwb3NlLlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZTtcbiAgICAgIH0sXG4gICAgICBkaXNwb3NlQ3VycmVudFJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZSkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIENvbnRyb2xsZWRTdWJqZWN0O1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogQXR0YWNoZXMgYSBjb250cm9sbGVyIHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGFiaWxpdHkgdG8gcXVldWUuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMCkuY29udHJvbGxlZCgpO1xuICAgKiBzb3VyY2UucmVxdWVzdCgzKTsgLy8gUmVhZHMgMyB2YWx1ZXNcbiAgICogQHBhcmFtIHtib29sfSBlbmFibGVRdWV1ZSB0cnV0aHkgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBzaG91bGQgYmUgcXVldWVkIHBlbmRpbmcgdGhlIG5leHQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIGRldGVybWluZXMgaG93IHRoZSByZXF1ZXN0cyB3aWxsIGJlIHNjaGVkdWxlZFxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggb25seSBwcm9wYWdhdGVzIHZhbHVlcyBvbiByZXF1ZXN0LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbnRyb2xsZWQgPSBmdW5jdGlvbiAoZW5hYmxlUXVldWUsIHNjaGVkdWxlcikge1xuXG4gICAgaWYgKGVuYWJsZVF1ZXVlICYmIGlzU2NoZWR1bGVyKGVuYWJsZVF1ZXVlKSkge1xuICAgICAgc2NoZWR1bGVyID0gZW5hYmxlUXVldWU7XG4gICAgICBlbmFibGVRdWV1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZVF1ZXVlID09IG51bGwpIHsgIGVuYWJsZVF1ZXVlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBuZXcgQ29udHJvbGxlZE9ic2VydmFibGUodGhpcywgZW5hYmxlUXVldWUsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFN0b3BBbmRXYWl0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3RvcEFuZFdhaXRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN0b3BBbmRXYWl0T2JzZXJ2YWJsZSAoc291cmNlKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLnNvdXJjZS5yZXF1ZXN0KDEpO1xuICAgIH1cblxuICAgIFN0b3BBbmRXYWl0T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3RvcEFuZFdhaXRPYnNlcnZlcihvLCB0aGlzLCB0aGlzLnN1YnNjcmlwdGlvbikpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbixcbiAgICAgICAgZGVmYXVsdFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBzY2hlZHVsZU1ldGhvZClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBTdG9wQW5kV2FpdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1Yl9fKSB7XG4gICAgICBpbmhlcml0cyhTdG9wQW5kV2FpdE9ic2VydmVyLCBfX3N1Yl9fKTtcbiAgICAgIGZ1bmN0aW9uIFN0b3BBbmRXYWl0T2JzZXJ2ZXIgKG9ic2VydmVyLCBvYnNlcnZhYmxlLCBjYW5jZWwpIHtcbiAgICAgICAgX19zdWJfXy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH07XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gaW5uZXJTY2hlZHVsZU1ldGhvZChzLCBzZWxmKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm9ic2VydmFibGUuc291cmNlLnJlcXVlc3QoMSk7XG4gICAgICB9XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IGRlZmF1bHRTY2hlZHVsZXIuc2NoZWR1bGUodGhpcywgaW5uZXJTY2hlZHVsZU1ldGhvZCk7XG4gICAgICB9O1xuXG4gICAgICBTdG9wQW5kV2FpdE9ic2VydmVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbC5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSkge1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgX19zdWJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFN0b3BBbmRXYWl0T2JzZXJ2ZXI7XG4gICAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgICByZXR1cm4gU3RvcEFuZFdhaXRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIHN0b3AgYW5kIHdhaXQgb2JzZXJ2YWJsZSB0byB0aGUgY3VycmVudCBvYnNlcnZhYmxlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzdG9wIGFuZCB3YWl0IG9ic2VydmFibGUuXG4gICAqL1xuICBDb250cm9sbGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3RvcEFuZFdhaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9wQW5kV2FpdE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFdpbmRvd2VkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoV2luZG93ZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFdpbmRvd2VkT2JzZXJ2YWJsZShzb3VyY2UsIHdpbmRvd1NpemUpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLnNvdXJjZS5yZXF1ZXN0KHNlbGYud2luZG93U2l6ZSk7XG4gICAgfVxuXG4gICAgV2luZG93ZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dlZE9ic2VydmVyKG8sIHRoaXMsIHRoaXMuc3Vic2NyaXB0aW9uKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLFxuICAgICAgICBkZWZhdWx0U2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIHNjaGVkdWxlTWV0aG9kKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIFdpbmRvd2VkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3ViX18pIHtcbiAgICAgIGluaGVyaXRzKFdpbmRvd2VkT2JzZXJ2ZXIsIF9fc3ViX18pO1xuICAgICAgZnVuY3Rpb24gV2luZG93ZWRPYnNlcnZlcihvYnNlcnZlciwgb2JzZXJ2YWJsZSwgY2FuY2VsKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICAgIF9fc3ViX18uY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgV2luZG93ZWRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgV2luZG93ZWRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBpbm5lclNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYub2JzZXJ2YWJsZS5zb3VyY2UucmVxdWVzdChzZWxmLm9ic2VydmFibGUud2luZG93U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIFdpbmRvd2VkT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gKyt0aGlzLnJlY2VpdmVkICUgdGhpcy5vYnNlcnZhYmxlLndpbmRvd1NpemU7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPT09IDAgJiYgKHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gZGVmYXVsdFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBpbm5lclNjaGVkdWxlTWV0aG9kKSk7XG4gICAgICB9O1xuXG4gICAgICBXaW5kb3dlZE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWwuZGlzcG9zZSgpO1xuICAgICAgICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlZHVsZURpc3Bvc2FibGUpIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZURpc3Bvc2FibGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF9fc3ViX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBXaW5kb3dlZE9ic2VydmVyO1xuICAgIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gICAgcmV0dXJuIFdpbmRvd2VkT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzbGlkaW5nIHdpbmRvd2VkIG9ic2VydmFibGUgYmFzZWQgdXBvbiB0aGUgd2luZG93IHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dTaXplIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHdpbmRvd1xuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSB3aW5kb3dlZCBvYnNlcnZhYmxlIGJhc2VkIHVwb24gdGhlIHdpbmRvdyBzaXplLlxuICAgKi9cbiAgQ29udHJvbGxlZE9ic2VydmFibGUucHJvdG90eXBlLndpbmRvd2VkID0gZnVuY3Rpb24gKHdpbmRvd1NpemUpIHtcbiAgICByZXR1cm4gbmV3IFdpbmRvd2VkT2JzZXJ2YWJsZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogUGlwZXMgdGhlIGV4aXN0aW5nIE9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIE5vZGUuanMgU3RyZWFtLlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gZGVzdCBUaGUgZGVzdGluYXRpb24gTm9kZS5qcyBzdHJlYW0uXG4gICAqIEByZXR1cm5zIHtTdHJlYW19IFRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMucGF1c2FibGVCdWZmZXJlZCgpO1xuXG4gICAgZnVuY3Rpb24gb25EcmFpbigpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICBkZXN0LmFkZExpc3RlbmVyKCdkcmFpbicsIG9uRHJhaW4pO1xuXG4gICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICFkZXN0LndyaXRlKHgpICYmIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBIYWNrIGNoZWNrIGJlY2F1c2UgU1RESU8gaXMgbm90IGNsb3NhYmxlXG4gICAgICAgICFkZXN0Ll9pc1N0ZGlvICYmIGRlc3QuZW5kKCk7XG4gICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25EcmFpbik7XG4gICAgICB9KTtcblxuICAgIHNvdXJjZS5yZXN1bWUoKTtcblxuICAgIHJldHVybiBkZXN0O1xuICB9O1xuXG4gIHZhciBNdWx0aWNhc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhNdWx0aWNhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE11bHRpY2FzdE9ic2VydmFibGUoc291cmNlLCBmbjEsIGZuMikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbjEgPSBmbjE7XG4gICAgICB0aGlzLl9mbjIgPSBmbjI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNdWx0aWNhc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuc291cmNlLm11bHRpY2FzdCh0aGlzLl9mbjEoKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUodGhpcy5fZm4yKGNvbm5lY3RhYmxlKS5zdWJzY3JpYmUobyksIGNvbm5lY3RhYmxlLmNvbm5lY3QoKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNdWx0aWNhc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIE11bHRpY2FzdHMgdGhlIHNvdXJjZSBzZXF1ZW5jZSBub3RpZmljYXRpb25zIHRocm91Z2ggYW4gaW5zdGFudGlhdGVkIHN1YmplY3QgaW50byBhbGwgdXNlcyBvZiB0aGUgc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uIEVhY2hcbiAgICogc3Vic2NyaXB0aW9uIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2F1c2VzIGEgc2VwYXJhdGUgbXVsdGljYXN0IGludm9jYXRpb24sIGV4cG9zaW5nIHRoZSBzZXF1ZW5jZSByZXN1bHRpbmcgZnJvbSB0aGUgc2VsZWN0b3IgZnVuY3Rpb24nc1xuICAgKiBpbnZvY2F0aW9uLiBGb3Igc3BlY2lhbGl6YXRpb25zIHdpdGggZml4ZWQgc3ViamVjdCB0eXBlcywgc2VlIFB1Ymxpc2gsIFB1Ymxpc2hMYXN0LCBhbmQgUmVwbGF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAxIC0gcmVzID0gc291cmNlLm11bHRpY2FzdChvYnNlcnZhYmxlKTtcbiAgICogMiAtIHJlcyA9IHNvdXJjZS5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3QoKTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN1YmplY3R9IHN1YmplY3RPclN1YmplY3RTZWxlY3RvclxuICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgc3ViamVjdCB0aHJvdWdoIHdoaWNoIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBlbGVtZW50cyB3aWxsIGJlIG11bHRpY2FzdCB0byB0aGUgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqIE9yOlxuICAgKiBTdWJqZWN0IHRvIHB1c2ggc291cmNlIGVsZW1lbnRzIGludG8uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIHN1YmplY3QgdG8gdGhlIHBvbGljaWVzIGVuZm9yY2VkIGJ5IHRoZSBjcmVhdGVkIHN1YmplY3QuIFNwZWNpZmllZCBvbmx5IGlmIDxwYXJhbXJlZiBuYW1lPVwic3ViamVjdE9yU3ViamVjdFNlbGVjdG9yXCIgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm11bHRpY2FzdCA9IGZ1bmN0aW9uIChzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yKSA/XG4gICAgICBuZXcgTXVsdGljYXN0T2JzZXJ2YWJsZSh0aGlzLCBzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSA6XG4gICAgICBuZXcgQ29ubmVjdGFibGVPYnNlcnZhYmxlKHRoaXMsIHN1YmplY3RPclN1YmplY3RTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSByZWd1bGFyIFN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXNyZXMgPSBzb3VyY2UucHVibGlzaCgpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIFNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IFN1YmplY3QoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoIHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCkucmVmQ291bnQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBjb250YWluaW5nIG9ubHkgdGhlIGxhc3Qgbm90aWZpY2F0aW9uLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgQXN5bmNTdWJqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hMYXN0KCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaExhc3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgW09wdGlvbmFsXSBTZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCBvbmx5IHJlY2VpdmUgdGhlIGxhc3Qgbm90aWZpY2F0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaExhc3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgJiYgaXNGdW5jdGlvbihzZWxlY3RvcikgP1xuICAgICAgdGhpcy5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFzeW5jU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IEFzeW5jU3ViamVjdCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBhbmQgc3RhcnRzIHdpdGggaW5pdGlhbFZhbHVlLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgQmVoYXZpb3JTdWJqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hWYWx1ZSg0Mik7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaFZhbHVlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNlbGVjdChmdW5jdGlvbiAoeSkgeyByZXR1cm4geSAqIHk7IH0pIH0sIDQyKTtcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGltbWVkaWF0ZWx5IHJlY2VpdmUgdGhlIGluaXRpYWwgdmFsdWUsIGZvbGxvd2VkIGJ5IGFsbCBub3RpZmljYXRpb25zIG9mIHRoZSBzb3VyY2UgZnJvbSB0aGUgdGltZSBvZiB0aGUgc3Vic2NyaXB0aW9uIG9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsVmFsdWUgSW5pdGlhbCB2YWx1ZSByZWNlaXZlZCBieSBvYnNlcnZlcnMgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaFZhbHVlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IsIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAyID9cbiAgICAgIHRoaXMubXVsdGljYXN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sIGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IpIDpcbiAgICAgIHRoaXMubXVsdGljYXN0KG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlT3JTZWxlY3RvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIGFuZCBzdGFydHMgd2l0aCBhbiBpbml0aWFsVmFsdWUuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoVmFsdWUgd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsVmFsdWUgSW5pdGlhbCB2YWx1ZSByZWNlaXZlZCBieSBvYnNlcnZlcnMgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2hhcmVWYWx1ZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoVmFsdWUoaW5pdGlhbFZhbHVlKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiBhIGNvbm5lY3RhYmxlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIHJlcGxheWluZyBub3RpZmljYXRpb25zIHN1YmplY3QgdG8gYSBtYXhpbXVtIHRpbWUgbGVuZ3RoIGZvciB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIE11bHRpY2FzdCB1c2luZyBhIFJlcGxheVN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KG51bGwsIDMpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDApO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDAsIHNjaGVkdWxlcik7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRha2UoNikucmVwZWF0KCk7IH0sIDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIFtPcHRpb25hbF0gU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgdGhlIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBzdWJqZWN0IHRvIHRoZSBzcGVjaWZpZWQgcmVwbGF5IGJ1ZmZlciB0cmltbWluZyBwb2xpY3kuXG4gICAqIEBwYXJhbSBidWZmZXJTaXplIFtPcHRpb25hbF0gTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gd2luZG93U2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gdGltZSBsZW5ndGggb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSBzY2hlZHVsZXIgW09wdGlvbmFsXSBTY2hlZHVsZXIgd2hlcmUgY29ubmVjdGVkIG9ic2VydmVycyB3aXRoaW4gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5yZXBsYXkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGJ1ZmZlclNpemUsIHdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgcmVwbGF5aW5nIG5vdGlmaWNhdGlvbnMgc3ViamVjdCB0byBhIG1heGltdW0gdGltZSBsZW5ndGggZm9yIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgcmVwbGF5IHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZVJlcGxheSgzKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZVJlcGxheSgzLCA1MDApO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICpcblxuICAgKiBAcGFyYW0gYnVmZmVyU2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gZWxlbWVudCBjb3VudCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHdpbmRvdyBbT3B0aW9uYWxdIE1heGltdW0gdGltZSBsZW5ndGggb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSBzY2hlZHVsZXIgW09wdGlvbmFsXSBTY2hlZHVsZXIgd2hlcmUgY29ubmVjdGVkIG9ic2VydmVycyB3aXRoaW4gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZVJlcGxheSA9IGZ1bmN0aW9uIChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYXkobnVsbCwgYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIHZhciBJbm5lclN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzLCBvKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fbyA9IG87XG4gIH07XG5cbiAgSW5uZXJTdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9zLmlzRGlzcG9zZWQgJiYgdGhpcy5fbyAhPT0gbnVsbCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuX3Mub2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5fbyk7XG4gICAgICB0aGlzLl9zLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHRoaXMuX28gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgUmVmQ291bnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSZWZDb3VudE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICB0aGlzLl9jb25uZWN0YWJsZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZWZDb3VudE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc291cmNlLnN1YnNjcmliZShvKTtcbiAgICAgICsrdGhpcy5fY291bnQgPT09IDEgJiYgKHRoaXMuX2Nvbm5lY3RhYmxlU3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2UuY29ubmVjdCgpKTtcbiAgICAgIHJldHVybiBuZXcgUmVmQ291bnREaXNwb3NhYmxlKHRoaXMsIHN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlZkNvdW50RGlzcG9zYWJsZShwLCBzKSB7XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgUmVmQ291bnREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcy5kaXNwb3NlKCk7XG4gICAgICAgIC0tdGhpcy5fcC5fY291bnQgPT09IDAgJiYgdGhpcy5fcC5fY29ubmVjdGFibGVTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUmVmQ291bnRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IFJ4LkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHN1YmplY3QpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICB0aGlzLl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbm5lY3REaXNwb3NhYmxlKHBhcmVudCwgc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBDb25uZWN0RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zKSB7XG4gICAgICAgIHRoaXMuX3MuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcC5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zb3VyY2Uuc3Vic2NyaWJlKHRoaXMuX3N1YmplY3QpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbmV3IENvbm5lY3REaXNwb3NhYmxlKHRoaXMsIHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbjtcbiAgICB9O1xuXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0LnN1YnNjcmliZShvKTtcbiAgICB9O1xuXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVmQ291bnRPYnNlcnZhYmxlKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS4gVGhpcyBvYnNlcnZhYmxlIHNlcXVlbmNlXG4gICAqIGNhbiBiZSByZXN1YnNjcmliZWQgdG8sIGV2ZW4gaWYgYWxsIHByaW9yIHN1YnNjcmlwdGlvbnMgaGF2ZSBlbmRlZC4gKHVubGlrZSBgLnB1Ymxpc2goKS5yZWZDb3VudCgpYClcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaW5nbGVJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBoYXNPYnNlcnZhYmxlID0gZmFsc2UsIG9ic2VydmFibGU7XG5cbiAgICBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlKCkge1xuICAgICAgaWYgKCFoYXNPYnNlcnZhYmxlKSB7XG4gICAgICAgIGhhc09ic2VydmFibGUgPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlID0gc291cmNlWydmaW5hbGx5J10oZnVuY3Rpb24oKSB7IGhhc09ic2VydmFibGUgPSBmYWxzZTsgfSkucHVibGlzaCgpLnJlZkNvdW50KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIGdldE9ic2VydmFibGUoKS5zdWJzY3JpYmUobyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDb3JyZWxhdGVzIHRoZSBlbGVtZW50cyBvZiB0d28gc2VxdWVuY2VzIGJhc2VkIG9uIG92ZXJsYXBwaW5nIGR1cmF0aW9ucy5cbiAgICpcbiAgICogIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcmlnaHQgVGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UgdG8gam9pbiBlbGVtZW50cyBmb3IuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBsZWZ0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIGxlZnQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNlZCB0byBkZXRlcm1pbmUgb3ZlcmxhcC5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJpZ2h0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBBIGZ1bmN0aW9uIGludm9rZWQgdG8gY29tcHV0ZSBhIHJlc3VsdCBlbGVtZW50IGZvciBhbnkgdHdvIG92ZXJsYXBwaW5nIGVsZW1lbnRzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlcy4gVGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBjb3JyZXNwb25kIHdpdGggdGhlIGVsZW1lbnRzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IHNvdXJjZSBzZXF1ZW5jZXMgZm9yIHdoaWNoIG92ZXJsYXAgb2NjdXJzLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyByZXN1bHQgZWxlbWVudHMgY29tcHV0ZWQgZnJvbSBzb3VyY2UgZWxlbWVudHMgdGhhdCBoYXZlIGFuIG92ZXJsYXBwaW5nIGR1cmF0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmpvaW4gPSBmdW5jdGlvbiAocmlnaHQsIGxlZnREdXJhdGlvblNlbGVjdG9yLCByaWdodER1cmF0aW9uU2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBsZWZ0RG9uZSA9IGZhbHNlLCByaWdodERvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBsZWZ0SWQgPSAwLCByaWdodElkID0gMDtcbiAgICAgIHZhciBsZWZ0TWFwID0gbmV3IE1hcCgpLCByaWdodE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfTtcblxuICAgICAgZ3JvdXAuYWRkKGxlZnQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaWQgPSBsZWZ0SWQrKywgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgICAgIGxlZnRNYXAuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoKGxlZnREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpOyB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBsZWZ0TWFwWydkZWxldGUnXShpZCkgJiYgbGVmdE1hcC5zaXplID09PSAwICYmIGxlZnREb25lICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHJpZ2h0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChyZXN1bHRTZWxlY3RvcikodmFsdWUsIHYpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgICAgICAgIG8ub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGVmdERvbmUgPSB0cnVlO1xuICAgICAgICAgIChyaWdodERvbmUgfHwgbGVmdE1hcC5zaXplID09PSAwKSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBncm91cC5hZGQocmlnaHQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaWQgPSByaWdodElkKyssIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgICAgICByaWdodE1hcC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgICBncm91cC5hZGQobWQpO1xuXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2gocmlnaHREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpOyB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByaWdodE1hcFsnZGVsZXRlJ10oaWQpICYmIHJpZ2h0TWFwLnNpemUgPT09IDAgJiYgcmlnaHREb25lICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKSh2LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICAgICAgby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByaWdodERvbmUgPSB0cnVlO1xuICAgICAgICAgIChsZWZ0RG9uZSB8fCByaWdodE1hcC5zaXplID09PSAwKSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sIGxlZnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgQ29ycmVsYXRlcyB0aGUgZWxlbWVudHMgb2YgdHdvIHNlcXVlbmNlcyBiYXNlZCBvbiBvdmVybGFwcGluZyBkdXJhdGlvbnMsIGFuZCBncm91cHMgdGhlIHJlc3VsdHMuXG4gICAqXG4gICAqICBAcGFyYW0ge09ic2VydmFibGV9IHJpZ2h0IFRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGpvaW4gZWxlbWVudHMgZm9yLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gbGVmdER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSBsZWZ0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSByaWdodER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2VkIHRvIGRldGVybWluZSBvdmVybGFwLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgQSBmdW5jdGlvbiBpbnZva2VkIHRvIGNvbXB1dGUgYSByZXN1bHQgZWxlbWVudCBmb3IgYW55IGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VxdWVuY2Ugd2l0aCBvdmVybGFwcGluZyBlbGVtZW50cyBmcm9tIHRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlLiBUaGUgZmlyc3QgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gaXMgYW4gZWxlbWVudCBvZiB0aGUgbGVmdCBzZXF1ZW5jZS4gVGhlIHNlY29uZCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBpcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggZWxlbWVudHMgZnJvbSB0aGUgcmlnaHQgc2VxdWVuY2UgdGhhdCBvdmVybGFwIHdpdGggdGhlIGxlZnQgc2VxdWVuY2UncyBlbGVtZW50LlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyByZXN1bHQgZWxlbWVudHMgY29tcHV0ZWQgZnJvbSBzb3VyY2UgZWxlbWVudHMgdGhhdCBoYXZlIGFuIG92ZXJsYXBwaW5nIGR1cmF0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmdyb3VwSm9pbiA9IGZ1bmN0aW9uIChyaWdodCwgbGVmdER1cmF0aW9uU2VsZWN0b3IsIHJpZ2h0RHVyYXRpb25TZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICB2YXIgbGVmdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIHIgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGdyb3VwKTtcbiAgICAgIHZhciBsZWZ0TWFwID0gbmV3IE1hcCgpLCByaWdodE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBsZWZ0SWQgPSAwLCByaWdodElkID0gMDtcbiAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyB2Lm9uRXJyb3IoZSk7IH07IH07XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGUpIHsgfTtcblxuICAgICAgZ3JvdXAuYWRkKGxlZnQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgdmFyIGlkID0gbGVmdElkKys7XG4gICAgICAgICAgbGVmdE1hcC5zZXQoaWQsIHMpO1xuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKSh2YWx1ZSwgYWRkUmVmKHMsIHIpKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKHJlc3VsdC5lKSk7XG4gICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5vbk5leHQocmVzdWx0KTtcblxuICAgICAgICAgIHJpZ2h0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcy5vbk5leHQodik7IH0pO1xuXG4gICAgICAgICAgdmFyIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoKGxlZnREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGR1cmF0aW9uLmUpKTtcbiAgICAgICAgICAgIHJldHVybiBvLm9uRXJyb3IoZHVyYXRpb24uZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBsZWZ0TWFwWydkZWxldGUnXShpZCkgJiYgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgICBncm91cC5yZW1vdmUobWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IG8ub25Db21wbGV0ZWQoKTsgfSlcbiAgICAgICk7XG5cbiAgICAgIGdyb3VwLmFkZChyaWdodC5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IHJpZ2h0SWQrKztcbiAgICAgICAgICByaWdodE1hcC5zZXQoaWQsIHZhbHVlKTtcblxuICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgIGdyb3VwLmFkZChtZCk7XG5cbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChyaWdodER1cmF0aW9uU2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZHVyYXRpb24uZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJpZ2h0TWFwWydkZWxldGUnXShpZCk7XG4gICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5vbk5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIGxlZnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoeCkgeyByZXR1cm4geC50b0FycmF5KCk7IH1cblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gemVybyBvciBtb3JlIGJ1ZmZlcnMuXG4gICAqICBAcGFyYW0ge01peGVkfSBidWZmZXJPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yIE9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgZGVub3RlIHRoZSBjcmVhdGlvbiBvZiBuZXcgd2luZG93cywgb3IsIGEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHByb2R1Y2VkIHdpbmRvd3MgKGEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWQsIHJlc3VsdGluZyBpbiBub24tb3ZlcmxhcHBpbmcgd2luZG93cykuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbYnVmZmVyQ2xvc2luZ1NlbGVjdG9yXSBBIGZ1bmN0aW9uIGludm9rZWQgdG8gZGVmaW5lIHRoZSBjbG9zaW5nIG9mIGVhY2ggcHJvZHVjZWQgd2luZG93LiBJZiBhIGNsb3Npbmcgc2VsZWN0b3IgZnVuY3Rpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyLCB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMud2luZG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIC5mbGF0TWFwKHRvQXJyYXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cy5cbiAgICpcbiAgICogIEBwYXJhbSB7TWl4ZWR9IHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBkZW5vdGUgdGhlIGNyZWF0aW9uIG9mIG5ldyB3aW5kb3dzLCBvciwgYSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcHJvZHVjZWQgd2luZG93cyAoYSBuZXcgd2luZG93IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb25lIGlzIGNsb3NlZCwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzKS5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFt3aW5kb3dDbG9zaW5nU2VsZWN0b3JdIEEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGNsb3Npbmcgb2YgZWFjaCBwcm9kdWNlZCB3aW5kb3cuIElmIGEgY2xvc2luZyBzZWxlY3RvciBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQuXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLndpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVdpbmRvd1dpdGhCb3VuZGFyaWVzLmNhbGwodGhpcywgd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBvYnNlcnZhYmxlV2luZG93V2l0aENsb3NpbmdTZWxlY3Rvci5jYWxsKHRoaXMsIHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IpIDpcbiAgICAgIG9ic2VydmFibGVXaW5kb3dXaXRoT3BlbmluZ3MuY2FsbCh0aGlzLCB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVXaW5kb3dXaXRoT3BlbmluZ3Mod2luZG93T3BlbmluZ3MsIHdpbmRvd0Nsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB3aW5kb3dPcGVuaW5ncy5ncm91cEpvaW4odGhpcywgd2luZG93Q2xvc2luZ1NlbGVjdG9yLCBvYnNlcnZhYmxlRW1wdHksIGZ1bmN0aW9uIChfLCB3aW4pIHtcbiAgICAgIHJldHVybiB3aW47XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aEJvdW5kYXJpZXMod2luZG93Qm91bmRhcmllcykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciB3aW4gPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcbiAgICAgICAgciA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZCk7XG5cbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG5cbiAgICAgIGQuYWRkKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgd2luLm9uTmV4dCh4KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcblxuICAgICAgaXNQcm9taXNlKHdpbmRvd0JvdW5kYXJpZXMpICYmICh3aW5kb3dCb3VuZGFyaWVzID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHdpbmRvd0JvdW5kYXJpZXMpKTtcblxuICAgICAgZC5hZGQod2luZG93Qm91bmRhcmllcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHdpbiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHdpbi5vbkVycm9yKGVycik7XG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aENsb3NpbmdTZWxlY3Rvcih3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShtKSxcbiAgICAgICAgciA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZCksXG4gICAgICAgIHdpbiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHdpbiwgcikpO1xuICAgICAgZC5hZGQoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHdpbi5vbk5leHQoeCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlV2luZG93Q2xvc2UgKCkge1xuICAgICAgICB2YXIgd2luZG93Q2xvc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93Q2xvc2UgPSB3aW5kb3dDbG9zaW5nU2VsZWN0b3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNQcm9taXNlKHdpbmRvd0Nsb3NlKSAmJiAod2luZG93Q2xvc2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uod2luZG93Q2xvc2UpKTtcblxuICAgICAgICB2YXIgbTEgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKG0xKTtcbiAgICAgICAgbTEuc2V0RGlzcG9zYWJsZSh3aW5kb3dDbG9zZS50YWtlKDEpLnN1YnNjcmliZShub29wLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB3aW4gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG4gICAgICAgICAgY3JlYXRlV2luZG93Q2xvc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVXaW5kb3dDbG9zZSgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIHZhciBQYWlyd2lzZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJ3aXNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFBhaXJ3aXNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBQYWlyd2lzZU9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhaXJ3aXNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBQYWlyd2lzZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJ3aXNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUGFpcndpc2VPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBudWxsO1xuICAgICAgdGhpcy5faHAgPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFBhaXJ3aXNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2hwKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KFt0aGlzLl9wLCB4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ocCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9wID0geDtcbiAgICB9O1xuICAgIFBhaXJ3aXNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikgeyB0aGlzLl9vLm9uRXJyb3IoZXJyKTsgfTtcbiAgICBQYWlyd2lzZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBQYWlyd2lzZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYnNlcnZhYmxlIHRoYXQgdHJpZ2dlcnMgb24gdGhlIHNlY29uZCBhbmQgc3Vic2VxdWVudCB0cmlnZ2VyaW5ncyBvZiB0aGUgaW5wdXQgb2JzZXJ2YWJsZS5cbiAgICogVGhlIE50aCB0cmlnZ2VyaW5nIG9mIHRoZSBpbnB1dCBvYnNlcnZhYmxlIHBhc3NlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIE4tMXRoIGFuZCBOdGggdHJpZ2dlcmluZyBhcyBhIHBhaXIuXG4gICAqIFRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIE4tMXRoIHRyaWdnZXJpbmcgaXMgaGVsZCBpbiBoaWRkZW4gaW50ZXJuYWwgc3RhdGUgdW50aWwgdGhlIE50aCB0cmlnZ2VyaW5nIG9jY3Vycy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCB0cmlnZ2VycyBvbiBzdWNjZXNzaXZlIHBhaXJzIG9mIG9ic2VydmF0aW9ucyBmcm9tIHRoZSBpbnB1dCBvYnNlcnZhYmxlIGFzIGFuIGFycmF5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhaXJ3aXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUGFpcndpc2VPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHR3byBvYnNlcnZhYmxlcyB3aGljaCBwYXJ0aXRpb24gdGhlIG9ic2VydmF0aW9ucyBvZiB0aGUgc291cmNlIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICogVGhlIGZpcnN0IHdpbGwgdHJpZ2dlciBvYnNlcnZhdGlvbnMgZm9yIHRob3NlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuXG4gICAqIFRoZSBzZWNvbmQgd2lsbCB0cmlnZ2VyIG9ic2VydmF0aW9ucyBmb3IgdGhvc2UgdmFsdWVzIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyBmYWxzZS5cbiAgICogVGhlIHByZWRpY2F0ZSBpcyBleGVjdXRlZCBvbmNlIGZvciBlYWNoIHN1YnNjcmliZWQgb2JzZXJ2ZXIuXG4gICAqIEJvdGggYWxzbyBwcm9wYWdhdGUgYWxsIGVycm9yIG9ic2VydmF0aW9ucyBhcmlzaW5nIGZyb20gdGhlIHNvdXJjZSBhbmQgZWFjaCBjb21wbGV0ZXNcbiAgICogd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAqICAgIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggb3V0cHV0IE9ic2VydmFibGUgd2lsbCB0cmlnZ2VyIGEgcGFydGljdWxhciBvYnNlcnZhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiAgICBBbiBhcnJheSBvZiBvYnNlcnZhYmxlcy4gVGhlIGZpcnN0IHRyaWdnZXJzIHdoZW4gdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUsXG4gICAqICAgIGFuZCB0aGUgc2Vjb25kIHRyaWdnZXJzIHdoZW4gdGhlIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGFydGl0aW9uID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdmFyIGZuID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZyksXG4gICAgICB0aGlzLmZpbHRlcihmdW5jdGlvbiAoeCwgaSwgbykgeyByZXR1cm4gIWZuKHgsIGksIG8pOyB9KVxuICAgIF07XG4gIH07XG5cbiAgdmFyIFdoaWxlRW51bWVyYWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaGlsZUVudW1lcmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2hpbGVFbnVtZXJhYmxlKGMsIHMpIHtcbiAgICAgIHRoaXMuYyA9IGM7XG4gICAgICB0aGlzLnMgPSBzO1xuICAgIH1cbiAgICBXaGlsZUVudW1lcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmMoKSA/XG4gICAgICAgICAgIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzZWxmLnMgfSA6XG4gICAgICAgICAgIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFdoaWxlRW51bWVyYWJsZTtcbiAgfShFbnVtZXJhYmxlKSk7XG4gIFxuICBmdW5jdGlvbiBlbnVtZXJhYmxlV2hpbGUoY29uZGl0aW9uLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFdoaWxlRW51bWVyYWJsZShjb25kaXRpb24sIHNvdXJjZSk7XG4gIH0gIFxuXG4gICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zLlxuICAgKiAgVGhpcyBvcGVyYXRvciBhbGxvd3MgZm9yIGEgZmx1ZW50IHN0eWxlIG9mIHdyaXRpbmcgcXVlcmllcyB0aGF0IHVzZSB0aGUgc2FtZSBzZXF1ZW5jZSBtdWx0aXBsZSB0aW1lcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IHNoYXJpbmcgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmxldEJpbmQgPSBvYnNlcnZhYmxlUHJvdG9bJ2xldCddID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYyh0aGlzKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHZhbHVlcy4gXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pZihjb25kaXRpb24sIG9iczEpO1xuICAgKiAgMiAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaWYoY29uZGl0aW9uLCBvYnMxLCBvYnMyKTtcbiAgICogIDMgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSwgc2NoZWR1bGVyKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgdGhlblNvdXJjZSBvciBlbHNlU291cmNlIHdpbGwgYmUgcnVuLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHRoZW5Tb3VyY2UgVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBjb25kaXRpb24gZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IFtlbHNlU291cmNlXSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gUnguT2JzZXJ2YWJlLkVtcHR5IHdpdGggdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIGVpdGhlciB0aGUgdGhlblNvdXJjZSBvciBlbHNlU291cmNlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZVsnaWYnXSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2VPclNjaGVkdWxlcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgZWxzZVNvdXJjZU9yU2NoZWR1bGVyIHx8IChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoKSk7XG5cbiAgICAgIGlzUHJvbWlzZSh0aGVuU291cmNlKSAmJiAodGhlblNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh0aGVuU291cmNlKSk7XG4gICAgICBpc1Byb21pc2UoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSAmJiAoZWxzZVNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGVsc2VTb3VyY2VPclNjaGVkdWxlcikpO1xuXG4gICAgICAvLyBBc3N1bWUgYSBzY2hlZHVsZXIgZm9yIGVtcHR5IG9ubHlcbiAgICAgIHR5cGVvZiBlbHNlU291cmNlT3JTY2hlZHVsZXIubm93ID09PSAnZnVuY3Rpb24nICYmIChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSk7XG4gICAgICByZXR1cm4gY29uZGl0aW9uKCkgPyB0aGVuU291cmNlIDogZWxzZVNvdXJjZU9yU2NoZWR1bGVyO1xuICAgIH0pO1xuICB9O1xuXG4gICAvKipcbiAgICogIENvbmNhdGVuYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb2J0YWluZWQgYnkgcnVubmluZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmb3IgZWFjaCBlbGVtZW50IGluIHNvdXJjZS5cbiAgICogVGhlcmUgaXMgYW4gYWxpYXMgZm9yIHRoaXMgbWV0aG9kIGNhbGxlZCAnZm9ySW4nIGZvciBicm93c2VycyA8SUU5XG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZXMgQW4gYXJyYXkgb2YgdmFsdWVzIHRvIHR1cm4gaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiB0aGUgc291cmNlcyBhcnJheSB0byB0dXJuIGl0IGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSB0aGUgY29uY2F0ZW5hdGVkIG9ic2VydmFibGUgc2VxdWVuY2VzLlxuICAgKi9cbiAgT2JzZXJ2YWJsZVsnZm9yJ10gPSBPYnNlcnZhYmxlLmZvckluID0gZnVuY3Rpb24gKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGVudW1lcmFibGVPZihzb3VyY2VzLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykuY29uY2F0KCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgUmVwZWF0cyBzb3VyY2UgYXMgbG9uZyBhcyBjb25kaXRpb24gaG9sZHMgZW11bGF0aW5nIGEgd2hpbGUgbG9vcC5cbiAgICogVGhlcmUgaXMgYW4gYWxpYXMgZm9yIHRoaXMgbWV0aG9kIGNhbGxlZCAnd2hpbGVEbycgZm9yIGJyb3dzZXJzIDxJRTlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgc291cmNlIHdpbGwgYmUgcmVwZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc291cmNlIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIHRydWUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIHJlcGVhdGVkIGFzIGxvbmcgYXMgdGhlIGNvbmRpdGlvbiBob2xkcy5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlV2hpbGVEbyA9IE9ic2VydmFibGVbJ3doaWxlJ10gPSBPYnNlcnZhYmxlLndoaWxlRG8gPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBzb3VyY2UpIHtcbiAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgIHJldHVybiBlbnVtZXJhYmxlV2hpbGUoY29uZGl0aW9uLCBzb3VyY2UpLmNvbmNhdCgpO1xuICB9O1xuXG4gICAvKipcbiAgICogIFJlcGVhdHMgc291cmNlIGFzIGxvbmcgYXMgY29uZGl0aW9uIGhvbGRzIGVtdWxhdGluZyBhIGRvIHdoaWxlIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHNvdXJjZSB3aWxsIGJlIHJlcGVhdGVkLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNvdXJjZSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBjb25kaXRpb24gZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyByZXBlYXRlZCBhcyBsb25nIGFzIHRoZSBjb25kaXRpb24gaG9sZHMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZG9XaGlsZSA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUNvbmNhdChbdGhpcywgb2JzZXJ2YWJsZVdoaWxlRG8oY29uZGl0aW9uLCB0aGlzKV0pO1xuICB9O1xuXG4gICAvKipcbiAgICogIFVzZXMgc2VsZWN0b3IgdG8gZGV0ZXJtaW5lIHdoaWNoIHNvdXJjZSBpbiBzb3VyY2VzIHRvIHVzZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIGZ1bmN0aW9uIHdoaWNoIGV4dHJhY3RzIHRoZSB2YWx1ZSBmb3IgdG8gdGVzdCBpbiBhIGNhc2Ugc3RhdGVtZW50LlxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIEEgb2JqZWN0IHdoaWNoIGhhcyBrZXlzIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNhc2Ugc3RhdGVtZW50IGxhYmVscy5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZWxzZVNvdXJjZV0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBzb3VyY2VzIGFyZSBub3QgbWF0Y2hlZC4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIFJ4Lk9ic2VydmFiZS5lbXB0eSB3aXRoIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBkZXRlcm1pbmVkIGJ5IGEgY2FzZSBzdGF0ZW1lbnQuXG4gICAqL1xuICBPYnNlcnZhYmxlWydjYXNlJ10gPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNvdXJjZXMsIGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgaXNQcm9taXNlKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikgJiYgKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpKTtcbiAgICAgIGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciB8fCAoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUVtcHR5KCkpO1xuXG4gICAgICBpc1NjaGVkdWxlcihkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpICYmIChkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBzb3VyY2VzW3NlbGVjdG9yKCldO1xuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBkZWZhdWx0U291cmNlT3JTY2hlZHVsZXI7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEV4cGFuZE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXhwYW5kT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHBhbmRPYnNlcnZhYmxlKHNvdXJjZSwgZm4sIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUoYXJncywgcmVjdXJzZSkge1xuICAgICAgdmFyIHN0YXRlID0gYXJnc1swXSwgc2VsZiA9IGFyZ3NbMV07XG4gICAgICB2YXIgd29yaztcbiAgICAgIGlmIChzdGF0ZS5xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd29yayA9IHN0YXRlLnEuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmlzQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG0xID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBzdGF0ZS5kLmFkZChtMSk7XG4gICAgICBtMS5zZXREaXNwb3NhYmxlKHdvcmsuc3Vic2NyaWJlKG5ldyBFeHBhbmRPYnNlcnZlcihzdGF0ZSwgc2VsZiwgbTEpKSk7XG4gICAgICByZWN1cnNlKFtzdGF0ZSwgc2VsZl0pO1xuICAgIH1cblxuICAgIEV4cGFuZE9ic2VydmFibGUucHJvdG90eXBlLl9lbnN1cmVBY3RpdmUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBpc093bmVyID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUucS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzT3duZXIgPSAhc3RhdGUuaXNBY3F1aXJlZDtcbiAgICAgICAgc3RhdGUuaXNBY3F1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpc093bmVyICYmIHN0YXRlLm0uc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoW3N0YXRlLCB0aGlzXSwgc2NoZWR1bGVSZWN1cnNpdmUpKTtcbiAgICB9O1xuXG4gICAgRXhwYW5kT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShtKSxcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgcTogW10sXG4gICAgICAgICAgbTogbSxcbiAgICAgICAgICBkOiBkLFxuICAgICAgICAgIGFjdGl2ZUNvdW50OiAwLFxuICAgICAgICAgIGlzQWNxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgIG86IG9cbiAgICAgICAgfTtcblxuICAgICAgc3RhdGUucS5wdXNoKHRoaXMuc291cmNlKTtcbiAgICAgIHN0YXRlLmFjdGl2ZUNvdW50Kys7XG4gICAgICB0aGlzLl9lbnN1cmVBY3RpdmUoc3RhdGUpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHBhbmRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEV4cGFuZE9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV4cGFuZE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV4cGFuZE9ic2VydmVyKHN0YXRlLCBwYXJlbnQsIG0xKSB7XG4gICAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fbTEgPSBtMTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV4cGFuZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3Muby5vbk5leHQoeCk7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fcC5fZm4pKHgpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX3Muby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgdGhpcy5fcy5xLnB1c2gocmVzdWx0KTtcbiAgICAgIHRoaXMuX3MuYWN0aXZlQ291bnQrKztcbiAgICAgIHRoaXMuX3AuX2Vuc3VyZUFjdGl2ZSh0aGlzLl9zKTtcbiAgICB9O1xuXG4gICAgRXhwYW5kT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3Muby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBFeHBhbmRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcy5kLnJlbW92ZSh0aGlzLl9tMSk7XG4gICAgICB0aGlzLl9zLmFjdGl2ZUNvdW50LS07XG4gICAgICB0aGlzLl9zLmFjdGl2ZUNvdW50ID09PSAwICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXhwYW5kT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gICAvKipcbiAgICogIEV4cGFuZHMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSByZWN1cnNpdmVseSBpbnZva2luZyBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHByb2R1Y2VkIGVsZW1lbnQsIHJlc3VsdGluZyBpbiBhbm90aGVyIHNlcXVlbmNlIHRvIHdoaWNoIHRoZSBzZWxlY3RvciB3aWxsIGJlIGludm9rZWQgcmVjdXJzaXZlbHkgYWdhaW4uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcGVyZm9ybSB0aGUgZXhwYW5zaW9uLiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgdGhyZWFkIHNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIHByb2R1Y2VkIGJ5IHRoZSByZWN1cnNpdmUgZXhwYW5zaW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmV4cGFuZCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBFeHBhbmRPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIEZvcmtKb2luT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRm9ya0pvaW5PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZvcmtKb2luT2JzZXJ2YWJsZShzb3VyY2VzLCBjYikge1xuICAgICAgdGhpcy5fc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRm9ya0pvaW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBmaW5pc2hlZDogZmFsc2UsXG4gICAgICAgIGhhc1Jlc3VsdHM6IG5ldyBBcnJheShjb3VudCksXG4gICAgICAgIGhhc0NvbXBsZXRlZDogbmV3IEFycmF5KGNvdW50KSxcbiAgICAgICAgcmVzdWx0czogbmV3IEFycmF5KGNvdW50KVxuICAgICAgfTtcblxuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXNbaV07XG4gICAgICAgIGlzUHJvbWlzZShzb3VyY2UpICYmIChzb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc291cmNlKSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuYWRkKHNvdXJjZS5zdWJzY3JpYmUobmV3IEZvcmtKb2luT2JzZXJ2ZXIobywgc3RhdGUsIGksIHRoaXMuX2NiLCBzdWJzY3JpcHRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9ucztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcmtKb2luT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBGb3JrSm9pbk9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZvcmtKb2luT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRm9ya0pvaW5PYnNlcnZlcihvLCBzLCBpLCBjYiwgc3Vicykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fY2IgPSBjYjtcbiAgICAgIHRoaXMuX3N1YnMgPSBzdWJzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRm9ya0pvaW5PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXRoaXMuX3MuZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5fcy5oYXNSZXN1bHRzW3RoaXMuX2ldID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcy5yZXN1bHRzW3RoaXMuX2ldID0geDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ya0pvaW5PYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgICB0aGlzLl9zdWJzLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgRm9ya0pvaW5PYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9zLmZpbmlzaGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fcy5oYXNSZXN1bHRzW3RoaXMuX2ldKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zLmhhc0NvbXBsZXRlZFt0aGlzLl9pXSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcy5yZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9zLmhhc0NvbXBsZXRlZFtpXSkgeyByZXR1cm47IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zLmZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fY2IpLmFwcGx5KG51bGwsIHRoaXMuX3MucmVzdWx0cyk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG5cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRm9ya0pvaW5PYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgIC8qKlxuICAgKiAgUnVucyBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gcGFyYWxsZWwgYW5kIGNvbGxlY3QgdGhlaXIgbGFzdCBlbGVtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmZvcmtKb2luKFtvYnMxLCBvYnMyXSk7XG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5mb3JrSm9pbihvYnMxLCBvYnMyLCAuLi4pO1xuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGFuIGFycmF5IGNvbGxlY3RpbmcgdGhlIGxhc3QgZWxlbWVudHMgb2YgYWxsIHRoZSBpbnB1dCBzZXF1ZW5jZXMuXG4gICAqL1xuICBPYnNlcnZhYmxlLmZvcmtKb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKGFyZ3NbbGVuIC0gMV0pID8gYXJncy5wb3AoKSA6IGFyZ3VtZW50c1RvQXJyYXk7XG4gICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiAoYXJncyA9IGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXcgRm9ya0pvaW5PYnNlcnZhYmxlKGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBSdW5zIHR3byBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiBwYXJhbGxlbCBhbmQgY29tYmluZXMgdGhlaXIgbGFzdCBlbGVtZW5ldHMuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc2Vjb25kIFNlY29uZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBSZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24gdG8gaW52b2tlIHdpdGggdGhlIGxhc3QgZWxlbWVudHMgb2YgYm90aCBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aXRoIHRoZSBsYXN0IGVsZW1lbnRzIG9mIGJvdGggaW5wdXQgc2VxdWVuY2VzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZvcmtKb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgYXJnc1swXS51bnNoaWZ0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZhYmxlLmZvcmtKb2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21vbmFkaWMgYmluZCBvcGVyYXRvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZWR1bGVyIFNjaGVkdWxlciB1c2VkIHRvIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdGhlIEltbWVkaWF0ZVNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggcmVzdWx0cyBmcm9tIHRoZSBjb21vbmFkaWMgYmluZCBvcGVyYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWFueVNlbGVjdCA9IG9ic2VydmFibGVQcm90by5leHRlbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlci5pbW1lZGlhdGUpO1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoYWluO1xuXG4gICAgICByZXR1cm4gc291cmNlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgY3VyciA9IG5ldyBDaGFpbk9ic2VydmFibGUoeCk7XG5cbiAgICAgICAgICBjaGFpbiAmJiBjaGFpbi5vbk5leHQoeCk7XG4gICAgICAgICAgY2hhaW4gPSBjdXJyO1xuXG4gICAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICAgIH0pXG4gICAgICAgIC50YXAoXG4gICAgICAgICAgbm9vcCxcbiAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBjaGFpbiAmJiBjaGFpbi5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHsgY2hhaW4gJiYgY2hhaW4ub25Db21wbGV0ZWQoKTsgfVxuICAgICAgICApXG4gICAgICAgIC5vYnNlcnZlT24oc2NoZWR1bGVyKVxuICAgICAgICAubWFwKHNlbGVjdG9yKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBDaGFpbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENoYWluT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDaGFpbk9ic2VydmFibGUoaGVhZCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgICAgdGhpcy50YWlsID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoQ2hhaW5PYnNlcnZhYmxlLnByb3RvdHlwZSwgT2JzZXJ2ZXIsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgICAgZy5hZGQoY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBmdW5jdGlvbiAoXywgc2VsZikge1xuICAgICAgICAgIG8ub25OZXh0KHNlbGYuaGVhZCk7XG4gICAgICAgICAgZy5hZGQoc2VsZi50YWlsLm1lcmdlQWxsKCkuc3Vic2NyaWJlKG8pKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25OZXh0KE9ic2VydmFibGUuZW1wdHkoKSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5vbk5leHQoT2JzZXJ2YWJsZVsndGhyb3cnXShlKSk7XG4gICAgICB9LFxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLnRhaWwub25OZXh0KHYpO1xuICAgICAgICB0aGlzLnRhaWwub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBDaGFpbk9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIE1hcCA9IHJvb3QuTWFwIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIH1cblxuICAgIE1hcC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9rZXlzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNYXA7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBSZXByZXNlbnRzIGEgam9pbiBwYXR0ZXJuIG92ZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqL1xuICBmdW5jdGlvbiBQYXR0ZXJuKHBhdHRlcm5zKSB7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuICB9XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGEgcGF0dGVybiB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnQgcGxhbiBtYXRjaGVzIGFuZCB3aGVuIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGFzIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICogIEBwYXJhbSBvdGhlciBPYnNlcnZhYmxlIHNlcXVlbmNlIHRvIG1hdGNoIGluIGFkZGl0aW9uIHRvIHRoZSBjdXJyZW50IHBhdHRlcm4uXG4gICAqICBAcmV0dXJuIHtQYXR0ZXJufSBQYXR0ZXJuIG9iamVjdCB0aGF0IG1hdGNoZXMgd2hlbiBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4gaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUuXG4gICAqL1xuICBQYXR0ZXJuLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFBhdHRlcm4odGhpcy5wYXR0ZXJucy5jb25jYXQob3RoZXIpKTtcbiAgfTtcblxuICAvKipcbiAgICogIE1hdGNoZXMgd2hlbiBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4gKHNwZWNpZmllZCB1c2luZyBhIGNoYWluIG9mIGFuZCBvcGVyYXRvcnMpIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlIGFuZCBwcm9qZWN0cyB0aGUgdmFsdWVzLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgdGhhdCB3aWxsIGJlIGludm9rZWQgd2l0aCBhdmFpbGFibGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZXMsIGluIHRoZSBzYW1lIG9yZGVyIG9mIHRoZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4uXG4gICAqICBAcmV0dXJuIHtQbGFufSBQbGFuIHRoYXQgcHJvZHVjZXMgdGhlIHByb2plY3RlZCB2YWx1ZXMsIHRvIGJlIGZlZCAod2l0aCBvdGhlciBwbGFucykgdG8gdGhlIHdoZW4gb3BlcmF0b3IuXG4gICAqL1xuICBQYXR0ZXJuLnByb3RvdHlwZS50aGVuRG8gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBsYW4odGhpcywgc2VsZWN0b3IpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFBsYW4oZXhwcmVzc2lvbiwgc2VsZWN0b3IpIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9uRXJyb3IobykgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9OyB9XG4gIGZ1bmN0aW9uIGhhbmRsZU9uTmV4dChzZWxmLCBvYnNlcnZlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk5leHQgKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHNlbGYuc2VsZWN0b3IpLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gb2JzZXJ2ZXIub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBQbGFuLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChleHRlcm5hbFN1YnNjcmlwdGlvbnMsIG9ic2VydmVyLCBkZWFjdGl2YXRlKSB7XG4gICAgdmFyIGpvaW5PYnNlcnZlcnMgPSBbXSwgZXJySGFuZGxlciA9IGhhbmRsZU9uRXJyb3Iob2JzZXJ2ZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmV4cHJlc3Npb24ucGF0dGVybnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGpvaW5PYnNlcnZlcnMucHVzaChwbGFuQ3JlYXRlT2JzZXJ2ZXIoZXh0ZXJuYWxTdWJzY3JpcHRpb25zLCB0aGlzLmV4cHJlc3Npb24ucGF0dGVybnNbaV0sIGVyckhhbmRsZXIpKTtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZVBsYW4gPSBuZXcgQWN0aXZlUGxhbihqb2luT2JzZXJ2ZXJzLCBoYW5kbGVPbk5leHQodGhpcywgb2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGpvaW5PYnNlcnZlcnMubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIGpvaW5PYnNlcnZlcnNbal0ucmVtb3ZlQWN0aXZlUGxhbihhY3RpdmVQbGFuKTtcbiAgICAgIH1cbiAgICAgIGRlYWN0aXZhdGUoYWN0aXZlUGxhbik7XG4gICAgfSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gam9pbk9ic2VydmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgam9pbk9ic2VydmVyc1tpXS5hZGRBY3RpdmVQbGFuKGFjdGl2ZVBsYW4pO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlUGxhbjtcbiAgfTtcblxuICBmdW5jdGlvbiBwbGFuQ3JlYXRlT2JzZXJ2ZXIoZXh0ZXJuYWxTdWJzY3JpcHRpb25zLCBvYnNlcnZhYmxlLCBvbkVycm9yKSB7XG4gICAgdmFyIGVudHJ5ID0gZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmdldChvYnNlcnZhYmxlKTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSm9pbk9ic2VydmVyKG9ic2VydmFibGUsIG9uRXJyb3IpO1xuICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLnNldChvYnNlcnZhYmxlLCBvYnNlcnZlcik7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFjdGl2ZVBsYW4oam9pbk9ic2VydmVyQXJyYXksIG9uTmV4dCwgb25Db21wbGV0ZWQpIHtcbiAgICB0aGlzLmpvaW5PYnNlcnZlckFycmF5ID0gam9pbk9ic2VydmVyQXJyYXk7XG4gICAgdGhpcy5vbk5leHQgPSBvbk5leHQ7XG4gICAgdGhpcy5vbkNvbXBsZXRlZCA9IG9uQ29tcGxldGVkO1xuICAgIHRoaXMuam9pbk9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGpvaW5PYnNlcnZlciA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV07XG4gICAgICB0aGlzLmpvaW5PYnNlcnZlcnMuc2V0KGpvaW5PYnNlcnZlciwgam9pbk9ic2VydmVyKTtcbiAgICB9XG4gIH1cblxuICBBY3RpdmVQbGFuLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuam9pbk9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYucXVldWUuc2hpZnQoKTsgfSk7XG4gIH07XG5cbiAgQWN0aXZlUGxhbi5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksIGxlbiwgaGFzVmFsdWVzID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmpvaW5PYnNlcnZlckFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXS5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaGFzVmFsdWVzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzVmFsdWVzKSB7XG4gICAgICB2YXIgZmlyc3RWYWx1ZXMgPSBbXSxcbiAgICAgICAgICBpc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaXJzdFZhbHVlcy5wdXNoKHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV0ucXVldWVbMF0pO1xuICAgICAgICB0aGlzLmpvaW5PYnNlcnZlckFycmF5W2ldLnF1ZXVlWzBdLmtpbmQgPT09ICdDJyAmJiAoaXNDb21wbGV0ZWQgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbXBsZXRlZCkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaXJzdFZhbHVlcy5sZW5ndGg7IGkgPCBmaXJzdFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGZpcnN0VmFsdWVzW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTmV4dC5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgSm9pbk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhKb2luT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBKb2luT2JzZXJ2ZXIoc291cmNlLCBvbkVycm9yKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMgPSBbXTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgSm9pbk9ic2VydmVyUHJvdG90eXBlID0gSm9pbk9ic2VydmVyLnByb3RvdHlwZTtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5raW5kID09PSAnRScpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKG5vdGlmaWNhdGlvbi5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG5vdGlmaWNhdGlvbik7XG4gICAgICAgIHZhciBhY3RpdmVQbGFucyA9IHRoaXMuYWN0aXZlUGxhbnMuc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhY3RpdmVQbGFucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGFjdGl2ZVBsYW5zW2ldLm1hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmVycm9yID0gbm9vcDtcbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuY29tcGxldGVkID0gbm9vcDtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5hZGRBY3RpdmVQbGFuID0gZnVuY3Rpb24gKGFjdGl2ZVBsYW4pIHtcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMucHVzaChhY3RpdmVQbGFuKTtcbiAgICB9O1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2UubWF0ZXJpYWxpemUoKS5zdWJzY3JpYmUodGhpcykpO1xuICAgIH07XG5cbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUucmVtb3ZlQWN0aXZlUGxhbiA9IGZ1bmN0aW9uIChhY3RpdmVQbGFuKSB7XG4gICAgICB0aGlzLmFjdGl2ZVBsYW5zLnNwbGljZSh0aGlzLmFjdGl2ZVBsYW5zLmluZGV4T2YoYWN0aXZlUGxhbiksIDEpO1xuICAgICAgdGhpcy5hY3RpdmVQbGFucy5sZW5ndGggPT09IDAgJiYgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBKb2luT2JzZXJ2ZXI7XG4gIH0gKEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyB3aGVuIGJvdGggb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUuXG4gICAqXG4gICAqICBAcGFyYW0gcmlnaHQgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHNlcXVlbmNlLlxuICAgKiAgQHJldHVybiB7UGF0dGVybn0gUGF0dGVybiBvYmplY3QgdGhhdCBtYXRjaGVzIHdoZW4gYm90aCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXZlIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5hbmQgPSBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IFBhdHRlcm4oW3RoaXMsIHJpZ2h0XSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBNYXRjaGVzIHdoZW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgaGFzIGFuIGF2YWlsYWJsZSB2YWx1ZSBhbmQgcHJvamVjdHMgdGhlIHZhbHVlLlxuICAgKlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgdGhhdCB3aWxsIGJlIGludm9rZWQgZm9yIHZhbHVlcyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiAgQHJldHVybnMge1BsYW59IFBsYW4gdGhhdCBwcm9kdWNlcyB0aGUgcHJvamVjdGVkIHZhbHVlcywgdG8gYmUgZmVkICh3aXRoIG90aGVyIHBsYW5zKSB0byB0aGUgd2hlbiBvcGVyYXRvci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50aGVuRG8gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBhdHRlcm4oW3RoaXNdKS50aGVuRG8oc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgSm9pbnMgdG9nZXRoZXIgdGhlIHJlc3VsdHMgZnJvbSBzZXZlcmFsIHBhdHRlcm5zLlxuICAgKlxuICAgKiAgQHBhcmFtIHBsYW5zIEEgc2VyaWVzIG9mIHBsYW5zIChzcGVjaWZpZWQgYXMgYW4gQXJyYXkgb2YgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzKSBjcmVhdGVkIGJ5IHVzZSBvZiB0aGUgVGhlbiBvcGVyYXRvciBvbiBwYXR0ZXJucy5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHJlc3VsdHMgZm9ybSBtYXRjaGluZyBzZXZlcmFsIHBhdHRlcm5zLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS53aGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbGFucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBwbGFucyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGxhbnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBwbGFuc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhY3RpdmVQbGFucyA9IFtdLFxuICAgICAgICAgIGV4dGVybmFsU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBvdXRPYnNlcnZlciA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAoeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGV4dGVybmFsU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYub25FcnJvcihlcnIpOyB9KTtcbiAgICAgICAgICBvLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHgpIHsgby5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBsYW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYWN0aXZlUGxhbnMucHVzaChwbGFuc1tpXS5hY3RpdmF0ZShleHRlcm5hbFN1YnNjcmlwdGlvbnMsIG91dE9ic2VydmVyLCBmdW5jdGlvbiAoYWN0aXZlUGxhbikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGFjdGl2ZVBsYW5zLmluZGV4T2YoYWN0aXZlUGxhbik7XG4gICAgICAgICAgICBhY3RpdmVQbGFucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGFjdGl2ZVBsYW5zLmxlbmd0aCA9PT0gMCAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlVGhyb3coZSkuc3Vic2NyaWJlKG8pO1xuICAgICAgfVxuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGV4dGVybmFsU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChqb2luT2JzZXJ2ZXIpIHtcbiAgICAgICAgam9pbk9ic2VydmVyLnN1YnNjcmliZSgpO1xuICAgICAgICBncm91cC5hZGQoam9pbk9ic2VydmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFRpbWVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGltZXJPYnNlcnZhYmxlKGR0LCBzKSB7XG4gICAgICB0aGlzLl9kdCA9IGR0O1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lck9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUobywgdGhpcy5fZHQsIHNjaGVkdWxlTWV0aG9kKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgbykge1xuICAgICAgby5vbk5leHQoMCk7XG4gICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRpbWVyT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIGZ1bmN0aW9uIF9vYnNlcnZhYmxlVGltZXIoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lck9ic2VydmFibGUoZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVUaW1lckRhdGVBbmRQZXJpb2QoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZCA9IGR1ZVRpbWUsIHAgPSBub3JtYWxpemVUaW1lKHBlcmlvZCk7XG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKDAsIGQsIGZ1bmN0aW9uIChjb3VudCwgc2VsZikge1xuICAgICAgICBpZiAocCA+IDApIHtcbiAgICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICAgIGQgPSBuZXcgRGF0ZShkLmdldFRpbWUoKSArIHApO1xuICAgICAgICAgIGQuZ2V0VGltZSgpIDw9IG5vdyAmJiAoZCA9IG5ldyBEYXRlKG5vdyArIHApKTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5vbk5leHQoY291bnQpO1xuICAgICAgICBzZWxmKGNvdW50ICsgMSwgbmV3IERhdGUoZCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlVGltZXJUaW1lU3BhbkFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBkdWVUaW1lID09PSBwZXJpb2QgP1xuICAgICAgbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVQZXJpb2RpYygwLCBwZXJpb2QsIGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChjb3VudCk7XG4gICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfSk7XG4gICAgICB9KSA6XG4gICAgICBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChuZXcgRGF0ZShzY2hlZHVsZXIubm93KCkgKyBkdWVUaW1lKSwgcGVyaW9kLCBzY2hlZHVsZXIpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZWFjaCBwZXJpb2QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICogIDIgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZCBQZXJpb2QgZm9yIHByb2R1Y2luZyB0aGUgdmFsdWVzIGluIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgUnguU2NoZWR1bGVyLnRpbWVvdXQgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGVhY2ggcGVyaW9kLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVpbnRlcnZhbCA9IE9ic2VydmFibGUuaW50ZXJ2YWwgPSBmdW5jdGlvbiAocGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW5BbmRQZXJpb2QocGVyaW9kLCBwZXJpb2QsIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgPyBzY2hlZHVsZXIgOiBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZHVlVGltZSBoYXMgZWxhcHNlZCBhbmQgdGhlbiBhZnRlciBlYWNoIHBlcmlvZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgKHNwZWNpZmllZCBhcyBhIERhdGUgb2JqZWN0KSBvciByZWxhdGl2ZSB0aW1lIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpIGF0IHdoaWNoIHRvIHByb2R1Y2UgdGhlIGZpcnN0IHZhbHVlLlxuICAgKiBAcGFyYW0ge01peGVkfSBbcGVyaW9kT3JTY2hlZHVsZXJdICBQZXJpb2QgdG8gcHJvZHVjZSBzdWJzZXF1ZW50IHZhbHVlcyAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSwgb3IgdGhlIHNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcmVzdWx0aW5nIHRpbWVyIGlzIG5vdCByZWN1cnJpbmcuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZHVlIHRpbWUgaGFzIGVsYXBzZWQgYW5kIHRoZW4gZWFjaCBwZXJpb2QuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZVRpbWVyID0gT2JzZXJ2YWJsZS50aW1lciA9IGZ1bmN0aW9uIChkdWVUaW1lLCBwZXJpb2RPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XG4gICAgdmFyIHBlcmlvZDtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICBpZiAocGVyaW9kT3JTY2hlZHVsZXIgIT0gbnVsbCAmJiB0eXBlb2YgcGVyaW9kT3JTY2hlZHVsZXIgPT09ICdudW1iZXInKSB7XG4gICAgICBwZXJpb2QgPSBwZXJpb2RPclNjaGVkdWxlcjtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZWR1bGVyKHBlcmlvZE9yU2NoZWR1bGVyKSkge1xuICAgICAgc2NoZWR1bGVyID0gcGVyaW9kT3JTY2hlZHVsZXI7XG4gICAgfVxuICAgIGlmICgoZHVlVGltZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGR1ZVRpbWUgPT09ICdudW1iZXInKSAmJiBwZXJpb2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlVGltZXIoZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgICB9XG4gICAgaWYgKGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlICYmIHBlcmlvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2RPclNjaGVkdWxlciwgc2NoZWR1bGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmFibGVUaW1lclRpbWVTcGFuQW5kUGVyaW9kKGR1ZVRpbWUsIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlRGVsYXlSZWxhdGl2ZShzb3VyY2UsIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgZXhjZXB0aW9uID0gbnVsbCxcbiAgICAgICAgcSA9IFtdLFxuICAgICAgICBydW5uaW5nID0gZmFsc2UsXG4gICAgICAgIHN1YnNjcmlwdGlvbjtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5tYXRlcmlhbGl6ZSgpLnRpbWVzdGFtcChzY2hlZHVsZXIpLnN1YnNjcmliZShmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHZhciBkLCBzaG91bGRSdW47XG4gICAgICAgIGlmIChub3RpZmljYXRpb24udmFsdWUua2luZCA9PT0gJ0UnKSB7XG4gICAgICAgICAgcSA9IFtdO1xuICAgICAgICAgIHEucHVzaChub3RpZmljYXRpb24pO1xuICAgICAgICAgIGV4Y2VwdGlvbiA9IG5vdGlmaWNhdGlvbi52YWx1ZS5lcnJvcjtcbiAgICAgICAgICBzaG91bGRSdW4gPSAhcnVubmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxLnB1c2goeyB2YWx1ZTogbm90aWZpY2F0aW9uLnZhbHVlLCB0aW1lc3RhbXA6IG5vdGlmaWNhdGlvbi50aW1lc3RhbXAgKyBkdWVUaW1lIH0pO1xuICAgICAgICAgIHNob3VsZFJ1biA9ICFhY3RpdmU7XG4gICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUnVuKSB7XG4gICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgby5vbkVycm9yKGV4Y2VwdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICAgIGNhbmNlbGFibGUuc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUobnVsbCwgZHVlVGltZSwgZnVuY3Rpb24gKF8sIHNlbGYpIHtcbiAgICAgICAgICAgICAgdmFyIGUsIHJlY3Vyc2VEdWVUaW1lLCByZXN1bHQsIHNob3VsZFJlY3Vyc2U7XG4gICAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA+IDAgJiYgcVswXS50aW1lc3RhbXAgLSBzY2hlZHVsZXIubm93KCkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcS5zaGlmdCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuYWNjZXB0KG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSB3aGlsZSAocmVzdWx0ICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgc2hvdWxkUmVjdXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZWN1cnNlRHVlVGltZSA9IDA7XG4gICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzaG91bGRSZWN1cnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWN1cnNlRHVlVGltZSA9IE1hdGgubWF4KDAsIHFbMF0udGltZXN0YW1wIC0gc2NoZWR1bGVyLm5vdygpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlID0gZXhjZXB0aW9uO1xuICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmKG51bGwsIHJlY3Vyc2VEdWVUaW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZURlbGF5QWJzb2x1dGUoc291cmNlLCBkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlRGVsYXlSZWxhdGl2ZShzb3VyY2UsIGR1ZVRpbWUgLSBzY2hlZHVsZXIubm93KCksIHNjaGVkdWxlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxheVdpdGhTZWxlY3Rvcihzb3VyY2UsIHN1YnNjcmlwdGlvbkRlbGF5LCBkZWxheUR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViRGVsYXksIHNlbGVjdG9yO1xuICAgIGlmIChpc0Z1bmN0aW9uKHN1YnNjcmlwdGlvbkRlbGF5KSkge1xuICAgICAgc2VsZWN0b3IgPSBzdWJzY3JpcHRpb25EZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViRGVsYXkgPSBzdWJzY3JpcHRpb25EZWxheTtcbiAgICAgIHNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkZWxheXMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLCBhdEVuZCA9IGZhbHNlLCBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuXG4gICAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdHJ5Q2F0Y2goc2VsZWN0b3IpKHgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGRlbGF5LmUpOyB9XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgICAgZGVsYXlzLmFkZChkKTtcbiAgICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZShkZWxheS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICAgICAgICBkZWxheXMucmVtb3ZlKGQpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgby5vbk5leHQoeCk7XG4gICAgICAgICAgICAgICAgZGVsYXlzLnJlbW92ZShkKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgICAgIGF0RW5kICYmIGRlbGF5cy5sZW5ndGggPT09IDAgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN1YkRlbGF5KSB7XG4gICAgICAgIHN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShzdWJEZWxheS5zdWJzY3JpYmUoc3RhcnQsIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSwgc3RhcnQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgZGVsYXlzKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqICBUaW1lIHNoaWZ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBkdWVUaW1lLlxuICAgKiAgVGhlIHJlbGF0aXZlIHRpbWUgaW50ZXJ2YWxzIGJldHdlZW4gdGhlIHZhbHVlcyBhcmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSAoc3BlY2lmaWVkIGFzIGEgRGF0ZSBvYmplY3QpIG9yIHJlbGF0aXZlIHRpbWUgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykgYnkgd2hpY2ggdG8gc2hpZnQgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSBkZWxheSB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGltZS1zaGlmdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRlbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnbnVtYmVyJyB8fCBmaXJzdEFyZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHZhciBkdWVUaW1lID0gZmlyc3RBcmcsIHNjaGVkdWxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgICAgcmV0dXJuIGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgb2JzZXJ2YWJsZURlbGF5QWJzb2x1dGUodGhpcywgZHVlVGltZSwgc2NoZWR1bGVyKSA6XG4gICAgICAgIG9ic2VydmFibGVEZWxheVJlbGF0aXZlKHRoaXMsIGR1ZVRpbWUsIHNjaGVkdWxlcik7XG4gICAgfSBlbHNlIGlmIChPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShmaXJzdEFyZykgfHwgaXNGdW5jdGlvbihmaXJzdEFyZykpIHtcbiAgICAgIHJldHVybiBkZWxheVdpdGhTZWxlY3Rvcih0aGlzLCBmaXJzdEFyZywgYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgRGVib3VuY2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWJvdW5jZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VPYnNlcnZhYmxlKHNvdXJjZSwgZHQsIHMpIHtcbiAgICAgIGlzU2NoZWR1bGVyKHMpIHx8IChzID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2R0ID0gZHQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERlYm91bmNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgY2FuY2VsYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VPYnNlcnZlcihvLCB0aGlzLl9kdCwgdGhpcy5fcywgY2FuY2VsYWJsZSkpLFxuICAgICAgICBjYW5jZWxhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlYm91bmNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEZWJvdW5jZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWJvdW5jZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlT2JzZXJ2ZXIob2JzZXJ2ZXIsIGR1ZVRpbWUsIHNjaGVkdWxlciwgY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5fZCA9IGR1ZVRpbWU7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLl9jID0gY2FuY2VsYWJsZTtcbiAgICAgIHRoaXMuX3YgPSBudWxsO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lkID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRnV0dXJlKHMsIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5zZWxmLl9odiAmJiBzdGF0ZS5zZWxmLl9pZCA9PT0gc3RhdGUuY3VycmVudElkICYmIHN0YXRlLnNlbGYuX28ub25OZXh0KHN0YXRlLngpO1xuICAgICAgc3RhdGUuc2VsZi5faHYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBEZWJvdW5jZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2h2ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3YgPSB4O1xuICAgICAgdmFyIGN1cnJlbnRJZCA9ICsrdGhpcy5faWQsIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX2Muc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUodGhpcywgdGhpcy5fZCwgZnVuY3Rpb24gKF8sIHNlbGYpIHtcbiAgICAgICAgc2VsZi5faHYgJiYgc2VsZi5faWQgPT09IGN1cnJlbnRJZCAmJiBzZWxmLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgc2VsZi5faHYgPSBmYWxzZTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgRGVib3VuY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fYy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faWQrKztcbiAgICB9O1xuXG4gICAgRGVib3VuY2VPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9odiAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZCsrO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVib3VuY2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VXaXRoU2VsZWN0b3Ioc291cmNlLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgdmFsdWUsIGhhc1ZhbHVlID0gZmFsc2UsIGNhbmNlbGFibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLCBpZCA9IDA7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgdGhyb3R0bGUgPSB0cnlDYXRjaChkdXJhdGlvblNlbGVjdG9yKSh4KTtcbiAgICAgICAgICBpZiAodGhyb3R0bGUgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IodGhyb3R0bGUuZSk7IH1cblxuICAgICAgICAgIGlzUHJvbWlzZSh0aHJvdHRsZSkgJiYgKHRocm90dGxlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHRocm90dGxlKSk7XG5cbiAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgdmFsdWUgPSB4O1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgdmFyIGN1cnJlbnRpZCA9IGlkLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgY2FuY2VsYWJsZS5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aHJvdHRsZS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlICYmIGlkID09PSBjdXJyZW50aWQgJiYgby5vbk5leHQodmFsdWUpO1xuICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlICYmIGlkID09PSBjdXJyZW50aWQgJiYgby5vbk5leHQodmFsdWUpO1xuICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjYW5jZWxhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FuY2VsYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgaGFzVmFsdWUgJiYgby5vbk5leHQodmFsdWUpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlkKys7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgb2JzZXJ2YWJsZVByb3RvLmRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0Z1bmN0aW9uIChhcmd1bWVudHNbMF0pKSB7XG4gICAgICByZXR1cm4gZGVib3VuY2VXaXRoU2VsZWN0b3IodGhpcywgYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gbmV3IERlYm91bmNlT2JzZXJ2YWJsZSh0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSB3aW5kb3dzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiB0aW1pbmcgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBMZW5ndGggb2YgZWFjaCB3aW5kb3cgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aW1lU2hpZnRPclNjaGVkdWxlcl0gIEludGVydmFsIGJldHdlZW4gY3JlYXRpb24gb2YgY29uc2VjdXRpdmUgd2luZG93cyAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSwgb3IgYW4gb3B0aW9uYWwgc2NoZWR1bGVyIHBhcmFtZXRlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWUgc2hpZnQgY29ycmVzcG9uZHMgdG8gdGhlIHRpbWVTcGFuIHBhcmFtZXRlciwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyBhZGphY2VudCB3aW5kb3dzLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gd2luZG93aW5nIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHdpbmRvd3MuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2luZG93V2l0aFRpbWUgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93VGltZSA9IGZ1bmN0aW9uICh0aW1lU3BhbiwgdGltZVNoaWZ0T3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLCB0aW1lU2hpZnQ7XG4gICAgdGltZVNoaWZ0T3JTY2hlZHVsZXIgPT0gbnVsbCAmJiAodGltZVNoaWZ0ID0gdGltZVNwYW4pO1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIGlmICh0eXBlb2YgdGltZVNoaWZ0T3JTY2hlZHVsZXIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aW1lU2hpZnQgPSB0aW1lU2hpZnRPclNjaGVkdWxlcjtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZWR1bGVyKHRpbWVTaGlmdE9yU2NoZWR1bGVyKSkge1xuICAgICAgdGltZVNoaWZ0ID0gdGltZVNwYW47XG4gICAgICBzY2hlZHVsZXIgPSB0aW1lU2hpZnRPclNjaGVkdWxlcjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGdyb3VwRGlzcG9zYWJsZSxcbiAgICAgICAgbmV4dFNoaWZ0ID0gdGltZVNoaWZ0LFxuICAgICAgICBuZXh0U3BhbiA9IHRpbWVTcGFuLFxuICAgICAgICBxID0gW10sXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSxcbiAgICAgICAgdGltZXJEID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgdG90YWxUaW1lID0gMDtcbiAgICAgICAgZ3JvdXBEaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUodGltZXJEKSxcbiAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cERpc3Bvc2FibGUpO1xuXG4gICAgICAgZnVuY3Rpb24gY3JlYXRlVGltZXIgKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICAgIGlzU3BhbiA9IGZhbHNlLFxuICAgICAgICAgIGlzU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgdGltZXJELnNldERpc3Bvc2FibGUobSk7XG4gICAgICAgIGlmIChuZXh0U3BhbiA9PT0gbmV4dFNoaWZ0KSB7XG4gICAgICAgICAgaXNTcGFuID0gdHJ1ZTtcbiAgICAgICAgICBpc1NoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3BhbiA8IG5leHRTaGlmdCkge1xuICAgICAgICAgICAgaXNTcGFuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1NoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VG90YWxUaW1lID0gaXNTcGFuID8gbmV4dFNwYW4gOiBuZXh0U2hpZnQsXG4gICAgICAgICAgdHMgPSBuZXdUb3RhbFRpbWUgLSB0b3RhbFRpbWU7XG4gICAgICAgIHRvdGFsVGltZSA9IG5ld1RvdGFsVGltZTtcbiAgICAgICAgaWYgKGlzU3Bhbikge1xuICAgICAgICAgIG5leHRTcGFuICs9IHRpbWVTaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGlmdCkge1xuICAgICAgICAgIG5leHRTaGlmdCArPSB0aW1lU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShudWxsLCB0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc1NoaWZ0KSB7XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICBxLnB1c2gocyk7XG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1NwYW4gJiYgcS5zaGlmdCgpLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgY3JlYXRlVGltZXIoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIHEucHVzaChuZXcgU3ViamVjdCgpKTtcbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocVswXSwgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICBjcmVhdGVUaW1lcigpO1xuICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IHFbaV0ub25OZXh0KHgpOyB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbkVycm9yKGUpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IHFbaV0ub25Db21wbGV0ZWQoKTsgfVxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuIHJlZkNvdW50RGlzcG9zYWJsZTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIHdpbmRvdyB0aGF0IGlzIGNvbXBsZXRlZCB3aGVuIGVpdGhlciBpdCdzIGZ1bGwgb3IgYSBnaXZlbiBhbW91bnQgb2YgdGltZSBoYXMgZWxhcHNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIE1heGltdW0gdGltZSBsZW5ndGggb2YgYSB3aW5kb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgYSB3aW5kb3cuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB3aW5kb3dpbmcgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoVGltZU9yQ291bnQgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93VGltZU9yQ291bnQgPSBmdW5jdGlvbiAodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgdGltZXJEID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgICBncm91cERpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSh0aW1lckQpLFxuICAgICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKSxcbiAgICAgICAgICBuID0gMCxcbiAgICAgICAgICB3aW5kb3dJZCA9IDAsXG4gICAgICAgICAgcyA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRpbWVyKGlkKSB7XG4gICAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRpbWVyRC5zZXREaXNwb3NhYmxlKG0pO1xuICAgICAgICBtLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKG51bGwsIHRpbWVTcGFuLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlkICE9PSB3aW5kb3dJZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBuID0gMDtcbiAgICAgICAgICB2YXIgbmV3SWQgPSArK3dpbmRvd0lkO1xuICAgICAgICAgIHMub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgICAgIGNyZWF0ZVRpbWVyKG5ld0lkKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgY3JlYXRlVGltZXIoMCk7XG5cbiAgICAgIGdyb3VwRGlzcG9zYWJsZS5hZGQoc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgbmV3SWQgPSAwLCBuZXdXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICBzLm9uTmV4dCh4KTtcbiAgICAgICAgICBpZiAoKytuID09PSBjb3VudCkge1xuICAgICAgICAgICAgbmV3V2luZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgbmV3SWQgPSArK3dpbmRvd0lkO1xuICAgICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdXaW5kb3cgJiYgY3JlYXRlVGltZXIobmV3SWQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHMub25FcnJvcihlKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuIHJlZkNvdW50RGlzcG9zYWJsZTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoeCkgeyByZXR1cm4geC50b0FycmF5KCk7IH1cblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gemVybyBvciBtb3JlIGJ1ZmZlcnMgd2hpY2ggYXJlIHByb2R1Y2VkIGJhc2VkIG9uIHRpbWluZyBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIExlbmd0aCBvZiBlYWNoIGJ1ZmZlciAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RpbWVTaGlmdE9yU2NoZWR1bGVyXSAgSW50ZXJ2YWwgYmV0d2VlbiBjcmVhdGlvbiBvZiBjb25zZWN1dGl2ZSBidWZmZXJzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciBhbiBvcHRpb25hbCBzY2hlZHVsZXIgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZSBzaGlmdCBjb3JyZXNwb25kcyB0byB0aGUgdGltZVNwYW4gcGFyYW1ldGVyLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIGFkamFjZW50IGJ1ZmZlcnMuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biBidWZmZXIgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgYnVmZmVycy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5idWZmZXJXaXRoVGltZSA9IG9ic2VydmFibGVQcm90by5idWZmZXJUaW1lID0gZnVuY3Rpb24gKHRpbWVTcGFuLCB0aW1lU2hpZnRPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIHRoaXMud2luZG93V2l0aFRpbWUodGltZVNwYW4sIHRpbWVTaGlmdE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpLmZsYXRNYXAodG9BcnJheSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9BcnJheSh4KSB7IHJldHVybiB4LnRvQXJyYXkoKTsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIGJ1ZmZlciB0aGF0IGlzIGNvbXBsZXRlZCB3aGVuIGVpdGhlciBpdCdzIGZ1bGwgb3IgYSBnaXZlbiBhbW91bnQgb2YgdGltZSBoYXMgZWxhcHNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIE1heGltdW0gdGltZSBsZW5ndGggb2YgYSBidWZmZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgYSBidWZmZXIuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biBidWZmZXJpbiB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhUaW1lT3JDb3VudCA9IG9ic2VydmFibGVQcm90by5idWZmZXJUaW1lT3JDb3VudCA9IGZ1bmN0aW9uICh0aW1lU3BhbiwgY291bnQsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiB0aGlzLndpbmRvd1dpdGhUaW1lT3JDb3VudCh0aW1lU3BhbiwgY291bnQsIHNjaGVkdWxlcikuZmxhdE1hcCh0b0FycmF5KTtcbiAgfTtcblxuICB2YXIgVGltZUludGVydmFsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZUludGVydmFsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlKHNvdXJjZSwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRpbWVJbnRlcnZhbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGltZUludGVydmFsT2JzZXJ2ZXIobywgdGhpcy5fcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGltZUludGVydmFsT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUaW1lSW50ZXJ2YWxPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZUludGVydmFsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBUaW1lSW50ZXJ2YWxPYnNlcnZlcihvLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fbCA9IHMubm93KCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lSW50ZXJ2YWxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKSwgc3BhbiA9IG5vdyAtIHRoaXMuX2w7XG4gICAgICB0aGlzLl9sID0gbm93O1xuICAgICAgdGhpcy5fby5vbk5leHQoeyB2YWx1ZTogeCwgaW50ZXJ2YWw6IHNwYW4gfSk7XG4gICAgfTtcbiAgICBUaW1lSW50ZXJ2YWxPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGltZUludGVydmFsT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFRpbWVJbnRlcnZhbE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJlY29yZHMgdGhlIHRpbWUgaW50ZXJ2YWwgYmV0d2VlbiBjb25zZWN1dGl2ZSB2YWx1ZXMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGltZUludGVydmFsKCk7XG4gICAqICAyIC0gcmVzID0gc291cmNlLnRpbWVJbnRlcnZhbChSeC5TY2hlZHVsZXIudGltZW91dCk7XG4gICAqXG4gICAqIEBwYXJhbSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHVzZWQgdG8gY29tcHV0ZSB0aW1lIGludGVydmFscy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGltZSBpbnRlcnZhbCBpbmZvcm1hdGlvbiBvbiB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGltZUludGVydmFsID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBUaW1lc3RhbXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lc3RhbXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRpbWVzdGFtcE9ic2VydmFibGUoc291cmNlLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZXN0YW1wT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lc3RhbXBPYnNlcnZlcihvLCB0aGlzLl9zKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUaW1lc3RhbXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRpbWVzdGFtcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lc3RhbXBPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBPYnNlcnZlcihvLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZXN0YW1wT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fby5vbk5leHQoeyB2YWx1ZTogeCwgdGltZXN0YW1wOiB0aGlzLl9zLm5vdygpIH0pO1xuICAgIH07XG5cbiAgICBUaW1lc3RhbXBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUaW1lc3RhbXBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGltZXN0YW1wT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmVjb3JkcyB0aGUgdGltZXN0YW1wIGZvciBlYWNoIHZhbHVlIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLnRpbWVzdGFtcCgpOyAvLyBwcm9kdWNlcyB7IHZhbHVlOiB4LCB0aW1lc3RhbXA6IHRzIH1cbiAgICogIDIgLSByZXMgPSBzb3VyY2UudGltZXN0YW1wKFJ4LlNjaGVkdWxlci5kZWZhdWx0KTtcbiAgICpcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdXNlZCB0byBjb21wdXRlIHRpbWVzdGFtcHMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRpbWVzdGFtcCBpbmZvcm1hdGlvbiBvbiB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGltZXN0YW1wID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTYW1wbGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNhbXBsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2FtcGxlT2JzZXJ2YWJsZShzb3VyY2UsIHNhbXBsZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fc2FtcGxlciA9IHNhbXBsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTYW1wbGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgYXRFbmQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgICBzb3VyY2VTdWJzY3JpcHRpb246IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpXG4gICAgICB9O1xuXG4gICAgICBzdGF0ZS5zb3VyY2VTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNhbXBsZVNvdXJjZU9ic2VydmVyKHN0YXRlKSkpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICBzdGF0ZS5zb3VyY2VTdWJzY3JpcHRpb24sXG4gICAgICAgIHRoaXMuX3NhbXBsZXIuc3Vic2NyaWJlKG5ldyBTYW1wbGVyT2JzZXJ2ZXIoc3RhdGUpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNhbXBsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2FtcGxlck9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNhbXBsZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTYW1wbGVyT2JzZXJ2ZXIocykge1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTYW1wbGVyT2JzZXJ2ZXIucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3MuaGFzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zLm8ub25OZXh0KHRoaXMuX3MudmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcy5hdEVuZCAmJiB0aGlzLl9zLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgU2FtcGxlck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oYW5kbGVNZXNzYWdlKCk7IH07XG4gICAgU2FtcGxlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Mub25FcnJvcihlKTsgfTtcbiAgICBTYW1wbGVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGFuZGxlTWVzc2FnZSgpOyB9O1xuXG4gICAgcmV0dXJuIFNhbXBsZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIFNhbXBsZVNvdXJjZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNhbXBsZVNvdXJjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNhbXBsZVNvdXJjZU9ic2VydmVyKHMpIHtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2FtcGxlU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICB0aGlzLl9zLnZhbHVlID0geDtcbiAgICB9O1xuICAgIFNhbXBsZVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuICAgIFNhbXBsZVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zLmF0RW5kID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Muc291cmNlU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNhbXBsZVNvdXJjZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFNhbXBsZXMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYXQgZWFjaCBpbnRlcnZhbC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKHNhbXBsZU9ic2VydmFibGUpOyAvLyBTYW1wbGVyIHRpY2sgc2VxdWVuY2VcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKDUwMDApOyAvLyA1IHNlY29uZHNcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKDUwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTsgLy8gNSBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGludGVydmFsT3JTYW1wbGVyIEludGVydmFsIGF0IHdoaWNoIHRvIHNhbXBsZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSBvciBTYW1wbGVyIE9ic2VydmFibGUuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgc2FtcGxpbmcgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gU2FtcGxlZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNhbXBsZSA9IGZ1bmN0aW9uIChpbnRlcnZhbE9yU2FtcGxlciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnRlcnZhbE9yU2FtcGxlciA9PT0gJ251bWJlcicgP1xuICAgICAgbmV3IFNhbXBsZU9ic2VydmFibGUodGhpcywgb2JzZXJ2YWJsZWludGVydmFsKGludGVydmFsT3JTYW1wbGVyLCBzY2hlZHVsZXIpKSA6XG4gICAgICBuZXcgU2FtcGxlT2JzZXJ2YWJsZSh0aGlzLCBpbnRlcnZhbE9yU2FtcGxlcik7XG4gIH07XG5cbiAgdmFyIFRpbWVvdXRFcnJvciA9IFJ4LlRpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCc7XG4gICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgVGltZW91dEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiB0aW1lb3V0V2l0aFNlbGVjdG9yKHNvdXJjZSwgZmlyc3RUaW1lb3V0LCB0aW1lb3V0RHVyYXRpb25TZWxlY3Rvciwgb3RoZXIpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmaXJzdFRpbWVvdXQpKSB7XG4gICAgICBvdGhlciA9IHRpbWVvdXREdXJhdGlvblNlbGVjdG9yO1xuICAgICAgdGltZW91dER1cmF0aW9uU2VsZWN0b3IgPSBmaXJzdFRpbWVvdXQ7XG4gICAgICBmaXJzdFRpbWVvdXQgPSBvYnNlcnZhYmxlTmV2ZXIoKTtcbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob3RoZXIpIHx8IChvdGhlciA9IG9ic2VydmFibGVUaHJvdyhuZXcgVGltZW91dEVycm9yKCkpKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICB0aW1lciA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIG9yaWdpbmFsID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG9yaWdpbmFsKTtcblxuICAgICAgdmFyIGlkID0gMCwgc3dpdGNoZWQgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gc2V0VGltZXIodGltZW91dCkge1xuICAgICAgICB2YXIgbXlJZCA9IGlkLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdGltZXJXaW5zKCkge1xuICAgICAgICAgIHN3aXRjaGVkID0gKG15SWQgPT09IGlkKTtcbiAgICAgICAgICByZXR1cm4gc3dpdGNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lci5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgICBkLnNldERpc3Bvc2FibGUodGltZW91dC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVyV2lucygpICYmIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShvKSk7XG4gICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGltZXJXaW5zKCkgJiYgby5vbkVycm9yKGUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGltZXJXaW5zKCkgJiYgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG8pKTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgc2V0VGltZXIoZmlyc3RUaW1lb3V0KTtcblxuICAgICAgZnVuY3Rpb24gb1dpbnMoKSB7XG4gICAgICAgIHZhciByZXMgPSAhc3dpdGNoZWQ7XG4gICAgICAgIGlmIChyZXMpIHsgaWQrKzsgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKG9XaW5zKCkpIHtcbiAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICB2YXIgdGltZW91dCA9IHRyeUNhdGNoKHRpbWVvdXREdXJhdGlvblNlbGVjdG9yKSh4KTtcbiAgICAgICAgICBpZiAodGltZW91dCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcih0aW1lb3V0LmUpOyB9XG4gICAgICAgICAgc2V0VGltZXIoaXNQcm9taXNlKHRpbWVvdXQpID8gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHRpbWVvdXQpIDogdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIG9XaW5zKCkgJiYgby5vbkVycm9yKGUpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBvV2lucygpICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIHRpbWVyKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZW91dChzb3VyY2UsIGR1ZVRpbWUsIG90aGVyLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoaXNTY2hlZHVsZXIob3RoZXIpKSB7XG4gICAgICBzY2hlZHVsZXIgPSBvdGhlcjtcbiAgICAgIG90aGVyID0gb2JzZXJ2YWJsZVRocm93KG5ldyBUaW1lb3V0RXJyb3IoKSk7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEVycm9yKSB7IG90aGVyID0gb2JzZXJ2YWJsZVRocm93KG90aGVyKTsgfVxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG90aGVyKSB8fCAob3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cobmV3IFRpbWVvdXRFcnJvcigpKSk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgaWQgPSAwLFxuICAgICAgICBvcmlnaW5hbCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBzd2l0Y2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lciA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG9yaWdpbmFsKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVGltZXIoKSB7XG4gICAgICAgIHZhciBteUlkID0gaWQ7XG4gICAgICAgIHRpbWVyLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKG51bGwsIGR1ZVRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzd2l0Y2hlZCA9IGlkID09PSBteUlkO1xuICAgICAgICAgIGlmIChzd2l0Y2hlZCkge1xuICAgICAgICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShvKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZVRpbWVyKCk7XG5cbiAgICAgIG9yaWdpbmFsLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXN3aXRjaGVkKSB7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICBjcmVhdGVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXN3aXRjaGVkKSB7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlZCkge1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCB0aW1lcik7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIG9ic2VydmFibGVQcm90by50aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZmlyc3RBcmcgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBmaXJzdEFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aW1lb3V0KHRoaXMsIGZpcnN0QXJnLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgfSBlbHNlIGlmIChPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShmaXJzdEFyZykgfHwgaXNGdW5jdGlvbihmaXJzdEFyZykpIHtcbiAgICAgIHJldHVybiB0aW1lb3V0V2l0aFNlbGVjdG9yKHRoaXMsIGZpcnN0QXJnLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZShzdGF0ZSwgY25kRm4sIGl0ckZuLCByZXNGbiwgdGltZUZuLCBzKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fY25kRm4gPSBjbmRGbjtcbiAgICAgIHRoaXMuX2l0ckZuID0gaXRyRm47XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fdGltZUZuID0gdGltZUZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgc3RhdGUuaGFzUmVzdWx0ICYmIHN0YXRlLm8ub25OZXh0KHN0YXRlLnJlc3VsdCk7XG5cbiAgICAgIGlmIChzdGF0ZS5maXJzdCkge1xuICAgICAgICBzdGF0ZS5maXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubmV3U3RhdGUgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9pdHJGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUubmV3U3RhdGUgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUubmV3U3RhdGUuZSk7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2NuZEZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuaGFzUmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLmhhc1Jlc3VsdC5lKTsgfVxuICAgICAgaWYgKHN0YXRlLmhhc1Jlc3VsdCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9yZXNGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUucmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLnJlc3VsdC5lKTsgfVxuICAgICAgICB2YXIgdGltZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3RpbWVGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAodGltZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcih0aW1lLmUpOyB9XG4gICAgICAgIHJlY3Vyc2Uoc3RhdGUsIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICAgICAgbmV3U3RhdGU6IHRoaXMuX3N0YXRlLFxuICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgaGFzUmVzdWx0OiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9zLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKHN0YXRlLCBuZXcgRGF0ZSh0aGlzLl9zLm5vdygpKSwgc2NoZWR1bGVSZWN1cnNpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIEdlbmVyYXRlQWJzb2x1dGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgaXRlcmF0aW5nIGEgc3RhdGUgZnJvbSBhbiBpbml0aWFsIHN0YXRlIHVudGlsIHRoZSBjb25kaXRpb24gZmFpbHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICByZXMgPSBzb3VyY2UuZ2VuZXJhdGVXaXRoQWJzb2x1dGVUaW1lKDAsXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHJldHVybiB0cnVlOyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gbmV3IERhdGUoKTsgfVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQ29uZGl0aW9uIHRvIHRlcm1pbmF0ZSBnZW5lcmF0aW9uICh1cG9uIHJldHVybmluZyBmYWxzZSkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGUgSXRlcmF0aW9uIHN0ZXAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZVNlbGVjdG9yIFRpbWUgc2VsZWN0b3IgZnVuY3Rpb24gdG8gY29udHJvbCB0aGUgc3BlZWQgb2YgdmFsdWVzIGJlaW5nIHByb2R1Y2VkIGVhY2ggaXRlcmF0aW9uLCByZXR1cm5pbmcgRGF0ZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3AuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIGdlbmVyYXRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIE9ic2VydmFibGUuZ2VuZXJhdGVXaXRoQWJzb2x1dGVUaW1lID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciwgdGltZVNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciwgdGltZVNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUoc3RhdGUsIGNuZEZuLCBpdHJGbiwgcmVzRm4sIHRpbWVGbiwgcykge1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX2NuZEZuID0gY25kRm47XG4gICAgICB0aGlzLl9pdHJGbiA9IGl0ckZuO1xuICAgICAgdGhpcy5fcmVzRm4gPSByZXNGbjtcbiAgICAgIHRoaXMuX3RpbWVGbiA9IHRpbWVGbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCAmJiBzdGF0ZS5vLm9uTmV4dChzdGF0ZS5yZXN1bHQpO1xuXG4gICAgICBpZiAoc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgc3RhdGUuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm5ld1N0YXRlID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5faXRyRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLm5ld1N0YXRlID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLm5ld1N0YXRlLmUpOyB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2NuZEZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuaGFzUmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLmhhc1Jlc3VsdC5lKTsgfVxuICAgICAgaWYgKHN0YXRlLmhhc1Jlc3VsdCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9yZXNGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUucmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLnJlc3VsdC5lKTsgfVxuICAgICAgICB2YXIgdGltZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3RpbWVGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAodGltZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcih0aW1lLmUpOyB9XG4gICAgICAgIHJlY3Vyc2Uoc3RhdGUsIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICAgICAgbmV3U3RhdGU6IHRoaXMuX3N0YXRlLFxuICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgaGFzUmVzdWx0OiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9zLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKHN0YXRlLCAwLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgaXRlcmF0aW5nIGEgc3RhdGUgZnJvbSBhbiBpbml0aWFsIHN0YXRlIHVudGlsIHRoZSBjb25kaXRpb24gZmFpbHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICByZXMgPSBzb3VyY2UuZ2VuZXJhdGVXaXRoUmVsYXRpdmVUaW1lKDAsXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHJldHVybiB0cnVlOyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gNTAwOyB9XG4gICAqICApO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsU3RhdGUgSW5pdGlhbCBzdGF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIENvbmRpdGlvbiB0byB0ZXJtaW5hdGUgZ2VuZXJhdGlvbiAodXBvbiByZXR1cm5pbmcgZmFsc2UpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiBmb3IgcmVzdWx0cyBwcm9kdWNlZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVTZWxlY3RvciBUaW1lIHNlbGVjdG9yIGZ1bmN0aW9uIHRvIGNvbnRyb2wgdGhlIHNwZWVkIG9mIHZhbHVlcyBiZWluZyBwcm9kdWNlZCBlYWNoIGl0ZXJhdGlvbiwgcmV0dXJuaW5nIGludGVnZXIgdmFsdWVzIGRlbm90aW5nIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5nZW5lcmF0ZVdpdGhSZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIERlbGF5U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlbGF5U3Vic2NyaXB0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlbGF5U3Vic2NyaXB0aW9uKHNvdXJjZSwgZHQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZHQgPSBkdDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVsYXlTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuXG4gICAgICBkLnNldERpc3Bvc2FibGUodGhpcy5fcy5zY2hlZHVsZUZ1dHVyZShbdGhpcy5zb3VyY2UsIG8sIGRdLCB0aGlzLl9kdCwgc2NoZWR1bGVNZXRob2QpKTtcblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHN0YXRlKSB7XG4gICAgICB2YXIgc291cmNlID0gc3RhdGVbMF0sIG8gPSBzdGF0ZVsxXSwgZCA9IHN0YXRlWzJdO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobykpO1xuICAgIH1cblxuICAgIHJldHVybiBEZWxheVN1YnNjcmlwdGlvbjtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgVGltZSBzaGlmdHMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgZGVsYXlpbmcgdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgdGltZSBkdXJhdGlvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2UuZGVsYXlTdWJzY3JpcHRpb24oNTAwMCk7IC8vIDVzXG4gICAqICAyIC0gcmVzID0gc291cmNlLmRlbGF5U3Vic2NyaXB0aW9uKDUwMDAsIFJ4LlNjaGVkdWxlci5kZWZhdWx0KTsgLy8gNSBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIG9yIGFic29sdXRlIHRpbWUgc2hpZnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSBzdWJzY3JpcHRpb24gZGVsYXkgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGltZS1zaGlmdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRlbGF5U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRGVsYXlTdWJzY3JpcHRpb24odGhpcywgZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgZCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU2tpcExhc3RXaXRoVGltZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHAuX3M7XG4gICAgICB0aGlzLl9kID0gcC5fZDtcbiAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHRoaXMuX3EucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB4IH0pO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCAmJiBub3cgLSB0aGlzLl9xWzBdLmludGVydmFsID49IHRoaXMuX2QpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fcS5zaGlmdCgpLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHdoaWxlICh0aGlzLl9xLmxlbmd0aCA+IDAgJiYgbm93IC0gdGhpcy5fcVswXS5pbnRlcnZhbCA+PSB0aGlzLl9kKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3Euc2hpZnQoKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgU2tpcHMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBpbml0aWFsIGR1cmF0aW9uIHdpbmRvdy5cbiAgICogIEFzIG1vcmUgZWxlbWVudHMgYXJlIHJlY2VpdmVkLCBlbGVtZW50cyBvbGRlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gYXJlIHRha2VuIGZyb20gdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGVcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHNraXBwaW5nIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0XG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHNraXBwZWQgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcExhc3RXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSh0aGlzLCBkdXJhdGlvbiwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgZCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMuX2QsIHRoaXMuX3MpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyKG8sIGQsIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHRoaXMuX3EucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB4IH0pO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCAmJiBub3cgLSB0aGlzLl9xWzBdLmludGVydmFsID49IHRoaXMuX2QpIHtcbiAgICAgICAgdGhpcy5fcS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub3cgPSB0aGlzLl9zLm5vdygpO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMuX3Euc2hpZnQoKTtcbiAgICAgICAgaWYgKG5vdyAtIG5leHQuaW50ZXJ2YWwgPD0gdGhpcy5fZCkgeyB0aGlzLl9vLm9uTmV4dChuZXh0LnZhbHVlKTsgfVxuICAgICAgfVxuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgZWxlbWVudHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXJzIHRvIHJ1biB0aW1lcnMgYW5kIHRvIGRyYWluIHRoZSBjb2xsZWN0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VMYXN0V2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUodGhpcywgZHVyYXRpb24sIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGFrZW4gZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3RCdWZmZXJXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgcSA9IFtdO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcbiAgICAgICAgcS5wdXNoKHsgaW50ZXJ2YWw6IG5vdywgdmFsdWU6IHggfSk7XG4gICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDAgJiYgbm93IC0gcVswXS5pbnRlcnZhbCA+PSBkdXJhdGlvbikge1xuICAgICAgICAgIHEuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCksIHJlcyA9IFtdO1xuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBxLnNoaWZ0KCk7XG4gICAgICAgICAgbm93IC0gbmV4dC5pbnRlcnZhbCA8PSBkdXJhdGlvbiAmJiByZXMucHVzaChuZXh0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvLm9uTmV4dChyZXMpO1xuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlV2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBkLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBvKSB7XG4gICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgfVxuXG4gICAgVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUobywgdGhpcy5fZCwgc2NoZWR1bGVNZXRob2QpLFxuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBUYWtlcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLnRha2VXaXRoVGltZSg1MDAwLCAgW29wdGlvbmFsIHNjaGVkdWxlcl0pO1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxuICAgKiAgQXMgbW9yZSBlbGVtZW50cyBhcmUgcmVjZWl2ZWQsIGVsZW1lbnRzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBhcmUgdGFrZW4gZnJvbSB0aGUgcXVldWUgYW5kIHByb2R1Y2VkIG9uIHRoZVxuICAgKiAgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkIHdpdGggZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3IgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZVdpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFRha2VXaXRoVGltZU9ic2VydmFibGUodGhpcywgZHVyYXRpb24sIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFNraXBXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBXaXRoVGltZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZShzb3VyY2UsIGQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgIHNlbGYuX29wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIFNraXBXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLl9zLnNjaGVkdWxlRnV0dXJlKHRoaXMsIHRoaXMuX2QsIHNjaGVkdWxlTWV0aG9kKSxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwV2l0aFRpbWVPYnNlcnZlcihvLCB0aGlzKSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBXaXRoVGltZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwV2l0aFRpbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNraXBXaXRoVGltZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3AuX29wZW4gJiYgdGhpcy5fby5vbk5leHQoeCk7IH07XG4gICAgU2tpcFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFNraXBXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBTa2lwV2l0aFRpbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBTa2lwcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgU3BlY2lmeWluZyBhIHplcm8gdmFsdWUgZm9yIGR1cmF0aW9uIGRvZXNuJ3QgZ3VhcmFudGVlIG5vIGVsZW1lbnRzIHdpbGwgYmUgZHJvcHBlZCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiAgVGhpcyBpcyBhIHNpZGUtZWZmZWN0IG9mIHRoZSBhc3luY2hyb255IGludHJvZHVjZWQgYnkgdGhlIHNjaGVkdWxlciwgd2hlcmUgdGhlIGFjdGlvbiB0aGF0IGNhdXNlcyBjYWxsYmFja3MgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlIHRvIGJlIGZvcndhcmRlZFxuICAgKiAgbWF5IG5vdCBleGVjdXRlIGltbWVkaWF0ZWx5LCBkZXNwaXRlIHRoZSB6ZXJvIGR1ZSB0aW1lLlxuICAgKlxuICAgKiAgRXJyb3JzIHByb2R1Y2VkIGJ5IHRoZSBzb3VyY2Ugc2VxdWVuY2UgYXJlIGFsd2F5cyBmb3J3YXJkZWQgdG8gdGhlIHJlc3VsdCBzZXF1ZW5jZSwgZXZlbiBpZiB0aGUgZXJyb3Igb2NjdXJzIGJlZm9yZSB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3Igc2tpcHBpbmcgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgc2tpcHBlZCBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlKHRoaXMsIGR1cmF0aW9uLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBzdGFydFRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zdCA9IHN0YXJ0VGltZTtcbiAgICAgIHRoaXMuX3MgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuX29wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUodGhpcywgdGhpcy5fc3QsIHNjaGVkdWxlTWV0aG9kKSxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3AuX29wZW4gJiYgdGhpcy5fby5vbk5leHQoeCk7IH07XG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cblxuICAvKipcbiAgICogIFNraXBzIGVsZW1lbnRzIGZyb20gdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlIHVudGlsIHRoZSBzcGVjaWZpZWQgc3RhcnQgdGltZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogIEVycm9ycyBwcm9kdWNlZCBieSB0aGUgc291cmNlIHNlcXVlbmNlIGFyZSBhbHdheXMgZm9yd2FyZGVkIHRvIHRoZSByZXN1bHQgc2VxdWVuY2UsIGV2ZW4gaWYgdGhlIGVycm9yIG9jY3VycyBiZWZvcmUgdGhlIHN0YXJ0IHRpbWUuXG4gICAqXG4gICAqIEBleGFtcGxlc1xuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5za2lwVW50aWxXaXRoVGltZShuZXcgRGF0ZSgpLCBbc2NoZWR1bGVyXSk7XG4gICAqICAyIC0gcmVzID0gc291cmNlLnNraXBVbnRpbFdpdGhUaW1lKDUwMDAsIFtzY2hlZHVsZXJdKTtcbiAgICogQHBhcmFtIHtEYXRlfE51bWJlcn0gc3RhcnRUaW1lIFRpbWUgdG8gc3RhcnQgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gSWYgdGhpcyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gRGF0ZSgpLCBubyBlbGVtZW50cyB3aWxsIGJlIHNraXBwZWQuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHNraXBwZWQgdW50aWwgdGhlIHNwZWNpZmllZCBzdGFydCB0aW1lLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBVbnRpbFdpdGhUaW1lID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUodGhpcywgc3RhcnRUaW1lLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgVGFrZXMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gdW50aWwgdGhlIHNwZWNpZmllZCBlbmQgdGltZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogQHBhcmFtIHtOdW1iZXIgfCBEYXRlfSBlbmRUaW1lIFRpbWUgdG8gc3RvcCB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLiBJZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuZXcgRGF0ZSgpLCB0aGUgcmVzdWx0IHN0cmVhbSB3aWxsIGNvbXBsZXRlIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIHVudGlsIHRoZSBzcGVjaWZpZWQgZW5kIHRpbWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZVVudGlsV2l0aFRpbWUgPSBmdW5jdGlvbiAoZW5kVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShvLCBlbmRUaW1lLCBmdW5jdGlvbiAoXywgbykgeyBvLm9uQ29tcGxldGVkKCk7IH0pLFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKG8pKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGR1cmluZyBzZXF1ZW50aWFsIHRpbWUgd2luZG93cyBvZiBhIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd0R1cmF0aW9uIHRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgYW5vdGhlciBpdGVtIGFmdGVyIGVtaXR0aW5nIHRoZSBsYXN0IGl0ZW1cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIHRoZSBTY2hlZHVsZXIgdG8gdXNlIGludGVybmFsbHkgdG8gbWFuYWdlIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGltZW91dCBmb3IgZWFjaCBpdGVtLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHRoZSB0aHJvdHRsZSBvcGVyYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGhyb3R0bGUgPSBmdW5jdGlvbiAod2luZG93RHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHZhciBkdXJhdGlvbiA9ICt3aW5kb3dEdXJhdGlvbiB8fCAwO1xuICAgIGlmIChkdXJhdGlvbiA8PSAwKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKCd3aW5kb3dEdXJhdGlvbiBjYW5ub3QgYmUgbGVzcyBvciBlcXVhbCB6ZXJvLicpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbGFzdE9uTmV4dCA9IDA7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICAgIGlmIChsYXN0T25OZXh0ID09PSAwIHx8IG5vdyAtIGxhc3RPbk5leHQgPj0gZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGxhc3RPbk5leHQgPSBub3c7XG4gICAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LCBmdW5jdGlvbiAoKSB7IG8ub25Db21wbGV0ZWQoKTsgfVxuICAgICAgKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBUcmFuc2R1Y2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVHJhbnNkdWNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVHJhbnNkdWNlT2JzZXJ2ZXIobywgeGZvcm0pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5feGZvcm0gPSB4Zm9ybTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRyYW5zZHVjZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl94Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSkuY2FsbCh0aGlzLl94Zm9ybSwgdGhpcy5fbywgeCk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgfTtcblxuICAgIFRyYW5zZHVjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcblxuICAgIFRyYW5zZHVjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl94Zm9ybVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHRoaXMuX28pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHJhbnNkdWNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUZvck9ic2VydmVyKG8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAdHJhbnNkdWNlci9pbml0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSxcbiAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uKG9icywgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG9icy5vbk5leHQoaW5wdXQpO1xuICAgICAgfSxcbiAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24ob2JzKSB7XG4gICAgICAgIHJldHVybiBvYnMub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgdHJhbnNkdWNlciB0byB0cmFuc2Zvcm0gdGhlIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogQHBhcmFtIHtUcmFuc2R1Y2VyfSB0cmFuc2R1Y2VyIEEgdHJhbnNkdWNlciB0byBleGVjdXRlXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgZnJvbSB0aGUgdHJhbnNkdWNlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50cmFuc2R1Y2UgPSBmdW5jdGlvbih0cmFuc2R1Y2VyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciB4Zm9ybSA9IHRyYW5zZHVjZXIodHJhbnNmb3JtRm9yT2JzZXJ2ZXIobykpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRyYW5zZHVjZU9ic2VydmVyKG8sIHhmb3JtKSk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgU3dpdGNoRmlyc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hGaXJzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hGaXJzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGhhc0N1cnJlbnQ6IGZhbHNlLFxuICAgICAgICAgIGlzU3RvcHBlZDogZmFsc2UsXG4gICAgICAgICAgbzogbyxcbiAgICAgICAgICBnOiBnXG4gICAgICAgIH07XG5cbiAgICAgIGcuYWRkKG0pO1xuICAgICAgbS5zZXREaXNwb3NhYmxlKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoRmlyc3RPYnNlcnZlcihzdGF0ZSkpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3dpdGNoRmlyc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFN3aXRjaEZpcnN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3dpdGNoRmlyc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE9ic2VydmVyKHN0YXRlKSB7XG4gICAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICghdGhpcy5fcy5oYXNDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuX3MuaGFzQ3VycmVudCA9IHRydWU7XG4gICAgICAgIGlzUHJvbWlzZSh4KSAmJiAoeCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh4KSk7XG4gICAgICAgIHZhciBpbm5lciA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aGlzLl9zLmcuYWRkKGlubmVyKTtcbiAgICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZSh4LnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcih0aGlzLl9zLCBpbm5lcikpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU3dpdGNoRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFN3aXRjaEZpcnN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3MuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICF0aGlzLl9zLmhhc0N1cnJlbnQgJiYgdGhpcy5fcy5nLmxlbmd0aCA9PT0gMSAmJiB0aGlzLl9zLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHN0YXRlLCBpbm5lcikge1xuICAgICAgdGhpcy5fcyA9IHN0YXRlO1xuICAgICAgdGhpcy5faSA9IGlubmVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3Muby5vbk5leHQoeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm8ub25FcnJvcihlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zLmcucmVtb3ZlKHRoaXMuX2kpO1xuICAgICAgdGhpcy5fcy5oYXNDdXJyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLl9zLmlzU3RvcHBlZCAmJiB0aGlzLl9zLmcubGVuZ3RoID09PSAxICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3dpdGNoRmlyc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZXhjbHVzaXZlIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCB0byBmaW5pc2ggYmVmb3JlIHN1YnNjcmliaW5nIHRvIGFub3RoZXIgb2JzZXJ2YWJsZS5cbiAgICogT2JzZXJ2YWJsZXMgdGhhdCBjb21lIGluIGJldHdlZW4gc3Vic2NyaXB0aW9ucyB3aWxsIGJlIGRyb3BwZWQgb24gdGhlIGZsb29yLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBleGNsdXNpdmUgb2JzZXJ2YWJsZSB3aXRoIG9ubHkgdGhlIHJlc3VsdHMgdGhhdCBoYXBwZW4gd2hlbiBzdWJzY3JpYmVkLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnN3aXRjaEZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3dpdGNoRmlyc3RPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG5vYnNlcnZhYmxlUHJvdG8uZmxhdE1hcEZpcnN0ID0gb2JzZXJ2YWJsZVByb3RvLmV4aGF1c3RNYXAgPSBmdW5jdGlvbihzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykuc3dpdGNoRmlyc3QoKTtcbn07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwV2l0aE1heENvbmN1cnJlbnQgPSBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcE1heENvbmN1cnJlbnQgPSBmdW5jdGlvbihsaW1pdCwgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0TWFwT2JzZXJ2YWJsZSh0aGlzLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpLm1lcmdlKGxpbWl0KTtcbn07XG5cbiAgLyoqIFByb3ZpZGVzIGEgc2V0IG9mIGV4dGVuc2lvbiBtZXRob2RzIGZvciB2aXJ0dWFsIHRpbWUgc2NoZWR1bGluZy4gKi9cbiAgdmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyID0gUnguVmlydHVhbFRpbWVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFZpcnR1YWxUaW1lU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyIHdpdGggdGhlIHNwZWNpZmllZCBpbml0aWFsIGNsb2NrIHZhbHVlIGFuZCBhYnNvbHV0ZSB0aW1lIGNvbXBhcmVyLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluaXRpYWxDbG9jayBJbml0aWFsIHZhbHVlIGZvciB0aGUgY2xvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgQ29tcGFyZXIgdG8gZGV0ZXJtaW5lIGNhdXNhbGl0eSBvZiBldmVudHMgYmFzZWQgb24gYWJzb2x1dGUgdGltZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaXJ0dWFsVGltZVNjaGVkdWxlcihpbml0aWFsQ2xvY2ssIGNvbXBhcmVyKSB7XG4gICAgICB0aGlzLmNsb2NrID0gaW5pdGlhbENsb2NrO1xuICAgICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgxMDI0KTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZSA9IFZpcnR1YWxUaW1lU2NoZWR1bGVyLnByb3RvdHlwZTtcblxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWJzb2x1dGVUaW1lKHRoaXMuY2xvY2spO1xuICAgIH07XG5cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUFic29sdXRlKHN0YXRlLCB0aGlzLmNsb2NrLCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgZHQgPSBkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgIHRoaXMudG9SZWxhdGl2ZVRpbWUoZHVlVGltZSAtIHRoaXMubm93KCkpIDpcbiAgICAgICAgdGhpcy50b1JlbGF0aXZlVGltZShkdWVUaW1lKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVSZWxhdGl2ZShzdGF0ZSwgZHQsIGFjdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZWxhdGl2ZSB0aW1lIHZhbHVlIHRvIGFuIGFic29sdXRlIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFic29sdXRlIEFic29sdXRlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXRpdmUgUmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJlc3VsdGluZyBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgc3VtIHZhbHVlLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkZCA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gYWJzb2x1dGUgdGltZSB0byBhIG51bWJlclxuICAgICAqIEBwYXJhbSB7QW55fSBUaGUgYWJzb2x1dGUgdGltZS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYWJzb2x1dGUgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnRvQWJzb2x1dGVUaW1lID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgVGltZVNwYW4gdmFsdWUgdG8gYSByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDb3JyZXNwb25kaW5nIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS50b1JlbGF0aXZlVGltZSA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgcGVyaW9kaWMgcGllY2Ugb2Ygd29yayBieSBkeW5hbWljYWxseSBkaXNjb3ZlcmluZyB0aGUgc2NoZWR1bGVyJ3MgY2FwYWJpbGl0aWVzLiBUaGUgcGVyaW9kaWMgdGFzayB3aWxsIGJlIGVtdWxhdGVkIHVzaW5nIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIEluaXRpYWwgc3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdXBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBydW5uaW5nIHRoZSB3b3JrIHBlcmlvZGljYWxseS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLCBwb3RlbnRpYWxseSB1cGRhdGluZyB0aGUgc3RhdGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIHJlY3VycmluZyBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZVBlcmlvZGljID0gZnVuY3Rpb24gKHN0YXRlLCBwZXJpb2QsIGFjdGlvbikge1xuICAgICAgdmFyIHMgPSBuZXcgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZSh0aGlzLCBzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pO1xuICAgICAgcmV0dXJuIHMuc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkdWVUaW1lLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlUmVsYXRpdmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdmFyIHJ1bkF0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgZHVlVGltZSk7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUFic29sdXRlKHN0YXRlLCBydW5BdCwgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVyKG5leHQuZHVlVGltZSwgdGhpcy5jbG9jaykgPiAwICYmICh0aGlzLmNsb2NrID0gbmV4dC5kdWVUaW1lKTtcbiAgICAgICAgICAgIG5leHQuaW52b2tlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLmlzRW5hYmxlZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgdG8gdGhlIHNwZWNpZmllZCB0aW1lLCBydW5uaW5nIGFsbCB3b3JrIHRpbGwgdGhhdCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBBYnNvbHV0ZSB0aW1lIHRvIGFkdmFuY2UgdGhlIHNjaGVkdWxlcidzIGNsb2NrIHRvLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkdmFuY2VUbyA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgZHVlVG9DbG9jayA9IHRoaXMuY29tcGFyZXIodGhpcy5jbG9jaywgdGltZSk7XG4gICAgICBpZiAodGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCB0aW1lKSA+IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICAgIGlmIChkdWVUb0Nsb2NrID09PSAwKSB7IHJldHVybjsgfVxuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsICYmIHRoaXMuY29tcGFyZXIobmV4dC5kdWVUaW1lLCB0aW1lKSA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVyKG5leHQuZHVlVGltZSwgdGhpcy5jbG9jaykgPiAwICYmICh0aGlzLmNsb2NrID0gbmV4dC5kdWVUaW1lKTtcbiAgICAgICAgICAgIG5leHQuaW52b2tlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLmlzRW5hYmxlZCk7XG4gICAgICAgIHRoaXMuY2xvY2sgPSB0aW1lO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSB0aW1lLCBydW5uaW5nIGFsbCB3b3JrIHNjaGVkdWxlZCBmb3IgdGhhdCB0aW1lc3Bhbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBSZWxhdGl2ZSB0aW1lIHRvIGFkdmFuY2UgdGhlIHNjaGVkdWxlcidzIGNsb2NrIGJ5LlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkdmFuY2VCeSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLmFkZCh0aGlzLmNsb2NrLCB0aW1lKSxcbiAgICAgICAgICBkdWVUb0Nsb2NrID0gdGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCBkdCk7XG4gICAgICBpZiAoZHVlVG9DbG9jayA+IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICAgIGlmIChkdWVUb0Nsb2NrID09PSAwKSB7ICByZXR1cm47IH1cblxuICAgICAgdGhpcy5hZHZhbmNlVG8oZHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSB0aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFJlbGF0aXZlIHRpbWUgdG8gYWR2YW5jZSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgdmFyIGR0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgdGltZSk7XG4gICAgICBpZiAodGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCBkdCkgPj0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuXG4gICAgICB0aGlzLmNsb2NrID0gZHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgc2NoZWR1bGVkIGl0ZW0gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMge1NjaGVkdWxlZEl0ZW19IFRoZSBuZXh0IHNjaGVkdWxlZCBpdGVtLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5xdWV1ZS5wZWVrKCk7XG4gICAgICAgIGlmIChuZXh0LmlzQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgZHVlVGltZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSB0aW1lIGF0IHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZUFic29sdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gcnVuKHNjaGVkdWxlciwgc3RhdGUxKSB7XG4gICAgICAgIHNlbGYucXVldWUucmVtb3ZlKHNpKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbihzY2hlZHVsZXIsIHN0YXRlMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaSA9IG5ldyBTY2hlZHVsZWRJdGVtKHRoaXMsIHN0YXRlLCBydW4sIGR1ZVRpbWUsIHRoaXMuY29tcGFyZXIpO1xuICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKHNpKTtcblxuICAgICAgcmV0dXJuIHNpLmRpc3Bvc2FibGU7XG4gICAgfTtcblxuICAgIHJldHVybiBWaXJ0dWFsVGltZVNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICAvKiogUHJvdmlkZXMgYSB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyIHRoYXQgdXNlcyBEYXRlIGZvciBhYnNvbHV0ZSB0aW1lIGFuZCBudW1iZXIgZm9yIHJlbGF0aXZlIHRpbWUuICovXG4gIFJ4Lkhpc3RvcmljYWxTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEhpc3RvcmljYWxTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGhpc3RvcmljYWwgc2NoZWR1bGVyIHdpdGggdGhlIHNwZWNpZmllZCBpbml0aWFsIGNsb2NrIHZhbHVlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbml0aWFsQ2xvY2sgSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIENvbXBhcmVyIHRvIGRldGVybWluZSBjYXVzYWxpdHkgb2YgZXZlbnRzIGJhc2VkIG9uIGFic29sdXRlIHRpbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGlzdG9yaWNhbFNjaGVkdWxlcihpbml0aWFsQ2xvY2ssIGNvbXBhcmVyKSB7XG4gICAgICB2YXIgY2xvY2sgPSBpbml0aWFsQ2xvY2sgPT0gbnVsbCA/IDAgOiBpbml0aWFsQ2xvY2s7XG4gICAgICB2YXIgY21wID0gY29tcGFyZXIgfHwgZGVmYXVsdFN1YkNvbXBhcmVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgY2xvY2ssIGNtcCk7XG4gICAgfVxuXG4gICAgdmFyIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90byA9IEhpc3RvcmljYWxTY2hlZHVsZXIucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHRpbWUgdmFsdWUgdG8gYW4gYWJzb2x1dGUgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxhdGl2ZSBSZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXG4gICAgICovXG4gICAgSGlzdG9yaWNhbFNjaGVkdWxlclByb3RvLmFkZCA9IGZ1bmN0aW9uIChhYnNvbHV0ZSwgcmVsYXRpdmUpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZSArIHJlbGF0aXZlO1xuICAgIH07XG5cbiAgICBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8udG9BYnNvbHV0ZVRpbWUgPSBmdW5jdGlvbiAoYWJzb2x1dGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShhYnNvbHV0ZSkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgVGltZVNwYW4gdmFsdWUgdG8gYSByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQG1lbWJlck9mIEhpc3RvcmljYWxTY2hlZHVsZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gVGltZVNwYW4gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvcnJlc3BvbmRpbmcgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqL1xuICAgIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90by50b1JlbGF0aXZlVGltZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xuICAgICAgcmV0dXJuIHRpbWVTcGFuO1xuICAgIH07XG5cbiAgICByZXR1cm4gSGlzdG9yaWNhbFNjaGVkdWxlcjtcbiAgfShSeC5WaXJ0dWFsVGltZVNjaGVkdWxlcikpO1xuXG5mdW5jdGlvbiBPbk5leHRQcmVkaWNhdGUocHJlZGljYXRlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG59XG5cbk9uTmV4dFByZWRpY2F0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAob3RoZXIgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG90aGVyLmtpbmQgIT09ICdOJykgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRoaXMucHJlZGljYXRlKG90aGVyLnZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIE9uRXJyb3JQcmVkaWNhdGUocHJlZGljYXRlKSB7XG4gIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xufVxuXG5PbkVycm9yUHJlZGljYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmIChvdGhlciA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAob3RoZXIua2luZCAhPT0gJ0UnKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdGhpcy5wcmVkaWNhdGUob3RoZXIuZXJyb3IpO1xufTtcblxudmFyIFJlYWN0aXZlVGVzdCA9IFJ4LlJlYWN0aXZlVGVzdCA9IHtcbiAgLyoqIERlZmF1bHQgdmlydHVhbCB0aW1lIHVzZWQgZm9yIGNyZWF0aW9uIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHVuaXQgdGVzdHMuICovXG4gIGNyZWF0ZWQ6IDEwMCxcbiAgLyoqIERlZmF1bHQgdmlydHVhbCB0aW1lIHVzZWQgdG8gc3Vic2NyaWJlIHRvIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHVuaXQgdGVzdHMuICovXG4gIHN1YnNjcmliZWQ6IDIwMCxcbiAgLyoqIERlZmF1bHQgdmlydHVhbCB0aW1lIHVzZWQgdG8gZGlzcG9zZSBzdWJzY3JpcHRpb25zIGluIHVuaXQgdGVzdHMuICovXG4gIGRpc3Bvc2VkOiAxMDAwLFxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYW4gT25OZXh0IG5vdGlmaWNhdGlvbiByZWNvcmQgYXQgYSBnaXZlbiB0aW1lIHdpdGggYSBnaXZlbiB2YWx1ZSBvciBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogMSAtIFJlYWN0aXZlVGVzdC5vbk5leHQoMjAwLCA0Mik7XG4gICAqIDIgLSBSZWFjdGl2ZVRlc3Qub25OZXh0KDIwMCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID09IDI7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gdGlja3MgUmVjb3JkZWQgdmlydHVhbCB0aW1lIHRoZSBPbk5leHQgbm90aWZpY2F0aW9uIG9jY3Vycy5cbiAgICogQHBhcmFtIHZhbHVlIFJlY29yZGVkIHZhbHVlIHN0b3JlZCBpbiB0aGUgT25OZXh0IG5vdGlmaWNhdGlvbiBvciBhIHByZWRpY2F0ZS5cbiAgICogQHJldHVybiBSZWNvcmRlZCBPbk5leHQgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgb25OZXh0OiBmdW5jdGlvbiAodGlja3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIG5ldyBPbk5leHRQcmVkaWNhdGUodmFsdWUpKSA6XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQodmFsdWUpKTtcbiAgfSxcbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBhbiBPbkVycm9yIG5vdGlmaWNhdGlvbiByZWNvcmQgYXQgYSBnaXZlbiB0aW1lIHdpdGggYSBnaXZlbiBlcnJvci5cbiAgICpcbiAgICogMSAtIFJlYWN0aXZlVGVzdC5vbk5leHQoMjAwLCBuZXcgRXJyb3IoJ2Vycm9yJykpO1xuICAgKiAyIC0gUmVhY3RpdmVUZXN0Lm9uTmV4dCgyMDAsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLm1lc3NhZ2UgPT09ICdlcnJvcic7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gdGlja3MgUmVjb3JkZWQgdmlydHVhbCB0aW1lIHRoZSBPbkVycm9yIG5vdGlmaWNhdGlvbiBvY2N1cnMuXG4gICAqIEBwYXJhbSBleGNlcHRpb24gUmVjb3JkZWQgZXhjZXB0aW9uIHN0b3JlZCBpbiB0aGUgT25FcnJvciBub3RpZmljYXRpb24uXG4gICAqIEByZXR1cm4gUmVjb3JkZWQgT25FcnJvciBub3RpZmljYXRpb24uXG4gICAqL1xuICBvbkVycm9yOiBmdW5jdGlvbiAodGlja3MsIGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIG5ldyBPbkVycm9yUHJlZGljYXRlKGVycm9yKSkgOlxuICAgICAgbmV3IFJlY29yZGVkKHRpY2tzLCBOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvcihlcnJvcikpO1xuICB9LFxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgZm9yIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiByZWNvcmQgYXQgYSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gdGlja3MgUmVjb3JkZWQgdmlydHVhbCB0aW1lIHRoZSBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24gb2NjdXJzLlxuICAgKiBAcmV0dXJuIFJlY29yZGVkIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAodGlja3MpIHtcbiAgICByZXR1cm4gbmV3IFJlY29yZGVkKHRpY2tzLCBOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQoKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYSBzdWJzY3JpcHRpb24gcmVjb3JkIGJhc2VkIG9uIGEgZ2l2ZW4gc3Vic2NyaXB0aW9uIGFuZCBkaXNwb3NhbCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnQgVmlydHVhbCB0aW1lIGluZGljYXRpbmcgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gZW5kIFZpcnR1YWwgdGltZSBpbmRpY2F0aW5nIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB3YXMgZGlzcG9zZWQuXG4gICAqIEByZXR1cm4gU3Vic2NyaXB0aW9uIG9iamVjdC5cbiAgICovXG4gIHN1YnNjcmliZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihzdGFydCwgZW5kKTtcbiAgfVxufTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgcmVjb3JkaW5nIHRoZSBwcm9kdWN0aW9uIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHZpcnR1YWwgdGltZS5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFZpcnR1YWwgdGltZSB0aGUgdmFsdWUgd2FzIHByb2R1Y2VkIG9uLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBWYWx1ZSB0aGF0IHdhcyBwcm9kdWNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgQW4gb3B0aW9uYWwgY29tcGFyZXIuXG4gICAqL1xuICB2YXIgUmVjb3JkZWQgPSBSeC5SZWNvcmRlZCA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSwgY29tcGFyZXIpIHtcbiAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXIgfHwgZGVmYXVsdENvbXBhcmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcmVjb3JkZWQgb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlY29yZGVkfSBvdGhlciBSZWNvcmRlZCBvYmplY3QgdG8gY2hlY2sgZm9yIGVxdWFsaXR5LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBib3RoIG9iamVjdHMgYXJlIGVxdWFsOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBSZWNvcmRlZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZSA9PT0gb3RoZXIudGltZSAmJiB0aGlzLmNvbXBhcmVyKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBSZWNvcmRlZCB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFJlY29yZGVkIHZhbHVlLlxuICAgKi9cbiAgUmVjb3JkZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgKyAnQCcgKyB0aGlzLnRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3Vic2NyaXB0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2aXJ0dWFsIHN1YnNjcmlwdGlvbiBhbmQgdW5zdWJzY3JpcHRpb24gdGltZS5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdWJzY3JpYmUgVmlydHVhbCB0aW1lIGF0IHdoaWNoIHRoZSBzdWJzY3JpcHRpb24gb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB1bnN1YnNjcmliZSBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdGhlIHVuc3Vic2NyaXB0aW9uIG9jY3VycmVkLlxuICAgKi9cbiAgdmFyIFN1YnNjcmlwdGlvbiA9IFJ4LlN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSBzdGFydDtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZW5kIHx8IE51bWJlci5NQVhfVkFMVUU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdWJzY3JpcHRpb24gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvdGhlciBTdWJzY3JpcHRpb24gb2JqZWN0IHRvIGNoZWNrIGZvciBlcXVhbGl0eS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYm90aCBvYmplY3RzIGFyZSBlcXVhbDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUgPT09IG90aGVyLnN1YnNjcmliZSAmJiB0aGlzLnVuc3Vic2NyaWJlID09PSBvdGhlci51bnN1YnNjcmliZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdmFsdWUuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdmFsdWUuXG4gICAqL1xuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnKCcgKyB0aGlzLnN1YnNjcmliZSArICcsICcgKyAodGhpcy51bnN1YnNjcmliZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/ICdJbmZpbml0ZScgOiB0aGlzLnVuc3Vic2NyaWJlKSArICcpJztcbiAgfTtcblxuICB2YXIgTW9ja0Rpc3Bvc2FibGUgPSBSeC5Nb2NrRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLmRpc3Bvc2VzID0gW107XG4gICAgdGhpcy5kaXNwb3Nlcy5wdXNoKHRoaXMuc2NoZWR1bGVyLmNsb2NrKTtcbiAgfTtcblxuICBNb2NrRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc3Bvc2VzLnB1c2godGhpcy5zY2hlZHVsZXIuY2xvY2spO1xuICB9O1xuXG4gIHZhciBNb2NrT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1vY2tPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1vY2tPYnNlcnZlcihzY2hlZHVsZXIpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgfVxuXG4gICAgdmFyIE1vY2tPYnNlcnZlclByb3RvdHlwZSA9IE1vY2tPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgICBNb2NrT2JzZXJ2ZXJQcm90b3R5cGUub25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobmV3IFJlY29yZGVkKHRoaXMuc2NoZWR1bGVyLmNsb2NrLCBOb3RpZmljYXRpb24uY3JlYXRlT25OZXh0KHZhbHVlKSkpO1xuICAgIH07XG5cbiAgICBNb2NrT2JzZXJ2ZXJQcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobmV3IFJlY29yZGVkKHRoaXMuc2NoZWR1bGVyLmNsb2NrLCBOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvcihlKSkpO1xuICAgIH07XG5cbiAgICBNb2NrT2JzZXJ2ZXJQcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobmV3IFJlY29yZGVkKHRoaXMuc2NoZWR1bGVyLmNsb2NrLCBOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQoKSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9ja09ic2VydmVyO1xuICB9KShPYnNlcnZlcik7XG5cbiAgZnVuY3Rpb24gTW9ja1Byb21pc2Uoc2NoZWR1bGVyLCBtZXNzYWdlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldLFxuICAgICAgICAgIG5vdGlmaWNhdGlvbiA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAoZnVuY3Rpb24gKGlubmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZUFic29sdXRlKG51bGwsIG1lc3NhZ2UudGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBvYnMgPSBzZWxmLm9ic2VydmVycy5zbGljZSgwKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gb2JzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgaW5uZXJOb3RpZmljYXRpb24uYWNjZXB0KG9ic1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH0pO1xuICAgICAgfSkobm90aWZpY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBNb2NrUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2gobmV3IFN1YnNjcmlwdGlvbih0aGlzLnNjaGVkdWxlci5jbG9jaykpO1xuICAgIHZhciBpbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgdmFyIG5ld1Byb21pc2U7XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBSeC5PYnNlcnZlci5jcmVhdGUoXG4gICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmV0VmFsdWUgPSBvblJlc29sdmVkKHgpO1xuICAgICAgICBpZiAocmV0VmFsdWUgJiYgdHlwZW9mIHJldFZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBuZXdQcm9taXNlID0gcmV0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRpY2tzID0gc2VsZi5zY2hlZHVsZXIuY2xvY2s7XG4gICAgICAgICAgbmV3UHJvbWlzZSA9IG5ldyBNb2NrUHJvbWlzZShzZWxmLnNjaGVkdWxlciwgW1J4LlJlYWN0aXZlVGVzdC5vbk5leHQodGlja3MsIHVuZGVmaW5lZCksIFJ4LlJlYWN0aXZlVGVzdC5vbkNvbXBsZXRlZCh0aWNrcyldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gc2VsZi5vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgIHNlbGYub2JzZXJ2ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbihzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdLnN1YnNjcmliZSwgc2VsZi5zY2hlZHVsZXIuY2xvY2spO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgb25SZWplY3RlZChlcnIpO1xuICAgICAgICB2YXIgaWR4ID0gc2VsZi5vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgIHNlbGYub2JzZXJ2ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbihzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdLnN1YnNjcmliZSwgc2VsZi5zY2hlZHVsZXIuY2xvY2spO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG5cbiAgICByZXR1cm4gbmV3UHJvbWlzZSB8fCBuZXcgTW9ja1Byb21pc2UodGhpcy5zY2hlZHVsZXIsIHRoaXMubWVzc2FnZXMpO1xuICB9O1xuXG4gIHZhciBIb3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhIb3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gSG90T2JzZXJ2YWJsZShzY2hlZHVsZXIsIG1lc3NhZ2VzKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHZhciBtZXNzYWdlLCBub3RpZmljYXRpb24sIG9ic2VydmFibGUgPSB0aGlzO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgICAgbm90aWZpY2F0aW9uID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgKGZ1bmN0aW9uIChpbm5lck5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZUFic29sdXRlKG51bGwsIG1lc3NhZ2UudGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9icyA9IG9ic2VydmFibGUub2JzZXJ2ZXJzLnNsaWNlKDApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IG9icy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgaW5uZXJOb3RpZmljYXRpb24uYWNjZXB0KG9ic1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KShub3RpZmljYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIEhvdE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzO1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb24odGhpcy5zY2hlZHVsZXIuY2xvY2spKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnMuaW5kZXhPZihvKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5vYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBvYnNlcnZhYmxlLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhvdE9ic2VydmFibGU7XG4gIH0pKE9ic2VydmFibGUpO1xuXG4gIHZhciBDb2xkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29sZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBDb2xkT2JzZXJ2YWJsZShzY2hlZHVsZXIsIG1lc3NhZ2VzKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuXG4gICAgQ29sZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG1lc3NhZ2UsIG5vdGlmaWNhdGlvbiwgb2JzZXJ2YWJsZSA9IHRoaXM7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc2NoZWR1bGVyLmNsb2NrKSk7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgICBub3RpZmljYXRpb24gPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAoZnVuY3Rpb24gKGlubmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgZC5hZGQob2JzZXJ2YWJsZS5zY2hlZHVsZXIuc2NoZWR1bGVSZWxhdGl2ZShudWxsLCBtZXNzYWdlLnRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlubmVyTm90aWZpY2F0aW9uLmFjY2VwdChvKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KShub3RpZmljYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZhYmxlLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZhYmxlLnN1YnNjcmlwdGlvbnNbaW5kZXhdLnN1YnNjcmliZSwgb2JzZXJ2YWJsZS5zY2hlZHVsZXIuY2xvY2spO1xuICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29sZE9ic2VydmFibGU7XG4gIH0pKE9ic2VydmFibGUpO1xuXG4gIC8qKiBWaXJ0dWFsIHRpbWUgc2NoZWR1bGVyIHVzZWQgZm9yIHRlc3RpbmcgYXBwbGljYXRpb25zIGFuZCBsaWJyYXJpZXMgYnVpbHQgdXNpbmcgUmVhY3RpdmUgRXh0ZW5zaW9ucy4gKi9cbiAgUnguVGVzdFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGVzdFNjaGVkdWxlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIGJhc2VDb21wYXJlcih4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHkgPyAxIDogKHggPCB5ID8gLTEgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUZXN0U2NoZWR1bGVyKCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgMCwgYmFzZUNvbXBhcmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IHRoZSBzcGVjaWZpZWQgdmlydHVhbCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSBkdWVUaW1lIEFic29sdXRlIHZpcnR1YWwgdGltZSBhdCB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybiBEaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlQWJzb2x1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgZHVlVGltZSA8PSB0aGlzLmNsb2NrICYmIChkdWVUaW1lID0gdGhpcy5jbG9jayArIDEpO1xuICAgICAgcmV0dXJuIF9fc3VwZXJfXy5wcm90b3R5cGUuc2NoZWR1bGVBYnNvbHV0ZS5jYWxsKHRoaXMsIHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB0byBhbiBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSByZWxhdGl2ZSBSZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYWRkLlxuICAgICAqIEByZXR1cm4gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFic29sdXRlLCByZWxhdGl2ZSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlICsgcmVsYXRpdmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGEgRGF0ZVRpbWVPZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiBDb3JyZXNwb25kaW5nIERhdGVUaW1lT2Zmc2V0IHZhbHVlLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLnRvQWJzb2x1dGVUaW1lID0gZnVuY3Rpb24gKGFic29sdXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYWJzb2x1dGUpLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBUaW1lU3BhbiB2YWx1ZSB0byBhIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lU3BhbiBUaW1lU3BhbiB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm4gQ29ycmVzcG9uZGluZyByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUudG9SZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiAodGltZVNwYW4pIHtcbiAgICAgIHJldHVybiB0aW1lU3BhbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdGVzdCBzY2hlZHVsZXIgYW5kIHVzZXMgdGhlIHNwZWNpZmllZCB2aXJ0dWFsIHRpbWVzIHRvIGludm9rZSB0aGUgZmFjdG9yeSBmdW5jdGlvbiwgc3Vic2NyaWJlIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UsIGFuZCBkaXNwb3NlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3JlYXRlIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBjcmVhdGVkIFZpcnR1YWwgdGltZSBhdCB3aGljaCB0byBpbnZva2UgdGhlIGZhY3RvcnkgdG8gY3JlYXRlIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHN1YnNjcmliZWQgVmlydHVhbCB0aW1lIGF0IHdoaWNoIHRvIHN1YnNjcmliZSB0byB0aGUgY3JlYXRlZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBkaXNwb3NlZCBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdG8gZGlzcG9zZSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqIEByZXR1cm4gT2JzZXJ2ZXIgd2l0aCB0aW1lc3RhbXBlZCByZWNvcmRpbmdzIG9mIG5vdGlmaWNhdGlvbiBtZXNzYWdlcyB0aGF0IHdlcmUgcmVjZWl2ZWQgZHVyaW5nIHRoZSB2aXJ0dWFsIHRpbWUgd2luZG93IHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgc291cmNlIHNlcXVlbmNlIHdhcyBhY3RpdmUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuc3RhcnRTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY3JlYXRlRm4sIHNldHRpbmdzKSB7XG4gICAgICBzZXR0aW5ncyB8fCAoc2V0dGluZ3MgPSB7fSk7XG4gICAgICBzZXR0aW5ncy5jcmVhdGVkID09IG51bGwgJiYgKHNldHRpbmdzLmNyZWF0ZWQgPSBSZWFjdGl2ZVRlc3QuY3JlYXRlZCk7XG4gICAgICBzZXR0aW5ncy5zdWJzY3JpYmVkID09IG51bGwgJiYgKHNldHRpbmdzLnN1YnNjcmliZWQgPSBSZWFjdGl2ZVRlc3Quc3Vic2NyaWJlZCk7XG4gICAgICBzZXR0aW5ncy5kaXNwb3NlZCA9PSBudWxsICYmIChzZXR0aW5ncy5kaXNwb3NlZCA9IFJlYWN0aXZlVGVzdC5kaXNwb3NlZCk7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMuY3JlYXRlT2JzZXJ2ZXIoKSwgc291cmNlLCBzdWJzY3JpcHRpb247XG5cbiAgICAgIHRoaXMuc2NoZWR1bGVBYnNvbHV0ZShudWxsLCBzZXR0aW5ncy5jcmVhdGVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvdXJjZSA9IGNyZWF0ZUZuKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2hlZHVsZUFic29sdXRlKG51bGwsIHNldHRpbmdzLnN1YnNjcmliZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2hlZHVsZUFic29sdXRlKG51bGwsIHNldHRpbmdzLmRpc3Bvc2VkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zdGFydCgpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBob3Qgb2JzZXJ2YWJsZSB1c2luZyB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcGVkIG5vdGlmaWNhdGlvbiBtZXNzYWdlcyBlaXRoZXIgYXMgYW4gYXJyYXkgb3IgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBOb3RpZmljYXRpb25zIHRvIHN1cmZhY2UgdGhyb3VnaCB0aGUgY3JlYXRlZCBzZXF1ZW5jZSBhdCB0aGVpciBzcGVjaWZpZWQgYWJzb2x1dGUgdmlydHVhbCB0aW1lcy5cbiAgICAgKiBAcmV0dXJuIEhvdCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB0aW1pbmcgb2Ygc3Vic2NyaXB0aW9ucyBhbmQgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVIb3RPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3M7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBIb3RPYnNlcnZhYmxlKHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29sZCBvYnNlcnZhYmxlIHVzaW5nIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wZWQgbm90aWZpY2F0aW9uIG1lc3NhZ2VzIGVpdGhlciBhcyBhbiBhcnJheSBvciBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIE5vdGlmaWNhdGlvbnMgdG8gc3VyZmFjZSB0aHJvdWdoIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGF0IHRoZWlyIHNwZWNpZmllZCB2aXJ0dWFsIHRpbWUgb2Zmc2V0cyBmcm9tIHRoZSBzZXF1ZW5jZSBzdWJzY3JpcHRpb24gdGltZS5cbiAgICAgKiBAcmV0dXJuIENvbGQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdGltaW5nIG9mIHN1YnNjcmlwdGlvbnMgYW5kIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlQ29sZE9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbGRPYnNlcnZhYmxlKHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVzb2x2ZWQgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBhbmQgdGlja3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGlja3MgVGhlIGFic29sdXRlIHRpbWUgb2YgdGhlIHJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byB5aWVsZCBhdCB0aGUgZ2l2ZW4gdGljay5cbiAgICAgKiBAcmV0dXJucyB7TW9ja1Byb21pc2V9IEEgbW9jayBQcm9taXNlIHdoaWNoIGZ1bGZpbGxzIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZVJlc29sdmVkUHJvbWlzZSA9IGZ1bmN0aW9uICh0aWNrcywgdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ja1Byb21pc2UodGhpcywgW1J4LlJlYWN0aXZlVGVzdC5vbk5leHQodGlja3MsIHZhbHVlKSwgUnguUmVhY3RpdmVUZXN0Lm9uQ29tcGxldGVkKHRpY2tzKV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiByZWFzb24gYW5kIHRpY2tzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpY2tzIFRoZSBhYnNvbHV0ZSB0aW1lIG9mIHRoZSByZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSByZWFzb24gVGhlIHJlYXNvbiBmb3IgcmVqZWN0aW9uIHRvIHlpZWxkIGF0IHRoZSBnaXZlbiB0aWNrLlxuICAgICAqIEByZXR1cm5zIHtNb2NrUHJvbWlzZX0gQSBtb2NrIFByb21pc2Ugd2hpY2ggcmVqZWN0cyB3aXRoIHRoZSBnaXZlbiByZWFzb24uXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlUmVqZWN0ZWRQcm9taXNlID0gZnVuY3Rpb24gKHRpY2tzLCByZWFzb24pIHtcbiAgICAgIHJldHVybiBuZXcgTW9ja1Byb21pc2UodGhpcywgW1J4LlJlYWN0aXZlVGVzdC5vbkVycm9yKHRpY2tzLCByZWFzb24pXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgdGhhdCByZWNvcmRzIHJlY2VpdmVkIG5vdGlmaWNhdGlvbiBtZXNzYWdlcyBhbmQgdGltZXN0YW1wcyB0aG9zZS5cbiAgICAgKiBAcmV0dXJuIE9ic2VydmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB0aW1pbmcgb2YgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ja09ic2VydmVyKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGVzdFNjaGVkdWxlcjtcbiAgfSkoVmlydHVhbFRpbWVTY2hlZHVsZXIpO1xuXG4gIHZhciBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQW5vbnltb3VzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIC8vIEZpeCBzdWJzY3JpYmVyIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb3IgZnVuY3Rpb24gcmV0dXJuZWQgdG8gZGVjb3JhdGUgYXMgRGlzcG9zYWJsZVxuICAgIGZ1bmN0aW9uIGZpeFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIgJiYgaXNGdW5jdGlvbihzdWJzY3JpYmVyLmRpc3Bvc2UpID8gc3Vic2NyaWJlciA6XG4gICAgICAgIGlzRnVuY3Rpb24oc3Vic2NyaWJlcikgPyBkaXNwb3NhYmxlQ3JlYXRlKHN1YnNjcmliZXIpIDogZGlzcG9zYWJsZUVtcHR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERpc3Bvc2FibGUocywgc3RhdGUpIHtcbiAgICAgIHZhciBhZG8gPSBzdGF0ZVswXSwgc2VsZiA9IHN0YXRlWzFdO1xuICAgICAgdmFyIHN1YiA9IHRyeUNhdGNoKHNlbGYuX19zdWJzY3JpYmUpLmNhbGwoc2VsZiwgYWRvKTtcbiAgICAgIGlmIChzdWIgPT09IGVycm9yT2JqICYmICFhZG8uZmFpbChlcnJvck9iai5lKSkgeyB0aHJvd2VyKGVycm9yT2JqLmUpOyB9XG4gICAgICBhZG8uc2V0RGlzcG9zYWJsZShmaXhTdWJzY3JpYmVyKHN1YikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFub255bW91c09ic2VydmFibGUoc3Vic2NyaWJlLCBwYXJlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gcGFyZW50O1xuICAgICAgdGhpcy5fX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEFub255bW91c09ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFkbyA9IG5ldyBBdXRvRGV0YWNoT2JzZXJ2ZXIobyksIHN0YXRlID0gW2FkbywgdGhpc107XG5cbiAgICAgIGlmIChjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVxdWlyZWQoKSkge1xuICAgICAgICBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzZXREaXNwb3NhYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldERpc3Bvc2FibGUobnVsbCwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFub255bW91c09ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIEF1dG9EZXRhY2hPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQXV0b0RldGFjaE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQXV0b0RldGFjaE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMubSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgIH1cblxuICAgIHZhciBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUgPSBBdXRvRGV0YWNoT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uTmV4dCkuY2FsbCh0aGlzLm9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhyb3dlcihyZXN1bHQuZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uRXJyb3IpLmNhbGwodGhpcy5vYnNlcnZlciwgZXJyKTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgcmVzdWx0ID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlc3VsdC5lKTtcbiAgICB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKS5jYWxsKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICByZXN1bHQgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzdWx0LmUpO1xuICAgIH07XG5cbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLm0uc2V0RGlzcG9zYWJsZSh2YWx1ZSk7IH07XG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm0uZ2V0RGlzcG9zYWJsZSgpOyB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBdXRvRGV0YWNoT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBVbmRlcmx5aW5nT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVW5kZXJseWluZ09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVW5kZXJseWluZ09ic2VydmFibGUobSwgdSkge1xuICAgICAgdGhpcy5fbSA9IG07XG4gICAgICB0aGlzLl91ID0gdTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFVuZGVybHlpbmdPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZSh0aGlzLl9tLmdldERpc3Bvc2FibGUoKSwgdGhpcy5fdS5zdWJzY3JpYmUobykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVW5kZXJseWluZ09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgR3JvdXBlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEdyb3VwZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgdW5kZXJseWluZ09ic2VydmFibGUsIG1lcmdlZERpc3Bvc2FibGUpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnVuZGVybHlpbmdPYnNlcnZhYmxlID0gIW1lcmdlZERpc3Bvc2FibGUgP1xuICAgICAgICB1bmRlcmx5aW5nT2JzZXJ2YWJsZSA6XG4gICAgICAgIG5ldyBVbmRlcmx5aW5nT2JzZXJ2YWJsZShtZXJnZWREaXNwb3NhYmxlLCB1bmRlcmx5aW5nT2JzZXJ2YWJsZSk7XG4gICAgfVxuXG4gICAgR3JvdXBlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMudW5kZXJseWluZ09ic2VydmFibGUuc3Vic2NyaWJlKG8pO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JvdXBlZE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiAgUmVwcmVzZW50cyBhbiBvYmplY3QgdGhhdCBpcyBib3RoIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgd2VsbCBhcyBhbiBvYnNlcnZlci5cbiAgICogIEVhY2ggbm90aWZpY2F0aW9uIGlzIGJyb2FkY2FzdGVkIHRvIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycy5cbiAgICovXG4gIHZhciBTdWJqZWN0ID0gUnguU3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoU3ViamVjdC5wcm90b3R5cGUsIE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gobyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbm5lclN1YnNjcmlwdGlvbih0aGlzLCBvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIG8ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKi9cbiAgICAgIGhhc09ic2VydmVyczogZnVuY3Rpb24gKCkgeyBjaGVja0Rpc3Bvc2VkKHRoaXMpOyByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDsgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuICAgICAgICovXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb3NbaV0ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IGVycm9yIFRoZSBleGNlcHRpb24gdG8gc2VuZCB0byBhbGwgb2JzZXJ2ZXJzLlxuICAgICAgICovXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9zW2ldLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3ViamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgb2JzZXJ2ZXIgYW5kIG9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcn0gb2JzZXJ2ZXIgVGhlIG9ic2VydmVyIHVzZWQgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0ge09ic2VydmFibGV9IG9ic2VydmFibGUgVGhlIG9ic2VydmFibGUgdXNlZCB0byBzdWJzY3JpYmUgdG8gbWVzc2FnZXMgc2VudCBmcm9tIHRoZSBzdWJqZWN0LlxuICAgICAqIEByZXR1cm5zIHtTdWJqZWN0fSBTdWJqZWN0IGltcGxlbWVudGVkIHVzaW5nIHRoZSBnaXZlbiBvYnNlcnZlciBhbmQgb2JzZXJ2YWJsZS5cbiAgICAgKi9cbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvYnNlcnZlciwgb2JzZXJ2YWJsZSkge1xuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KG9ic2VydmVyLCBvYnNlcnZhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiAgUmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG4gICAqICBUaGUgbGFzdCB2YWx1ZSBiZWZvcmUgdGhlIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiwgb3IgdGhlIGVycm9yIHJlY2VpdmVkIHRocm91Z2ggT25FcnJvciwgaXMgc2VudCB0byBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMuXG4gICAqL1xuICB2YXIgQXN5bmNTdWJqZWN0ID0gUnguQXN5bmNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBc3luY1N1YmplY3QsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3ViamVjdCB0aGF0IGNhbiBvbmx5IHJlY2VpdmUgb25lIHZhbHVlIGFuZCB0aGF0IHZhbHVlIGlzIGNhY2hlZCBmb3IgYWxsIGZ1dHVyZSBvYnNlcnZhdGlvbnMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNTdWJqZWN0KCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoQXN5bmNTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobykge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTdWJzY3JpcHRpb24odGhpcywgbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIG8ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgby5vbk5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgYWxzbyBjYXVzaW5nIHRoZSBsYXN0IHJlY2VpdmVkIHZhbHVlIHRvIGJlIHNlbnQgb3V0IChpZiBhbnkpLlxuICAgICAgICovXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgbGVuO1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gb3NbaV07XG4gICAgICAgICAgICAgIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXJyb3IuXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBUaGUgRXJyb3IgdG8gc2VuZCB0byBhbGwgb2JzZXJ2ZXJzLlxuICAgICAgICovXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9zW2ldLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFNlbmRzIGEgdmFsdWUgdG8gdGhlIHN1YmplY3QuIFRoZSBsYXN0IHZhbHVlIHJlY2VpdmVkIGJlZm9yZSBzdWNjZXNzZnVsIHRlcm1pbmF0aW9uIHdpbGwgYmUgc2VudCB0byBhbGwgc3Vic2NyaWJlZCBhbmQgZnV0dXJlIG9ic2VydmVycy5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGUgc3ViamVjdC5cbiAgICAgICAqL1xuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICAgKi9cbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQXN5bmNTdWJqZWN0O1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogIFJlcHJlc2VudHMgYSB2YWx1ZSB0aGF0IGNoYW5nZXMgb3ZlciB0aW1lLlxuICAgKiAgT2JzZXJ2ZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlIHN1YmplY3QgdG8gcmVjZWl2ZSB0aGUgbGFzdCAob3IgaW5pdGlhbCkgdmFsdWUgYW5kIGFsbCBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICB2YXIgQmVoYXZpb3JTdWJqZWN0ID0gUnguQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhCZWhhdmlvclN1YmplY3QsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQmVoYXZpb3JTdWJqZWN0KHZhbHVlKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgICAgIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTdWJzY3JpcHRpb24odGhpcywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICBvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgKiBWYWx1ZSBpcyBmcm96ZW4gYWZ0ZXIgb25Db21wbGV0ZWQgaXMgY2FsbGVkLlxuICAgICAgICogQWZ0ZXIgb25FcnJvciBpcyBjYWxsZWQgYWx3YXlzIHRocm93cyB0aGUgc3BlY2lmaWVkIGV4Y2VwdGlvbi5cbiAgICAgICAqIEFuIGV4Y2VwdGlvbiBpcyBhbHdheXMgdGhyb3duIGFmdGVyIGRpc3Bvc2UgaXMgY2FsbGVkLlxuICAgICAgICogQHJldHVybnMge01peGVkfSBUaGUgaW5pdGlhbCB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHVudGlsIG9uTmV4dCBpcyBjYWxsZWQ7IGFmdGVyIHdoaWNoLCB0aGUgbGFzdCB2YWx1ZSBwYXNzZWQgdG8gb25OZXh0LlxuICAgICAgICovXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikgeyB0aHJvd2VyKHRoaXMuZXJyb3IpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqL1xuICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7IGNoZWNrRGlzcG9zZWQodGhpcyk7IHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGggPiAwOyB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbk5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGlzIGJvdGggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyB3ZWxsIGFzIGFuIG9ic2VydmVyLlxuICAgKiBFYWNoIG5vdGlmaWNhdGlvbiBpcyBicm9hZGNhc3RlZCB0byBhbGwgc3Vic2NyaWJlZCBhbmQgZnV0dXJlIG9ic2VydmVycywgc3ViamVjdCB0byBidWZmZXIgdHJpbW1pbmcgcG9saWNpZXMuXG4gICAqL1xuICB2YXIgUmVwbGF5U3ViamVjdCA9IFJ4LlJlcGxheVN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuXG4gICAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUoc3ViamVjdCwgb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzcG9zZSgpO1xuICAgICAgICAhc3ViamVjdC5pc0Rpc3Bvc2VkICYmIHN1YmplY3Qub2JzZXJ2ZXJzLnNwbGljZShzdWJqZWN0Lm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhSZXBsYXlTdWJqZWN0LCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSZXBsYXlTdWJqZWN0IGNsYXNzIHdpdGggdGhlIHNwZWNpZmllZCBidWZmZXIgc2l6ZSwgd2luZG93IHNpemUgYW5kIHNjaGVkdWxlci5cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtidWZmZXJTaXplXSBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAgICogIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZV0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0aGUgb2JzZXJ2ZXJzIGFyZSBpbnZva2VkIG9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplID09IG51bGwgPyBtYXhTYWZlSW50ZWdlciA6IGJ1ZmZlclNpemU7XG4gICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplID09IG51bGwgPyBtYXhTYWZlSW50ZWdlciA6IHdpbmRvd1NpemU7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlciB8fCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyO1xuICAgICAgdGhpcy5xID0gW107XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKFJlcGxheVN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIHZhciBzbyA9IG5ldyBTY2hlZHVsZWRPYnNlcnZlcih0aGlzLnNjaGVkdWxlciwgbyksIHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUodGhpcywgc28pO1xuXG4gICAgICAgIHRoaXMuX3RyaW0odGhpcy5zY2hlZHVsZXIubm93KCkpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHNvKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5xLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc28ub25OZXh0KHRoaXMucVtpXS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIHNvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICBzby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc28uZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICBfdHJpbTogZnVuY3Rpb24gKG5vdykge1xuICAgICAgICB3aGlsZSAodGhpcy5xLmxlbmd0aCA+IHRoaXMuYnVmZmVyU2l6ZSkge1xuICAgICAgICAgIHRoaXMucS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnEubGVuZ3RoID4gMCAmJiAobm93IC0gdGhpcy5xWzBdLmludGVydmFsKSA+IHRoaXMud2luZG93U2l6ZSkge1xuICAgICAgICAgIHRoaXMucS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLnEucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5fdHJpbShub3cpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG9zW2ldO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgb2JzZXJ2ZXIuZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLl90cmltKG5vdyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG9zW2ldO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIG9ic2VydmVyLmVuc3VyZUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gb3NbaV07XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBvYnNlcnZlci5lbnN1cmVBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICAgKi9cbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlcGxheVN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIHZhciBBbm9ueW1vdXNTdWJqZWN0ID0gUnguQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQW5vbnltb3VzU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KG9ic2VydmVyLCBvYnNlcnZhYmxlKSB7XG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlLnN1YnNjcmliZShvKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XG4gICAgICB9LFxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAqIFVzZWQgdG8gcGF1c2UgYW5kIHJlc3VtZSBzdHJlYW1zLlxuICAqL1xuICBSeC5QYXVzZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAgICovXG4gICAgUGF1c2VyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5vbk5leHQoZmFsc2UpOyB9O1xuXG4gICAgLyoqXG4gICAgKiBSZXN1bWVzIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxuICAgICovXG4gICAgUGF1c2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMub25OZXh0KHRydWUpOyB9O1xuXG4gICAgcmV0dXJuIFBhdXNlcjtcbiAgfShTdWJqZWN0KSk7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgcm9vdC5SeCA9IFJ4O1xuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFJ4O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IFJ4KS5SeCA9IFJ4O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5SeCA9IFJ4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290LlJ4ID0gUng7XG4gIH1cblxuICAvLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxuICB2YXIgckVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG59LmNhbGwodGhpcykpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiAtMTtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHApO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDEpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXG4vLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1widXNlXCIsIFwib25cIiwgXCJvbmNlXCIsIFwic2V0XCIsIFwicXVlcnlcIiwgXCJ0eXBlXCIsIFwiYWNjZXB0XCIsIFwiYXV0aFwiLCBcIndpdGhDcmVkZW50aWFsc1wiLCBcInNvcnRRdWVyeVwiLCBcInJldHJ5XCIsIFwib2tcIiwgXCJyZWRpcmVjdHNcIixcbiBcInRpbWVvdXRcIiwgXCJidWZmZXJcIiwgXCJzZXJpYWxpemVcIiwgXCJwYXJzZVwiLCBcImNhXCIsIFwia2V5XCIsIFwicGZ4XCIsIFwiY2VydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC8qdmFyYXJncyovKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMucHVzaCh7Zm46Zm4sIGFyZ3VtZW50czphcmd1bWVudHN9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbkFnZW50LnByb3RvdHlwZS5fc2V0RGVmYXVsdHMgPSBmdW5jdGlvbihyZXEpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBkZWYuYXJndW1lbnRzKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnQ7XG4iLCIvKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHsgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIGNvbnNvbGUud2FybihcIlVzaW5nIGJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gIHJvb3QgPSB0aGlzO1xufVxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcbnZhciBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcbnZhciBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG52YXIgcmVxdWVzdCA9IGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciB0cmltID0gJycudHJpbVxuICA/IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9XG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSArICdbJyArIHN1YmtleSArICddJywgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFpcjtcbiAgdmFyIHBvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAndGV4dC94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnksXG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZSxcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIHZhciBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGlmIChzZWxmLnhocikge1xuICAgICAgICAvLyBpZTkgZG9lc24ndCBoYXZlICdyZXNwb25zZScgcHJvcGVydHlcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gdHlwZW9mIHNlbGYueGhyLnJlc3BvbnNlVHlwZSA9PSAndW5kZWZpbmVkJyA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IHNlbGYueGhyLnJlc3BvbnNlO1xuICAgICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgZXJyLnN0YXR1cyA9IHNlbGYueGhyLnN0YXR1cyA/IHNlbGYueGhyLnN0YXR1cyA6IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXNDb2RlID0gZXJyLnN0YXR1czsgLy8gYmFja3dhcmRzLWNvbXBhdCBvbmx5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIHZhciBuZXdfZXJyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXNlbGYuX2lzUmVzcG9uc2VPSyhyZXMpKSB7XG4gICAgICAgIG5ld19lcnIgPSBuZXcgRXJyb3IocmVzLnN0YXR1c1RleHQgfHwgJ1Vuc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChjdXN0b21fZXJyKSB7XG4gICAgICBuZXdfZXJyID0gY3VzdG9tX2VycjsgLy8gb2soKSBjYWxsYmFjayBjYW4gdGhyb3dcbiAgICB9XG5cbiAgICAvLyAjMTAwMCBkb24ndCBjYXRjaCBlcnJvcnMgZnJvbSB0aGUgY2FsbGJhY2sgdG8gYXZvaWQgZG91YmxlIGNhbGxpbmcgaXRcbiAgICBpZiAobmV3X2Vycikge1xuICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblJlcXVlc3RCYXNlKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3NdIG9wdGlvbmFsIGluIGNhc2Ugb2YgdXNpbmcgJ2JlYXJlcicgYXMgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nLCAnYmFzaWMnIG9yICdiZWFyZXInIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMpe1xuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcGFzcyA9ICcnO1xuICBpZiAodHlwZW9mIHBhc3MgPT09ICdvYmplY3QnICYmIHBhc3MgIT09IG51bGwpIHsgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGJ0b2EgPyAnYmFzaWMnIDogJ2F1dG8nLFxuICAgIH07XG4gIH1cblxuICB2YXIgZW5jb2RlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgdmFyIGZuID0gdGhpcy5fY2FsbGJhY2s7XG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgaWYgKGVycikge1xuICAgIGlmICh0aGlzLl9tYXhSZXRyaWVzKSBlcnIucmV0cmllcyA9IHRoaXMuX3JldHJpZXMgLSAxO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgZm4oZXJyLCByZXMpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24oKXtcbiAgY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbigpe1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyICYmIHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICBpZiAoNCAhPSByZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICB2YXIgaGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gc2VlICMxMTQ5XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmICdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5oZWFkZXJbZmllbGRdKSBjb250aW51ZTtcblxuICAgIGlmICh0aGlzLmhlYWRlci5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVR5cGUpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcblxuICAvLyBJRTExIHhoci5zZW5kKHVuZGVmaW5lZCkgc2VuZHMgJ3VuZGVmaW5lZCcgc3RyaW5nIGFzIFBPU1QgcGF5bG9hZCAoaW5zdGVhZCBvZiBub3RoaW5nKVxuICAvLyBXZSBuZWVkIG51bGwgaGVyZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIDogbnVsbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucmVxdWVzdC5hZ2VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEFnZW50KCk7XG59O1xuXG5bXCJHRVRcIiwgXCJQT1NUXCIsIFwiT1BUSU9OU1wiLCBcIlBBVENIXCIsIFwiUFVUXCIsIFwiREVMRVRFXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgdmFyIHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIHRoaXMuX3NldERlZmF1bHRzKHJlcSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICByZXEuZW5kKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn0pO1xuXG5BZ2VudC5wcm90b3R5cGUuZGVsID0gQWdlbnQucHJvdG90eXBlWydkZWxldGUnXTtcblxuLyoqXG4gKiBHRVQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE9QVElPTlMgcXVlcnkgdG8gYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdPUFRJT05TJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVsKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufVxuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVxdWVzdEJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBkZWxldGUgdGhpcy5fdGltZXI7XG4gIGRlbGV0ZSB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgYm9keSBwYXJzZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgaW5jb21pbmcgZGF0YSBpbnRvIHJlcXVlc3QuYm9keVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZm9ybWF0IG9mIGJpbmFyeSByZXNwb25zZSBib2R5LlxuICogSW4gYnJvd3NlciB2YWxpZCBmb3JtYXRzIGFyZSAnYmxvYicgYW5kICdhcnJheWJ1ZmZlcicsXG4gKiB3aGljaCByZXR1cm4gQmxvYiBhbmQgQXJyYXlCdWZmZXIsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJbiBOb2RlIGFsbCB2YWx1ZXMgcmVzdWx0IGluIEJ1ZmZlci5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24odmFsKXtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICB0aGlzLl9zZXJpYWxpemVyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGltZW91dHMuXG4gKlxuICogLSByZXNwb25zZSB0aW1lb3V0IGlzIHRpbWUgYmV0d2VlbiBzZW5kaW5nIHJlcXVlc3QgYW5kIHJlY2VpdmluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgcmVzcG9uc2UuIEluY2x1ZGVzIEROUyBhbmQgY29ubmVjdGlvbiB0aW1lLlxuICogLSBkZWFkbGluZSBpcyB0aGUgdGltZSBmcm9tIHN0YXJ0IG9mIHRoZSByZXF1ZXN0IHRvIHJlY2VpdmluZyByZXNwb25zZSBib2R5IGluIGZ1bGwuIElmIHRoZSBkZWFkbGluZSBpcyB0b28gc2hvcnQgbGFyZ2UgZmlsZXMgbWF5IG5vdCBsb2FkIGF0IGFsbCBvbiBzbG93IGNvbm5lY3Rpb25zLlxuICpcbiAqIFZhbHVlIG9mIDAgb3IgZmFsc2UgbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG1zIG9yIHtyZXNwb25zZSwgZGVhZGxpbmV9XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG9wdGlvbnMpe1xuICBpZiAoIW9wdGlvbnMgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvcih2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2gob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHRpbWVvdXQgb3B0aW9uXCIsIG9wdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIG9uIGVycm9yLlxuICpcbiAqIEZhaWxlZCByZXF1ZXN0cyB3aWxsIGJlIHJldHJpZWQgJ2NvdW50JyB0aW1lcyBpZiB0aW1lb3V0IG9yIGVyci5jb2RlID49IDUwMC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbiByZXRyeShjb3VudCwgZm4pe1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgdGhpcy5fcmV0cnlDYWxsYmFjayA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLl9yZXRyeUNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNTAwICYmIHJlcy5zdGF0dXMgIT0gNTAxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVycikge1xuICAgIGlmIChlcnIuY29kZSAmJiB+RVJST1JfQ09ERVMuaW5kZXhPZihlcnIuY29kZSkpIHJldHVybiB0cnVlO1xuICAgIC8vIFN1cGVyYWdlbnQgdGltZW91dFxuICAgIGlmIChlcnIudGltZW91dCAmJiBlcnIuY29kZSA9PSAnRUNPTk5BQk9SVEVEJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGVyci5jcm9zc0RvbWFpbikgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyeSByZXF1ZXN0XG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3JldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAvLyBub2RlXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGlubmVyUmVzb2x2ZSwgaW5uZXJSZWplY3QpIHtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIGlubmVyUmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYikgdGhyb3cgRXJyb3IoXCJDYWxsYmFjayByZXF1aXJlZFwiKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24ocmVzKSB7XG4gIGlmICghcmVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX29rQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fb2tDYWxsYmFjayhyZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDA7XG59O1xuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIGBmaWVsZGAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgZGVwcmVjYXRlZCBpbnRlcm5hbCBBUEkuIFVzZSBgLmdldChmaWVsZClgIGluc3RlYWQuXG4gKlxuICogKGdldEhlYWRlciBpcyBubyBsb25nZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzdXBlcmFnZW50IGNvZGUgYmFzZSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWwpe1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV0gPSB2YWw7XG4gIHRoaXMuaGVhZGVyW2ZpZWxkXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgdW5kZWZpbmVkID09PSBuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgIHRoaXMuZmllbGQoa2V5LCBuYW1lW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcbiAgaWYgKG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsKSB7XG4gICAgdmFsID0gJycgKyB2YWw7XG4gIH1cbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCk7IC8vIGJyb3dzZXJcbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBiYXNlNjRFbmNvZGVyKHVzZXIgKyAnOicgKyBwYXNzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmVhcmVyJzogLy8gdXNhZ2Ugd291bGQgYmUgLmF1dGgoYWNjZXNzVG9rZW4sIHsgdHlwZTogJ2JlYXJlcicgfSlcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgdXNlcik7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKG9uKSB7XG4gIC8vIFRoaXMgaXMgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uYWxpdHkuIE5vZGUgc2lkZSBpcyBuby1vcC5cbiAgaWYgKG9uID09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aW5nIGluIGJyb3dzZXIgWEhSIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLm1heFJlc3BvbnNlU2l6ZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBuKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgfVxuICB0aGlzLl9tYXhSZXNwb25zZVNpemUgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyLFxuICB9O1xufTtcblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgaXNPYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICh0aGlzLl9mb3JtRGF0YSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBtZXJnZSB0aGVzZSBzZW5kIGNhbGxzXCIpO1xuICB9XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKGlzT2JqICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAvLyBkZWZhdWx0IHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gdGhpcy5fZGF0YSArICcmJyArIGRhdGFcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTb3J0IGBxdWVyeXN0cmluZ2AgYnkgdGhlIHNvcnQgZnVuY3Rpb25cbiAqXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gZGVmYXVsdCBvcmRlclxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZWQgc29ydCBmdW5jdGlvblxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoZnVuY3Rpb24oYSwgYil7XG4gKiAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc29ydFF1ZXJ5ID0gZnVuY3Rpb24oc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDsgLy8gTWFrZXMgdGhlIGNhbGwgaWRlbXBvdGVudFxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9zb3J0KSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFyci5zb3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnN1YnN0cmluZygwLCBpbmRleCkgKyAnPycgKyBxdWVyeUFyci5qb2luKCcmJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdCBvbmx5XG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKSB7Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkXCIpO31cblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCB0aW1lb3V0LCBlcnJubyl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IocmVhc29uICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignVGltZW91dCBvZiAnLCBzZWxmLl90aW1lb3V0LCAnRVRJTUUnKTtcbiAgICB9LCB0aGlzLl90aW1lb3V0KTtcbiAgfVxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJywgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlQmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlQmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVzcG9uc2VCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVzcG9uc2VCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gICAgLy8gVE9ETzogbW9hciFcbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG5cbiAgICAvLyBjb250ZW50LXR5cGVcbiAgICB2YXIgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG5cbiAgICB0aGlzLmxpbmtzID0ge307XG5cbiAgICAvLyBsaW5rc1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gICAgdmFyIHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gICAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gICAgLy8gYmFzaWNzXG4gICAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICAgIHRoaXMub2sgPSAyID09IHR5cGU7XG4gICAgdGhpcy5yZWRpcmVjdCA9IDMgPT0gdHlwZTtcbiAgICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICAgIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gICAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgICAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvLyBzdWdhclxuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgICB2YXIgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICAgIHZhciByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqW3JlbF0gPSB1cmw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIGNoYW5nZXNPcmlnaW4pe1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlclsnaG9zdCddO1xuICAvLyBzZWN1aXJ0eVxuICBpZiAoY2hhbmdlc09yaWdpbikge1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgaGVhZGVyWydjb29raWUnXTtcbiAgfVxuICByZXR1cm4gaGVhZGVyO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8qIVxuICogd2F2ZXN1cmZlci5qcyAyLjEuMCAoTW9uIE9jdCAwMSAyMDE4IDExOjM0OjU0IEdNVCswMjAwIChDZW50cmFsIEV1cm9wZWFuIFN1bW1lciBUaW1lKSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rYXRzcGF1Z2gvd2F2ZXN1cmZlci5qc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlXG4gKi9cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwidGltZWxpbmVcIixbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnRpbWVsaW5lPXQoKTooZS5XYXZlU3VyZmVyPWUuV2F2ZVN1cmZlcnx8e30sZS5XYXZlU3VyZmVyLnRpbWVsaW5lPXQoKSl9KHdpbmRvdyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhKXt2YXIgcj17fTtmdW5jdGlvbiBuKGUpe2lmKHJbZV0pcmV0dXJuIHJbZV0uZXhwb3J0czt2YXIgdD1yW2VdPXtpOmUsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gYVtlXS5jYWxsKHQuZXhwb3J0cyx0LHQuZXhwb3J0cyxuKSx0Lmw9ITAsdC5leHBvcnRzfXJldHVybiBuLm09YSxuLmM9cixuLmQ9ZnVuY3Rpb24oZSx0LGEpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDphfSl9LG4ucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PW4odCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGE9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIoYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciByIGluIHQpbi5kKGEscixmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLHIpKTtyZXR1cm4gYX0sbi5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBuLmQodCxcImFcIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD1cImxvY2FsaG9zdDo4MDgwL2Rpc3QvcGx1Z2luL1wiLG4obi5zPTApfShbZnVuY3Rpb24oZSx0LGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtmb3IodmFyIGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIHI9dFthXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIG4oZSx0LGEpe3JldHVybiB0JiZyKGUucHJvdG90eXBlLHQpLGEmJnIoZSxhKSxlfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsdCl7dmFyIGE9dGhpcztpZihmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsciksby5jYWxsKHRoaXMpLHRoaXMuY29udGFpbmVyPVwic3RyaW5nXCI9PXR5cGVvZiBlLmNvbnRhaW5lcj9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUuY29udGFpbmVyKTplLmNvbnRhaW5lciwhdGhpcy5jb250YWluZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udGFpbmVyIGZvciB3YXZlc3VyZmVyIHRpbWVsaW5lXCIpO3RoaXMud2F2ZXN1cmZlcj10LHRoaXMudXRpbD10LnV0aWwsdGhpcy5wYXJhbXM9dGhpcy51dGlsLmV4dGVuZCh7fSx7aGVpZ2h0OjIwLG5vdGNoUGVyY2VudEhlaWdodDo5MCxsYWJlbFBhZGRpbmc6NSx1bmxhYmVsZWROb3RjaENvbG9yOlwiI2MwYzBjMFwiLHByaW1hcnlDb2xvcjpcIiMwMDBcIixzZWNvbmRhcnlDb2xvcjpcIiNjMGMwYzBcIixwcmltYXJ5Rm9udENvbG9yOlwiIzAwMFwiLHNlY29uZGFyeUZvbnRDb2xvcjpcIiMwMDBcIixmb250RmFtaWx5OlwiQXJpYWxcIixmb250U2l6ZToxMCx6b29tRGVib3VuY2U6ITEsZm9ybWF0VGltZUNhbGxiYWNrOnRoaXMuZGVmYXVsdEZvcm1hdFRpbWVDYWxsYmFjayx0aW1lSW50ZXJ2YWw6dGhpcy5kZWZhdWx0VGltZUludGVydmFsLHByaW1hcnlMYWJlbEludGVydmFsOnRoaXMuZGVmYXVsdFByaW1hcnlMYWJlbEludGVydmFsLHNlY29uZGFyeUxhYmVsSW50ZXJ2YWw6dGhpcy5kZWZhdWx0U2Vjb25kYXJ5TGFiZWxJbnRlcnZhbH0sZSksdGhpcy5jYW52YXNlcz1bXSx0aGlzLndyYXBwZXI9bnVsbCx0aGlzLmRyYXdlcj1udWxsLHRoaXMucGl4ZWxSYXRpbz1udWxsLHRoaXMubWF4Q2FudmFzV2lkdGg9bnVsbCx0aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aD1udWxsLHRoaXMuX29uWm9vbT10aGlzLnBhcmFtcy56b29tRGVib3VuY2U/dGhpcy53YXZlc3VyZmVyLnV0aWwuZGVib3VuY2UoZnVuY3Rpb24oKXtyZXR1cm4gYS5yZW5kZXIoKX0sdGhpcy5wYXJhbXMuem9vbURlYm91bmNlKTpmdW5jdGlvbigpe3JldHVybiBhLnJlbmRlcigpfX1yZXR1cm4gbihyLG51bGwsW3trZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm57bmFtZTpcInRpbWVsaW5lXCIsZGVmZXJJbml0OiEoIWV8fCFlLmRlZmVySW5pdCkmJmUuZGVmZXJJbml0LHBhcmFtczplLGluc3RhbmNlOnJ9fX1dKSxuKHIsW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLndhdmVzdXJmZXIub24oXCJyZWFkeVwiLHRoaXMuX29uUmVhZHkpLHRoaXMud2F2ZXN1cmZlci5pc1JlYWR5JiZ0aGlzLl9vblJlYWR5KCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy51bkFsbCgpLHRoaXMud2F2ZXN1cmZlci51bihcInJlZHJhd1wiLHRoaXMuX29uUmVkcmF3KSx0aGlzLndhdmVzdXJmZXIudW4oXCJ6b29tXCIsdGhpcy5fb25ab29tKSx0aGlzLndhdmVzdXJmZXIudW4oXCJyZWFkeVwiLHRoaXMuX29uUmVhZHkpLHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fb25TY3JvbGwpLHRoaXMud3JhcHBlciYmdGhpcy53cmFwcGVyLnBhcmVudE5vZGUmJih0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fb25XcmFwcGVyQ2xpY2spLHRoaXMud3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlciksdGhpcy53cmFwcGVyPW51bGwpfX0se2tleTpcImNyZWF0ZVdyYXBwZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMud2F2ZXN1cmZlci5wYXJhbXM7dGhpcy5jb250YWluZXIuaW5uZXJIVE1MPVwiXCIsdGhpcy53cmFwcGVyPXRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aW1lbGluZVwiKSksdGhpcy51dGlsLnN0eWxlKHRoaXMud3JhcHBlcix7ZGlzcGxheTpcImJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHVzZXJTZWxlY3Q6XCJub25lXCIsd2Via2l0VXNlclNlbGVjdDpcIm5vbmVcIixoZWlnaHQ6XCJcIi5jb25jYXQodGhpcy5wYXJhbXMuaGVpZ2h0LFwicHhcIil9KSwoZS5maWxsUGFyZW50fHxlLnNjcm9sbFBhcmVudCkmJnRoaXMudXRpbC5zdHlsZSh0aGlzLndyYXBwZXIse3dpZHRoOlwiMTAwJVwiLG92ZXJmbG93WDpcImhpZGRlblwiLG92ZXJmbG93WTpcImhpZGRlblwifSksdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uV3JhcHBlckNsaWNrKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMud3JhcHBlcnx8dGhpcy5jcmVhdGVXcmFwcGVyKCksdGhpcy51cGRhdGVDYW52YXNlcygpLHRoaXMudXBkYXRlQ2FudmFzZXNQb3NpdGlvbmluZygpLHRoaXMucmVuZGVyQ2FudmFzZXMoKX19LHtrZXk6XCJ1cGRhdGVDYW52YXNlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQsYT10aGlzLHI9TWF0aC5yb3VuZCh0aGlzLmRyYXdlci53cmFwcGVyLnNjcm9sbFdpZHRoKSxuPU1hdGguY2VpbChyL3RoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoKTt0aGlzLmNhbnZhc2VzLmxlbmd0aDxuOyl2b2lkIDAsZT1hLndyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSksYS5jYW52YXNlcy5wdXNoKGUpLGEudXRpbC5zdHlsZShlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsekluZGV4OjR9KTtmb3IoO3RoaXMuY2FudmFzZXMubGVuZ3RoPm47KXQ9dm9pZCAwLCh0PWEuY2FudmFzZXMucG9wKCkpLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodCl9fSx7a2V5OlwidXBkYXRlQ2FudmFzZXNQb3NpdGlvbmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcyxuPXRoaXMuY2FudmFzZXMubGVuZ3RoO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBhPXQ9PT1uLTE/ci5kcmF3ZXIud3JhcHBlci5zY3JvbGxXaWR0aC1yLm1heENhbnZhc0VsZW1lbnRXaWR0aCoobi0xKTpyLm1heENhbnZhc0VsZW1lbnRXaWR0aDtlLndpZHRoPWEqci5waXhlbFJhdGlvLGUuaGVpZ2h0PShyLnBhcmFtcy5oZWlnaHQrMSkqci5waXhlbFJhdGlvLHIudXRpbC5zdHlsZShlLHt3aWR0aDpcIlwiLmNvbmNhdChhLFwicHhcIiksaGVpZ2h0OlwiXCIuY29uY2F0KHIucGFyYW1zLmhlaWdodCxcInB4XCIpLGxlZnQ6XCJcIi5jb25jYXQodCpyLm1heENhbnZhc0VsZW1lbnRXaWR0aCxcInB4XCIpfSl9KX19LHtrZXk6XCJyZW5kZXJDYW52YXNlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcyxlPXRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLmdldER1cmF0aW9uKCk7aWYoIShlPD0wKSl7dmFyIHQsYT10aGlzLndhdmVzdXJmZXIucGFyYW1zLG49dGhpcy5wYXJhbXMuZm9udFNpemUqYS5waXhlbFJhdGlvLGk9cGFyc2VJbnQoZSwxMCkrMSxvPWEuZmlsbFBhcmVudCYmIWEuc2Nyb2xsUGFyZW50P3RoaXMuZHJhd2VyLmdldFdpZHRoKCk6dGhpcy5kcmF3ZXIud3JhcHBlci5zY3JvbGxXaWR0aCphLnBpeGVsUmF0aW8scz10aGlzLnBhcmFtcy5oZWlnaHQqdGhpcy5waXhlbFJhdGlvLGw9dGhpcy5wYXJhbXMuaGVpZ2h0Kih0aGlzLnBhcmFtcy5ub3RjaFBlcmNlbnRIZWlnaHQvMTAwKSp0aGlzLnBpeGVsUmF0aW8sYz1vL2UsdT10aGlzLnBhcmFtcy5mb3JtYXRUaW1lQ2FsbGJhY2ssaD1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UoYyk6ZX0scD1oKHRoaXMucGFyYW1zLnRpbWVJbnRlcnZhbCksZj1oKHRoaXMucGFyYW1zLnByaW1hcnlMYWJlbEludGVydmFsKSxkPWgodGhpcy5wYXJhbXMuc2Vjb25kYXJ5TGFiZWxJbnRlcnZhbCksdj0wLG09MCx5PVtdO2Zvcih0PTA7dDxpL3A7dCsrKXkucHVzaChbdCxtLHZdKSxtKz1wLHYrPWMqcDt2YXIgdz1mdW5jdGlvbih0KXt5LmZvckVhY2goZnVuY3Rpb24oZSl7dChlWzBdLGVbMV0sZVsyXSl9KX07dGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnByaW1hcnlDb2xvciksdGhpcy5zZXRGb250cyhcIlwiLmNvbmNhdChuLFwicHggXCIpLmNvbmNhdCh0aGlzLnBhcmFtcy5mb250RmFtaWx5KSksdGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnByaW1hcnlGb250Q29sb3IpLHcoZnVuY3Rpb24oZSx0LGEpe2UlZj09MCYmKHIuZmlsbFJlY3QoYSwwLDEscyksci5maWxsVGV4dCh1KHQsYyksYStyLnBhcmFtcy5sYWJlbFBhZGRpbmcqci5waXhlbFJhdGlvLHMpKX0pLHRoaXMuc2V0RmlsbFN0eWxlcyh0aGlzLnBhcmFtcy5zZWNvbmRhcnlDb2xvciksdGhpcy5zZXRGb250cyhcIlwiLmNvbmNhdChuLFwicHggXCIpLmNvbmNhdCh0aGlzLnBhcmFtcy5mb250RmFtaWx5KSksdGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnNlY29uZGFyeUZvbnRDb2xvciksdyhmdW5jdGlvbihlLHQsYSl7ZSVkPT0wJiYoci5maWxsUmVjdChhLDAsMSxzKSxyLmZpbGxUZXh0KHUodCxjKSxhK3IucGFyYW1zLmxhYmVsUGFkZGluZypyLnBpeGVsUmF0aW8scykpfSksdGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnVubGFiZWxlZE5vdGNoQ29sb3IpLHcoZnVuY3Rpb24oZSx0LGEpe2UlZCE9MCYmZSVmIT0wJiZyLmZpbGxSZWN0KGEsMCwxLGwpfSl9fX0se2tleTpcInNldEZpbGxTdHlsZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5nZXRDb250ZXh0KFwiMmRcIikuZmlsbFN0eWxlPXR9KX19LHtrZXk6XCJzZXRGb250c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmdldENvbnRleHQoXCIyZFwiKS5mb250PXR9KX19LHtrZXk6XCJmaWxsUmVjdFwiLHZhbHVlOmZ1bmN0aW9uKG4saSxvLHMpe3ZhciBsPXRoaXM7dGhpcy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIGE9dCpsLm1heENhbnZhc1dpZHRoLHI9e3gxOk1hdGgubWF4KG4sdCpsLm1heENhbnZhc1dpZHRoKSx5MTppLHgyOk1hdGgubWluKG4rbyx0KmwubWF4Q2FudmFzV2lkdGgrZS53aWR0aCkseTI6aStzfTtyLngxPHIueDImJmUuZ2V0Q29udGV4dChcIjJkXCIpLmZpbGxSZWN0KHIueDEtYSxyLnkxLHIueDItci54MSxyLnkyLXIueTEpfSl9fSx7a2V5OlwiZmlsbFRleHRcIix2YWx1ZTpmdW5jdGlvbihyLG4saSl7dmFyIG8scz0wO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLmdldENvbnRleHQoXCIyZFwiKSxhPXQuY2FudmFzLndpZHRoO24rbzxzfHwobjxzK2EmJihvPXQubWVhc3VyZVRleHQocikud2lkdGgsdC5maWxsVGV4dChyLG4tcyxpKSkscys9YSl9KX19LHtrZXk6XCJkZWZhdWx0Rm9ybWF0VGltZUNhbGxiYWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigxPGUvNjApe3ZhciBhPXBhcnNlSW50KGUvNjAsMTApO3JldHVybiBlPShlPXBhcnNlSW50KGUlNjAsMTApKTwxMD9cIjBcIitlOmUsXCJcIi5jb25jYXQoYSxcIjpcIikuY29uY2F0KGUpfXJldHVybiBNYXRoLnJvdW5kKDFlMyplKS8xZTN9fSx7a2V5OlwiZGVmYXVsdFRpbWVJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiAyNTw9ZT8xOjI1PD01KmU/NToyNTw9MTUqZT8xNTo2MCpNYXRoLmNlaWwoLjUvZSl9fSx7a2V5OlwiZGVmYXVsdFByaW1hcnlMYWJlbEludGVydmFsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIDI1PD1lPzEwOjI1PD01KmU/Njo0fX0se2tleTpcImRlZmF1bHRTZWNvbmRhcnlMYWJlbEludGVydmFsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIDI1PD1lPzU6Mn19XSkscn0oKTt0LmRlZmF1bHQ9aTt2YXIgbz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5fb25TY3JvbGw9ZnVuY3Rpb24oKXthLndyYXBwZXImJmEuZHJhd2VyLndyYXBwZXImJihhLndyYXBwZXIuc2Nyb2xsTGVmdD1hLmRyYXdlci53cmFwcGVyLnNjcm9sbExlZnQpfSx0aGlzLl9vblJlZHJhdz1mdW5jdGlvbigpe3JldHVybiBhLnJlbmRlcigpfSx0aGlzLl9vblJlYWR5PWZ1bmN0aW9uKCl7dmFyIGU9YS53YXZlc3VyZmVyO2EuZHJhd2VyPWUuZHJhd2VyLGEucGl4ZWxSYXRpbz1lLmRyYXdlci5wYXJhbXMucGl4ZWxSYXRpbyxhLm1heENhbnZhc1dpZHRoPWUuZHJhd2VyLm1heENhbnZhc1dpZHRofHxlLmRyYXdlci53aWR0aCxhLm1heENhbnZhc0VsZW1lbnRXaWR0aD1lLmRyYXdlci5tYXhDYW52YXNFbGVtZW50V2lkdGh8fE1hdGgucm91bmQoYS5tYXhDYW52YXNXaWR0aC9hLnBpeGVsUmF0aW8pLGUuZHJhd2VyLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGEuX29uU2Nyb2xsKSxlLm9uKFwicmVkcmF3XCIsYS5fb25SZWRyYXcpLGUub24oXCJ6b29tXCIsYS5fb25ab29tKSxhLnJlbmRlcigpfSx0aGlzLl9vbldyYXBwZXJDbGljaz1mdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCk7dmFyIHQ9XCJvZmZzZXRYXCJpbiBlP2Uub2Zmc2V0WDplLmxheWVyWDthLmZpcmVFdmVudChcImNsaWNrXCIsdC9hLndyYXBwZXIuc2Nyb2xsV2lkdGh8fDApfX07ZS5leHBvcnRzPXQuZGVmYXVsdH1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci50aW1lbGluZS5taW4uanMubWFwIiwiLyohXG4gKiB3YXZlc3VyZmVyLmpzIDIuMS4wIChNb24gT2N0IDAxIDIwMTggMTE6MzQ6NDkgR01UKzAyMDAgKENlbnRyYWwgRXVyb3BlYW4gU3VtbWVyIFRpbWUpKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2thdHNwYXVnaC93YXZlc3VyZmVyLmpzXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcbiAqL1xuIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJXYXZlU3VyZmVyXCIsW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5XYXZlU3VyZmVyPXQoKTplLldhdmVTdXJmZXI9dCgpfSh3aW5kb3csZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIG49e307ZnVuY3Rpb24gaShlKXtpZihuW2VdKXJldHVybiBuW2VdLmV4cG9ydHM7dmFyIHQ9bltlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHJbZV0uY2FsbCh0LmV4cG9ydHMsdCx0LmV4cG9ydHMsaSksdC5sPSEwLHQuZXhwb3J0c31yZXR1cm4gaS5tPXIsaS5jPW4saS5kPWZ1bmN0aW9uKGUsdCxyKXtpLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxpLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1pKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgbiBpbiB0KWkuZChyLG4sZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxuKSk7cmV0dXJuIHJ9LGkubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gaS5kKHQsXCJhXCIsdCksdH0saS5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxpLnA9XCJcIixpKGkucz00KX0oW2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImFqYXhcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZ2V0SWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwibWF4XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIm1pblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJPYnNlcnZlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJleHRlbmRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic3R5bGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImZyYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlYm91bmNlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByZXZlbnRDbGlja1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlZmF1bHR9fSk7dmFyIG49cChyKDUpKSxpPXAocig2KSksYT1wKHIoNykpLHM9cChyKDgpKSxvPXAocigxKSksdT1wKHIoOSkpLGw9cChyKDEwKSksYz1wKHIoMikpLGg9cChyKDExKSksZj1wKHIoMTIpKSxkPXAocigxMykpO2Z1bmN0aW9uIHAoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLmhhbmRsZXJzPW51bGx9dmFyIHQscixuO3JldHVybiB0PWUsKHI9W3trZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpczt0aGlzLmhhbmRsZXJzfHwodGhpcy5oYW5kbGVycz17fSk7dmFyIG49dGhpcy5oYW5kbGVyc1tlXTtyZXR1cm4gbnx8KG49dGhpcy5oYW5kbGVyc1tlXT1bXSksbi5wdXNoKHQpLHtuYW1lOmUsY2FsbGJhY2s6dCx1bjpmdW5jdGlvbihlLHQpe3JldHVybiByLnVuKGUsdCl9fX19LHtrZXk6XCJ1blwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5oYW5kbGVycyl7dmFyIHIsbj10aGlzLmhhbmRsZXJzW2VdO2lmKG4paWYodClmb3Iocj1uLmxlbmd0aC0xOzA8PXI7ci0tKW5bcl09PXQmJm4uc3BsaWNlKHIsMSk7ZWxzZSBuLmxlbmd0aD0wfX19LHtrZXk6XCJ1bkFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oYW5kbGVycz1udWxsfX0se2tleTpcIm9uY2VcIix2YWx1ZTpmdW5jdGlvbihpLGEpe3ZhciBzPXRoaXM7cmV0dXJuIHRoaXMub24oaSxmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkodCksbj0wO248dDtuKyspcltuXT1hcmd1bWVudHNbbl07YS5hcHBseShzLHIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzLnVuKGksZSl9LDApfSl9fSx7a2V5OlwiZmlyZUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkoMTx0P3QtMTowKSxuPTE7bjx0O24rKylyW24tMV09YXJndW1lbnRzW25dO2lmKHRoaXMuaGFuZGxlcnMpe3ZhciBpPXRoaXMuaGFuZGxlcnNbZV07aSYmaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYXBwbHkodm9pZCAwLHIpfSl9fX1dKSYmaSh0LnByb3RvdHlwZSxyKSxuJiZpKHQsbiksZX0oKTt0LmRlZmF1bHQ9bixlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgbj0od2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gc2V0VGltZW91dChlLDFlMy82MCl9KS5iaW5kKHdpbmRvdyk7dC5kZWZhdWx0PW4sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49ZnVuY3Rpb24oZSl7e2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpKXt2YXIgbj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOnt9O24uZ2V0fHxuLnNldD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4pOnRbcl09ZVtyXX1yZXR1cm4gdC5kZWZhdWx0PWUsdH19KHIoMCkpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuKGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIGEoZSx0LHIpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09cixlfWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PWkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZnVuY3Rpb24oZSl7aWYodm9pZCAwIT09ZSlyZXR1cm4gZTt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIil9KGUpOnR9ZnVuY3Rpb24gbyhlKXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gdShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbChlLHQscil7cmV0dXJuIHQmJnUoZS5wcm90b3R5cGUsdCksciYmdShlLHIpLGV9ZnVuY3Rpb24gYyhlLHQpe3JldHVybihjPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX12YXIgaD1cInBsYXlpbmdcIixmPVwicGF1c2VkXCIsZD1cImZpbmlzaGVkXCIscD1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKGUpe3ZhciB0LHIsbjtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGkpLChuPXModGhpcyxvKGkpLmNhbGwodGhpcykpKS5hdWRpb0NvbnRleHQ9bnVsbCxuLm9mZmxpbmVBdWRpb0NvbnRleHQ9bnVsbCxuLnN0YXRlQmVoYXZpb3JzPShhKHQ9e30saCx7aW5pdDpmdW5jdGlvbigpe3RoaXMuYWRkT25BdWRpb1Byb2Nlc3MoKX0sZ2V0UGxheWVkUGVyY2VudHM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldER1cmF0aW9uKCk7cmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKS9lfHwwfSxnZXRDdXJyZW50VGltZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0UG9zaXRpb24rdGhpcy5nZXRQbGF5ZWRUaW1lKCl9fSksYSh0LGYse2luaXQ6ZnVuY3Rpb24oKXt0aGlzLnJlbW92ZU9uQXVkaW9Qcm9jZXNzKCl9LGdldFBsYXllZFBlcmNlbnRzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXREdXJhdGlvbigpO3JldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkvZXx8MH0sZ2V0Q3VycmVudFRpbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydFBvc2l0aW9ufX0pLGEodCxkLHtpbml0OmZ1bmN0aW9uKCl7dGhpcy5yZW1vdmVPbkF1ZGlvUHJvY2VzcygpLHRoaXMuZmlyZUV2ZW50KFwiZmluaXNoXCIpfSxnZXRQbGF5ZWRQZXJjZW50czpmdW5jdGlvbigpe3JldHVybiAxfSxnZXRDdXJyZW50VGltZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldER1cmF0aW9uKCl9fSksdCksbi5wYXJhbXM9ZSxuLmFjPWUuYXVkaW9Db250ZXh0fHxuLmdldEF1ZGlvQ29udGV4dCgpLG4ubGFzdFBsYXk9bi5hYy5jdXJyZW50VGltZSxuLnN0YXJ0UG9zaXRpb249MCxuLnNjaGVkdWxlZFBhdXNlPW51bGwsbi5zdGF0ZXM9KGEocj17fSxoLE9iamVjdC5jcmVhdGUobi5zdGF0ZUJlaGF2aW9yc1toXSkpLGEocixmLE9iamVjdC5jcmVhdGUobi5zdGF0ZUJlaGF2aW9yc1tmXSkpLGEocixkLE9iamVjdC5jcmVhdGUobi5zdGF0ZUJlaGF2aW9yc1tkXSkpLHIpLG4uYW5hbHlzZXI9bnVsbCxuLmJ1ZmZlcj1udWxsLG4uZmlsdGVycz1bXSxuLmdhaW5Ob2RlPW51bGwsbi5tZXJnZWRQZWFrcz1udWxsLG4ub2ZmbGluZUFjPW51bGwsbi5wZWFrcz1udWxsLG4ucGxheWJhY2tSYXRlPTEsbi5hbmFseXNlcj1udWxsLG4uc2NyaXB0Tm9kZT1udWxsLG4uc291cmNlPW51bGwsbi5zcGxpdFBlYWtzPVtdLG4uc3RhdGU9bnVsbCxuLmV4cGxpY2l0RHVyYXRpb249bnVsbCxufXJldHVybiBmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmYyhlLHQpfShpLG4uT2JzZXJ2ZXIpLGwoaSxbe2tleTpcInN1cHBvcnRzV2ViQXVkaW9cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiEoIXdpbmRvdy5BdWRpb0NvbnRleHQmJiF3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KX19LHtrZXk6XCJnZXRBdWRpb0NvbnRleHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dHx8KHdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0PW5ldyh3aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSksd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHR9fSx7a2V5OlwiZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHR8fCh3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQ9bmV3KHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCkoMSwyLGUpKSx3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHR9fV0pLGwoaSxbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3JlYXRlVm9sdW1lTm9kZSgpLHRoaXMuY3JlYXRlU2NyaXB0Tm9kZSgpLHRoaXMuY3JlYXRlQW5hbHlzZXJOb2RlKCksdGhpcy5zZXRTdGF0ZShmKSx0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBhcmFtcy5hdWRpb1JhdGUpLHRoaXMuc2V0TGVuZ3RoKDApfX0se2tleTpcImRpc2Nvbm5lY3RGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZpbHRlcnMmJih0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlJiZlLmRpc2Nvbm5lY3QoKX0pLHRoaXMuZmlsdGVycz1udWxsLHRoaXMuYW5hbHlzZXIuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKSl9fSx7a2V5Olwic2V0U3RhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnN0YXRlIT09dGhpcy5zdGF0ZXNbZV0mJih0aGlzLnN0YXRlPXRoaXMuc3RhdGVzW2VdLHRoaXMuc3RhdGUuaW5pdC5jYWxsKHRoaXMpKX19LHtrZXk6XCJzZXRGaWx0ZXJcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3RoaXMuc2V0RmlsdGVycyh0KX19LHtrZXk6XCJzZXRGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5kaXNjb25uZWN0RmlsdGVycygpLGUmJmUubGVuZ3RoJiYodGhpcy5maWx0ZXJzPWUsdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCksZS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb25uZWN0KHQpLHR9LHRoaXMuYW5hbHlzZXIpLmNvbm5lY3QodGhpcy5nYWluTm9kZSkpfX0se2tleTpcImNyZWF0ZVNjcmlwdE5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyYW1zLmF1ZGlvU2NyaXB0UHJvY2Vzc29yP3RoaXMuc2NyaXB0Tm9kZT10aGlzLnBhcmFtcy5hdWRpb1NjcmlwdFByb2Nlc3Nvcjp0aGlzLmFjLmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcj90aGlzLnNjcmlwdE5vZGU9dGhpcy5hYy5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoaS5zY3JpcHRCdWZmZXJTaXplKTp0aGlzLnNjcmlwdE5vZGU9dGhpcy5hYy5jcmVhdGVKYXZhU2NyaXB0Tm9kZShpLnNjcmlwdEJ1ZmZlclNpemUpLHRoaXMuc2NyaXB0Tm9kZS5jb25uZWN0KHRoaXMuYWMuZGVzdGluYXRpb24pfX0se2tleTpcImFkZE9uQXVkaW9Qcm9jZXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2Vzcz1mdW5jdGlvbigpe3ZhciBlPXQuZ2V0Q3VycmVudFRpbWUoKTtlPj10LmdldER1cmF0aW9uKCk/KHQuc2V0U3RhdGUoZCksdC5maXJlRXZlbnQoXCJwYXVzZVwiKSk6ZT49dC5zY2hlZHVsZWRQYXVzZT90LnBhdXNlKCk6dC5zdGF0ZT09PXQuc3RhdGVzW2hdJiZ0LmZpcmVFdmVudChcImF1ZGlvcHJvY2Vzc1wiLGUpfX19LHtrZXk6XCJyZW1vdmVPbkF1ZGlvUHJvY2Vzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzPW51bGx9fSx7a2V5OlwiY3JlYXRlQW5hbHlzZXJOb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmFuYWx5c2VyPXRoaXMuYWMuY3JlYXRlQW5hbHlzZXIoKSx0aGlzLmFuYWx5c2VyLmNvbm5lY3QodGhpcy5nYWluTm9kZSl9fSx7a2V5OlwiY3JlYXRlVm9sdW1lTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hYy5jcmVhdGVHYWluP3RoaXMuZ2Fpbk5vZGU9dGhpcy5hYy5jcmVhdGVHYWluKCk6dGhpcy5nYWluTm9kZT10aGlzLmFjLmNyZWF0ZUdhaW5Ob2RlKCksdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMuYWMuZGVzdGluYXRpb24pfX0se2tleTpcInNldFNpbmtJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciB0PW5ldyB3aW5kb3cuQXVkaW87aWYoIXQuc2V0U2lua0lkKXJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzZXRTaW5rSWQgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXJcIikpO3QuYXV0b3BsYXk9ITA7dmFyIHI9dGhpcy5hYy5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7cmV0dXJuIHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpLHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChyKSx0LnNyY09iamVjdD1yLnN0cmVhbSx0LnNldFNpbmtJZChlKX1yZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXZpY2VJZDogXCIrZSkpfX0se2tleTpcInNldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShlLHRoaXMuYWMuY3VycmVudFRpbWUpfX0se2tleTpcImdldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZX19LHtrZXk6XCJkZWNvZGVBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXt0aGlzLm9mZmxpbmVBY3x8KHRoaXMub2ZmbGluZUFjPXRoaXMuZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dCh0aGlzLmFjJiZ0aGlzLmFjLnNhbXBsZVJhdGU/dGhpcy5hYy5zYW1wbGVSYXRlOjQ0MTAwKSksdGhpcy5vZmZsaW5lQWMuZGVjb2RlQXVkaW9EYXRhKGUsZnVuY3Rpb24oZSl7cmV0dXJuIHQoZSl9LHIpfX0se2tleTpcInNldFBlYWtzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmV4cGxpY2l0RHVyYXRpb249dCx0aGlzLnBlYWtzPWV9fSx7a2V5Olwic2V0TGVuZ3RoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIXRoaXMubWVyZ2VkUGVha3N8fGUhPTIqdGhpcy5tZXJnZWRQZWFrcy5sZW5ndGgtMSsyKXt0aGlzLnNwbGl0UGVha3M9W10sdGhpcy5tZXJnZWRQZWFrcz1bXTt2YXIgdCxyPXRoaXMuYnVmZmVyP3RoaXMuYnVmZmVyLm51bWJlck9mQ2hhbm5lbHM6MTtmb3IodD0wO3Q8cjt0KyspdGhpcy5zcGxpdFBlYWtzW3RdPVtdLHRoaXMuc3BsaXRQZWFrc1t0XVsyKihlLTEpXT0wLHRoaXMuc3BsaXRQZWFrc1t0XVsyKihlLTEpKzFdPTA7dGhpcy5tZXJnZWRQZWFrc1syKihlLTEpXT0wLHRoaXMubWVyZ2VkUGVha3NbMiooZS0xKSsxXT0wfX19LHtrZXk6XCJnZXRQZWFrc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXtpZih0aGlzLnBlYWtzKXJldHVybiB0aGlzLnBlYWtzO2lmKHQ9dHx8MCxyPXJ8fGUtMSx0aGlzLnNldExlbmd0aChlKSwhdGhpcy5idWZmZXIubGVuZ3RoKXt2YXIgbj10aGlzLmNyZWF0ZUJ1ZmZlcigxLDQwOTYsdGhpcy5zYW1wbGVSYXRlKTt0aGlzLmJ1ZmZlcj1uLmJ1ZmZlcn12YXIgaSxhPXRoaXMuYnVmZmVyLmxlbmd0aC9lLHM9fn4oYS8xMCl8fDEsbz10aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO2ZvcihpPTA7aTxvO2krKyl7dmFyIHU9dGhpcy5zcGxpdFBlYWtzW2ldLGw9dGhpcy5idWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSksYz12b2lkIDA7Zm9yKGM9dDtjPD1yO2MrKyl7dmFyIGg9fn4oYyphKSxmPX5+KGgrYSksZD0wLHA9MCx2PXZvaWQgMDtmb3Iodj1oO3Y8Zjt2Kz1zKXt2YXIgeT1sW3ZdO3A8eSYmKHA9eSkseTxkJiYoZD15KX11WzIqY109cCx1WzIqYysxXT1kLCgwPT1pfHxwPnRoaXMubWVyZ2VkUGVha3NbMipjXSkmJih0aGlzLm1lcmdlZFBlYWtzWzIqY109cCksKDA9PWl8fGQ8dGhpcy5tZXJnZWRQZWFrc1syKmMrMV0pJiYodGhpcy5tZXJnZWRQZWFrc1syKmMrMV09ZCl9fXJldHVybiB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzP3RoaXMuc3BsaXRQZWFrczp0aGlzLm1lcmdlZFBlYWtzfX0se2tleTpcImdldFBsYXllZFBlcmNlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5nZXRQbGF5ZWRQZXJjZW50cy5jYWxsKHRoaXMpfX0se2tleTpcImRpc2Nvbm5lY3RTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc291cmNlJiZ0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZCgpfHx0aGlzLnBhdXNlKCksdGhpcy51bkFsbCgpLHRoaXMuYnVmZmVyPW51bGwsdGhpcy5kaXNjb25uZWN0RmlsdGVycygpLHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpLHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpLHRoaXMuc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCksdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCksdGhpcy5wYXJhbXMuY2xvc2VBdWRpb0NvbnRleHQmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmFjLmNsb3NlJiZcImNsb3NlZFwiIT10aGlzLmFjLnN0YXRlJiZ0aGlzLmFjLmNsb3NlKCksdGhpcy5hYz1udWxsLHRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dD90aGlzLnBhcmFtcy5hdWRpb0NvbnRleHQ9bnVsbDp3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dD1udWxsLHdpbmRvdy5XYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dD1udWxsKX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5zdGFydFBvc2l0aW9uPTAsdGhpcy5sYXN0UGxheT10aGlzLmFjLmN1cnJlbnRUaW1lLHRoaXMuYnVmZmVyPWUsdGhpcy5jcmVhdGVTb3VyY2UoKX19LHtrZXk6XCJjcmVhdGVTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGlzY29ubmVjdFNvdXJjZSgpLHRoaXMuc291cmNlPXRoaXMuYWMuY3JlYXRlQnVmZmVyU291cmNlKCksdGhpcy5zb3VyY2Uuc3RhcnQ9dGhpcy5zb3VyY2Uuc3RhcnR8fHRoaXMuc291cmNlLm5vdGVHcmFpbk9uLHRoaXMuc291cmNlLnN0b3A9dGhpcy5zb3VyY2Uuc3RvcHx8dGhpcy5zb3VyY2Uubm90ZU9mZix0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUodGhpcy5wbGF5YmFja1JhdGUsdGhpcy5hYy5jdXJyZW50VGltZSksdGhpcy5zb3VyY2UuYnVmZmVyPXRoaXMuYnVmZmVyLHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5hbmFseXNlcil9fSx7a2V5OlwiaXNQYXVzZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlIT09dGhpcy5zdGF0ZXNbaF19fSx7a2V5OlwiZ2V0RHVyYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1ZmZlcj90aGlzLmJ1ZmZlci5kdXJhdGlvbjp0aGlzLmV4cGxpY2l0RHVyYXRpb24/dGhpcy5leHBsaWNpdER1cmF0aW9uOjB9fSx7a2V5Olwic2Vla1RvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmJ1ZmZlcilyZXR1cm4odGhpcy5zY2hlZHVsZWRQYXVzZT1udWxsKT09ZSYmKGU9dGhpcy5nZXRDdXJyZW50VGltZSgpKT49dGhpcy5nZXREdXJhdGlvbigpJiYoZT0wKSxudWxsPT10JiYodD10aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuc3RhcnRQb3NpdGlvbj1lLHRoaXMubGFzdFBsYXk9dGhpcy5hYy5jdXJyZW50VGltZSx0aGlzLnN0YXRlPT09dGhpcy5zdGF0ZXNbZF0mJnRoaXMuc2V0U3RhdGUoZikse3N0YXJ0OmUsZW5kOnR9fX0se2tleTpcImdldFBsYXllZFRpbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybih0aGlzLmFjLmN1cnJlbnRUaW1lLXRoaXMubGFzdFBsYXkpKnRoaXMucGxheWJhY2tSYXRlfX0se2tleTpcInBsYXlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKHRoaXMuYnVmZmVyKXt0aGlzLmNyZWF0ZVNvdXJjZSgpO3ZhciByPXRoaXMuc2Vla1RvKGUsdCk7ZT1yLnN0YXJ0LHQ9ci5lbmQsdGhpcy5zY2hlZHVsZWRQYXVzZT10LHRoaXMuc291cmNlLnN0YXJ0KDAsZSx0LWUpLFwic3VzcGVuZGVkXCI9PXRoaXMuYWMuc3RhdGUmJnRoaXMuYWMucmVzdW1lJiZ0aGlzLmFjLnJlc3VtZSgpLHRoaXMuc2V0U3RhdGUoaCksdGhpcy5maXJlRXZlbnQoXCJwbGF5XCIpfX19LHtrZXk6XCJwYXVzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZWRQYXVzZT1udWxsLHRoaXMuc3RhcnRQb3NpdGlvbis9dGhpcy5nZXRQbGF5ZWRUaW1lKCksdGhpcy5zb3VyY2UmJnRoaXMuc291cmNlLnN0b3AoMCksdGhpcy5zZXRTdGF0ZShmKSx0aGlzLmZpcmVFdmVudChcInBhdXNlXCIpfX0se2tleTpcImdldEN1cnJlbnRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5nZXRDdXJyZW50VGltZS5jYWxsKHRoaXMpfX0se2tleTpcImdldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlfX0se2tleTpcInNldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2U9ZXx8MSx0aGlzLmlzUGF1c2VkKCk/dGhpcy5wbGF5YmFja1JhdGU9ZToodGhpcy5wYXVzZSgpLHRoaXMucGxheWJhY2tSYXRlPWUsdGhpcy5wbGF5KCkpfX1dKSxpfSgpOyh0LmRlZmF1bHQ9cCkuc2NyaXB0QnVmZmVyU2l6ZT0yNTYsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIGk9ZnVuY3Rpb24oZSl7e2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpKXt2YXIgbj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOnt9O24uZ2V0fHxuLnNldD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4pOnRbcl09ZVtyXX1yZXR1cm4gdC5kZWZhdWx0PWUsdH19KHIoMCkpLGE9bihyKDE0KSkscz1uKHIoMykpLG89bihyKDE2KSksdT1uKHIoMTcpKTtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBsKGUpe3JldHVybihsPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1sKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2QoZSk6dH1mdW5jdGlvbiBoKGUpe3JldHVybihoPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuKGY9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIGQoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gcChlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gdihlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24geShlLHQscil7cmV0dXJuIHQmJnYoZS5wcm90b3R5cGUsdCksciYmdihlLHIpLGV9dmFyIG09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlKXt2YXIgdDtpZihwKHRoaXMsbiksKHQ9Yyh0aGlzLGgobikuY2FsbCh0aGlzKSkpLmRlZmF1bHRQYXJhbXM9e2F1ZGlvQ29udGV4dDpudWxsLGF1ZGlvUmF0ZToxLGF1dG9DZW50ZXI6ITAsYmFja2VuZDpcIldlYkF1ZGlvXCIsYmFySGVpZ2h0OjEsYmFyR2FwOm51bGwsY29udGFpbmVyOm51bGwsY3Vyc29yQ29sb3I6XCIjMzMzXCIsY3Vyc29yV2lkdGg6MSxkcmFnU2VsZWN0aW9uOiEwLGZpbGxQYXJlbnQ6ITAsZm9yY2VEZWNvZGU6ITEsaGVpZ2h0OjEyOCxoaWRlU2Nyb2xsYmFyOiExLGludGVyYWN0OiEwLGxvb3BTZWxlY3Rpb246ITAsbWF4Q2FudmFzV2lkdGg6NGUzLG1lZGlhQ29udGFpbmVyOm51bGwsbWVkaWFDb250cm9sczohMSxtZWRpYVR5cGU6XCJhdWRpb1wiLG1pblB4UGVyU2VjOjIwLG5vcm1hbGl6ZTohMSxwYXJ0aWFsUmVuZGVyOiExLHBpeGVsUmF0aW86d2luZG93LmRldmljZVBpeGVsUmF0aW98fHNjcmVlbi5kZXZpY2VYRFBJL3NjcmVlbi5sb2dpY2FsWERQSSxwbHVnaW5zOltdLHByb2dyZXNzQ29sb3I6XCIjNTU1XCIscmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95OiEwLHJlbmRlcmVyOmEuZGVmYXVsdCxyZXNwb25zaXZlOiExLHNjcm9sbFBhcmVudDohMSxza2lwTGVuZ3RoOjIsc3BsaXRDaGFubmVsczohMSx3YXZlQ29sb3I6XCIjOTk5XCIseGhyOnt9fSx0LmJhY2tlbmRzPXtNZWRpYUVsZW1lbnQ6by5kZWZhdWx0LFdlYkF1ZGlvOnMuZGVmYXVsdH0sdC51dGlsPWksdC5wYXJhbXM9aS5leHRlbmQoe30sdC5kZWZhdWx0UGFyYW1zLGUpLHQuY29udGFpbmVyPVwic3RyaW5nXCI9PXR5cGVvZiBlLmNvbnRhaW5lcj9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQucGFyYW1zLmNvbnRhaW5lcik6dC5wYXJhbXMuY29udGFpbmVyLCF0LmNvbnRhaW5lcil0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgZWxlbWVudCBub3QgZm91bmRcIik7aWYobnVsbD09dC5wYXJhbXMubWVkaWFDb250YWluZXI/dC5tZWRpYUNvbnRhaW5lcj10LmNvbnRhaW5lcjpcInN0cmluZ1wiPT10eXBlb2YgdC5wYXJhbXMubWVkaWFDb250YWluZXI/dC5tZWRpYUNvbnRhaW5lcj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQucGFyYW1zLm1lZGlhQ29udGFpbmVyKTp0Lm1lZGlhQ29udGFpbmVyPXQucGFyYW1zLm1lZGlhQ29udGFpbmVyLCF0Lm1lZGlhQ29udGFpbmVyKXRocm93IG5ldyBFcnJvcihcIk1lZGlhIENvbnRhaW5lciBlbGVtZW50IG5vdCBmb3VuZFwiKTtpZih0LnBhcmFtcy5tYXhDYW52YXNXaWR0aDw9MSl0aHJvdyBuZXcgRXJyb3IoXCJtYXhDYW52YXNXaWR0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpO2lmKHQucGFyYW1zLm1heENhbnZhc1dpZHRoJTI9PTEpdGhyb3cgbmV3IEVycm9yKFwibWF4Q2FudmFzV2lkdGggbXVzdCBiZSBhbiBldmVuIG51bWJlclwiKTtpZih0LnNhdmVkVm9sdW1lPTAsdC5pc011dGVkPSExLHQudG1wRXZlbnRzPVtdLHQuY3VycmVudEFqYXg9bnVsbCx0LmFycmF5YnVmZmVyPW51bGwsdC5kcmF3ZXI9bnVsbCx0LmJhY2tlbmQ9bnVsbCx0LnBlYWtDYWNoZT1udWxsLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQucGFyYW1zLnJlbmRlcmVyKXRocm93IG5ldyBFcnJvcihcIlJlbmRlcmVyIHBhcmFtZXRlciBpcyBpbnZhbGlkXCIpO3QuRHJhd2VyPXQucGFyYW1zLnJlbmRlcmVyLHQuQmFja2VuZD10LmJhY2tlbmRzW3QucGFyYW1zLmJhY2tlbmRdLHQuaW5pdGlhbGlzZWRQbHVnaW5MaXN0PXt9LHQuaXNEZXN0cm95ZWQ9ITEsdC5pc1JlYWR5PSExO3ZhciByPTA7cmV0dXJuIHQuX29uUmVzaXplPWkuZGVib3VuY2UoZnVuY3Rpb24oKXtyPT10LmRyYXdlci53cmFwcGVyLmNsaWVudFdpZHRofHx0LnBhcmFtcy5zY3JvbGxQYXJlbnR8fChyPXQuZHJhd2VyLndyYXBwZXIuY2xpZW50V2lkdGgsdC5kcmF3ZXIuZmlyZUV2ZW50KFwicmVkcmF3XCIpKX0sXCJudW1iZXJcIj09dHlwZW9mIHQucGFyYW1zLnJlc3BvbnNpdmU/dC5wYXJhbXMucmVzcG9uc2l2ZToxMDApLGModCxkKGQodCkpKX1yZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJmYoZSx0KX0obixpLk9ic2VydmVyKSx5KG4sbnVsbCxbe2tleTpcImNyZWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgbihlKS5pbml0KCl9fV0pLHkobixbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlZ2lzdGVyUGx1Z2lucyh0aGlzLnBhcmFtcy5wbHVnaW5zKSx0aGlzLmNyZWF0ZURyYXdlcigpLHRoaXMuY3JlYXRlQmFja2VuZCgpLHRoaXMuY3JlYXRlUGVha0NhY2hlKCksdGhpc319LHtrZXk6XCJyZWdpc3RlclBsdWdpbnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWRkUGx1Z2luKGUpfSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZGVmZXJJbml0fHx0LmluaXRQbHVnaW4oZS5uYW1lKX0pLHRoaXMuZmlyZUV2ZW50KFwicGx1Z2lucy1yZWdpc3RlcmVkXCIsZSksdGhpc319LHtrZXk6XCJhZGRQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10aGlzO2lmKCF0Lm5hbWUpdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIGRvZXMgbm90IGhhdmUgYSBuYW1lIVwiKTtpZighdC5pbnN0YW5jZSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KHQubmFtZSxcIiBkb2VzIG5vdCBoYXZlIGFuIGluc3RhbmNlIHByb3BlcnR5IVwiKSk7dC5zdGF0aWNQcm9wcyYmT2JqZWN0LmtleXModC5zdGF0aWNQcm9wcykuZm9yRWFjaChmdW5jdGlvbihlKXtyW2VdPXQuc3RhdGljUHJvcHNbZV19KTt2YXIgbj10Lmluc3RhbmNlO3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpLk9ic2VydmVyLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbihlKXtuLnByb3RvdHlwZVtlXT1pLk9ic2VydmVyLnByb3RvdHlwZVtlXX0pLHRoaXNbdC5uYW1lXT1uZXcgbih0LnBhcmFtc3x8e30sdGhpcyksdGhpcy5maXJlRXZlbnQoXCJwbHVnaW4tYWRkZWRcIix0Lm5hbWUpLHRoaXN9fSx7a2V5OlwiaW5pdFBsdWdpblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCF0aGlzW2VdKXRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQoZSxcIiBoYXMgbm90IGJlZW4gYWRkZWQgeWV0IVwiKSk7cmV0dXJuIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W2VdJiZ0aGlzLmRlc3Ryb3lQbHVnaW4oZSksdGhpc1tlXS5pbml0KCksdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbZV09ITAsdGhpcy5maXJlRXZlbnQoXCJwbHVnaW4taW5pdGlhbGlzZWRcIixlKSx0aGlzfX0se2tleTpcImRlc3Ryb3lQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbihlKXtpZighdGhpc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHlldCBhbmQgY2Fubm90IGJlIGRlc3Ryb3llZCFcIikpO2lmKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtlXSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgaXMgbm90IGFjdGl2ZSBhbmQgY2Fubm90IGJlIGRlc3Ryb3llZCFcIikpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXNbZV0uZGVzdHJveSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgZG9lcyBub3QgaGF2ZSBhIGRlc3Ryb3kgZnVuY3Rpb24hXCIpKTtyZXR1cm4gdGhpc1tlXS5kZXN0cm95KCksZGVsZXRlIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W2VdLHRoaXMuZmlyZUV2ZW50KFwicGx1Z2luLWRlc3Ryb3llZFwiLGUpLHRoaXN9fSx7a2V5OlwiZGVzdHJveUFsbFBsdWdpbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7T2JqZWN0LmtleXModGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuZGVzdHJveVBsdWdpbihlKX0pfX0se2tleTpcImNyZWF0ZURyYXdlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpczt0aGlzLmRyYXdlcj1uZXcgdGhpcy5EcmF3ZXIodGhpcy5jb250YWluZXIsdGhpcy5wYXJhbXMpLHRoaXMuZHJhd2VyLmluaXQoKSx0aGlzLmZpcmVFdmVudChcImRyYXdlci1jcmVhdGVkXCIsdGhpcy5kcmF3ZXIpLCExIT09dGhpcy5wYXJhbXMucmVzcG9uc2l2ZSYmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fb25SZXNpemUsITApLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLl9vblJlc2l6ZSwhMCkpLHRoaXMuZHJhd2VyLm9uKFwicmVkcmF3XCIsZnVuY3Rpb24oKXtyLmRyYXdCdWZmZXIoKSxyLmRyYXdlci5wcm9ncmVzcyhyLmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSl9KSx0aGlzLmRyYXdlci5vbihcImNsaWNrXCIsZnVuY3Rpb24oZSx0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHIuc2Vla1RvKHQpfSwwKX0pLHRoaXMuZHJhd2VyLm9uKFwic2Nyb2xsXCIsZnVuY3Rpb24oZSl7ci5wYXJhbXMucGFydGlhbFJlbmRlciYmci5kcmF3QnVmZmVyKCksci5maXJlRXZlbnQoXCJzY3JvbGxcIixlKX0pfX0se2tleTpcImNyZWF0ZUJhY2tlbmRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5iYWNrZW5kJiZ0aGlzLmJhY2tlbmQuZGVzdHJveSgpLFwiQXVkaW9FbGVtZW50XCI9PXRoaXMucGFyYW1zLmJhY2tlbmQmJih0aGlzLnBhcmFtcy5iYWNrZW5kPVwiTWVkaWFFbGVtZW50XCIpLFwiV2ViQXVkaW9cIiE9dGhpcy5wYXJhbXMuYmFja2VuZHx8dGhpcy5CYWNrZW5kLnByb3RvdHlwZS5zdXBwb3J0c1dlYkF1ZGlvLmNhbGwobnVsbCl8fCh0aGlzLnBhcmFtcy5iYWNrZW5kPVwiTWVkaWFFbGVtZW50XCIpLHRoaXMuYmFja2VuZD1uZXcgdGhpcy5CYWNrZW5kKHRoaXMucGFyYW1zKSx0aGlzLmJhY2tlbmQuaW5pdCgpLHRoaXMuZmlyZUV2ZW50KFwiYmFja2VuZC1jcmVhdGVkXCIsdGhpcy5iYWNrZW5kKSx0aGlzLmJhY2tlbmQub24oXCJmaW5pc2hcIixmdW5jdGlvbigpe3JldHVybiB0LmZpcmVFdmVudChcImZpbmlzaFwiKX0pLHRoaXMuYmFja2VuZC5vbihcInBsYXlcIixmdW5jdGlvbigpe3JldHVybiB0LmZpcmVFdmVudChcInBsYXlcIil9KSx0aGlzLmJhY2tlbmQub24oXCJwYXVzZVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZmlyZUV2ZW50KFwicGF1c2VcIil9KSx0aGlzLmJhY2tlbmQub24oXCJhdWRpb3Byb2Nlc3NcIixmdW5jdGlvbihlKXt0LmRyYXdlci5wcm9ncmVzcyh0LmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSksdC5maXJlRXZlbnQoXCJhdWRpb3Byb2Nlc3NcIixlKX0pfX0se2tleTpcImNyZWF0ZVBlYWtDYWNoZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wYXJhbXMucGFydGlhbFJlbmRlciYmKHRoaXMucGVha0NhY2hlPW5ldyB1LmRlZmF1bHQpfX0se2tleTpcImdldER1cmF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmdldER1cmF0aW9uKCl9fSx7a2V5OlwiZ2V0Q3VycmVudFRpbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuZ2V0Q3VycmVudFRpbWUoKX19LHtrZXk6XCJzZXRDdXJyZW50VGltZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2U+PXRoaXMuZ2V0RHVyYXRpb24oKT90aGlzLnNlZWtUbygxKTp0aGlzLnNlZWtUbyhlL3RoaXMuZ2V0RHVyYXRpb24oKSl9fSx7a2V5OlwicGxheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5maXJlRXZlbnQoXCJpbnRlcmFjdGlvblwiLGZ1bmN0aW9uKCl7cmV0dXJuIHIucGxheShlLHQpfSksdGhpcy5iYWNrZW5kLnBsYXkoZSx0KX19LHtrZXk6XCJwYXVzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuYmFja2VuZC5pc1BhdXNlZCgpKXJldHVybiB0aGlzLmJhY2tlbmQucGF1c2UoKX19LHtrZXk6XCJwbGF5UGF1c2VcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKT90aGlzLnBsYXkoKTp0aGlzLnBhdXNlKCl9fSx7a2V5OlwiaXNQbGF5aW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCl9fSx7a2V5Olwic2tpcEJhY2t3YXJkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5za2lwKC1lfHwtdGhpcy5wYXJhbXMuc2tpcExlbmd0aCl9fSx7a2V5Olwic2tpcEZvcndhcmRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNraXAoZXx8dGhpcy5wYXJhbXMuc2tpcExlbmd0aCl9fSx7a2V5Olwic2tpcFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0RHVyYXRpb24oKXx8MSxyPXRoaXMuZ2V0Q3VycmVudFRpbWUoKXx8MDtyPU1hdGgubWF4KDAsTWF0aC5taW4odCxyKyhlfHwwKSkpLHRoaXMuc2Vla0FuZENlbnRlcihyL3QpfX0se2tleTpcInNlZWtBbmRDZW50ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNlZWtUbyhlKSx0aGlzLmRyYXdlci5yZWNlbnRlcihlKX19LHtrZXk6XCJzZWVrVG9cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHwhaXNGaW5pdGUoZSl8fGU8MHx8MTxlKXJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyB3YXZlc3VyZmVyLnNlZWtUbywgcGFyYW1ldGVyIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIVwiKTt0aGlzLmZpcmVFdmVudChcImludGVyYWN0aW9uXCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5zZWVrVG8oZSl9KTt2YXIgcj10aGlzLmJhY2tlbmQuaXNQYXVzZWQoKTtyfHx0aGlzLmJhY2tlbmQucGF1c2UoKTt2YXIgbj10aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PSExLHRoaXMuYmFja2VuZC5zZWVrVG8oZSp0aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuZHJhd2VyLnByb2dyZXNzKGUpLHJ8fHRoaXMuYmFja2VuZC5wbGF5KCksdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PW4sdGhpcy5maXJlRXZlbnQoXCJzZWVrXCIsZSl9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wYXVzZSgpLHRoaXMuc2Vla1RvKDApLHRoaXMuZHJhd2VyLnByb2dyZXNzKDApfX0se2tleTpcInNldFNpbmtJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmJhY2tlbmQuc2V0U2lua0lkKGUpfX0se2tleTpcInNldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYmFja2VuZC5zZXRWb2x1bWUoZSksdGhpcy5maXJlRXZlbnQoXCJ2b2x1bWVcIixlKX19LHtrZXk6XCJnZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuZ2V0Vm9sdW1lKCl9fSx7a2V5Olwic2V0UGxheWJhY2tSYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5iYWNrZW5kLnNldFBsYXliYWNrUmF0ZShlKX19LHtrZXk6XCJnZXRQbGF5YmFja1JhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuZ2V0UGxheWJhY2tSYXRlKCl9fSx7a2V5OlwidG9nZ2xlTXV0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXRNdXRlKCF0aGlzLmlzTXV0ZWQpfX0se2tleTpcInNldE11dGVcIix2YWx1ZTpmdW5jdGlvbihlKXtlIT09dGhpcy5pc011dGVkJiYoZT8odGhpcy5zYXZlZFZvbHVtZT10aGlzLmJhY2tlbmQuZ2V0Vm9sdW1lKCksdGhpcy5iYWNrZW5kLnNldFZvbHVtZSgwKSx0aGlzLmlzTXV0ZWQ9ITAsdGhpcy5maXJlRXZlbnQoXCJ2b2x1bWVcIiwwKSk6KHRoaXMuYmFja2VuZC5zZXRWb2x1bWUodGhpcy5zYXZlZFZvbHVtZSksdGhpcy5pc011dGVkPSExLHRoaXMuZmlyZUV2ZW50KFwidm9sdW1lXCIsdGhpcy5zYXZlZFZvbHVtZSkpKSx0aGlzLmZpcmVFdmVudChcIm11dGVcIix0aGlzLmlzTXV0ZWQpfX0se2tleTpcImdldE11dGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTXV0ZWR9fSx7a2V5OlwiaXNSZWFkeVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSZWFkeX19LHtrZXk6XCJnZXRGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmZpbHRlcnN8fFtdfX0se2tleTpcInRvZ2dsZVNjcm9sbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PSF0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQsdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwidG9nZ2xlSW50ZXJhY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyYW1zLmludGVyYWN0PSF0aGlzLnBhcmFtcy5pbnRlcmFjdH19LHtrZXk6XCJnZXRXYXZlQ29sb3JcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtcy53YXZlQ29sb3J9fSx7a2V5Olwic2V0V2F2ZUNvbG9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMud2F2ZUNvbG9yPWUsdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwiZ2V0UHJvZ3Jlc3NDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyYW1zLnByb2dyZXNzQ29sb3J9fSx7a2V5Olwic2V0UHJvZ3Jlc3NDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGFyYW1zLnByb2dyZXNzQ29sb3I9ZSx0aGlzLmRyYXdCdWZmZXIoKX19LHtrZXk6XCJnZXRDdXJzb3JDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyYW1zLmN1cnNvckNvbG9yfX0se2tleTpcInNldEN1cnNvckNvbG9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMuY3Vyc29yQ29sb3I9ZSx0aGlzLmRyYXdlci51cGRhdGVDdXJzb3IoKX19LHtrZXk6XCJnZXRIZWlnaHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtcy5oZWlnaHR9fSx7a2V5Olwic2V0SGVpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMuaGVpZ2h0PWUsdGhpcy5kcmF3ZXIuc2V0SGVpZ2h0KGUqdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyksdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwiZHJhd0J1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD1NYXRoLnJvdW5kKHRoaXMuZ2V0RHVyYXRpb24oKSp0aGlzLnBhcmFtcy5taW5QeFBlclNlYyp0aGlzLnBhcmFtcy5waXhlbFJhdGlvKSxyPXRoaXMuZHJhd2VyLmdldFdpZHRoKCksbj10LGk9dGhpcy5kcmF3ZXIuZ2V0U2Nyb2xsWCgpLGE9TWF0aC5tYXgoaStyLG4pO2lmKHRoaXMucGFyYW1zLmZpbGxQYXJlbnQmJighdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50fHx0PHIpJiYoaT0wLGE9bj1yKSx0aGlzLnBhcmFtcy5wYXJ0aWFsUmVuZGVyKXt2YXIgcyxvPXRoaXMucGVha0NhY2hlLmFkZFJhbmdlVG9QZWFrQ2FjaGUobixpLGEpO2ZvcihzPTA7czxvLmxlbmd0aDtzKyspZT10aGlzLmJhY2tlbmQuZ2V0UGVha3MobixvW3NdWzBdLG9bc11bMV0pLHRoaXMuZHJhd2VyLmRyYXdQZWFrcyhlLG4sb1tzXVswXSxvW3NdWzFdKX1lbHNlIGU9dGhpcy5iYWNrZW5kLmdldFBlYWtzKG4saSxhKSx0aGlzLmRyYXdlci5kcmF3UGVha3MoZSxuLGksYSk7dGhpcy5maXJlRXZlbnQoXCJyZWRyYXdcIixlLG4pfX0se2tleTpcInpvb21cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQ9ZT8odGhpcy5wYXJhbXMubWluUHhQZXJTZWM9ZSwhMCk6KHRoaXMucGFyYW1zLm1pblB4UGVyU2VjPXRoaXMuZGVmYXVsdFBhcmFtcy5taW5QeFBlclNlYywhMSksdGhpcy5kcmF3QnVmZmVyKCksdGhpcy5kcmF3ZXIucHJvZ3Jlc3ModGhpcy5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpLHRoaXMuZHJhd2VyLnJlY2VudGVyKHRoaXMuZ2V0Q3VycmVudFRpbWUoKS90aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuZmlyZUV2ZW50KFwiem9vbVwiLGUpfX0se2tleTpcImxvYWRBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5kZWNvZGVBcnJheUJ1ZmZlcihlLGZ1bmN0aW9uKGUpe3QuaXNEZXN0cm95ZWR8fHQubG9hZERlY29kZWRCdWZmZXIoZSl9KX19LHtrZXk6XCJsb2FkRGVjb2RlZEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYmFja2VuZC5sb2FkKGUpLHRoaXMuZHJhd0J1ZmZlcigpLHRoaXMuZmlyZUV2ZW50KFwicmVhZHlcIiksdGhpcy5pc1JlYWR5PSEwfX0se2tleTpcImxvYWRCbG9iXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPW5ldyBGaWxlUmVhZGVyO3IuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQub25Qcm9ncmVzcyhlKX0pLHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5sb2FkQXJyYXlCdWZmZXIoZS50YXJnZXQucmVzdWx0KX0pLHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5maXJlRXZlbnQoXCJlcnJvclwiLFwiRXJyb3IgcmVhZGluZyBmaWxlXCIpfSksci5yZWFkQXNBcnJheUJ1ZmZlcihlKSx0aGlzLmVtcHR5KCl9fSx7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe2lmKHRoaXMuZW1wdHkoKSxyKXt2YXIgaT17XCJQcmVsb2FkIGlzIG5vdCAnYXV0bycsICdub25lJyBvciAnbWV0YWRhdGEnXCI6LTE9PT1bXCJhdXRvXCIsXCJtZXRhZGF0YVwiLFwibm9uZVwiXS5pbmRleE9mKHIpLFwiUGVha3MgYXJlIG5vdCBwcm92aWRlZFwiOiF0LFwiQmFja2VuZCBpcyBub3Qgb2YgdHlwZSBNZWRpYUVsZW1lbnRcIjpcIk1lZGlhRWxlbWVudFwiIT09dGhpcy5wYXJhbXMuYmFja2VuZCxcIlVybCBpcyBub3Qgb2YgdHlwZSBzdHJpbmdcIjpcInN0cmluZ1wiIT10eXBlb2YgZX0sYT1PYmplY3Qua2V5cyhpKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGlbZV19KTthLmxlbmd0aCYmKGNvbnNvbGUud2FybihcIlByZWxvYWQgcGFyYW1ldGVyIG9mIHdhdmVzdXJmZXIubG9hZCB3aWxsIGJlIGlnbm9yZWQgYmVjYXVzZTpcXG5cXHQtIFwiK2Euam9pbihcIlxcblxcdC0gXCIpKSxyPW51bGwpfXN3aXRjaCh0aGlzLnBhcmFtcy5iYWNrZW5kKXtjYXNlXCJXZWJBdWRpb1wiOnJldHVybiB0aGlzLmxvYWRCdWZmZXIoZSx0LG4pO2Nhc2VcIk1lZGlhRWxlbWVudFwiOnJldHVybiB0aGlzLmxvYWRNZWRpYUVsZW1lbnQoZSx0LHIsbil9fX0se2tleTpcImxvYWRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUscil7dmFyIG49dGhpcyxpPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZuLnRtcEV2ZW50cy5wdXNoKG4ub25jZShcInJlYWR5XCIsZSkpLG4uZ2V0QXJyYXlCdWZmZXIodCxmdW5jdGlvbihlKXtyZXR1cm4gbi5sb2FkQXJyYXlCdWZmZXIoZSl9KX07aWYoIWUpcmV0dXJuIGkoKTt0aGlzLmJhY2tlbmQuc2V0UGVha3MoZSxyKSx0aGlzLmRyYXdCdWZmZXIoKSx0aGlzLnRtcEV2ZW50cy5wdXNoKHRoaXMub25jZShcImludGVyYWN0aW9uXCIsaSkpfX0se2tleTpcImxvYWRNZWRpYUVsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXt2YXIgaT10aGlzLGE9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl0aGlzLmJhY2tlbmQubG9hZChhLHRoaXMubWVkaWFDb250YWluZXIsdCxyKTtlbHNle3ZhciBzPWU7dGhpcy5iYWNrZW5kLmxvYWRFbHQocyx0KSxhPXMuc3JjfXRoaXMudG1wRXZlbnRzLnB1c2godGhpcy5iYWNrZW5kLm9uY2UoXCJjYW5wbGF5XCIsZnVuY3Rpb24oKXtpLmRyYXdCdWZmZXIoKSxpLmZpcmVFdmVudChcInJlYWR5XCIpLGkuaXNSZWFkeT0hMH0pLHRoaXMuYmFja2VuZC5vbmNlKFwiZXJyb3JcIixmdW5jdGlvbihlKXtyZXR1cm4gaS5maXJlRXZlbnQoXCJlcnJvclwiLGUpfSkpLHQmJnRoaXMuYmFja2VuZC5zZXRQZWFrcyh0LG4pLHQmJiF0aGlzLnBhcmFtcy5mb3JjZURlY29kZXx8IXRoaXMuYmFja2VuZC5zdXBwb3J0c1dlYkF1ZGlvKCl8fHRoaXMuZ2V0QXJyYXlCdWZmZXIoYSxmdW5jdGlvbihlKXtpLmRlY29kZUFycmF5QnVmZmVyKGUsZnVuY3Rpb24oZSl7aS5iYWNrZW5kLmJ1ZmZlcj1lLGkuYmFja2VuZC5zZXRQZWFrcyhudWxsKSxpLmRyYXdCdWZmZXIoKSxpLmZpcmVFdmVudChcIndhdmVmb3JtLXJlYWR5XCIpfSl9KX19LHtrZXk6XCJkZWNvZGVBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIG49dGhpczt0aGlzLmFycmF5YnVmZmVyPXQsdGhpcy5iYWNrZW5kLmRlY29kZUFycmF5QnVmZmVyKHQsZnVuY3Rpb24oZSl7bi5pc0Rlc3Ryb3llZHx8bi5hcnJheWJ1ZmZlciE9dHx8KHIoZSksbi5hcnJheWJ1ZmZlcj1udWxsKX0sZnVuY3Rpb24oKXtyZXR1cm4gbi5maXJlRXZlbnQoXCJlcnJvclwiLFwiRXJyb3IgZGVjb2RpbmcgYXVkaW9idWZmZXJcIil9KX19LHtrZXk6XCJnZXRBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUscil7dmFyIG49dGhpcyx0PWkuYWpheCh7dXJsOmUscmVzcG9uc2VUeXBlOlwiYXJyYXlidWZmZXJcIix4aHI6dGhpcy5wYXJhbXMueGhyfSk7cmV0dXJuIHRoaXMuY3VycmVudEFqYXg9dCx0aGlzLnRtcEV2ZW50cy5wdXNoKHQub24oXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGUpe24ub25Qcm9ncmVzcyhlKX0pLHQub24oXCJzdWNjZXNzXCIsZnVuY3Rpb24oZSx0KXtyKGUpLG4uY3VycmVudEFqYXg9bnVsbH0pLHQub24oXCJlcnJvclwiLGZ1bmN0aW9uKGUpe24uZmlyZUV2ZW50KFwiZXJyb3JcIixcIlhIUiBlcnJvcjogXCIrZS50YXJnZXQuc3RhdHVzVGV4dCksbi5jdXJyZW50QWpheD1udWxsfSkpLHR9fSx7a2V5Olwib25Qcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0O3Q9ZS5sZW5ndGhDb21wdXRhYmxlP2UubG9hZGVkL2UudG90YWw6ZS5sb2FkZWQvKGUubG9hZGVkKzFlNiksdGhpcy5maXJlRXZlbnQoXCJsb2FkaW5nXCIsTWF0aC5yb3VuZCgxMDAqdCksZS50YXJnZXQpfX0se2tleTpcImV4cG9ydFBDTVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe2U9ZXx8MTAyNCxuPW58fDAsdD10fHwxZTQscj1yfHwhMTt2YXIgaT10aGlzLmJhY2tlbmQuZ2V0UGVha3MoZSxuKSxhPVtdLm1hcC5jYWxsKGksZnVuY3Rpb24oZSl7cmV0dXJuIE1hdGgucm91bmQoZSp0KS90fSkscz1KU09OLnN0cmluZ2lmeShhKTtyZXR1cm4gcnx8d2luZG93Lm9wZW4oXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCxcIitlbmNvZGVVUklDb21wb25lbnQocykpLHN9fSx7a2V5OlwiZXhwb3J0SW1hZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBlfHwoZT1cImltYWdlL3BuZ1wiKSx0fHwodD0xKSx0aGlzLmRyYXdlci5nZXRJbWFnZShlLHQpfX0se2tleTpcImNhbmNlbEFqYXhcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3VycmVudEFqYXgmJih0aGlzLmN1cnJlbnRBamF4Lnhoci5hYm9ydCgpLHRoaXMuY3VycmVudEFqYXg9bnVsbCl9fSx7a2V5OlwiY2xlYXJUbXBFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudG1wRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUudW4oKX0pfX0se2tleTpcImVtcHR5XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKXx8KHRoaXMuc3RvcCgpLHRoaXMuYmFja2VuZC5kaXNjb25uZWN0U291cmNlKCkpLHRoaXMuaXNSZWFkeT0hMSx0aGlzLmNhbmNlbEFqYXgoKSx0aGlzLmNsZWFyVG1wRXZlbnRzKCksdGhpcy5kcmF3ZXIucHJvZ3Jlc3MoMCksdGhpcy5kcmF3ZXIuc2V0V2lkdGgoMCksdGhpcy5kcmF3ZXIuZHJhd1BlYWtzKHtsZW5ndGg6dGhpcy5kcmF3ZXIuZ2V0V2lkdGgoKX0sMCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95QWxsUGx1Z2lucygpLHRoaXMuZmlyZUV2ZW50KFwiZGVzdHJveVwiKSx0aGlzLmNhbmNlbEFqYXgoKSx0aGlzLmNsZWFyVG1wRXZlbnRzKCksdGhpcy51bkFsbCgpLCExIT09dGhpcy5wYXJhbXMucmVzcG9uc2l2ZSYmKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fb25SZXNpemUsITApLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLl9vblJlc2l6ZSwhMCkpLHRoaXMuYmFja2VuZC5kZXN0cm95KCksdGhpcy5kcmF3ZXIuZGVzdHJveSgpLHRoaXMuaXNEZXN0cm95ZWQ9ITAsdGhpcy5pc1JlYWR5PSExLHRoaXMuYXJyYXlidWZmZXI9bnVsbH19XSksbn0oKTsodC5kZWZhdWx0PW0pLlZFUlNJT049XCIyLjEuMFwiLG0udXRpbD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGkuZGVmYXVsdCxyPW5ldyBYTUxIdHRwUmVxdWVzdCxuPSExO3Iub3BlbihlLm1ldGhvZHx8XCJHRVRcIixlLnVybCwhMCksci5yZXNwb25zZVR5cGU9ZS5yZXNwb25zZVR5cGV8fFwianNvblwiLGUueGhyJiYoZS54aHIucmVxdWVzdEhlYWRlcnMmJmUueGhyLnJlcXVlc3RIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ci5zZXRSZXF1ZXN0SGVhZGVyKGUua2V5LGUudmFsdWUpfSksZS54aHIud2l0aENyZWRlbnRpYWxzJiYoci53aXRoQ3JlZGVudGlhbHM9ITApKTtyZXR1cm4gci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIixmdW5jdGlvbihlKXt0LmZpcmVFdmVudChcInByb2dyZXNzXCIsZSksZS5sZW5ndGhDb21wdXRhYmxlJiZlLmxvYWRlZD09ZS50b3RhbCYmKG49ITApfSksci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKGUpe258fHQuZmlyZUV2ZW50KFwicHJvZ3Jlc3NcIixlKSx0LmZpcmVFdmVudChcImxvYWRcIixlKSwyMDA9PXIuc3RhdHVzfHwyMDY9PXIuc3RhdHVzP3QuZmlyZUV2ZW50KFwic3VjY2Vzc1wiLHIucmVzcG9uc2UsZSk6dC5maXJlRXZlbnQoXCJlcnJvclwiLGUpfSksci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5maXJlRXZlbnQoXCJlcnJvclwiLGUpfSksci5zZW5kKCksdC54aHI9cix0fTt2YXIgbixpPShuPXIoMSkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKCl7cmV0dXJuXCJ3YXZlc3VyZmVyX1wiK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnN1YnN0cmluZygyKX0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbih0KXt2YXIgcj0tMS8wO3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV0+ciYmKHI9dFtlXSl9KSxyfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHQpe3ZhciByPU51bWJlcigxLzApO3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV08ciYmKHI9dFtlXSl9KSxyfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KDE8ZT9lLTE6MCksbj0xO248ZTtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24oZSl7cltlXT10W2VdfSl9KSxyfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHQscil7cmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goZnVuY3Rpb24oZSl7dC5zdHlsZVtlXSE9PXJbZV0mJih0LnN0eWxlW2VdPXJbZV0pfSksdH0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4oMCxpLmRlZmF1bHQpKGZ1bmN0aW9uKCl7cmV0dXJuIG4uYXBwbHkodm9pZCAwLHQpfSl9fTt2YXIgbixpPShuPXIoMikpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIodCxyLG4pe3ZhciBpLGEscyxvLHU7ZnVuY3Rpb24gbCgpe3ZhciBlPURhdGUubm93KCktbztlPHImJjA8PWU/aT1zZXRUaW1lb3V0KGwsci1lKTooaT1udWxsLG58fCh1PXQuYXBwbHkocyxhKSxzPWE9bnVsbCkpfW51bGw9PXImJihyPTEwMCk7dmFyIGU9ZnVuY3Rpb24oKXtzPXRoaXMsYT1hcmd1bWVudHMsbz1EYXRlLm5vdygpO3ZhciBlPW4mJiFpO3JldHVybiBpfHwoaT1zZXRUaW1lb3V0KGwscikpLGUmJih1PXQuYXBwbHkocyxhKSxzPWE9bnVsbCksdX07cmV0dXJuIGUuY2xlYXI9ZnVuY3Rpb24oKXtpJiYoY2xlYXJUaW1lb3V0KGkpLGk9bnVsbCl9LGUuZmx1c2g9ZnVuY3Rpb24oKXtpJiYodT10LmFwcGx5KHMsYSkscz1hPW51bGwsY2xlYXJUaW1lb3V0KGkpLGk9bnVsbCl9LGV9ci5kZWJvdW5jZT1yLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsbiwhMCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKGUpe2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsbiwhMCl9LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGE9KG49cigxNSkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxmPWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSl7dmFyIG49T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTp7fTtuLmdldHx8bi5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixuKTp0W3JdPWVbcl19cmV0dXJuIHQuZGVmYXVsdD1lLHR9fShyKDApKTtmdW5jdGlvbiBpKGUpe3JldHVybihpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBzKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1pKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIHUoZSl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9dmFyIGM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe3ZhciByO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbiksKHI9byh0aGlzLHUobikuY2FsbCh0aGlzLGUsdCkpKS5tYXhDYW52YXNXaWR0aD10Lm1heENhbnZhc1dpZHRoLHIubWF4Q2FudmFzRWxlbWVudFdpZHRoPU1hdGgucm91bmQodC5tYXhDYW52YXNXaWR0aC90LnBpeGVsUmF0aW8pLHIuaGFzUHJvZ3Jlc3NDYW52YXM9dC53YXZlQ29sb3IhPXQucHJvZ3Jlc3NDb2xvcixyLmhhbGZQaXhlbD0uNS90LnBpeGVsUmF0aW8sci5jYW52YXNlcz1bXSxyLnByb2dyZXNzV2F2ZT1udWxsLHJ9dmFyIHQscixpO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbChlLHQpfShuLGEuZGVmYXVsdCksdD1uLChyPVt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jcmVhdGVXcmFwcGVyKCksdGhpcy5jcmVhdGVFbGVtZW50cygpfX0se2tleTpcImNyZWF0ZUVsZW1lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb2dyZXNzV2F2ZT10aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwid2F2ZVwiKSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHpJbmRleDozLGxlZnQ6MCx0b3A6MCxib3R0b206MCxvdmVyZmxvdzpcImhpZGRlblwiLHdpZHRoOlwiMFwiLGRpc3BsYXk6XCJub25lXCIsYm94U2l6aW5nOlwiYm9yZGVyLWJveFwiLGJvcmRlclJpZ2h0U3R5bGU6XCJzb2xpZFwiLHBvaW50ZXJFdmVudHM6XCJub25lXCJ9KSksdGhpcy5hZGRDYW52YXMoKSx0aGlzLnVwZGF0ZUN1cnNvcigpfX0se2tleTpcInVwZGF0ZUN1cnNvclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zdHlsZSh0aGlzLnByb2dyZXNzV2F2ZSx7Ym9yZGVyUmlnaHRXaWR0aDp0aGlzLnBhcmFtcy5jdXJzb3JXaWR0aCtcInB4XCIsYm9yZGVyUmlnaHRDb2xvcjp0aGlzLnBhcmFtcy5jdXJzb3JDb2xvcn0pfX0se2tleTpcInVwZGF0ZVNpemVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgbj10aGlzLGU9TWF0aC5yb3VuZCh0aGlzLndpZHRoL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pLHQ9TWF0aC5jZWlsKGUvdGhpcy5tYXhDYW52YXNFbGVtZW50V2lkdGgpO3RoaXMuY2FudmFzZXMubGVuZ3RoPHQ7KXRoaXMuYWRkQ2FudmFzKCk7Zm9yKDt0aGlzLmNhbnZhc2VzLmxlbmd0aD50Oyl0aGlzLnJlbW92ZUNhbnZhcygpO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciByPW4ubWF4Q2FudmFzV2lkdGgrMipNYXRoLmNlaWwobi5wYXJhbXMucGl4ZWxSYXRpby8yKTt0PT1uLmNhbnZhc2VzLmxlbmd0aC0xJiYocj1uLndpZHRoLW4ubWF4Q2FudmFzV2lkdGgqKG4uY2FudmFzZXMubGVuZ3RoLTEpKSxuLnVwZGF0ZURpbWVuc2lvbnMoZSxyLG4uaGVpZ2h0KSxuLmNsZWFyV2F2ZUZvckVudHJ5KGUpfSl9fSx7a2V5OlwiYWRkQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT17fSx0PXRoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoKnRoaXMuY2FudmFzZXMubGVuZ3RoO2Uud2F2ZT10aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHtwb3NpdGlvbjpcImFic29sdXRlXCIsekluZGV4OjIsbGVmdDp0K1wicHhcIix0b3A6MCxib3R0b206MCxoZWlnaHQ6XCIxMDAlXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIn0pKSxlLndhdmVDdHg9ZS53YXZlLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLmhhc1Byb2dyZXNzQ2FudmFzJiYoZS5wcm9ncmVzcz10aGlzLnByb2dyZXNzV2F2ZS5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixsZWZ0OnQrXCJweFwiLHRvcDowLGJvdHRvbTowLGhlaWdodDpcIjEwMCVcIn0pKSxlLnByb2dyZXNzQ3R4PWUucHJvZ3Jlc3MuZ2V0Q29udGV4dChcIjJkXCIpKSx0aGlzLmNhbnZhc2VzLnB1c2goZSl9fSx7a2V5OlwicmVtb3ZlQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmNhbnZhc2VzLnBvcCgpO2Uud2F2ZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGUud2F2ZSksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmZS5wcm9ncmVzcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGUucHJvZ3Jlc3MpfX0se2tleTpcInVwZGF0ZURpbWVuc2lvbnNcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7dmFyIG49TWF0aC5yb3VuZCh0L3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pLGk9TWF0aC5yb3VuZCh0aGlzLndpZHRoL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pO2Uuc3RhcnQ9ZS53YXZlQ3R4LmNhbnZhcy5vZmZzZXRMZWZ0L2l8fDAsZS5lbmQ9ZS5zdGFydCtuL2ksZS53YXZlQ3R4LmNhbnZhcy53aWR0aD10LGUud2F2ZUN0eC5jYW52YXMuaGVpZ2h0PXIsdGhpcy5zdHlsZShlLndhdmVDdHguY2FudmFzLHt3aWR0aDpuK1wicHhcIn0pLHRoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUse2Rpc3BsYXk6XCJibG9ja1wifSksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmKGUucHJvZ3Jlc3NDdHguY2FudmFzLndpZHRoPXQsZS5wcm9ncmVzc0N0eC5jYW52YXMuaGVpZ2h0PXIsdGhpcy5zdHlsZShlLnByb2dyZXNzQ3R4LmNhbnZhcyx7d2lkdGg6bitcInB4XCJ9KSl9fSx7a2V5OlwiY2xlYXJXYXZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5jbGVhcldhdmVGb3JFbnRyeShlKX0pfX0se2tleTpcImNsZWFyV2F2ZUZvckVudHJ5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS53YXZlQ3R4LmNsZWFyUmVjdCgwLDAsZS53YXZlQ3R4LmNhbnZhcy53aWR0aCxlLndhdmVDdHguY2FudmFzLmhlaWdodCksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmZS5wcm9ncmVzc0N0eC5jbGVhclJlY3QoMCwwLGUucHJvZ3Jlc3NDdHguY2FudmFzLndpZHRoLGUucHJvZ3Jlc3NDdHguY2FudmFzLmhlaWdodCl9fSx7a2V5OlwiZHJhd0JhcnNcIix2YWx1ZTpmdW5jdGlvbihlLHQsdix5KXt2YXIgbT10aGlzO3JldHVybiB0aGlzLnByZXBhcmVEcmF3KGUsdCx2LHksZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hYnNtYXgscj1lLmhhc01pblZhbHMsbj0oZS5oZWlnaHQsZS5vZmZzZXRZKSxpPWUuaGFsZkgsYT1lLnBlYWtzO2lmKHZvaWQgMCE9PXYpe3ZhciBzLG89cj8yOjEsdT1hLmxlbmd0aC9vLGw9bS5wYXJhbXMuYmFyV2lkdGgqbS5wYXJhbXMucGl4ZWxSYXRpbyxjPWwrKG51bGw9PT1tLnBhcmFtcy5iYXJHYXA/TWF0aC5tYXgobS5wYXJhbXMucGl4ZWxSYXRpbyx+fihsLzIpKTpNYXRoLm1heChtLnBhcmFtcy5waXhlbFJhdGlvLG0ucGFyYW1zLmJhckdhcCptLnBhcmFtcy5waXhlbFJhdGlvKSksaD11L20ud2lkdGgsZj15O2ZvcihzPXY7czxmO3MrPWMpe3ZhciBkPWFbTWF0aC5mbG9vcihzKmgqbyldfHwwLHA9TWF0aC5yb3VuZChkL3QqaSk7bS5maWxsUmVjdChzK20uaGFsZlBpeGVsLGktcCtuLGwrbS5oYWxmUGl4ZWwsMipwKX19fSl9fSx7a2V5OlwiZHJhd1dhdmVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbCxjKXt2YXIgaD10aGlzO3JldHVybiB0aGlzLnByZXBhcmVEcmF3KGUsdCxsLGMsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hYnNtYXgscj1lLmhhc01pblZhbHMsbj0oZS5oZWlnaHQsZS5vZmZzZXRZKSxpPWUuaGFsZkgsYT1lLnBlYWtzO2lmKCFyKXt2YXIgcyxvPVtdLHU9YS5sZW5ndGg7Zm9yKHM9MDtzPHU7cysrKW9bMipzXT1hW3NdLG9bMipzKzFdPS1hW3NdO2E9b312b2lkIDAhPT1sJiZoLmRyYXdMaW5lKGEsdCxpLG4sbCxjKSxoLmZpbGxSZWN0KDAsaStuLWguaGFsZlBpeGVsLGgud2lkdGgsaC5oYWxmUGl4ZWwpfSl9fSx7a2V5OlwiZHJhd0xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LHIsbixpLGEscyl7dmFyIG89dGhpczt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7by5zZXRGaWxsU3R5bGVzKGUpLG8uZHJhd0xpbmVUb0NvbnRleHQoZSxlLndhdmVDdHgsdCxyLG4saSxhLHMpLG8uZHJhd0xpbmVUb0NvbnRleHQoZSxlLnByb2dyZXNzQ3R4LHQscixuLGksYSxzKX0pfX0se2tleTpcImRyYXdMaW5lVG9Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbixpLGEscyxvKXtpZih0KXt2YXIgdT1yLmxlbmd0aC8yLGw9dGhpcy5wYXJhbXMuZmlsbFBhcmVudCYmdGhpcy53aWR0aCE9dT90aGlzLndpZHRoL3U6MSxjPU1hdGgucm91bmQodSplLnN0YXJ0KSxoPU1hdGgucm91bmQodSplLmVuZCkrMTtpZighKG88Y3x8aDxzKSl7dmFyIGYsZCxwPU1hdGgubWluKGMscyksdj1NYXRoLm1heChoLG8pO2Zvcih0LmJlZ2luUGF0aCgpLHQubW92ZVRvKChwLWMpKmwrdGhpcy5oYWxmUGl4ZWwsaSthKSxmPXA7Zjx2O2YrKyl7dmFyIHk9clsyKmZdfHwwLG09TWF0aC5yb3VuZCh5L24qaSk7dC5saW5lVG8oKGYtYykqbCt0aGlzLmhhbGZQaXhlbCxpLW0rYSl9Zm9yKGQ9di0xO3A8PWQ7ZC0tKXt2YXIgYj1yWzIqZCsxXXx8MCxnPU1hdGgucm91bmQoYi9uKmkpO3QubGluZVRvKChkLWMpKmwrdGhpcy5oYWxmUGl4ZWwsaS1nK2EpfXQuY2xvc2VQYXRoKCksdC5maWxsKCl9fX19LHtrZXk6XCJmaWxsUmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpLGE9TWF0aC5mbG9vcihlL3RoaXMubWF4Q2FudmFzV2lkdGgpLHM9TWF0aC5taW4oTWF0aC5jZWlsKChlK3IpL3RoaXMubWF4Q2FudmFzV2lkdGgpKzEsdGhpcy5jYW52YXNlcy5sZW5ndGgpO2ZvcihpPWE7aTxzO2krKyl7dmFyIG89dGhpcy5jYW52YXNlc1tpXSx1PWkqdGhpcy5tYXhDYW52YXNXaWR0aCxsPXt4MTpNYXRoLm1heChlLGkqdGhpcy5tYXhDYW52YXNXaWR0aCkseTE6dCx4MjpNYXRoLm1pbihlK3IsaSp0aGlzLm1heENhbnZhc1dpZHRoK28ud2F2ZUN0eC5jYW52YXMud2lkdGgpLHkyOnQrbn07bC54MTxsLngyJiYodGhpcy5zZXRGaWxsU3R5bGVzKG8pLHRoaXMuZmlsbFJlY3RUb0NvbnRleHQoby53YXZlQ3R4LGwueDEtdSxsLnkxLGwueDItbC54MSxsLnkyLWwueTEpLHRoaXMuZmlsbFJlY3RUb0NvbnRleHQoby5wcm9ncmVzc0N0eCxsLngxLXUsbC55MSxsLngyLWwueDEsbC55Mi1sLnkxKSl9fX0se2tleTpcInByZXBhcmVEcmF3XCIsdmFsdWU6ZnVuY3Rpb24ocyxvLHUsbCxjKXt2YXIgaD10aGlzO3JldHVybiBmLmZyYW1lKGZ1bmN0aW9uKCl7aWYoc1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBlPXM7aWYoaC5wYXJhbXMuc3BsaXRDaGFubmVscylyZXR1cm4gaC5zZXRIZWlnaHQoZS5sZW5ndGgqaC5wYXJhbXMuaGVpZ2h0KmgucGFyYW1zLnBpeGVsUmF0aW8pLGUuZm9yRWFjaChmdW5jdGlvbihlLHQpe3JldHVybiBoLnByZXBhcmVEcmF3KGUsdCx1LGwsYyl9KTtzPWVbMF19dmFyIHQ9MS9oLnBhcmFtcy5iYXJIZWlnaHQ7aWYoaC5wYXJhbXMubm9ybWFsaXplKXt2YXIgcj1mLm1heChzKSxuPWYubWluKHMpO3Q9cjwtbj8tbjpyfXZhciBpPVtdLnNvbWUuY2FsbChzLGZ1bmN0aW9uKGUpe3JldHVybiBlPDB9KSxhPWgucGFyYW1zLmhlaWdodCpoLnBhcmFtcy5waXhlbFJhdGlvO3JldHVybiBjKHthYnNtYXg6dCxoYXNNaW5WYWxzOmksaGVpZ2h0OmEsb2Zmc2V0WTphKm98fDAsaGFsZkg6YS8yLHBlYWtzOnN9KX0pKCl9fSx7a2V5OlwiZmlsbFJlY3RUb0NvbnRleHRcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuLGkpe2UmJmUuZmlsbFJlY3QodCxyLG4saSl9fSx7a2V5Olwic2V0RmlsbFN0eWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2Uud2F2ZUN0eC5maWxsU3R5bGU9dGhpcy5wYXJhbXMud2F2ZUNvbG9yLHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMmJihlLnByb2dyZXNzQ3R4LmZpbGxTdHlsZT10aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yKX19LHtrZXk6XCJnZXRJbWFnZVwiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIGU9dGhpcy5jYW52YXNlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUud2F2ZS50b0RhdGFVUkwodCxyKX0pO3JldHVybiAxPGUubGVuZ3RoP2U6ZVswXX19LHtrZXk6XCJ1cGRhdGVQcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUse3dpZHRoOmUrXCJweFwifSl9fV0pJiZzKHQucHJvdG90eXBlLHIpLGkmJnModCxpKSxufSgpO3QuZGVmYXVsdD1jLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBhPWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSl7dmFyIG49T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTp7fTtuLmdldHx8bi5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixuKTp0W3JdPWVbcl19cmV0dXJuIHQuZGVmYXVsdD1lLHR9fShyKDApKTtmdW5jdGlvbiBuKGUpe3JldHVybihuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBzKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1uKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIHUoZSl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9dmFyIGk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe3ZhciByO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbiksKHI9byh0aGlzLHUobikuY2FsbCh0aGlzKSkpLmNvbnRhaW5lcj1lLHIucGFyYW1zPXQsci53aWR0aD0wLHIuaGVpZ2h0PXQuaGVpZ2h0KnIucGFyYW1zLnBpeGVsUmF0aW8sci5sYXN0UG9zPTAsci53cmFwcGVyPW51bGwscn12YXIgdCxyLGk7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZsKGUsdCl9KG4sYS5PYnNlcnZlciksdD1uLChyPVt7a2V5Olwic3R5bGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLnN0eWxlKGUsdCl9fSx7a2V5OlwiY3JlYXRlV3JhcHBlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53cmFwcGVyPXRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ3YXZlXCIpKSx0aGlzLnN0eWxlKHRoaXMud3JhcHBlcix7ZGlzcGxheTpcImJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHVzZXJTZWxlY3Q6XCJub25lXCIsd2Via2l0VXNlclNlbGVjdDpcIm5vbmVcIixoZWlnaHQ6dGhpcy5wYXJhbXMuaGVpZ2h0K1wicHhcIn0pLCh0aGlzLnBhcmFtcy5maWxsUGFyZW50fHx0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpJiZ0aGlzLnN0eWxlKHRoaXMud3JhcHBlcix7d2lkdGg6XCIxMDAlXCIsb3ZlcmZsb3dYOnRoaXMucGFyYW1zLmhpZGVTY3JvbGxiYXI/XCJoaWRkZW5cIjpcImF1dG9cIixvdmVyZmxvd1k6XCJoaWRkZW5cIn0pLHRoaXMuc2V0dXBXcmFwcGVyRXZlbnRzKCl9fSx7a2V5OlwiaGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpeyF0JiZlLnByZXZlbnREZWZhdWx0KCk7dmFyIHIsbj1lLnRhcmdldFRvdWNoZXM/ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFg6ZS5jbGllbnRYLGk9dGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGE9dGhpcy53aWR0aCxzPXRoaXMuZ2V0V2lkdGgoKTtyZXR1cm4hdGhpcy5wYXJhbXMuZmlsbFBhcmVudCYmYTxzPzE8KHI9KG4taS5sZWZ0KSoodGhpcy5wYXJhbXMucGl4ZWxSYXRpby9hKXx8MCkmJihyPTEpOnI9KG4taS5sZWZ0K3RoaXMud3JhcHBlci5zY3JvbGxMZWZ0KS90aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGh8fDAscn19LHtrZXk6XCJzZXR1cFdyYXBwZXJFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGUpe3ZhciB0PW4ud3JhcHBlci5vZmZzZXRIZWlnaHQtbi53cmFwcGVyLmNsaWVudEhlaWdodDtpZigwIT10KXt2YXIgcj1uLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoZS5jbGllbnRZPj1yLmJvdHRvbS10KXJldHVybn1uLnBhcmFtcy5pbnRlcmFjdCYmbi5maXJlRXZlbnQoXCJjbGlja1wiLGUsbi5oYW5kbGVFdmVudChlKSl9KSx0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGZ1bmN0aW9uKGUpe3JldHVybiBuLmZpcmVFdmVudChcInNjcm9sbFwiLGUpfSl9fSx7a2V5OlwiZHJhd1BlYWtzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbil7dGhpcy5zZXRXaWR0aCh0KXx8dGhpcy5jbGVhcldhdmUoKSx0aGlzLnBhcmFtcy5iYXJXaWR0aD90aGlzLmRyYXdCYXJzKGUsMCxyLG4pOnRoaXMuZHJhd1dhdmUoZSwwLHIsbil9fSx7a2V5OlwicmVzZXRTY3JvbGxcIix2YWx1ZTpmdW5jdGlvbigpe251bGwhPT10aGlzLndyYXBwZXImJih0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdD0wKX19LHtrZXk6XCJyZWNlbnRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCplO3RoaXMucmVjZW50ZXJPblBvc2l0aW9uKHQsITApfX0se2tleTpcInJlY2VudGVyT25Qb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy53cmFwcGVyLnNjcm9sbExlZnQsbj1+fih0aGlzLndyYXBwZXIuY2xpZW50V2lkdGgvMiksaT10aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGgtdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoLGE9ZS1uLHM9YS1yO2lmKDAhPWkpe2lmKCF0JiYtbjw9cyYmczxuKXthPXIrKHM9TWF0aC5tYXgoLTUsTWF0aC5taW4oNSxzKSkpfShhPU1hdGgubWF4KDAsTWF0aC5taW4oaSxhKSkpIT1yJiYodGhpcy53cmFwcGVyLnNjcm9sbExlZnQ9YSl9fX0se2tleTpcImdldFNjcm9sbFhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucGFyYW1zLnBpeGVsUmF0aW8sdD1NYXRoLnJvdW5kKHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0KmUpO2lmKHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCl7dmFyIHI9fn4odGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoKmUtdGhpcy5nZXRXaWR0aCgpKTt0PU1hdGgubWluKHIsTWF0aC5tYXgoMCx0KSl9cmV0dXJuIHR9fSx7a2V5OlwiZ2V0V2lkdGhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoKnRoaXMucGFyYW1zLnBpeGVsUmF0aW8pfX0se2tleTpcInNldFdpZHRoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud2lkdGghPWUmJih0aGlzLndpZHRoPWUsdGhpcy5wYXJhbXMuZmlsbFBhcmVudHx8dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50P3RoaXMuc3R5bGUodGhpcy53cmFwcGVyLHt3aWR0aDpcIlwifSk6dGhpcy5zdHlsZSh0aGlzLndyYXBwZXIse3dpZHRoOn5+KHRoaXMud2lkdGgvdGhpcy5wYXJhbXMucGl4ZWxSYXRpbykrXCJweFwifSksdGhpcy51cGRhdGVTaXplKCksITApfX0se2tleTpcInNldEhlaWdodFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlIT10aGlzLmhlaWdodCYmKHRoaXMuaGVpZ2h0PWUsdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIse2hlaWdodDp+fih0aGlzLmhlaWdodC90aGlzLnBhcmFtcy5waXhlbFJhdGlvKStcInB4XCJ9KSx0aGlzLnVwZGF0ZVNpemUoKSwhMCl9fSx7a2V5OlwicHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8scj1NYXRoLnJvdW5kKGUqdGhpcy53aWR0aCkqdDtpZihyPHRoaXMubGFzdFBvc3x8ci10aGlzLmxhc3RQb3M+PXQpe2lmKHRoaXMubGFzdFBvcz1yLHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCYmdGhpcy5wYXJhbXMuYXV0b0NlbnRlcil7dmFyIG49fn4odGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoKmUpO3RoaXMucmVjZW50ZXJPblBvc2l0aW9uKG4pfXRoaXMudXBkYXRlUHJvZ3Jlc3Mocil9fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudW5BbGwoKSx0aGlzLndyYXBwZXImJih0aGlzLndyYXBwZXIucGFyZW50Tm9kZT09dGhpcy5jb250YWluZXImJnRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlciksdGhpcy53cmFwcGVyPW51bGwpfX0se2tleTpcInVwZGF0ZUN1cnNvclwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInVwZGF0ZVNpemVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJkcmF3QmFyc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe319LHtrZXk6XCJkcmF3V2F2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe319LHtrZXk6XCJjbGVhcldhdmVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJ1cGRhdGVQcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe319XSkmJnModC5wcm90b3R5cGUsciksaSYmcyh0LGkpLG59KCk7dC5kZWZhdWx0PWksZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4sYT0obj1yKDMpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07IWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikpe3ZhciBuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUscik6e307bi5nZXR8fG4uc2V0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsbik6dFtyXT1lW3JdfXQuZGVmYXVsdD1lfX0ocigwKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4oaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09aSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXJldHVybiBlO3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0oZSk6dH1mdW5jdGlvbiB1KGUsdCxyKXtyZXR1cm4odT1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5nZXQ/UmVmbGVjdC5nZXQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWZ1bmN0aW9uKGUsdCl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJm51bGwhPT0oZT1sKGUpKTspO3JldHVybiBlfShlLHQpO2lmKG4pe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtyZXR1cm4gaS5nZXQ/aS5nZXQuY2FsbChyKTppLnZhbHVlfX0pKGUsdCxyfHxlKX1mdW5jdGlvbiBsKGUpe3JldHVybihsPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuKGM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfXZhciBoPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSl7dmFyIHQ7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxuKSwodD1vKHRoaXMsbChuKS5jYWxsKHRoaXMsZSkpKS5wYXJhbXM9ZSx0Lm1lZGlhPXtjdXJyZW50VGltZTowLGR1cmF0aW9uOjAscGF1c2VkOiEwLHBsYXliYWNrUmF0ZToxLHBsYXk6ZnVuY3Rpb24oKXt9LHBhdXNlOmZ1bmN0aW9uKCl7fSx2b2x1bWU6MH0sdC5tZWRpYVR5cGU9ZS5tZWRpYVR5cGUudG9Mb3dlckNhc2UoKSx0LmVsZW1lbnRQb3NpdGlvbj1lLmVsZW1lbnRQb3NpdGlvbix0LnBlYWtzPW51bGwsdC5wbGF5YmFja1JhdGU9MSx0LnZvbHVtZT0xLHQuYnVmZmVyPW51bGwsdC5vblBsYXlFbmQ9bnVsbCx0fXZhciB0LHIsaTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJmMoZSx0KX0obixhLmRlZmF1bHQpLHQ9biwocj1be2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGFyYW1zLmF1ZGlvUmF0ZSksdGhpcy5jcmVhdGVUaW1lcigpfX0se2tleTpcImNyZWF0ZVRpbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMub24oXCJwbGF5XCIsZnVuY3Rpb24gZSgpe3QuaXNQYXVzZWQoKXx8KHQuZmlyZUV2ZW50KFwiYXVkaW9wcm9jZXNzXCIsdC5nZXRDdXJyZW50VGltZSgpKSwod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkoZSkpfSksdGhpcy5vbihcInBhdXNlXCIsZnVuY3Rpb24oKXt0LmZpcmVFdmVudChcImF1ZGlvcHJvY2Vzc1wiLHQuZ2V0Q3VycmVudFRpbWUoKSl9KX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1lZGlhVHlwZSk7aS5jb250cm9scz10aGlzLnBhcmFtcy5tZWRpYUNvbnRyb2xzLGkuYXV0b3BsYXk9dGhpcy5wYXJhbXMuYXV0b3BsYXl8fCExLGkucHJlbG9hZD1udWxsPT1uP1wiYXV0b1wiOm4saS5zcmM9ZSxpLnN0eWxlLndpZHRoPVwiMTAwJVwiO3ZhciBhPXQucXVlcnlTZWxlY3Rvcih0aGlzLm1lZGlhVHlwZSk7YSYmdC5yZW1vdmVDaGlsZChhKSx0LmFwcGVuZENoaWxkKGkpLHRoaXMuX2xvYWQoaSxyKX19LHtrZXk6XCJsb2FkRWx0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtlLmNvbnRyb2xzPXRoaXMucGFyYW1zLm1lZGlhQ29udHJvbHMsZS5hdXRvcGxheT10aGlzLnBhcmFtcy5hdXRvcGxheXx8ITEsdGhpcy5fbG9hZChlLHQpfX0se2tleTpcIl9sb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO1wiZnVuY3Rpb25cIj09dHlwZW9mIGUubG9hZCYmZS5sb2FkKCksZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbigpe3IuZmlyZUV2ZW50KFwiZXJyb3JcIixcIkVycm9yIGxvYWRpbmcgbWVkaWEgZWxlbWVudFwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIixmdW5jdGlvbigpe3IuZmlyZUV2ZW50KFwiY2FucGxheVwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcImZpbmlzaFwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlcIixmdW5jdGlvbigpe3IuZmlyZUV2ZW50KFwicGxheVwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcInBhdXNlXCIpfSksdGhpcy5tZWRpYT1lLHRoaXMucGVha3M9dCx0aGlzLm9uUGxheUVuZD1udWxsLHRoaXMuYnVmZmVyPW51bGwsdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wbGF5YmFja1JhdGUpLHRoaXMuc2V0Vm9sdW1lKHRoaXMudm9sdW1lKX19LHtrZXk6XCJpc1BhdXNlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMubWVkaWF8fHRoaXMubWVkaWEucGF1c2VkfX0se2tleTpcImdldER1cmF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmV4cGxpY2l0RHVyYXRpb24pcmV0dXJuIHRoaXMuZXhwbGljaXREdXJhdGlvbjt2YXIgZT0odGhpcy5idWZmZXJ8fHRoaXMubWVkaWEpLmR1cmF0aW9uO3JldHVybiAxLzA8PWUmJihlPXRoaXMubWVkaWEuc2Vla2FibGUuZW5kKDApKSxlfX0se2tleTpcImdldEN1cnJlbnRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZWRpYSYmdGhpcy5tZWRpYS5jdXJyZW50VGltZX19LHtrZXk6XCJnZXRQbGF5ZWRQZXJjZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKS90aGlzLmdldER1cmF0aW9uKCl8fDB9fSx7a2V5OlwiZ2V0UGxheWJhY2tSYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGV8fHRoaXMubWVkaWEucGxheWJhY2tSYXRlfX0se2tleTpcInNldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGxheWJhY2tSYXRlPWV8fDEsdGhpcy5tZWRpYS5wbGF5YmFja1JhdGU9dGhpcy5wbGF5YmFja1JhdGV9fSx7a2V5Olwic2Vla1RvXCIsdmFsdWU6ZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKHRoaXMubWVkaWEuY3VycmVudFRpbWU9ZSksdGhpcy5jbGVhclBsYXlFbmQoKX19LHtrZXk6XCJwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLnNlZWtUbyhlKTt2YXIgcj10aGlzLm1lZGlhLnBsYXkoKTtyZXR1cm4gdCYmdGhpcy5zZXRQbGF5RW5kKHQpLHJ9fSx7a2V5OlwicGF1c2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3JldHVybiB0aGlzLm1lZGlhJiYoZT10aGlzLm1lZGlhLnBhdXNlKCkpLHRoaXMuY2xlYXJQbGF5RW5kKCksZX19LHtrZXk6XCJzZXRQbGF5RW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dGhpczt0aGlzLl9vblBsYXlFbmQ9ZnVuY3Rpb24oZSl7dDw9ZSYmKHIucGF1c2UoKSxyLnNlZWtUbyh0KSl9LHRoaXMub24oXCJhdWRpb3Byb2Nlc3NcIix0aGlzLl9vblBsYXlFbmQpfX0se2tleTpcImNsZWFyUGxheUVuZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fb25QbGF5RW5kJiYodGhpcy51bihcImF1ZGlvcHJvY2Vzc1wiLHRoaXMuX29uUGxheUVuZCksdGhpcy5fb25QbGF5RW5kPW51bGwpfX0se2tleTpcImdldFBlYWtzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLmJ1ZmZlcj91KGwobi5wcm90b3R5cGUpLFwiZ2V0UGVha3NcIix0aGlzKS5jYWxsKHRoaXMsZSx0LHIpOnRoaXMucGVha3N8fFtdfX0se2tleTpcInNldFNpbmtJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlP3RoaXMubWVkaWEuc2V0U2lua0lkP3RoaXMubWVkaWEuc2V0U2lua0lkKGUpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNldFNpbmtJZCBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlclwiKSk6UHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXZpY2VJZDogXCIrZSkpfX0se2tleTpcImdldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudm9sdW1lfHx0aGlzLm1lZGlhLnZvbHVtZX19LHtrZXk6XCJzZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnZvbHVtZT1lLHRoaXMubWVkaWEudm9sdW1lPXRoaXMudm9sdW1lfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGF1c2UoKSx0aGlzLnVuQWxsKCksdGhpcy5wYXJhbXMucmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95JiZ0aGlzLm1lZGlhJiZ0aGlzLm1lZGlhLnBhcmVudE5vZGUmJnRoaXMubWVkaWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1lZGlhKSx0aGlzLm1lZGlhPW51bGx9fV0pJiZzKHQucHJvdG90eXBlLHIpLGkmJnModCxpKSxufSgpO3QuZGVmYXVsdD1oLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5jbGVhclBlYWtDYWNoZSgpfXZhciB0LHIsbjtyZXR1cm4gdD1lLChyPVt7a2V5OlwiY2xlYXJQZWFrQ2FjaGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGVha0NhY2hlUmFuZ2VzPVtdLHRoaXMucGVha0NhY2hlTGVuZ3RoPS0xfX0se2tleTpcImFkZFJhbmdlVG9QZWFrQ2FjaGVcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7ZSE9dGhpcy5wZWFrQ2FjaGVMZW5ndGgmJih0aGlzLmNsZWFyUGVha0NhY2hlKCksdGhpcy5wZWFrQ2FjaGVMZW5ndGg9ZSk7Zm9yKHZhciBuPVtdLGk9MDtpPHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aCYmdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV08dDspaSsrO2ZvcihpJTI9PTAmJm4ucHVzaCh0KTtpPHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aCYmdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV08PXI7KW4ucHVzaCh0aGlzLnBlYWtDYWNoZVJhbmdlc1tpXSksaSsrO2klMj09MCYmbi5wdXNoKHIpLG49bi5maWx0ZXIoZnVuY3Rpb24oZSx0LHIpe3JldHVybiAwPT10P2UhPXJbdCsxXTp0PT1yLmxlbmd0aC0xP2UhPXJbdC0xXTplIT1yW3QtMV0mJmUhPXJbdCsxXX0pLHRoaXMucGVha0NhY2hlUmFuZ2VzPXRoaXMucGVha0NhY2hlUmFuZ2VzLmNvbmNhdChuKSx0aGlzLnBlYWtDYWNoZVJhbmdlcz10aGlzLnBlYWtDYWNoZVJhbmdlcy5zb3J0KGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUtdH0pLmZpbHRlcihmdW5jdGlvbihlLHQscil7cmV0dXJuIDA9PXQ/ZSE9clt0KzFdOnQ9PXIubGVuZ3RoLTE/ZSE9clt0LTFdOmUhPXJbdC0xXSYmZSE9clt0KzFdfSk7dmFyIGE9W107Zm9yKGk9MDtpPG4ubGVuZ3RoO2krPTIpYS5wdXNoKFtuW2ldLG5baSsxXV0pO3JldHVybiBhfX0se2tleTpcImdldENhY2hlUmFuZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PVtdO2ZvcihlPTA7ZTx0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGg7ZSs9Mil0LnB1c2goW3RoaXMucGVha0NhY2hlUmFuZ2VzW2VdLHRoaXMucGVha0NhY2hlUmFuZ2VzW2UrMV1dKTtyZXR1cm4gdH19XSkmJmkodC5wcm90b3R5cGUsciksbiYmaSh0LG4pLGV9KCk7dC5kZWZhdWx0PW4sZS5leHBvcnRzPXQuZGVmYXVsdH1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci5taW4uanMubWFwIiwiLyoqXG4gKiAoU2luZ2xlKSBSZWdpb24gcGx1Z2luIGNsYXNzXG4gKlxuICogTXVzdCBiZSB0dXJuZWQgaW50byBhbiBvYnNlcnZlciBiZWZvcmUgaW5zdGFudGlhdGluZy4gVGhpcyBpcyBkb25lIGluXG4gKiBSZWdpb25zUGx1Z2luIChtYWluIHBsdWdpbiBjbGFzcylcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKi9cbmNsYXNzIFJlZ2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCB3cykge1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIgPSB3cztcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3MuZHJhd2VyLndyYXBwZXI7XG4gICAgICAgIHRoaXMudXRpbCA9IHdzLnV0aWw7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLnV0aWwuc3R5bGU7XG5cbiAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZCA9PSBudWxsID8gd3MudXRpbC5nZXRJZCgpIDogcGFyYW1zLmlkO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gTnVtYmVyKHBhcmFtcy5zdGFydCkgfHwgMDtcbiAgICAgICAgdGhpcy5lbmQgPVxuICAgICAgICAgICAgcGFyYW1zLmVuZCA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAvLyBzbWFsbCBtYXJrZXItbGlrZSByZWdpb25cbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgK1xuICAgICAgICAgICAgICAgICAgKDQgLyB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGgpICogdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKClcbiAgICAgICAgICAgICAgICA6IE51bWJlcihwYXJhbXMuZW5kKTtcbiAgICAgICAgdGhpcy5yZXNpemUgPVxuICAgICAgICAgICAgcGFyYW1zLnJlc2l6ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4ocGFyYW1zLnJlc2l6ZSk7XG4gICAgICAgIHRoaXMuZHJhZyA9IHBhcmFtcy5kcmFnID09PSB1bmRlZmluZWQgPyB0cnVlIDogQm9vbGVhbihwYXJhbXMuZHJhZyk7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ocGFyYW1zLmxvb3ApO1xuICAgICAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8ICdyZ2JhKDAsIDAsIDAsIDAuMSknO1xuICAgICAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YSB8fCB7fTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBwYXJhbXMubWF4TGVuZ3RoO1xuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IHBhcmFtcy5taW5MZW5ndGg7XG4gICAgICAgIHRoaXMuX29uUmVkcmF3ID0gKCkgPT4gdGhpcy51cGRhdGVSZW5kZXIoKTtcblxuICAgICAgICB0aGlzLnNjcm9sbCA9IHBhcmFtcy5zY3JvbGwgIT09IGZhbHNlICYmIHdzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBwYXJhbXMuc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSBwYXJhbXMuc2Nyb2xsVGhyZXNob2xkIHx8IDEwO1xuXG4gICAgICAgIHRoaXMuYmluZEluT3V0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5vbignem9vbScsIHRoaXMuX29uUmVkcmF3KTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLm9uKCdyZWRyYXcnLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jcmVhdGVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyogVXBkYXRlIHJlZ2lvbiBwYXJhbXMuICovXG4gICAgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBOdW1iZXIocGFyYW1zLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IE51bWJlcihwYXJhbXMuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgdGhpcy5sb29wID0gQm9vbGVhbihwYXJhbXMubG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT0gcGFyYW1zLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMucmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IEJvb2xlYW4ocGFyYW1zLnJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT0gcGFyYW1zLmRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZyA9IEJvb2xlYW4ocGFyYW1zLmRyYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWF4TGVuZ3RoID0gTnVtYmVyKHBhcmFtcy5tYXhMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWluTGVuZ3RoID0gTnVtYmVyKHBhcmFtcy5taW5MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBwYXJhbXMuYXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cGRhdGUnKTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXVwZGF0ZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgYSBzaW5nbGUgcmVnaW9uLiAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlbW92ZScpO1xuICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCd6b29tJywgdGhpcy5fb25SZWRyYXcpO1xuICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCdyZWRyYXcnLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgICAgICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tcmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogUGxheSB0aGUgYXVkaW8gcmVnaW9uLiAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5wbGF5KHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsYXknKTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXBsYXknLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKiBQbGF5IHRoZSByZWdpb24gaW4gbG9vcC4gKi9cbiAgICBwbGF5TG9vcCgpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIHRoaXMub25jZSgnb3V0JywgKCkgPT4gdGhpcy5wbGF5TG9vcCgpKTtcbiAgICB9XG5cbiAgICAvKiBSZW5kZXIgYSByZWdpb24gYXMgYSBET00gZWxlbWVudC4gKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVnaW9uJyk7XG4gICAgICAgIHJlZ2lvbkVsLmNsYXNzTmFtZSA9ICd3YXZlc3VyZmVyLXJlZ2lvbic7XG4gICAgICAgIHJlZ2lvbkVsLnRpdGxlID0gdGhpcy5mb3JtYXRUaW1lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgcmVnaW9uRWwuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgdGhpcy5pZCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBhdHRybmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJlZ2lvbkVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAnZGF0YS1yZWdpb24tJyArIGF0dHJuYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRybmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aDtcbiAgICAgICAgdGhpcy5zdHlsZShyZWdpb25FbCwge1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIHRvcDogJzBweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogUmVzaXplIGhhbmRsZXMgKi9cbiAgICAgICAgaWYgKHRoaXMucmVzaXplKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVMZWZ0ID0gcmVnaW9uRWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaGFuZGxlJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVSaWdodCA9IHJlZ2lvbkVsLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hhbmRsZScpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFuZGxlTGVmdC5jbGFzc05hbWUgPSAnd2F2ZXN1cmZlci1oYW5kbGUgd2F2ZXN1cmZlci1oYW5kbGUtc3RhcnQnO1xuICAgICAgICAgICAgaGFuZGxlUmlnaHQuY2xhc3NOYW1lID0gJ3dhdmVzdXJmZXItaGFuZGxlIHdhdmVzdXJmZXItaGFuZGxlLWVuZCc7XG4gICAgICAgICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnY29sLXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgbGVmdDogJzBweCcsXG4gICAgICAgICAgICAgICAgdG9wOiAnMHB4JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzElJyxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzRweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN0eWxlKGhhbmRsZUxlZnQsIGNzcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKGhhbmRsZVJpZ2h0LCBjc3MpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZShoYW5kbGVSaWdodCwge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICcxMDAlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQocmVnaW9uRWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcigpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudHMocmVnaW9uRWwpO1xuICAgIH1cblxuICAgIGZvcm1hdFRpbWUoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gKHN0YXJ0ID09IGVuZCA/IFtzdGFydF0gOiBbc3RhcnQsIGVuZF0pXG4gICAgICAgICAgICAubWFwKHRpbWUgPT5cbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHRpbWUgJSAzNjAwKSAvIDYwKSwgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgICAgICAoJzAwJyArIE1hdGguZmxvb3IodGltZSAlIDYwKSkuc2xpY2UoLTIpIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICBdLmpvaW4oJzonKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJy0nKTtcbiAgICB9XG5cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud2lkdGggLyB0aGlzLndhdmVzdXJmZXIucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLyogVXBkYXRlIGVsZW1lbnQncyBwb3NpdGlvbiwgd2lkdGgsIGNvbG9yLiAqL1xuICAgIHVwZGF0ZVJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgZHVyID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmQgPiBkdXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZHVyO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGR1ciAtICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgodGhpcy5zdGFydCArIHRoaXMubWluTGVuZ3RoLCB0aGlzLmVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0ICsgdGhpcy5tYXhMZW5ndGgsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCB3aWR0aCB2YWx1ZXMgb2YgdGhlIHJlZ2lvbiBzdWNoIHRoYXRcbiAgICAgICAgICAgIC8vIG5vIGdhcHMgYXBwZWFyIGJldHdlZW4gcmVnaW9ucy5cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLnJvdW5kKCh0aGlzLnN0YXJ0IC8gZHVyKSAqIHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbldpZHRoID0gTWF0aC5yb3VuZCgodGhpcy5lbmQgLyBkdXIpICogd2lkdGgpIC0gbGVmdDtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVnaW9uV2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHRoaXMuZHJhZyA/ICdtb3ZlJyA6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cm5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcmVnaW9uLScgKyBhdHRybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJuYW1lXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IHRoaXMuZm9ybWF0VGltZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBCaW5kIGF1ZGlvIGV2ZW50cy4gKi9cbiAgICBiaW5kSW5PdXQoKSB7XG4gICAgICAgIHRoaXMuZmlyZWRJbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpcmVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3Qgb25Qcm9jZXNzID0gdGltZSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMuZmlyZWRPdXQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVkSW4gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zdGFydCA+PSBNYXRoLnJvdW5kKHRpbWUgKiAxMDApIC8gMTAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kIDw9IE1hdGgucm91bmQodGltZSAqIDEwMCkgLyAxMDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVkSW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnb3V0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW91dCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmZpcmVkSW4gJiYgdGhpcy5zdGFydCA8PSB0aW1lICYmIHRoaXMuZW5kID4gdGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZWRJbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlZE91dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCdpbicpO1xuICAgICAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1pbicsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLm9uKCdhdWRpb3Byb2Nlc3MnLCBvblByb2Nlc3MpO1xuXG4gICAgICAgIHRoaXMub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLnVuKCdhdWRpb3Byb2Nlc3MnLCBvblByb2Nlc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBMb29wIHBsYXliYWNrLiAqL1xuICAgICAgICB0aGlzLm9uKCdvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLnBsYXkodGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIEJpbmQgRE9NIGV2ZW50cy4gKi9cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ21vdXNlZW50ZXInLCBlKTtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1tb3VzZWVudGVyJywgdGhpcywgZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnbW91c2VsZWF2ZScsIGUpO1xuICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW1vdXNlbGVhdmUnLCB0aGlzLCBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnY2xpY2snLCBlKTtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jbGljaycsIHRoaXMsIGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1kYmxjbGljaycsIHRoaXMsIGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBEcmFnIG9yIHJlc2l6ZSBvbiBtb3VzZW1vdmUuICovXG4gICAgICAgICh0aGlzLmRyYWcgfHwgdGhpcy5yZXNpemUpICYmXG4gICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsU3BlZWQgPSB0aGlzLnNjcm9sbFNwZWVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoSWQ7XG4gICAgICAgICAgICAgICAgbGV0IGRyYWc7XG4gICAgICAgICAgICAgICAgbGV0IG1heFNjcm9sbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVzaXplO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlclJlY3Q7XG5cbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VTY3JvbGwgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxEaXJlY3Rpb24gfHwgKCFkcmFnICYmICFyZXNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGxldCBzY3JvbGxMZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ICsgc2Nyb2xsU3BlZWQgKiBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2Nyb2xsLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc2Nyb2xsTGVmdClcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZSkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGRyYWdnaW5nIG9yIHJlc2l6aW5nXG4gICAgICAgICAgICAgICAgICAgIGRyYWcgPyB0aGlzLm9uRHJhZyhkZWx0YSkgOiB0aGlzLm9uUmVzaXplKGRlbHRhLCByZXNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGVhdFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VTY3JvbGwoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbkRvd24gPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoSWQgPSBlLnRhcmdldFRvdWNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCB0cnVlKSAqIGR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGZvciBzY3JvbGwgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIG1heFNjcm9sbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggLSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJSZWN0ID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2hhbmRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3YXZlc3VyZmVyLWhhbmRsZS1zdGFydCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUgPSAnc3RhcnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUgPSAnZW5kJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uVXAgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWcgfHwgcmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51dGlsLnByZXZlbnRDbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3VwZGF0ZS1lbmQnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi11cGRhdGUtZW5kJywgdGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uTW92ZSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXRUb3VjaGVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllciAhPSB0b3VjaElkXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWcgfHwgcmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlKSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZyAmJiBkcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZWQgfHwgISFkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRHJhZyhkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplICYmIHJlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVkIHx8ICEhZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZShkZWx0YSwgcmVzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGhyZXNob2xkIGlzIG5vdCBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGNvbnRhaW5lciBlZGdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpcyBiZXR3ZWVuIHRoZSByZWdpb24gYW5kIHRoZSBjb250YWluZXIgZWRnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdpb25SZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHJlZ2lvblJlY3QubGVmdCAtIHdyYXBwZXJSZWN0LmxlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgb2xkVGltZSAmJiB4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSA+IG9sZFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyByZWdpb25SZWN0LndpZHRoIDw9IHdyYXBwZXJSZWN0LnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgd2UgYXJlIHN0aWxsIGJleW9uZCB0aGUgdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzY3JvbGxEaXJlY3Rpb24gPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA+IHNjcm9sbFRocmVzaG9sZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzY3JvbGxEaXJlY3Rpb24gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgcmVnaW9uUmVjdC53aWR0aCA8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJSZWN0LnJpZ2h0IC0gc2Nyb2xsVGhyZXNob2xkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3VzZSBiYXNlZCB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBlLmNsaWVudFggLSB3cmFwcGVyUmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA8PSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA+PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlclJlY3QucmlnaHQgLSBzY3JvbGxUaHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiAmJiBlZGdlU2Nyb2xsKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvd24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb3duKTtcblxuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbk1vdmUpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25VcCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblVwKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uTW92ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndhdmVzdXJmZXIub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25VcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIG9uRHJhZyhkZWx0YSkge1xuICAgICAgICBjb25zdCBtYXhFbmQgPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuZW5kICsgZGVsdGEgPiBtYXhFbmQgfHwgdGhpcy5zdGFydCArIGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgKyBkZWx0YSxcbiAgICAgICAgICAgIGVuZDogdGhpcy5lbmQgKyBkZWx0YVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZShkZWx0YSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbih0aGlzLnN0YXJ0ICsgZGVsdGEsIHRoaXMuZW5kKSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWF4KHRoaXMuc3RhcnQgKyBkZWx0YSwgdGhpcy5lbmQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5taW4odGhpcy5lbmQgKyBkZWx0YSwgdGhpcy5zdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBNYXRoLm1heCh0aGlzLmVuZCArIGRlbHRhLCB0aGlzLnN0YXJ0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVnaW9uc1BsdWdpblBhcmFtc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZHJhZ1NlbGVjdGlvbiBFbmFibGUgY3JlYXRpbmcgcmVnaW9ucyBieSBkcmFnZ2luZyB3aWhcbiAqIHRoZSBtb3VzZVxuICogQHByb3BlcnR5IHs/UmVnaW9uUGFyYW1zW119IHJlZ2lvbnMgUmVnaW9ucyB0aGF0IHNob3VsZCBiZSBhZGRlZCB1cG9uXG4gKiBpbml0aWFsaXNhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsb3A9MiBUaGUgc2Vuc2l0aXZpdHkgb2YgdGhlIG1vdXNlIGRyYWdnaW5nXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZWZlckluaXQgU2V0IHRvIHRydWUgdG8gbWFudWFsbHkgY2FsbFxuICogYGluaXRQbHVnaW4oJ3JlZ2lvbnMnKWBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZ2lvblBhcmFtc1xuICogQGRlc2MgVGhlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXNjcmliZSBhIHJlZ2lvbi5cbiAqIEBleGFtcGxlIHdhdmVzdXJmZXIuYWRkUmVnaW9uKHJlZ2lvblBhcmFtcyk7XG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQ94oaScmFuZG9tIFRoZSBpZCBvZiB0aGUgcmVnaW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnQ9MCBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiAoaW4gc2Vjb25kcykuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kPTAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVnaW9uIChpbiBzZWNvbmRzKS5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGxvb3AgV2hldGhlciB0byBsb29wIHRoZSByZWdpb24gd2hlbiBwbGF5ZWQgYmFjay5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZHJhZz10cnVlIEFsbG93L2Rpc3NhbGxvdyBkcmFnZ2luZyB0aGUgcmVnaW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSByZXNpemU9dHJ1ZSBBbGxvdy9kaXNzYWxsb3cgcmVzaXppbmcgdGhlIHJlZ2lvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3I9J3JnYmEoMCwgMCwgMCwgMC4xKSddIEhUTUwgY29sb3IgY29kZS5cbiAqL1xuXG4vKipcbiAqIFJlZ2lvbnMgYXJlIHZpc3VhbCBvdmVybGF5cyBvbiB3YXZlZm9ybSB0aGF0IGNhbiBiZSB1c2VkIHRvIHBsYXkgYW5kIGxvb3BcbiAqIHBvcnRpb25zIG9mIGF1ZGlvLiBSZWdpb25zIGNhbiBiZSBkcmFnZ2VkIGFuZCByZXNpemVkLlxuICpcbiAqIFZpc3VhbCBjdXN0b21pemF0aW9uIGlzIHBvc3NpYmxlIHZpYSBDU1MgKHVzaW5nIHRoZSBzZWxlY3RvcnNcbiAqIGAud2F2ZXN1cmZlci1yZWdpb25gIGFuZCBgLndhdmVzdXJmZXItaGFuZGxlYCkuXG4gKlxuICogQGltcGxlbWVudHMge1BsdWdpbkNsYXNzfVxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBlczZcbiAqIGltcG9ydCBSZWdpb25zUGx1Z2luIGZyb20gJ3dhdmVzdXJmZXIucmVnaW9ucy5qcyc7XG4gKlxuICogLy8gY29tbW9uanNcbiAqIHZhciBSZWdpb25zUGx1Z2luID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5yZWdpb25zLmpzJyk7XG4gKlxuICogLy8gaWYgeW91IGFyZSB1c2luZyA8c2NyaXB0PiB0YWdzXG4gKiB2YXIgUmVnaW9uc1BsdWdpbiA9IHdpbmRvdy5XYXZlU3VyZmVyLnJlZ2lvbnM7XG4gKlxuICogLy8gLi4uIGluaXRpYWxpc2luZyB3YXZlc3VyZmVyIHdpdGggdGhlIHBsdWdpblxuICogdmFyIHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZSh7XG4gKiAgIC8vIHdhdmVzdXJmZXIgb3B0aW9ucyAuLi5cbiAqICAgcGx1Z2luczogW1xuICogICAgIFJlZ2lvbnNQbHVnaW4uY3JlYXRlKHtcbiAqICAgICAgIC8vIHBsdWdpbiBvcHRpb25zIC4uLlxuICogICAgIH0pXG4gKiAgIF1cbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWdpb25zUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBSZWdpb25zIHBsdWdpbiBkZWZpbml0aW9uIGZhY3RvcnlcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGNyZWF0ZSBhIHBsdWdpbiBkZWZpbml0aW9uIHdoaWNoIGNhbiBiZVxuICAgICAqIHVzZWQgYnkgd2F2ZXN1cmZlciB0byBjb3JyZWN0bHkgaW5zdGFudGlhdGUgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaW9uc1BsdWdpblBhcmFtc30gcGFyYW1zIHBhcmFtZXRlcnMgdXNlIHRvIGluaXRpYWxpc2UgdGhlIHBsdWdpblxuICAgICAqIEByZXR1cm4ge1BsdWdpbkRlZmluaXRpb259IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBsdWdpblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAncmVnaW9ucycsXG4gICAgICAgICAgICBkZWZlckluaXQ6IHBhcmFtcyAmJiBwYXJhbXMuZGVmZXJJbml0ID8gcGFyYW1zLmRlZmVySW5pdCA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBzdGF0aWNQcm9wczoge1xuICAgICAgICAgICAgICAgIGluaXRSZWdpb25zKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnRGVwcmVjYXRlZCBpbml0UmVnaW9ucyEgVXNlIHdhdmVzdXJmZXIuaW5pdFBsdWdpbnMoXCJyZWdpb25zXCIpIGluc3RlYWQhJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQbHVnaW4oJ3JlZ2lvbnMnKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWRkUmVnaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdC5yZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQbHVnaW4oJ3JlZ2lvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25zLmFkZChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgY2xlYXJSZWdpb25zKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbnMgJiYgdGhpcy5yZWdpb25zLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGVuYWJsZURyYWdTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0LnJlZ2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBsdWdpbigncmVnaW9ucycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaW9ucy5lbmFibGVEcmFnU2VsZWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBkaXNhYmxlRHJhZ1NlbGVjdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25zLmRpc2FibGVEcmFnU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBSZWdpb25zUGx1Z2luXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocGFyYW1zLCB3cykge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyID0gd3M7XG4gICAgICAgIHRoaXMudXRpbCA9IHdzLnV0aWw7XG5cbiAgICAgICAgLy8gdHVybiB0aGUgcGx1Z2luIGluc3RhbmNlIGludG8gYW4gb2JzZXJ2ZXJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJQcm90b3R5cGVLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXG4gICAgICAgICAgICB0aGlzLnV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIG9ic2VydmVyUHJvdG90eXBlS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBSZWdpb24ucHJvdG90eXBlW2tleV0gPSB0aGlzLnV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIuUmVnaW9uID0gUmVnaW9uO1xuXG4gICAgICAgIC8vIElkLWJhc2VkIGhhc2ggb2YgcmVnaW9ucy5cbiAgICAgICAgdGhpcy5saXN0ID0ge307XG4gICAgICAgIHRoaXMuX29uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLndyYXBwZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbXMucmVnaW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLnJlZ2lvbnMuZm9yRWFjaChyZWdpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChyZWdpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZURyYWdTZWxlY3Rpb24odGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdzIGlzIHJlYWR5XG4gICAgICAgIGlmICh0aGlzLndhdmVzdXJmZXIuaXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5fb25SZWFkeSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5vbigncmVhZHknLCB0aGlzLl9vblJlYWR5KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIudW4oJ3JlYWR5JywgdGhpcy5fb25SZWFkeSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZURyYWdTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKiBBZGQgYSByZWdpb24uICovXG4gICAgYWRkKHBhcmFtcykge1xuICAgICAgICBjb25zdCByZWdpb24gPSBuZXcgdGhpcy53YXZlc3VyZmVyLlJlZ2lvbihwYXJhbXMsIHRoaXMud2F2ZXN1cmZlcik7XG5cbiAgICAgICAgdGhpcy5saXN0W3JlZ2lvbi5pZF0gPSByZWdpb247XG5cbiAgICAgICAgcmVnaW9uLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W3JlZ2lvbi5pZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWdpb247XG4gICAgfVxuXG4gICAgLyogUmVtb3ZlIGFsbCByZWdpb25zLiAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3QpLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0W2lkXS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZW5hYmxlRHJhZ1NlbGVjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgc2xvcCA9IHBhcmFtcy5zbG9wIHx8IDI7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBzY3JvbGwgPVxuICAgICAgICAgICAgcGFyYW1zLnNjcm9sbCAhPT0gZmFsc2UgJiYgdGhpcy53YXZlc3VyZmVyLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbFNwZWVkID0gcGFyYW1zLnNjcm9sbFNwZWVkIHx8IDE7XG4gICAgICAgIGNvbnN0IHNjcm9sbFRocmVzaG9sZCA9IHBhcmFtcy5zY3JvbGxUaHJlc2hvbGQgfHwgMTA7XG4gICAgICAgIGxldCBkcmFnO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgbGV0IG1heFNjcm9sbDtcbiAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICBsZXQgcmVnaW9uO1xuICAgICAgICBsZXQgdG91Y2hJZDtcbiAgICAgICAgbGV0IHB4TW92ZSA9IDA7XG4gICAgICAgIGxldCBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgIGxldCB3cmFwcGVyUmVjdDtcblxuICAgICAgICAvLyBTY3JvbGwgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuICAgICAgICBjb25zdCBlZGdlU2Nyb2xsID0gZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlZ2lvbiB8fCAhc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICBsZXQgc2Nyb2xsTGVmdCA9XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnNjcm9sbExlZnQgKyBzY3JvbGxTcGVlZCAqIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIG1heFNjcm9sbCxcbiAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBzY3JvbGxMZWZ0KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHJhbmdlXG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgcmVnaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWluKGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWF4KGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgbW9yZSB0byBzY3JvbGwgYW5kIHJlcGVhdFxuICAgICAgICAgICAgaWYgKHNjcm9sbExlZnQgPCBtYXhTY3JvbGwgJiYgc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVNjcm9sbChlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBldmVudERvd24gPSBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgdG91Y2hJZCA9IGUudGFyZ2V0VG91Y2hlcyA/IGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gU3RvcmUgZm9yIHNjcm9sbCBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIG1heFNjcm9sbCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAtIHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHdyYXBwZXJSZWN0ID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBkcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCB0cnVlKTtcbiAgICAgICAgICAgIHJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnREb3duKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBldmVudERvd24pO1xuICAgICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBldmVudERvd24pO1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50RG93bik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50VXAgPSBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHB4TW92ZSA9IDA7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGlsLnByZXZlbnRDbGljaygpO1xuICAgICAgICAgICAgICAgIHJlZ2lvbi5maXJlRXZlbnQoJ3VwZGF0ZS1lbmQnLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tdXBkYXRlLWVuZCcsIHJlZ2lvbiwgZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZ2lvbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRVcCk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50VXApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnRVcCk7XG4gICAgICAgIHRoaXMub24oJ2Rpc2FibGUtZHJhZy1zZWxlY3Rpb24nLCAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudFVwKTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnRNb3ZlID0gZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKytweE1vdmUgPD0gc2xvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXIgIT0gdG91Y2hJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLmFkZChwYXJhbXMgfHwge30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgcmVnaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWluKGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWF4KGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBlbmFibGVkXG4gICAgICAgICAgICBpZiAoc2Nyb2xsICYmIGNvbnRhaW5lci5jbGllbnRXaWR0aCA8IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRocmVzaG9sZCBiYXNlZCBvbiBtb3VzZVxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSB3cmFwcGVyUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh4IDw9IHNjcm9sbFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPj0gd3JhcHBlclJlY3QucmlnaHQgLSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gJiYgZWRnZVNjcm9sbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudE1vdmUpO1xuICAgICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnRNb3ZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzYWJsZURyYWdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyogR2V0IGN1cnJlbnQgcmVnaW9uXG4gICAgICogIFRoZSBzbWFsbGVzdCByZWdpb24gdGhhdCBjb250YWlucyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqICBJZiBzZXZlcmFsIHN1Y2ggcmVnaW9ucyBleGlzdCwgd2UgdGFrZSB0aGUgZmlyc3QuXG4gICAgICogIFJldHVybiBudWxsIGlmIG5vbmUgZXhpc3QuICovXG4gICAgZ2V0Q3VycmVudFJlZ2lvbigpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMud2F2ZXN1cmZlci5nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0KS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IHRoaXMubGlzdFtpZF07XG4gICAgICAgICAgICBpZiAoY3VyLnN0YXJ0IDw9IHRpbWUgJiYgY3VyLmVuZCA+PSB0aW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtaW4gfHwgY3VyLmVuZCAtIGN1ci5zdGFydCA8IG1pbi5lbmQgLSBtaW4uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY3VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGxpYlxuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG4vLyBpbml0aWFsIHN0YXRlXG5jb25zdCBpbml0aWFsID0ge1xuXHRudW1iZXI6IDBcbn07XG5cbi8vIGFjdGlvblxuY29uc3Qgc2V0ID0gbnVtYmVyID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgJ2NvdW50ZXInLCB7bnVtYmVyfSk7XG5jb25zdCBpbmNyID0gKCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCAnY291bnRlcicsIHtudW1iZXI6IHN0YXRlLmNvdW50ZXIubnVtYmVyICsgMX0pO1xuY29uc3QgZGVjciA9ICgpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgJ2NvdW50ZXInLCB7bnVtYmVyOiBzdGF0ZS5jb3VudGVyLm51bWJlciAtIDF9KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGluaXRpYWwsXG5cdHNldCxcblx0aW5jcixcblx0ZGVjclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgYXJyfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbi8vIG5hbWVzcGFjZXM9XG5jb25zdCBjb3VudGVyID0gcmVxdWlyZSgnLi9jb3VudGVyJyk7XG5jb25zdCBtaWRpTWFwID0gcmVxdWlyZSgnLi9taWRpLW1hcCcpO1xuXG4vLyBpbml0aWFsXG5jb25zdCBpbml0aWFsID0ge1xuXHRtb2RlOiAxLFxuXHRzdHQ6IGZhbHNlLFxuXHRzdHRNaWM6IGZhbHNlLFxuXHRxdWVyeTogJycsXG5cdHNlc3Npb246IHtcblx0XHRzYW1wbGU6ICdhc3NldHMvTGF0aW5FdGhub0VsZWt0cm9Hcm9vdmUubXAzJyxcblx0XHRwbGF5aW5nOiBmYWxzZSxcblx0XHRmb2N1c2VkOiBbMCwgMF0sXG5cdFx0cGFkczoge31cblx0fSxcblx0c2FtcGxlczoge1xuXHRcdGxpc3Q6IFtdLFxuXHRcdHF1ZXJ5OiB7XG5cdFx0XHRwYWdlOiAxLFxuXHRcdFx0cGF0dGVybjogJycsXG5cdFx0XHRzb3VyY2U6ICdmcmVlc291bmQnLFxuXHRcdFx0bGltaXQ6IDEyXG5cdFx0fVxuXHR9LFxuXHRyYWNrOiB7XG5cdFx0dmNmOiB7XG5cdFx0XHRvbjogZmFsc2UsXG5cdFx0XHR0eXBlOiAnbG93cGFzcycsXG5cdFx0XHRjdXRvZmY6IDAuNjQsXG5cdFx0XHRyZXNvbmFuY2U6IDAsXG5cdFx0XHRnYWluOiAwXG5cdFx0fSxcblx0XHRyZXZlcmI6IHtcblx0XHRcdG9uOiBmYWxzZSxcblx0XHRcdHNlY29uZHM6IDMsXG5cdFx0XHRkZWNheTogMixcblx0XHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdFx0ZHJ5OiAwLjgsXG5cdFx0XHR3ZXQ6IDAuN1xuXHRcdH1cblx0fVxufTtcblxuLy8gYWN0aW9uc1xuY29uc3Qgc2V0ID0gKGtleSwgdmFsdWUpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwga2V5LCB2YWx1ZSk7XG5jb25zdCB0b2dnbGUgPSBrZXkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBrZXksICFvYmouc3ViKHN0YXRlLCBrZXkpKTtcbmNvbnN0IGFyclRvZ2dsZSA9IChrZXksIHZhbHVlKSA9PiBzdGF0ZSA9PlxuXHRvYmoucGF0Y2goc3RhdGUsIGtleSxcblx0XHRhcnIudG9nZ2xlKG9iai5zdWIoc3RhdGUsIGtleSksIHZhbHVlKVxuXHQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aW5pdGlhbCxcblx0Ly8gbmFtZXNwYWNlc1xuXHRtaWRpTWFwLFxuXHQvLyBhY3Rpb25zXG5cdHNldCxcblx0dG9nZ2xlLFxuXHRhcnJUb2dnbGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuLy8gdXRpbFxuY29uc3Qge29iaiwgYXJyfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IGFyck1vZCA9IChhLCBwLCB2KSA9PiBbXS5jb25jYXQoXG5cdGEuc2xpY2UoMCwgcFswXSksXG5cdFtwLmxlbmd0aCA9PT0gMSA/IHYgOiBhcnJNb2QoYVtwWzBdXSwgcC5zbGljZSgxKSwgdildLFxuXHRhLnNsaWNlKHBbMF0gKyAxKVxuKTtcblxuY29uc3QgaW5pdGlhbCA9IHtcblx0ZGV2aWNlczoge1xuXHRcdGlucHV0czogW10sXG5cdFx0b3V0cHV0czogW11cblx0fSxcblx0c2V0dGluZ3M6IHtcblx0XHRtaWRpUm91dGVUb0FjdGl2ZTogdHJ1ZVxuXHR9LFxuXHRjbG9jazoge1xuXHRcdGluOiBbXSxcblx0XHRvdXQ6IFtdXG5cdH0sXG5cdGRhdGE6IHtcblx0XHRpbjogW10sXG5cdFx0b3V0OiBbXVxuXHR9LFxuXHRwaXRjaDogMCxcblx0Y2hhbm5lbHM6IHtcblx0fSxcblx0bWFwOiBbXG5cdFx0Wydjb250cm9sbGVyJywgMjAsIFsnaW5zdHJ1bWVudCcsICd2Y2YnLCAnY3V0b2ZmJ11dLFxuXHRcdFsnY29udHJvbGxlcicsIDIxLCBbJ2luc3RydW1lbnQnLCAndmNmJywgJ3Jlc29uYW5jZSddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyMiwgWydzdHVkaW8nLCAnYnBtJ10sIDYwLCAyMDAsIDBdLFxuXHRcdFsnY29udHJvbGxlcicsIDIzLCBbJ3N0dWRpbycsICd2b2x1bWUnXV0sXG5cdFx0Wydjb250cm9sbGVyJywgMjQsIFsnaW5zdHJ1bWVudCcsICdlZycsICdhdHRhY2snXV0sXG5cdFx0Wydjb250cm9sbGVyJywgMjUsIFsnaW5zdHJ1bWVudCcsICdlZycsICdkZWNheSddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNiwgWydpbnN0cnVtZW50JywgJ2VnJywgJ3N1c3RhaW4nXV0sXG5cdFx0Wydjb250cm9sbGVyJywgMjcsIFsnaW5zdHJ1bWVudCcsICdlZycsICdyZWxlYXNlJ11dXG5cdF1cbn07XG5cbmNvbnN0IGNvbm5lY3QgPSBkZXZpY2VzID0+XG5cdHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgJ21pZGlNYXAnLCB7XG5cdFx0ZGV2aWNlcyxcblx0XHRkYXRhOiB7XG5cdFx0XHQuLi5zdGF0ZS5taWRpTWFwLmRhdGEsXG5cdFx0XHRpbjogc3RhdGUubWlkaU1hcC5kYXRhLmluLmluZGV4T2YoZGV2aWNlcy5pbnB1dHMuZmluZEluZGV4KGRldiA9PiBkZXYubmFtZS5tYXRjaCgvTVBLbWluaTIvKSkpID09PSAtMVxuXHRcdFx0XHQ/IGFyci5hZGQoc3RhdGUubWlkaU1hcC5kYXRhLmluLCBkZXZpY2VzLmlucHV0cy5maW5kSW5kZXgoZGV2ID0+IGRldi5uYW1lLm1hdGNoKC9NUEttaW5pMi8pKSlcblx0XHRcdFx0OiBzdGF0ZS5taWRpTWFwLmRhdGEuaW5cblx0XHR9XG5cdH0pO1xuXG5jb25zdCB0b2dnbGVDbG9jayA9IChpbk91dCwgaW5kZXgpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJywgJ2Nsb2NrJywgaW5PdXRdLFxuXHRhcnIudG9nZ2xlKG9iai5zdWIoc3RhdGUsIFsnbWlkaU1hcCcsICdjbG9jayddKVtpbk91dF0sIGluZGV4KVxuKTtcblxuY29uc3QgdG9nZ2xlRGF0YSA9IChpbk91dCwgaW5kZXgpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJywgJ2RhdGEnLCBpbk91dF0sXG5cdGFyci50b2dnbGUob2JqLnN1YihzdGF0ZSwgWydtaWRpTWFwJywgJ2RhdGEnLCBpbk91dF0pLCBpbmRleClcbik7XG5cbmNvbnN0IG5vdGVPbiA9IChkZXZpY2UgPSAwLCBjaGFubmVsLCBub3RlLCB2ZWxvY2l0eSA9IDApID0+IHN0YXRlID0+IGNoYW5uZWwgIT09IHVuZGVmaW5lZCA/IChcblx0Ly8gY29uc29sZS5sb2coc3RhdGUubWlkaU1hcC5jaGFubmVscywgb2JqLnN1YihzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJywgY2hhbm5lbCwgbm90ZV0pLCBjaGFubmVsLCBub3RlLCB2ZWxvY2l0eSksXG5cdHZlbG9jaXR5ICE9PSAwXG5cdFx0PyBvYmoucGF0Y2goc3RhdGUsIFsnbWlkaU1hcCcsICdjaGFubmVscycsIGRldmljZSwgY2hhbm5lbCwgbm90ZV0sIHZlbG9jaXR5KVxuXHRcdDogb2JqLnBhdGNoKHN0YXRlLCBbJ21pZGlNYXAnLCAnY2hhbm5lbHMnLCBkZXZpY2VdLCB7XG5cdFx0XHRbY2hhbm5lbF06IG9iai5maWx0ZXIoXG5cdFx0XHRcdG9iai5zdWIoc3RhdGUsIFsnbWlkaU1hcCcsICdjaGFubmVscycsIGRldmljZSwgY2hhbm5lbF0pIHx8IHt9LFxuXHRcdFx0XHQoa2V5LCB2YWx1ZSkgPT4ga2V5ICE9PSBub3RlKVxuXHRcdH0pXG5cdCkgOiBzdGF0ZTtcblxuY29uc3QgcGFuaWMgPSAoKSA9PiBzdGF0ZSA9PlxuXHRvYmoucGF0Y2goc3RhdGUsIFsnbWlkaU1hcCcsICdjaGFubmVscyddLCB7fSk7XG5cbmNvbnN0IG1vZGlmeSA9IChwLCB2KSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIFsnbWlkaU1hcCddLCB7XG5cdG1hcDogYXJyTW9kKHN0YXRlLm1pZGlNYXAubWFwLCBwLCB2KVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbml0aWFsLFxuXHRjb25uZWN0LFxuXHR0b2dnbGVDbG9jayxcblx0dG9nZ2xlRGF0YSxcblx0bm90ZU9uLFxuXHRwYW5pYyxcblx0bW9kaWZ5XG59O1xuIiwiXG5pbXBvcnQgUmVnaW9uc1BsdWdpbiBmcm9tICd3YXZlc3VyZmVyLmpzL3NyYy9wbHVnaW4vcmVnaW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4dFdTUmVnaW9uc1BsdWdpbiBleHRlbmRzIFJlZ2lvbnNQbHVnaW4ge1xuXHQvLyBjb25zdHJ1Y3RvcihwYXJhbXMsIHdzKSB7XG5cdC8vIFx0c3VwZXIocGFyYW1zLCB3cyk7XG5cdC8vIH1cblx0c3RhdGljIGNyZWF0ZShwYXJhbXMpIHtcblx0XHRjb25zdCB7c3RhdGljUHJvcHN9ID0gUmVnaW9uc1BsdWdpbi5jcmVhdGUocGFyYW1zKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogJ3JlZ2lvbnMnLFxuXHRcdFx0ZGVmZXJJbml0OiBwYXJhbXMgJiYgcGFyYW1zLmRlZmVySW5pdCA/IHBhcmFtcy5kZWZlckluaXQgOiBmYWxzZSxcblx0XHRcdHBhcmFtcyxcblx0XHRcdHN0YXRpY1Byb3BzLFxuXHRcdFx0aW5zdGFuY2U6IEV4dFdTUmVnaW9uc1BsdWdpblxuXHRcdH07XG5cdH1cblx0YWRkKHBhcmFtcykge1xuXHRcdC8vIGNvbnNvbGUubG9nKHRoaXMucGFyYW1zKTtcblx0XHRpZiAodGhpcy5wYXJhbXMuc2luZ2xlUmVnaW9uID09PSB0cnVlKSB7XG5cdFx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVnaW9uID0gbmV3IHRoaXMud2F2ZXN1cmZlci5SZWdpb24ocGFyYW1zLCB0aGlzLndhdmVzdXJmZXIpO1xuXG5cdFx0dGhpcy5saXN0W3JlZ2lvbi5pZF0gPSByZWdpb247XG5cblx0XHRyZWdpb24ub24oJ3JlbW92ZScsICgpID0+IHtcblx0XHRcdGRlbGV0ZSB0aGlzLmxpc3RbcmVnaW9uLmlkXTtcblx0XHR9KTtcblxuXHRcdHJldHVybiByZWdpb247XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuLy8gaWJsb2t6XG5jb25zdCB2ZG9tID0gcmVxdWlyZSgnaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMnKTtcbmNvbnN0IHtvYmosIGFycn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG4vLyBhcHBcbmNvbnN0IGFwcCA9IHJlcXVpcmUoJy4vdXRpbC9hcHAnKTtcbmxldCBhY3Rpb25zID0gYXBwLmFkYXB0KHJlcXVpcmUoJy4vYWN0aW9ucycpKTtcbmxldCB1aSA9IHJlcXVpcmUoJy4vdWknKTtcbmxldCBhY3Rpb25zJDtcbmNvbnN0IHN0YXRlJCA9IG5ldyBSeC5CZWhhdmlvclN1YmplY3QoKTtcbi8vIHNlcnZpY2VzXG4vLyB3YXZlc3VyZmVyXG5sZXQgd2F2ZXN1cmZlciA9IHJlcXVpcmUoJy4vc2VydmljZXMvd2F2ZXN1cmZlci5qcycpO1xuLy8gc2FtcGxlcyAtIGF1ZGlvY29tbW9uc1xubGV0IHNhbXBsZXMgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3NhbXBsZXMuanMnKTtcbmFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdzYW1wbGVzJywgc2FtcGxlcy5hY3Rpb25zKTtcbi8vIHBhZHNcbmxldCBwYWRzID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9wYWRzLmpzJyk7XG5hY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAncGFkcycsIHBhZHMuYWN0aW9ucyk7XG4vLyBtaWRpXG5sZXQgbWlkaSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWlkaS5qcycpO1xuYWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ21pZGknLCBtaWRpLmFjdGlvbnMpO1xuLy8gc3R0IC0gc3BlYWNoIHRvIHRleHRcbmxldCBzdHQgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3N0dC5qcycpO1xuLy8gY29udHJvbFxubGV0IGNvbnRyb2wgPSByZXF1aXJlKCcuL3NlcnZpY2VzL2NvbnRyb2wuanMnKTtcbmFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdjb250cm9sJywgY29udHJvbC5hY3Rpb25zKTtcblxuLy8gaG90IHJlbG9hZGluZ1xuaWYgKG1vZHVsZS5ob3QpIHtcblx0Ly8gYWN0aW9uc1xuXHRhY3Rpb25zJCA9ICQuZnJvbUV2ZW50UGF0dGVybihcbiAgICBoID0+IG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9hY3Rpb25zXCIsIGgpXG5cdCkuZmxhdE1hcCgoKSA9PiB7XG5cdFx0YWN0aW9ucyA9IGFwcC5hZGFwdChyZXF1aXJlKCcuL2FjdGlvbnMnKSk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3BhZHMnLCBwYWRzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdzYW1wbGVzJywgc2FtcGxlcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnbWlkaScsIG1pZGkuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ2NvbnRyb2wnLCBjb250cm9sLmFjdGlvbnMpO1xuXHRcdHJldHVybiBhY3Rpb25zLnN0cmVhbS5zdGFydFdpdGgoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KS5tZXJnZShhY3Rpb25zLnN0cmVhbSk7XG5cdC8vIHVpXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi91aVwiLCBmdW5jdGlvbigpIHtcblx0XHR1aSA9IHJlcXVpcmUoJy4vdWknKTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcblx0Ly8gc2VydmljZXNcblx0Ly8gd2F2ZXN1cmZlclxuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vc2VydmljZXMvd2F2ZXN1cmZlci5qc1wiLCBmdW5jdGlvbigpIHtcblx0XHR3YXZlc3VyZmVyLnVuaG9vaygpO1xuXHRcdHdhdmVzdXJmZXIgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3dhdmVzdXJmZXIuanMnKTtcblx0XHR3YXZlc3VyZmVyLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xuXHQvLyBzYW1wbGVzXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9zZXJ2aWNlcy9zYW1wbGVzLmpzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHNhbXBsZXMudW5ob29rKCk7XG5cdFx0c2FtcGxlcyA9IHJlcXVpcmUoJy4vc2VydmljZXMvc2FtcGxlcy5qcycpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYWRhcHQocmVxdWlyZSgnLi9hY3Rpb25zJykpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdwYWRzJywgcGFkcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnc2FtcGxlcycsIHNhbXBsZXMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ21pZGknLCBtaWRpLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdjb250cm9sJywgY29udHJvbC5hY3Rpb25zKTtcblx0XHRzYW1wbGVzLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xuXHQvLyBwYWRzXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9zZXJ2aWNlcy9wYWRzLmpzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHBhZHMudW5ob29rKCk7XG5cdFx0cGFkcyA9IHJlcXVpcmUoJy4vc2VydmljZXMvcGFkcy5qcycpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYWRhcHQocmVxdWlyZSgnLi9hY3Rpb25zJykpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdwYWRzJywgcGFkcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnc2FtcGxlcycsIHNhbXBsZXMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ21pZGknLCBtaWRpLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdjb250cm9sJywgY29udHJvbC5hY3Rpb25zKTtcblx0XHRwYWRzLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xuXHQvLyBtaWRpXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9zZXJ2aWNlcy9taWRpLmpzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdG1pZGkudW5ob29rKCk7XG5cdFx0bWlkaSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWlkaS5qcycpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYWRhcHQocmVxdWlyZSgnLi9hY3Rpb25zJykpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdwYWRzJywgcGFkcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnc2FtcGxlcycsIHNhbXBsZXMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ21pZGknLCBtaWRpLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdjb250cm9sJywgY29udHJvbC5hY3Rpb25zKTtcblx0XHRtaWRpLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xuXHQvLyBzdHRcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NlcnZpY2VzL3N0dC5qc1wiLCBmdW5jdGlvbigpIHtcblx0XHRzdHQudW5ob29rKCk7XG5cdFx0c3R0ID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9zdHQuanMnKTtcblx0XHRzdHQuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG5cdC8vIGNvbnRyb2xcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NlcnZpY2VzL2NvbnRyb2wuanNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0Y29udHJvbC51bmhvb2soKTtcblx0XHRjb250cm9sID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9jb250cm9sLmpzJyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hZGFwdChyZXF1aXJlKCcuL2FjdGlvbnMnKSk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3BhZHMnLCBwYWRzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdzYW1wbGVzJywgc2FtcGxlcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnbWlkaScsIG1pZGkuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ2NvbnRyb2wnLCBjb250cm9sLmFjdGlvbnMpO1xuXHRcdGNvbnRyb2wuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG59IGVsc2Uge1xuXHRhY3Rpb25zJCA9IGFjdGlvbnMuc3RyZWFtO1xufVxuXG4vLyBhY3Rpb25zIC0+IHN0YXRlXG5hY3Rpb25zJFxuXHQubWFwKGFjdGlvbiA9PiAoXG5cdFx0YWN0aW9uLnBhdGggJiYgY29uc29sZS5sb2coYWN0aW9uLnBhdGguam9pbignLicpLCBhY3Rpb24ucGF5bG9hZCksXG5cdFx0Y29uc29sZS5sb2coYWN0aW9uKSxcblx0XHRhY3Rpb25cblx0KSlcblx0LnN0YXJ0V2l0aCgoKSA9PiBhY3Rpb25zLmluaXRpYWwpXG5cdC5zY2FuKChzdGF0ZSwgY2hhbmdlKSA9PiBjaGFuZ2Uoc3RhdGUpLCB7fSlcblx0Lm1hcChzdGF0ZSA9PiAoY29uc29sZS5sb2coc3RhdGUpLCBzdGF0ZSkpXG5cdC5zdWJzY3JpYmUoc3RhdGUgPT4gc3RhdGUkLm9uTmV4dChzdGF0ZSkpO1xuXG4vLyBzdGF0ZSAtPiB1aVxuY29uc3QgdWkkID0gc3RhdGUkLm1hcChzdGF0ZSA9PiB1aSh7c3RhdGUsIGFjdGlvbnN9KSk7XG52ZG9tLnBhdGNoU3RyZWFtKHVpJCwgJyN1aScpO1xuXG53YXZlc3VyZmVyLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuc2FtcGxlcy5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcbnBhZHMuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5taWRpLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuc3R0Lmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuY29udHJvbC5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblxuLy8gbGl2ZXJlbG9hZCBpbXBsLlxuaWYgKG1vZHVsZS5ob3QpIHtcblx0ZG9jdW1lbnQud3JpdGUoYDxzY3JpcHQgc3JjPVwiaHR0cDovLyR7KGxvY2F0aW9uLmhvc3QgfHwgJ2xvY2FsaG9zdCcpLnNwbGl0KCc6JylbMF19YCArXG5cdGA6MzU3MjkvbGl2ZXJlbG9hZC5qcz9zbmlwdmVyPTFcIj48L3NjcmlwdD5gKTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGxpYlxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5cbmNvbnN0IGdhbWVwYWQgPSByZXF1aXJlKCcuLi91dGlsL2dhbWVwYWQnKTtcblxubGV0IGFjdGlvbnMgPSB7XG5cdGluaXRpYWw6IHt9XG59O1xuXG5jb25zdCBwbGF5ID0gdXJsID0+IHtcblx0bGV0IGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQVVESU8nKTtcblx0YW4uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIHRydWUpO1xuXHRhbi5zcmMgPSB1cmw7XG59O1xuXG5jb25zdCBrZXlNYXAgPSBbXG5cdFsnNycsICc4JywgJzknLCAnMCddLFxuXHRbJ3UnLCAnaScsICdvJywgJ3AnXSxcblx0WydqJywgJ2snLCAnbCcsICc7J10sXG5cdFsnbScsICcsJywgJy4nLCAnLyddXG5dO1xuXG5jb25zdCBnZXRJbmRleCA9IGtleSA9PiBrZXlNYXAucmVkdWNlKFxuXHQocDEsIGNvbHMsIHJvdykgPT4gcDEucm93ID09PSAtMSA/IGNvbHMucmVkdWNlKFxuXHRcdChwMiwgbWFwS2V5LCBjb2wpID0+IGtleSA9PT0gbWFwS2V5XG5cdFx0XHQ/ICh7cm93LCBjb2x9KVxuXHRcdFx0OiBwMixcblx0XHRwMVxuXHQpIDogcDEsXG5cdHtyb3c6IC0xLCBjb2w6IC0xfVxuKTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXG5cdGdhbWVwYWQuY2hhbmdlcygpXG5cdFx0Lm1hcChwYWRzID0+IChjb25zb2xlLmxvZyh7cGFkc30pLCBwYWRzKSlcblx0XHQud2l0aExhdGVzdEZyb20oc3RhdGUkLCAocGFkcywgc3RhdGUpID0+ICh7cGFkcywgc3RhdGV9KSlcblx0XHQuc3Vic2NyaWJlKCh7cGFkcywgc3RhdGV9KSA9PiB7XG5cdFx0XHRjb25zb2xlLmxvZyhwYWRzWzBdKTtcblx0XHRcdGlmIChwYWRzWzBdKSB7XG5cdFx0XHRcdGlmIChwYWRzWzBdLmF4ZXNbMV0gPT09IC0xKSBhY3Rpb25zLnNhbXBsZXMucHJldigpO1xuXHRcdFx0XHQvLyBpZiAocGFkc1swXS5heGVzWzBdID4gMCkgYWN0aW9ucy5tb3ZlKCdyaWdodCcpO1xuXHRcdFx0XHRpZiAocGFkc1swXS5heGVzWzFdID09PSAxKSBhY3Rpb25zLnNhbXBsZXMubmV4dCgpO1xuXHRcdFx0XHQvLyBpZiAocGFkc1swXS5heGVzWzBdIDwgMCkgYWN0aW9ucy5tb3ZlKCdsZWZ0Jyk7XG5cdFx0XHRcdGlmIChwYWRzWzBdLmJ1dHRvbnNbOF0ucHJlc3NlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGlmIChzdGF0ZS5zYW1wbGVzLmxpc3Rbc3RhdGUuc2FtcGxlcy5pbmRleF0pIHBsYXkoc3RhdGUuc2FtcGxlcy5saXN0W3N0YXRlLnNhbXBsZXMuaW5kZXhdLnNvdW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFkc1swXS5idXR0b25zWzNdLnByZXNzZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRsZXQgc2FtcGxlID0gc3RhdGUuc2FtcGxlcy5saXN0W3N0YXRlLnNhbXBsZXMuaW5kZXhdO1xuXHRcdFx0XHRcdGlmIChzYW1wbGUpIGFjdGlvbnMucGFkcy5sb2FkKHNhbXBsZSwgc2FtcGxlLnNvdW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFkc1swXS5idXR0b25zWzBdLnByZXNzZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRhY3Rpb25zLnNldCgnc3R0TWljJywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhZHNbMF0uYnV0dG9uc1sxXS5wcmVzc2VkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0YWN0aW9ucy5zZXQoJ21vZGUnLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFkc1swXS5idXR0b25zWzJdLnByZXNzZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRhY3Rpb25zLnNldCgnbW9kZScsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0JC5mcm9tRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJylcblx0XHQuZmlsdGVyKGV2ID0+XG5cdFx0XHRbJ2lucHV0JywgJ3RleHRhcmVhJ10uaW5kZXhPZihldi50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTFcblx0XHRcdHx8IGV2LnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgZXYudGFyZ2V0LnR5cGUgPT09ICdyYW5nZSdcblx0XHQpXG5cdFx0LndpdGhMYXRlc3RGcm9tKHN0YXRlJCwgKGV2LCBzdGF0ZSkgPT4gKHtldiwgc3RhdGV9KSlcblx0XHQuc3Vic2NyaWJlKCh7ZXYsIHN0YXRlfSkgPT4ge1xuXHRcdFx0aWYgKGV2LmtleSA+IDAgJiYgZXYua2V5IDwgNCkge1xuXHRcdFx0XHRhY3Rpb25zLnNldCgnbW9kZScsIHBhcnNlSW50KGV2LmtleSwgMTApIC0gMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgcG9zID0gZ2V0SW5kZXgoZXYua2V5KTtcblx0XHRcdFx0Y29uc29sZS5sb2coZXYua2V5LCBldi50YXJnZXQsIHBvcyk7XG5cdFx0XHRcdGlmIChwb3Mucm93ICE9PSAtMSkge1xuXHRcdFx0XHRcdGFjdGlvbnMuc2V0KFsncGFkcycsICdmb2N1c2VkJ10sIFtcblx0XHRcdFx0XHRcdHBvcy5yb3csIHBvcy5jb2xcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRpZiAoc3RhdGUubW9kZSA9PT0gMilcblx0XHRcdFx0XHRcdGFjdGlvbnMubWlkaS50cmlnZ2VyKHBvcy5yb3csIHBvcy5jb2wpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0dW5ob29rID0gKCkgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIuZGlzcG9zZSgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhY3Rpb25zLFxuXHRob29rLFxuXHR1bmhvb2s6ICgpID0+IHVuaG9vaygpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG5jb25zdCBtaWRpID0gcmVxdWlyZSgnLi4vdXRpbC9taWRpJyk7XG5jb25zdCBwb2NrZXQgPSByZXF1aXJlKCcuLi91dGlsL3BvY2tldCcpO1xuY29uc3QgYSA9IHJlcXVpcmUoJy4uL3V0aWwvYXVkaW8nKTtcbmNvbnN0IHNhbXBsZXIgPSByZXF1aXJlKCcuLi91dGlsL2F1ZGlvL3NvdXJjZXMvc2FtcGxlcicpO1xuXG5sZXQgcmV2ZXJiID0gYS5jb25uZWN0KGEuY3JlYXRlKCdyZXZlcmInLCB7XG5cdG9uOiBmYWxzZSxcblx0d2V0OiAwLjEsXG5cdGRyeTogMC45XG59KSwgYS5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxubGV0IHZjZiA9IGEuY29ubmVjdChhLmNyZWF0ZSgndmNmJywge1xuXHRvbjogZmFsc2UsXG5cdHR5cGU6ICdsb3dwYXNzJyxcblx0Y3V0b2ZmOiAwLjY0LFxuXHRyZXNvbmFuY2U6IDAsXG5cdGdhaW46IDBcbn0pLCByZXZlcmIpO1xuXG5jb25zdCByYWNrID0ge1xufTtcblxuY29uc3QgZ2V0SWRzID0gKGlucHV0cywgaW5kZXhlcykgPT4gaW5wdXRzXG5cdC5tYXAoaW5wID0+IGlucC5pZClcblx0LmZpbHRlcigoaWQsIGkpID0+IGluZGV4ZXMuaW5kZXhPZihpKSA+IC0xKTtcblxuY29uc3QgdHJpZ2dlciA9IChyb3csIGNvbCkgPT4gc3RhdGUgPT4ge1xuXHRsZXQgc2FtcGxlSWQgPSBvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2wsICdpZCddKTtcblx0aWYgKHNhbXBsZUlkKSB7XG5cdFx0bGV0IGluc3QgPSBzYW1wbGVyLmNsb25lKHBvY2tldC5nZXQoXG5cdFx0XHRbJ3NhbXBsZUJhbmsnLCBzYW1wbGVJZF1cblx0XHQpKTtcblx0XHRpbnN0ID0gYS5jb25uZWN0KGluc3QsIHN0YXRlLnJhY2sudmNmLm9uXG5cdFx0XHQ/IHZjZlxuXHRcdFx0OiBzdGF0ZS5yYWNrLnJldmVyYi5vblxuXHRcdFx0XHQ/IHJldmVyYlxuXHRcdFx0XHQ6IGEuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0YS5zdGFydChpbnN0KTtcblx0fVxuXHRyZXR1cm4gc3RhdGU7XG59O1xuXG5sZXQgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge30sXG5cdHRyaWdnZXJcbn07XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblxuXHRjb25zdCB7ZGV2aWNlcyQsIG1zZyR9ID0gbWlkaS5pbml0KCk7XG5cblx0Ly8gYXVkaW8gcmFja1xuXHRzdWJzLnB1c2goXG5cdFx0c3RhdGUkLmRpc3RpbmN0VW50aWxDaGFuZ2VkKHN0YXRlID0+IHN0YXRlLnJhY2spXG5cdFx0XHQuc3Vic2NyaWJlKHN0YXRlID0+IHtcblx0XHRcdFx0cmV2ZXJiID0gYS51cGRhdGUocmV2ZXJiLCBzdGF0ZS5yYWNrLnJldmVyYik7XG5cdFx0XHRcdHZjZiA9IGEudXBkYXRlKHZjZiwgc3RhdGUucmFjay52Y2YpO1xuXHRcdFx0XHRpZiAoc3RhdGUucmFjay5yZXZlcmIub24pIHtcblx0XHRcdFx0XHR2Y2YgPSBhLmRpc2Nvbm5lY3QodmNmKTtcblx0XHRcdFx0XHR2Y2YgPSBhLmNvbm5lY3QodmNmLCByZXZlcmIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZjZiA9IGEuZGlzY29ubmVjdCh2Y2YpO1xuXHRcdFx0XHRcdHZjZiA9IGEuY29ubmVjdCh2Y2YsIGEuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdCk7XG5cblx0Ly8gbWlkaSBkZXZpY2UgYWNjZXNzXG5cdHN1YnMucHVzaChcblx0XHRkZXZpY2VzJC5zdWJzY3JpYmUoZGF0YSA9PiBhY3Rpb25zLm1pZGlNYXAuY29ubmVjdChkYXRhKSlcblx0KTtcblxuXHRjb25zdCBwYXJzZWRNaWRpTXNnJCA9IG1zZyRcblx0XHQubWFwKHJhdyA9PiAoe21zZzogbWlkaS5wYXJzZU1pZGlNc2cocmF3Lm1zZyksIHJhd30pKVxuXHRcdC8vIC5tYXAoZGF0YSA9PiAoY29uc29sZS5sb2coZGF0YSksIGRhdGEpKVxuXHRcdC5zaGFyZSgpO1xuXG5cdC8vIG1pZGkgbWVzc2FnZXNcblx0c3Vicy5wdXNoKFxuXHRcdHBhcnNlZE1pZGlNc2ckXG5cdFx0XHQubWFwKG1pZGlEYXRhID0+IChjb25zb2xlLmxvZyh7bWlkaURhdGF9KSwgbWlkaURhdGEpKVxuXHRcdFx0Ly8gLmZpbHRlcigoe21zZ30pID0+IFsnbm90ZU9uJywgJ25vdGVPZmYnXS5pbmRleE9mKG1zZy5zdGF0ZSkgPiAtMSlcblx0XHRcdC5maWx0ZXIoKHttc2d9KSA9PlxuXHRcdFx0XHRtc2cuc3RhdGUgPT09ICdjb250cm9sbGVyJyB8fCBtc2cuc3RhdGUgPT09ICdub3RlT24nXG5cdFx0XHQpXG5cdFx0XHQud2l0aExhdGVzdEZyb20oc3RhdGUkLCAobWlkaURhdGEsIHN0YXRlKSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgbWlkaURhdGEsIHtzdGF0ZX0pKSlcblx0XHRcdC8vIC5maWx0ZXIoKHtyYXcsIHN0YXRlfSkgPT4gKFxuXHRcdFx0Ly8gXHQvLyBjb25zb2xlLmxvZyhyYXcuaW5wdXQuaWQsIHN0YXRlLm1pZGlNYXAuZGV2aWNlcy5pbnB1dHMsIHN0YXRlLm1pZGlNYXAuZGF0YS5pbiksXG5cdFx0XHQvLyBcdGdldElkcyhzdGF0ZS5taWRpTWFwLmRldmljZXMuaW5wdXRzLCBzdGF0ZS5taWRpTWFwLmRhdGEuaW4pLmluZGV4T2YoXG5cdFx0XHQvLyBcdFx0cmF3LmlucHV0LmlkXG5cdFx0XHQvLyBcdCkgPiAtMVxuXHRcdFx0Ly8gKSlcblx0XHRcdC5zdWJzY3JpYmUoKHtyYXcsIG1zZywgc3RhdGV9KSA9PiB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKHN0YXRlLm1pZGlNYXAuZGV2aWNlcy5pbnB1dHMsIHJhdy5pbnB1dCk7XG5cdFx0XHRcdC8vIHRyYWt0b3Jcblx0XHRcdFx0aWYgKG1zZy5jaGFubmVsID09PSAxMyAmJiBtc2cuc3RhdGUgPT09ICdjb250cm9sbGVyJyAmJiBtc2cudmFsdWUgPT09IDEpIHtcblx0XHRcdFx0XHRpZiAobXNnLmNvbnRyb2xsZXIgPj0gMTAgJiYgbXNnLmNvbnRyb2xsZXIgPD0gMjYpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNvbCA9IChtc2cuY29udHJvbGxlciAtIDEwKSAlIDQ7XG5cdFx0XHRcdFx0XHRjb25zdCByb3cgPSAoKG1zZy5jb250cm9sbGVyIC0gMTAgLSBjb2wpIC8gNCk7XG5cdFx0XHRcdFx0XHRsZXQgc2FtcGxlSWQgPSBvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2xdKTtcblx0XHRcdFx0XHRcdC8vIGxldCBpbnN0O1xuXHRcdFx0XHRcdFx0YWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW1xuXHRcdFx0XHRcdFx0XHRyb3csIGNvbFxuXHRcdFx0XHRcdFx0XSk7XG5cdFx0XHRcdFx0XHRpZiAoc3RhdGUubW9kZSA9PT0gMilcblx0XHRcdFx0XHRcdFx0dHJpZ2dlcihyb3csIGNvbCkoc3RhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobXNnLmNvbnRyb2xsZXIgPj0gMzcgJiYgbXNnLmNvbnRyb2xsZXIgPD0gMzkpIHtcblx0XHRcdFx0XHRcdGFjdGlvbnMuc2V0KCdtb2RlJywgbXNnLmNvbnRyb2xsZXIgLSAzNyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtc2cuY2hhbm5lbCA9PT0gMTAgJiYgbXNnLnN0YXRlID09PSAnbm90ZU9uJykge1xuXHRcdFx0XHRcdGNvbnN0IGNvbCA9IChtc2cubm90ZS5udW1iZXIgLSA2MCkgJSA0O1xuXHRcdFx0XHRcdGNvbnN0IHJvdyA9IChtc2cubm90ZS5udW1iZXIgLSA2MCAtIGNvbCkgLyA0ICtcblx0XHRcdFx0XHRcdCgoKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAvIDQgJSAyID09PSAxKVxuXHRcdFx0XHRcdFx0XHQ/IC0xIDogMSk7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAvIDQsIChtc2cubm90ZS5udW1iZXIgLSA2MCAtIGNvbCkgJSAyLCByb3csIGNvbCk7XG5cdFx0XHRcdFx0YWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW1xuXHRcdFx0XHRcdFx0cm93LCBjb2xcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRpZiAoc3RhdGUubW9kZSA9PT0gMilcblx0XHRcdFx0XHRcdHRyaWdnZXIocm93LCBjb2wpKHN0YXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobXNnLmNoYW5uZWwgPT09IDExICYmIG1zZy5zdGF0ZSA9PT0gJ25vdGVPbicpIHtcblx0XHRcdFx0XHRjb25zdCBjb2wgPSAobXNnLm5vdGUubnVtYmVyIC0gNTUpICUgMTA7XG5cdFx0XHRcdFx0Y29uc3Qgcm93ID0gKG1zZy5ub3RlLm51bWJlciAtIDU1IC0gY29sKSAvIDEwO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKChtc2cubm90ZS5udW1iZXIgLSA2MCAtIGNvbCkgLyA0LCAobXNnLm5vdGUubnVtYmVyIC0gNjAgLSBjb2wpICUgMiwgcm93LCBjb2wpO1xuXHRcdFx0XHRcdGFjdGlvbnMuc2V0KFsncGFkcycsICdmb2N1c2VkJ10sIFtcblx0XHRcdFx0XHRcdHJvdywgY29sXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdFx0aWYgKHN0YXRlLm1vZGUgPT09IDIpXG5cdFx0XHRcdFx0XHR0cmlnZ2VyKHJvdywgY29sKShzdGF0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdCk7XG5cblx0dW5ob29rID0gKCkgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIuZGlzcG9zZSgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhY3Rpb25zLFxuXHRob29rLFxuXHR1bmhvb2s6ICgpID0+IHVuaG9vaygpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHBvY2tldCA9IHJlcXVpcmUoJy4uL3V0aWwvcG9ja2V0Jyk7XG5jb25zdCBmaWxlID0gcmVxdWlyZSgnLi4vdXRpbC9maWxlJyk7XG5jb25zdCB7Y29udGV4dH0gPSByZXF1aXJlKCcuLi91dGlsL2F1ZGlvJyk7XG5jb25zdCBzYW1wbGVyID0gcmVxdWlyZSgnLi4vdXRpbC9hdWRpby9zb3VyY2VzL3NhbXBsZXInKTtcblxuY29uc3QgbG9hZCA9IChzYW1wbGUsIHVybCkgPT4gJC5mcm9tUHJvbWlzZShmZXRjaCh1cmwucmVwbGFjZSgnaHR0cDovLycsICcvLycpKVxuXHQudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpKVxuXHQuY29uY2F0TWFwKGJ1ZmZlciA9PiAkLmZyb21DYWxsYmFjayhjb250ZXh0LmRlY29kZUF1ZGlvRGF0YSwgY29udGV4dCkoYnVmZmVyKSlcblx0Lm1hcChidWZmZXIgPT4gKHtcblx0XHRzYW1wbGUsXG5cdFx0bm9kZTogc2FtcGxlci5jcmVhdGUodXJsLCBidWZmZXIpXG5cdH0pKVxuXHQubWFwKCh7c2FtcGxlLCBub2RlfSkgPT4gKFxuXHRcdHBvY2tldC5wdXQoWydzYW1wbGVCYW5rJywgc2FtcGxlLmlkXSwgbm9kZSksXG5cdFx0c3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgLi4uc3RhdGUucGFkcy5mb2N1c2VkXSwgc2FtcGxlKVxuXHQpKTtcblxuY29uc3QgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge1xuXHRcdGZvY3VzZWQ6IFswLCAwXSxcblx0XHRtYXA6IHt9XG5cdH0sXG5cdGxvYWRcbn07XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3QgcG9ja2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9wb2NrZXQnKTtcblxuY29uc3QgdXJsID0gYGh0dHBzOi8vbTIuYXVkaW9jb21tb25zLm9yZy9hcGkvYXVkaW9jbGlwc2A7XG5cbmNvbnN0IHNlYXJjaCA9ICh7cGF0dGVybiwgc291cmNlID0gJ2ZyZWVzb3VuZCcsIGxpbWl0ID0gMTIsIHBhZ2UgPSAxfSkgPT5cblx0cmVxdWVzdC5nZXQoYCR7dXJsfS9zZWFyY2hgKVxuXHRcdC5xdWVyeSh7cGF0dGVybiwgc291cmNlLCBsaW1pdCwgcGFnZX0pXG5cdFx0LnRoZW4ocmVzID0+IHJlcy5ib2R5LnJlc3VsdHMpXG5cdFx0LnRoZW4ocmVzdWx0cyA9PiAoY29uc29sZS5sb2cocmVzdWx0cyksIHJlc3VsdHMpKVxuXHRcdC50aGVuKHJlc3VsdHMgPT4gcmVzdWx0c1swXS5tZW1iZXJzLm1hcChcblx0XHRcdG0gPT4gKHtcblx0XHRcdFx0aWQ6IG0uY29udGVudFsnQGlkJ10sXG5cdFx0XHRcdG5hbWU6IG0uY29udGVudC50aXRsZSxcblx0XHRcdFx0YXV0aG9yOiBtLmNvbnRlbnQuYXV0aG9yLnJlcGxhY2UoJ2ZyZWVzb3VuZC11c2VyczonLCAnJyksXG5cdFx0XHRcdHNvdW5kOiBtLmNvbnRlbnQuYXZhaWxhYmxlQXNbMF0ubG9jYXRvcixcblx0XHRcdFx0aW1hZ2U6IG0uY29udGVudC5pbWFnZXNbMF0ubG9jYXRvcixcblx0XHRcdFx0bGljZW5zZTogbS5jb250ZW50LmxpY2Vuc2UsXG5cdFx0XHRcdGR1cmF0aW9uOiBtLmNvbnRlbnQuZHVyYXRpb25cblx0XHRcdH0pXG5cdFx0KSlcblx0XHQudGhlbihsaXN0ID0+IChcblx0XHRcdHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydzYW1wbGVzJ10sIHtcblx0XHRcdFx0bGlzdDogcGFnZSA+IDEgPyBbXS5jb25jYXQoc3RhdGUuc2FtcGxlcy5saXN0LCBsaXN0KSA6IGxpc3QsXG5cdFx0XHRcdHF1ZXJ5OiB7cGF0dGVybiwgc291cmNlLCBsaW1pdCwgcGFnZX19KVxuXHRcdCkpO1xuXG5jb25zdCBuZXh0ID0gKCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ3NhbXBsZXMnXSwge1xuXHRpbmRleDogc3RhdGUuc2FtcGxlcy5pbmRleCA8IHN0YXRlLnNhbXBsZXMubGlzdC5sZW5ndGggLSAxXG5cdFx0PyBzdGF0ZS5zYW1wbGVzLmluZGV4ICsgMVxuXHRcdDogc3RhdGUuc2FtcGxlcy5pbmRleFxufSk7XG5cbmNvbnN0IHByZXYgPSAoKSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIFsnc2FtcGxlcyddLCB7XG5cdGluZGV4OiBzdGF0ZS5zYW1wbGVzLmluZGV4ID4gMCA/IHN0YXRlLnNhbXBsZXMuaW5kZXggLSAxIDogc3RhdGUuc2FtcGxlcy5pbmRleFxufSk7XG5cbmNvbnN0IGFjdGlvbnMgPSB7XG5cdGluaXRpYWw6IHtcblx0XHRsaXN0OiBbXSxcblx0XHRpbmRleDogMFxuXHR9LFxuXHRzZWFyY2gsXG5cdG5leHQsXG5cdHByZXZcbn07XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblx0dW5ob29rID0gKCkgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIuZGlzcG9zZSgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhY3Rpb25zLFxuXHRob29rLFxuXHR1bmhvb2s6ICgpID0+IHVuaG9vaygpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG5cbmNvbnN0IFNwZWVjaFNESyA9IHdpbmRvdy5TcGVlY2hTREs7XG5cbmNvbnN0IHN1YnNjcmlwdGlvbktleSA9ICdjNjMwNTdlMTIxOTQ0MTQ4OWMxYjQzMTMyNjg1YzRiOCc7XG5jb25zdCByZWdpb24gPSAnd2VzdHVzJztcbmNvbnN0IHVybCA9IGBodHRwczovLyR7cmVnaW9ufS5hcGkuY29nbml0aXZlLm1pY3Jvc29mdC5jb20vc3RzL3YxLjAvaXNzdWVUb2tlbmA7XG5cbmNvbnN0IGluaXQgPSB0b2tlbiA9PiB7XG5cdGxldCBzcGVlY2hDb25maWcgPSBTcGVlY2hTREsuU3BlZWNoQ29uZmlnLmZyb21BdXRob3JpemF0aW9uVG9rZW4odG9rZW4sIHJlZ2lvbik7XG5cdHNwZWVjaENvbmZpZy5zcGVlY2hSZWNvZ25pdGlvbkxhbmd1YWdlID0gXCJlbi1HQlwiO1xuXHRsZXQgYXVkaW9Db25maWcgPSBTcGVlY2hTREsuQXVkaW9Db25maWcuZnJvbURlZmF1bHRNaWNyb3Bob25lSW5wdXQoKTtcblx0bGV0IHJlY29nbml6ZXIgPSBuZXcgU3BlZWNoU0RLLlNwZWVjaFJlY29nbml6ZXIoc3BlZWNoQ29uZmlnLCBhdWRpb0NvbmZpZyk7XG5cdHJldHVybiByZWNvZ25pemVyO1xufTtcblxuY29uc3QgcmVjb2duaXplID0gcmVjb2duaXplciA9PlxuXHQkLmZyb21DYWxsYmFjayhyZWNvZ25pemVyLnJlY29nbml6ZU9uY2VBc3luYywgcmVjb2duaXplcikoKVxuXHQubWFwKHJlcyA9PiAoY29uc29sZS5sb2cocmVzKSwgcmVzKSk7XG5cbmxldCB1bmhvb2sgPSAoKSA9PiB7fTtcbmNvbnN0IGhvb2sgPSAoe3N0YXRlJCwgYWN0aW9uc30pID0+IHtcblx0bGV0IHN1YnMgPSBbXTtcblxuXHRyZXF1ZXN0XG5cdFx0LnBvc3QodXJsKVxuXHRcdC5zZXQoe1xuXHRcdFx0J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcblx0XHRcdCdPY3AtQXBpbS1TdWJzY3JpcHRpb24tS2V5Jzogc3Vic2NyaXB0aW9uS2V5XG5cdFx0fSlcblx0XHQudGhlbihyZXMgPT4gYWN0aW9ucy5zZXQoJ3N0dCcsIHJlcy50ZXh0KSk7XG5cblx0c3RhdGUkLmRpc3RpbmN0VW50aWxDaGFuZ2VkKHN0YXRlID0+IHN0YXRlLnN0dCArICcgJyArIHN0YXRlLnN0dE1pYylcblx0XHQuZmlsdGVyKHN0YXRlID0+IHN0YXRlLnN0dCAmJiBzdGF0ZS5zdHRNaWMpXG5cdFx0Lm1hcChzdGF0ZSA9PiBpbml0KHN0YXRlLnN0dCkpXG5cdFx0LmZsYXRNYXAocmVjb2duaXplKVxuXHRcdC5zdWJzY3JpYmUocmVzID0+IHtcblx0XHRcdGxldCBwYXR0ZXJuID0gcmVzLnByaXZUZXh0LnJlcGxhY2UoL1xcLiQvLCAnJyk7XG5cdFx0XHRhY3Rpb25zLnNhbXBsZXMuc2VhcmNoKHtwYXR0ZXJufSk7XG5cdFx0XHRhY3Rpb25zLnNldCgnc3R0TWljJywgZmFsc2UpO1xuXHRcdH0pO1xuXG5cdHVuaG9vayA9ICgpID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViLmRpc3Bvc2UoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aG9vayxcblx0dW5ob29rOiAoKSA9PiB1bmhvb2soKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGxpYlxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5cbmNvbnN0IFdhdmVTdXJmZXIgPSByZXF1aXJlKCd3YXZlc3VyZmVyLmpzJyk7XG4vLyB3aW5kb3cuV2F2ZVN1cmZlciA9IFdhdmVTdXJmZXI7XG5jb25zdCBUaW1lbGluZVBsdWdpbiA9IHJlcXVpcmUoJ3dhdmVzdXJmZXIuanMvZGlzdC9wbHVnaW4vd2F2ZXN1cmZlci50aW1lbGluZS5taW4uanMnKTtcbmNvbnN0IEV4dFdTUmVnaW9uc1BsdWdpbiA9IHJlcXVpcmUoJy4uL2V4dC93cy9yZWdpb25zLmpzJykuZGVmYXVsdDtcbi8vIGNvbnNvbGUubG9nKFJlZ2lvbnNQbHVnaW4pO1xuLy8gcmVxdWlyZSgnd2F2ZXN1cmZlci9wbHVnaW4vd2F2ZXN1cmZlci50aW1lbGluZS5qcycpO1xuLy8gV2F2ZVN1cmZlciA9IHdpbmRvdy5XYXZlU3VyZmVyO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCBwb2NrZXQgPSByZXF1aXJlKCcuLi91dGlsL3BvY2tldCcpO1xuXG5jb25zdCBpbml0ID0gY29udGFpbmVyID0+IHtcblx0Y29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXHRsZXQgd2F2ZXN1cmZlciA9IFdhdmVTdXJmZXIuY3JlYXRlKHtcblx0XHRjb250YWluZXI6ICcjd2F2ZWZvcm0nLFxuXHRcdHdhdmVDb2xvcjogJyMwMDAnLFxuXHRcdHByb2dyZXNzQ29sb3I6ICcjMTExNTE2Jyxcblx0XHRwbHVnaW5zOiBbXG5cdFx0XHRUaW1lbGluZVBsdWdpbi5jcmVhdGUoe1xuXHRcdFx0XHRjb250YWluZXI6ICcjd2F2ZS10aW1lbGluZSdcblx0XHRcdFx0Ly8gZGVmZXJJbml0OiB0cnVlIC8vIHN0b3AgdGhlIHBsdWdpbiBmcm9tIGluaXRpYWxpc2luZyBpbW1lZGlhdGVseVxuXHRcdFx0fSksXG5cdFx0XHRFeHRXU1JlZ2lvbnNQbHVnaW4uY3JlYXRlKHtcblx0XHRcdFx0ZHJhZ1NlbGVjdGlvbjogdHJ1ZSxcblx0XHRcdFx0c2luZ2xlUmVnaW9uOiB0cnVlXG5cdFx0XHRcdC8vIHBsdWdpbiBvcHRpb25zIC4uLlxuXHRcdFx0fSlcblx0XHRdXG5cdH0pO1xuXHQvLyB3YXZlc3VyZmVyLmxvYWQoJ2Fzc2V0cy9MYXRpbkV0aG5vRWxla3Ryb0dyb292ZS5tcDMnKTtcblx0cmV0dXJuIHdhdmVzdXJmZXI7XG59O1xuXG5jb25zdCBsb2FkID0gKHt3YXZlc3VyZmVyLCBzYW1wbGV9KSA9PiB7XG5cdGNvbnNvbGUubG9nKHdhdmVzdXJmZXIsIHNhbXBsZSwgcG9ja2V0KTtcblx0aWYgKHNhbXBsZVswXSA9PT0gJ3VybCcpIHdhdmVzdXJmZXIubG9hZChzYW1wbGVbMV0pO1xuXHRlbHNlIGlmIChzYW1wbGVbMV0pXG5cdFx0d2F2ZXN1cmZlci5sb2FkRGVjb2RlZEJ1ZmZlcihcblx0XHRcdHBvY2tldC5nZXQoWydzYW1wbGVCYW5rJywgc2FtcGxlWzFdXSkub3V0cHV0LmJ1ZmZlclxuXHRcdCk7XG5cdHJldHVybiB3YXZlc3VyZmVyO1xufTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXG5cdGxldCB3YXZlc3VyZmVyJCA9ICQuaW50ZXJ2YWwoMTAwKVxuXHRcdC5tYXAoKCkgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3dhdmVmb3JtJykpXG5cdFx0LmRpc3RpbmN0VW50aWxDaGFuZ2VkKGVsID0+IGVsKVxuXHRcdC5maWx0ZXIoZWwgPT4gZWwpXG5cdFx0Lm1hcChpbml0KTtcblxuXHRsZXQgc2FtcGxlQ2hhbmdlJCA9IHN0YXRlJFxuXHRcdC5kaXN0aW5jdFVudGlsQ2hhbmdlZChzdGF0ZSA9PlxuXHRcdFx0c3RhdGUucGFkcy5mb2N1c2VkLnRvU3RyaW5nKCkgK1xuXHRcdFx0XHQnICcgKyBvYmouc3ViKHN0YXRlLnBhZHMsIFsnbWFwJywgLi4uc3RhdGUucGFkcy5mb2N1c2VkLCAnaWQnXSlcblx0XHQpXG5cdFx0Lm1hcChzdGF0ZSA9PiAoWydpZCcsIG9iai5zdWIoc3RhdGUucGFkcy5tYXAsIFsuLi5zdGF0ZS5wYWRzLmZvY3VzZWQsICdpZCddKV0pKVxuXHRcdC5zdGFydFdpdGgoKFsndXJsJywgJ2Fzc2V0cy9MYXRpbkV0aG5vRWxla3Ryb0dyb292ZS5tcDMnXSkpO1xuXG5cdHdhdmVzdXJmZXIkXG5cdFx0LmZsYXRNYXAod2F2ZXN1cmZlciA9PlxuXHRcdFx0JC5tZXJnZShcblx0XHRcdFx0c2FtcGxlQ2hhbmdlJFxuXHRcdFx0XHRcdC5tYXAoc2FtcGxlID0+IHdhdmVzdXJmZXIgPT4gbG9hZCh7d2F2ZXN1cmZlciwgc2FtcGxlfSkpLFxuXHRcdFx0XHRzdGF0ZSRcblx0XHRcdFx0XHQuZGlzdGluY3RVbnRpbENoYW5nZWQoc3RhdGUgPT4gc3RhdGUuc2Vzc2lvbi5wbGF5aW5nKVxuXHRcdFx0XHRcdC5tYXAoc3RhdGUgPT4gd2F2ZXN1cmZlciA9PiAod2F2ZXN1cmZlci5wbGF5UGF1c2UoKSwgd2F2ZXN1cmZlcikpXG5cdFx0XHQpXG5cdFx0XHQuc2Nhbigod2F2ZXN1cmZlciwgcmVkdWNlcikgPT4gcmVkdWNlcih3YXZlc3VyZmVyKSwgd2F2ZXN1cmZlcilcblx0XHQpXG5cdFx0LnN1YnNjcmliZShkYXRhID0+IHt9KTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0c2VjdGlvbiwgc3BhbiwgYSwgZGl2LCBwcmUsIGltZywgaSxcblx0Zm9ybSwgaW5wdXQsIGJ1dHRvbiwgbGFiZWwsIHNlbGVjdCwgb3B0aW9uLFxuXHR1bCwgbGksIHRhYmxlLCB0Ym9keSwgdGhlYWQsIHRyLCB0ZCwgdGhcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5jb25zdCBmb3JtVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybScpO1xuY29uc3Qge2ZuLCBvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3QgcGxheSA9IHVybCA9PiB7XG5cdGxldCBhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0FVRElPJyk7XG5cdGFuLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCB0cnVlKTtcblx0YW4uc3JjID0gdXJsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe3N0YXRlLCBhY3Rpb25zfSkgPT4gc2VjdGlvbignI2JvYXJkJywgW10uY29uY2F0KFxuXHRmb3JtKCcjYm9hcmQtc2VhcmNoJywge1xuXHRcdG9uOiB7XG5cdFx0XHRzdWJtaXQ6IGV2ID0+IHtcblx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0bGV0IGRhdGEgPSBmb3JtVXRpbC50b0RhdGEoZXYudGFyZ2V0KTtcblx0XHRcdFx0Y29uc29sZS5sb2coZGF0YSk7XG5cdFx0XHRcdGFjdGlvbnMuc2FtcGxlcy5zZWFyY2goZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCBbXG5cdFx0aW5wdXQoYFt0eXBlPVwiaGlkZGVuXCJdW25hbWU9XCJwYWdlXCJdW3ZhbHVlPTFdYCksXG5cdFx0aW5wdXQoYCNib2FyZC1zZWFyY2gtcGF0dGVybltuYW1lPVwicGF0dGVyblwiXVtwbGFjZWhvbGRlcj1cIlF1ZXJ5XCJdYCwge1xuXHRcdFx0YXR0cnM6IHtcblx0XHRcdFx0dmFsdWU6IHN0YXRlLnNhbXBsZXMucXVlcnkucGF0dGVyblxuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdHNlbGVjdChgW25hbWU9XCJzb3VyY2VcIl1gLCBbJ2ZyZWVzb3VuZCcsICdqYW1lbmRvJywgJ2V1cm9wZWFuYSddLm1hcChcblx0XHRcdHMgPT4gb3B0aW9uKGBbdmFsdWU9XCIke3N9XCJdYCwgcylcblx0XHQpKSxcblx0XHRidXR0b24oJ1NlYXJjaCcpXG5cdF0pLFxuXHQoc3RhdGUuc2FtcGxlcy5saXN0Lmxlbmd0aCA+IDApID8gdWwoJyNib2FyZC1zYW1wbGVzJywgW10uY29uY2F0KFxuXHRcdHN0YXRlLnNhbXBsZXMubGlzdC5tYXAoKHNhbXBsZSwgaW5kZXgpID0+XG5cdFx0XHRsaSh7XG5cdFx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdFx0c2VsZWN0ZWQ6IGluZGV4ID09PSBzdGF0ZS5zYW1wbGVzLmluZGV4XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtcblx0XHRcdFx0aW1nKGAud2F2ZVtzcmM9XCIke3NhbXBsZS5pbWFnZX1cIl1gKSxcblx0XHRcdFx0c3BhbignLm5hbWUnLCB7XG5cdFx0XHRcdFx0b246IHtcblx0XHRcdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnNldChbJ3NhbXBsZXMnLCAnaW5kZXgnXSwgaW5kZXgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBzYW1wbGUubmFtZSksXG5cdFx0XHRcdGEoYC5hdXRob3JbdGl0bGU9XCIke3NhbXBsZS5hdXRob3J9XCJdYCwgaSgnLmZhLmZhLXVzZXInKSksXG5cdFx0XHRcdHNwYW4oJy5kdXJhdGlvbicsIGAkeyhzYW1wbGUuZHVyYXRpb24gLyAxMDAwKS50b0ZpeGVkKDIpfSBzYCksXG5cdFx0XHRcdGEoYC5saWNlbnNlW3RhcmdldD1cIl9ibGFua1wiXVtocmVmPVwiJHtzYW1wbGUubGljZW5zZX1cIl1gLFxuXHRcdFx0XHRcdGZuLnBpcGUoXG5cdFx0XHRcdFx0XHQoKSA9PiBzYW1wbGUubGljZW5zZS5yZXBsYWNlKCdodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy8nLCAnJyksXG5cdFx0XHRcdFx0XHRsaWNlbnNlID0+IG9iai5zd2l0Y2gobGljZW5zZSwge1xuXHRcdFx0XHRcdFx0XHQnZGVmYXVsdCc6IGxpY2Vuc2UsXG5cdFx0XHRcdFx0XHRcdCdsaWNlbnNlcy9ieS8zLjAvJzogW1xuXHRcdFx0XHRcdFx0XHRcdGkoYC5jYy5jYy1jYy5jYy0yeGApLFxuXHRcdFx0XHRcdFx0XHRcdGkoYC5jYy5jYy1ieS5jYy0yeGApXG5cdFx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRcdCdwdWJsaWNkb21haW4vemVyby8xLjAvJzogW1xuXHRcdFx0XHRcdFx0XHRcdGkoYC5jYy5jYy1jYy5jYy0yeGApLFxuXHRcdFx0XHRcdFx0XHRcdGkoYC5jYy5jYy16ZXJvLmNjLTJ4YClcblx0XHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdFx0J2xpY2Vuc2VzL2J5LW5jLzMuMC8nOiBbXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLWNjLmNjLTJ4YCksXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLWJ5LmNjLTJ4YCksXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLW5jLmNjLTJ4YClcblx0XHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdFx0J2xpY2Vuc2VzL3NhbXBsaW5nKy8xLjAvJzogW1xuXHRcdFx0XHRcdFx0XHRcdGkoYC5jYy5jYy1jYy5jYy0yeGApXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdCksXG5cdFx0XHRcdHNwYW4oJy5jb250cm9scycsIFtcblx0XHRcdFx0XHRidXR0b24oe1xuXHRcdFx0XHRcdFx0b246IHtcblx0XHRcdFx0XHRcdFx0Y2xpY2s6ICgpID0+IHBsYXkoc2FtcGxlLnNvdW5kKSxcblx0XHRcdFx0XHRcdFx0dG91Y2hzdGFydDogKCkgPT4gcGxheShzYW1wbGUuc291bmQpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgaSgnLmZhLmZhLXBsYXknKSksXG5cdFx0XHRcdFx0YnV0dG9uKHtcblx0XHRcdFx0XHRcdG9uOiB7XG5cdFx0XHRcdFx0XHRcdGNsaWNrOiBldiA9PiBhY3Rpb25zLnBhZHMubG9hZChzYW1wbGUsIHNhbXBsZS5zb3VuZCksXG5cdFx0XHRcdFx0XHRcdHRvdWNoc3RhcnQ6IGV2ID0+IGFjdGlvbnMucGFkcy5sb2FkKHNhbXBsZSwgc2FtcGxlLnNvdW5kKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIGkoJy5mYS5mYS1wbHVzJykpLFxuXHRcdFx0XHRcdGEoe1xuXHRcdFx0XHRcdFx0YXR0cnM6IHtcblx0XHRcdFx0XHRcdFx0aHJlZjogc2FtcGxlLnNvdW5kLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQ6ICdfYmxhbmsnXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgaSgnLmZhLmZhLWRvd25sb2FkJykpXG5cdFx0XHRcdF0pXG5cdFx0XHRdKSksXG5cdFx0bGkoYnV0dG9uKGAuZnVsbGAsIHtcblx0XHRcdG9uOiB7XG5cdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnNhbXBsZXMuc2VhcmNoKHsuLi5zdGF0ZS5zYW1wbGVzLnF1ZXJ5LCBwYWdlOiBzdGF0ZS5zYW1wbGVzLnF1ZXJ5LnBhZ2UgKyAxfSlcblx0XHRcdH1cblx0XHR9LCAnTG9hZCBtb3JlIHNhbXBsZXMuLi4nKSlcblx0KSkgOiBbXVxuKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0c2VjdGlvbiwgYnV0dG9uLCBzcGFuLCBoZWFkZXIsIGgxLFxuXHR1bCwgbGksIGksIGltZ1xufSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtzdGF0ZSwgYWN0aW9uc30pID0+IGhlYWRlcihbXG5cdHVsKCcubGVmdCcsIFtcblx0XHRsaShidXR0b24oe1xuXHRcdFx0b246IHtcblx0XHRcdFx0Y2xpY2s6ICgpID0+IGFjdGlvbnMuc2V0KCdtb2RlJywgMClcblx0XHRcdH0sXG5cdFx0XHRjbGFzczoge1xuXHRcdFx0XHRzZWxlY3RlZDogc3RhdGUubW9kZSA9PT0gMFxuXHRcdFx0fVxuXHRcdH0sIGltZyhgW3NyYz1cImFzc2V0cy9pY29ucy9taWRpLnN2Z1wiXWApKSksXG5cdFx0bGkoYnV0dG9uKHtcblx0XHRcdG9uOiB7XG5cdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnNldCgnbW9kZScsIDEpXG5cdFx0XHR9LFxuXHRcdFx0Y2xhc3M6IHtcblx0XHRcdFx0c2VsZWN0ZWQ6IHN0YXRlLm1vZGUgPT09IDFcblx0XHRcdH1cblx0XHR9LCBpKCcuZmEuZmEtZWRpdCcpKSksXG5cdFx0bGkoYnV0dG9uKHtcblx0XHRcdG9uOiB7XG5cdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnNldCgnbW9kZScsIDIpXG5cdFx0XHR9LFxuXHRcdFx0Y2xhc3M6IHtcblx0XHRcdFx0c2VsZWN0ZWQ6IHN0YXRlLm1vZGUgPT09IDJcblx0XHRcdH1cblx0XHR9LCBpKCcuZmEuZmEtbXVzaWMnKSkpXG5cdF0pLFxuXHRoMSgneEFtcGxSJyksXG5cdHVsKCcucmlnaHQnLCBbXG5cdFx0bGkoYnV0dG9uKHtcblx0XHRcdG9uOiB7XG5cdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnNldCgnc3R0TWljJywgdHJ1ZSlcblx0XHRcdH0sXG5cdFx0XHRjbGFzczoge1xuXHRcdFx0XHRzZWxlY3RlZDogc3RhdGUuc3R0TWljXG5cdFx0XHR9XG5cdFx0fSwgaSgnLmZhLmZhLXZvbHVtZS1jb250cm9sLXBob25lJykpKVxuXHRdKVxuXSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGRvbVxuY29uc3Qge1xuXHRoMSwgYSwgZGl2LCBpLFxuXHRzZWN0aW9uLCBidXR0b24sIHNwYW5cbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuLy8gY29tcG9uZW50c1xuY29uc3QgaGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXInKTtcbmNvbnN0IGJvYXJkID0gcmVxdWlyZSgnLi9ib2FyZCcpO1xuY29uc3QgcGFkcyA9IHJlcXVpcmUoJy4vcGFkcycpO1xuY29uc3QgcmFjayA9IHJlcXVpcmUoJy4vcmFjaycpO1xuY29uc3Qgd2F2ZWRpdG9yID0gcmVxdWlyZSgnLi93YXZlZGl0b3InKTtcbi8vIGNvbnN0IGNvdW50ZXIgPSByZXF1aXJlKCcuL2NvdW50ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe3N0YXRlLCBhY3Rpb25zfSkgPT4gc2VjdGlvbignI3VpJywgW1xuXHRoZWFkZXIoe3N0YXRlLCBhY3Rpb25zfSksXG5cdHdhdmVkaXRvcih7c3RhdGUsIGFjdGlvbnN9KSxcblx0Ym9hcmQoe3N0YXRlLCBhY3Rpb25zfSksXG5cdHBhZHMoe3N0YXRlLCBhY3Rpb25zfSksXG5cdHJhY2soe3N0YXRlLCBhY3Rpb25zfSlcbl0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG5cdHNlY3Rpb24sIHNwYW4sIGEsIGRpdiwgcHJlLCBpbWcsIGksXG5cdGZvcm0sIGlucHV0LCBidXR0b24sIGxhYmVsLFxuXHR1bCwgbGksIHRhYmxlLCB0Ym9keSwgdGhlYWQsIHRyLCB0ZCwgdGhcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtzdGF0ZSwgYWN0aW9uc30pID0+IHNlY3Rpb24oJyNwYWRzJyxcblx0ZGl2KCcucm93cycsIEFycmF5KDQpLmZpbGwoe30pLm1hcCgoYSwgcm93KSA9PlxuXHRcdGRpdignLmNvbHMnLCBBcnJheSg0KS5maWxsKHt9KS5tYXAoKGEsIGNvbCkgPT5cblx0XHRcdGJ1dHRvbignLnBhZCcsIHtcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHQuLi4ob2JqLnN1YihzdGF0ZSwgWydwYWRzJywgJ21hcCcsIHJvdywgY29sLCAnaWQnXSlcblx0XHRcdFx0XHRcdD8ge2JhY2tncm91bmRJbWFnZTogYHVybCgke29iai5zdWIoc3RhdGUsIFsncGFkcycsICdtYXAnLCByb3csIGNvbCwgJ2ltYWdlJ10pfSlgfVxuXHRcdFx0XHRcdFx0OiB7fSlcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xhc3M6IHtcblx0XHRcdFx0XHRmb2N1c2VkOiBzdGF0ZS5wYWRzLmZvY3VzZWRbMF0gPT09IHJvdyAmJiBzdGF0ZS5wYWRzLmZvY3VzZWRbMV0gPT09IGNvbCxcblx0XHRcdFx0XHRhc3NpZ25lZDogb2JqLnN1YihzdGF0ZSwgWydwYWRzJywgJ21hcCcsIHJvdywgY29sLCAnaWQnXSlcblx0XHRcdFx0fSxcblx0XHRcdFx0b246IHtcblx0XHRcdFx0XHRmb2N1czogKCkgPT4gYWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW3JvdywgY29sXSksXG5cdFx0XHRcdFx0bW91c2Vkb3duOiAoKSA9PiAoXG5cdFx0XHRcdFx0XHRzdGF0ZS5tb2RlID09PSAyICYmIGFjdGlvbnMubWlkaS50cmlnZ2VyKHJvdywgY29sKSxcblx0XHRcdFx0XHRcdHN0YXRlLm1vZGUgPT09IDEgJiYgYWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW3JvdywgY29sXSlcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdHRvdWNoc3RhcnQ6ICgpID0+IChcblx0XHRcdFx0XHRcdHN0YXRlLm1vZGUgPT09IDIgJiYgYWN0aW9ucy5taWRpLnRyaWdnZXIocm93LCBjb2wpLFxuXHRcdFx0XHRcdFx0c3RhdGUubW9kZSA9PT0gMSAmJiBhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbcm93LCBjb2xdKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0fVxuXHRcdFx0fSwgb2JqLnN1YihzdGF0ZSwgWydwYWRzJywgJ21hcCcsIHJvdywgY29sLCAnbmFtZSddKSB8fCAnJylcblx0XHQpKVxuXHQpKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuXHRzZWN0aW9uLCBzcGFuLCBhLCBkaXYsIHByZSwgaW1nLCBpLFxuXHRmb3JtLCBpbnB1dCwgYnV0dG9uLCBsYWJlbCxcblx0dWwsIGxpLCB0YWJsZSwgdGJvZHksIHRoZWFkLCB0ciwgdGQsIHRoXG59ID0gcmVxdWlyZSgnaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMnKTtcblxuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3QgdmNmID0gcmVxdWlyZSgnLi92Y2YnKTtcbmNvbnN0IHJldmVyYiA9IHJlcXVpcmUoJy4vcmV2ZXJiJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtzdGF0ZSwgYWN0aW9uc30pID0+IHNlY3Rpb24oJyNyYWNrJywgW10uY29uY2F0KFxuXHR2Y2Yoe1xuXHRcdG5hbWU6ICd2Y2YnLFxuXHRcdHByb3BzOiBzdGF0ZS5yYWNrLnZjZixcblx0XHR1cGRhdGU6IChwYXRoLCB2YWx1ZSkgPT4gYWN0aW9ucy5zZXQoW10uY29uY2F0KFsncmFjaycsICd2Y2YnXSwgcGF0aCksIHZhbHVlKVxuXHR9KSxcblx0cmV2ZXJiKHtcblx0XHRuYW1lOiAncmV2ZXJiJyxcblx0XHRwcm9wczogc3RhdGUucmFjay5yZXZlcmIsXG5cdFx0dXBkYXRlOiAocGF0aCwgdmFsdWUpID0+IGFjdGlvbnMuc2V0KFtdLmNvbmNhdChbJ3JhY2snLCAncmV2ZXJiJ10sIHBhdGgpLCB2YWx1ZSlcblx0fSlcbikpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG5cdGRpdiwgaDIsIHNwYW4sIHAsIHVsLCBsaSwgaHIsIGJ1dHRvbiwgYnIsXG5cdGZvcm0sIGxhYmVsLCBpbnB1dCwgZmllbGRzZXQsIGxlZ2VuZCwgaSwgaW1nXG59ID0gcmVxdWlyZSgnaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe25hbWUgPSAncmV2ZXJiJywgcHJvcHMsIHVwZGF0ZX0pID0+IGZpZWxkc2V0KFtcblx0bGVnZW5kKFtcblx0XHRzcGFuKCcub24nLCBbXG5cdFx0XHRuYW1lLnRvVXBwZXJDYXNlKClcblx0XHRdKVxuXHRdKSxcblx0ZGl2KCcub24tc3dpdGNoLmZhJywge1xuXHRcdG9uOiB7Y2xpY2s6IGV2ID0+IHVwZGF0ZSgnb24nLCAhcHJvcHMub24pfSxcblx0XHRjbGFzczoge1xuXHRcdFx0J2ZhLWNpcmNsZS10aGluJzogIXByb3BzLm9uLFxuXHRcdFx0J29uJzogcHJvcHMub24sXG5cdFx0XHQnZmEtY2lyY2xlJzogcHJvcHMub25cblx0XHR9XG5cdH0pLFxuXHRkaXYoW1xuXHRcdGxhYmVsKGBTZWNvbmRzYCksXG5cdFx0JyAnLFxuXHRcdC8vIHNwYW4oJy5yaWdodCcsIGAke3Byb3BzLnNlY29uZHN9YCksXG5cdFx0aW5wdXQoJ1t0eXBlPVwibnVtYmVyXCJdJywge1xuXHRcdFx0YXR0cnM6IHttaW46IDEsIG1heDogNTAsIHN0ZXA6IDAuMDF9LFxuXHRcdFx0cHJvcHM6IHt2YWx1ZTogcHJvcHMuc2Vjb25kc30sXG5cdFx0XHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCdzZWNvbmRzJywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHR9KSxcblx0XHQnICcsXG5cdFx0bGFiZWwoYERlY2F5YCksXG5cdFx0Ly8gc3BhbignLnJpZ2h0JywgYCR7cHJvcHMuZGVjYXl9YCksXG5cdFx0JyAnLFxuXHRcdGlucHV0KCdbdHlwZT1cIm51bWJlclwiXScsIHtcblx0XHRcdGF0dHJzOiB7bWluOiAwLCBtYXg6IDEwMCwgc3RlcDogMC4wMX0sXG5cdFx0XHRwcm9wczoge3ZhbHVlOiBwcm9wcy5kZWNheX0sXG5cdFx0XHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCdkZWNheScsIHBhcnNlRmxvYXQoZXYudGFyZ2V0LnZhbHVlKSl9XG5cdFx0fSksXG5cdFx0JyAnLFxuXHRcdC8qXG5cdFx0bGFiZWwoYFJldmVyc2VgKSxcblx0XHQvLyBzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5yZXZlcnNlfWApLFxuXHRcdCcgJyxcblx0XHRidXR0b24oJy5mYScsIHtcblx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdCdmYS10b2dnbGUtb24nOiBwcm9wcy5yZXZlcnNlLFxuXHRcdFx0XHQnZmEtdG9nZ2xlLW9mZic6ICFwcm9wcy5yZXZlcnNlXG5cdFx0XHR9LFxuXHRcdFx0b246IHtcblx0XHRcdFx0Y2xpY2s6ICgpID0+IHVwZGF0ZSgncmV2ZXJzZScsICFwcm9wcy5yZXZlcnNlKVxuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdCovXG5cdFx0YnIoKSxcblx0XHRsYWJlbChgRHJ5YCksXG5cdFx0c3BhbignLnJpZ2h0JywgYCR7cHJvcHMuZHJ5fWApLFxuXHRcdGlucHV0KCdbdHlwZT1cInJhbmdlXCJdJywge1xuXHRcdFx0YXR0cnM6IHttaW46IDAsIG1heDogMSwgc3RlcDogMC4wMX0sXG5cdFx0XHRwcm9wczoge3ZhbHVlOiBwcm9wcy5kcnl9LFxuXHRcdFx0b246IHtjaGFuZ2U6IGV2ID0+IHVwZGF0ZSgnZHJ5JywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHR9KSxcblx0XHRsYWJlbChgV2V0YCksXG5cdFx0c3BhbignLnJpZ2h0JywgYCR7cHJvcHMud2V0fWApLFxuXHRcdGlucHV0KCdbdHlwZT1cInJhbmdlXCJdJywge1xuXHRcdFx0YXR0cnM6IHttaW46IDAsIG1heDogMSwgc3RlcDogMC4wMX0sXG5cdFx0XHRwcm9wczoge3ZhbHVlOiBwcm9wcy53ZXR9LFxuXHRcdFx0b246IHtjaGFuZ2U6IGV2ID0+IHVwZGF0ZSgnd2V0JywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHR9KVxuXHRcdC8vIGxhYmVsKGBHYWluYCksXG5cdFx0Ly8gc3BhbignLnJpZ2h0JywgYCR7cHJvcHMuZ2Fpbn1gKSxcblx0XHQvLyBpbnB1dCgnW3R5cGU9XCJyYW5nZVwiXScsIHtcblx0XHQvLyBcdGF0dHJzOiB7bWluOiAwLCBtYXg6IDEsIHN0ZXA6IDAuMDA1fSxcblx0XHQvLyBcdHByb3BzOiB7dmFsdWU6IHByb3BzLmdhaW59LFxuXHRcdC8vIFx0b246IHtjaGFuZ2U6IGV2ID0+IHVwZGF0ZSgnZ2FpbicsIHBhcnNlRmxvYXQoZXYudGFyZ2V0LnZhbHVlKSl9XG5cdFx0Ly8gfSlcblx0XSlcbl0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG5cdGRpdiwgaDIsIHNwYW4sIHAsIHVsLCBsaSwgaHIsIGJ1dHRvbiwgYnIsIGEsXG5cdGZvcm0sIGxhYmVsLCBpbnB1dCwgZmllbGRzZXQsIGxlZ2VuZCwgaSwgaW1nLFxuXHRzZWxlY3QsIG9wdGlvblxufSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtuYW1lID0gJ3JldmVyYicsIHByb3BzLCB1cGRhdGV9KSA9PiBmaWVsZHNldChbXG5cdGxlZ2VuZChbXG5cdFx0c3BhbignLm9uJywgW1xuXHRcdFx0bmFtZS50b1VwcGVyQ2FzZSgpXG5cdFx0XSlcblx0XSksXG5cdGRpdignLm9uLXN3aXRjaC5mYScsIHtcblx0XHRvbjoge2NsaWNrOiBldiA9PiB1cGRhdGUoJ29uJywgIXByb3BzLm9uKX0sXG5cdFx0Y2xhc3M6IHtcblx0XHRcdCdmYS1jaXJjbGUtdGhpbic6ICFwcm9wcy5vbixcblx0XHRcdCdvbic6IHByb3BzLm9uLFxuXHRcdFx0J2ZhLWNpcmNsZSc6IHByb3BzLm9uXG5cdFx0fVxuXHR9KSxcblx0ZGl2KFtcblx0XHRkaXYoW1xuXHRcdFx0bGFiZWwoYFR5cGVgKSxcblx0XHRcdHNlbGVjdCh7XG5cdFx0XHRcdG9uOiB7Y2hhbmdlOiBldiA9PiB1cGRhdGUoJ3R5cGUnLCBldi50YXJnZXQudmFsdWUpfVxuXHRcdFx0fSwgW1xuXHRcdFx0XHQnbG93cGFzcycsICdoaWdocGFzcydcblx0XHRcdFx0Ly8gJ2JhbmRwYXNzJywgJ2xvd3NoZWxmJywgJ2hpZ2hzaGVsZicsICdwZWFraW5nJywgJ25vdGNoJywgJ2FsbHBhc3MnXG5cdFx0XHRdLm1hcCh0eXBlID0+XG5cdFx0XHRcdG9wdGlvbih7XG5cdFx0XHRcdFx0YXR0cnM6IHtcblx0XHRcdFx0XHRcdHZhbHVlOiB0eXBlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWQ6IHByb3BzLnR5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHR5cGUpXG5cdFx0XHQpKVxuXHRcdF0pLFxuXHRcdGRpdihbXG5cdFx0XHRsYWJlbChgQ3V0b2ZmYCksXG5cdFx0XHRzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5jdXRvZmZ9YCksXG5cdFx0XHRpbnB1dCgnW3R5cGU9XCJyYW5nZVwiXScsIHtcblx0XHRcdFx0YXR0cnM6IHttaW46IDAsIG1heDogMSwgc3RlcDogMC4wMX0sXG5cdFx0XHRcdHByb3BzOiB7dmFsdWU6IHByb3BzLmN1dG9mZn0sXG5cdFx0XHRcdG9uOiB7Y2hhbmdlOiBldiA9PiB1cGRhdGUoJ2N1dG9mZicsIHBhcnNlRmxvYXQoZXYudGFyZ2V0LnZhbHVlKSl9XG5cdFx0XHR9KVxuXHRcdF0pLFxuXHRcdGxhYmVsKGBSZXNvbmFuY2VgKSxcblx0XHRzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5yZXNvbmFuY2V9YCksXG5cdFx0aW5wdXQoJ1t0eXBlPVwicmFuZ2VcIl0nLCB7XG5cdFx0XHRhdHRyczoge21pbjogMCwgbWF4OiAxLCBzdGVwOiAwLjAxfSxcblx0XHRcdHByb3BzOiB7dmFsdWU6IHByb3BzLnJlc29uYW5jZX0sXG5cdFx0XHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCdyZXNvbmFuY2UnLCBwYXJzZUZsb2F0KGV2LnRhcmdldC52YWx1ZSkpfVxuXHRcdH0pXG5cdFx0Ly8gbGFiZWwoYEdhaW5gKSxcblx0XHQvLyBzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5nYWlufWApLFxuXHRcdC8vIGlucHV0KCdbdHlwZT1cInJhbmdlXCJdJywge1xuXHRcdC8vIFx0YXR0cnM6IHttaW46IDAsIG1heDogMSwgc3RlcDogMC4wMDV9LFxuXHRcdC8vIFx0cHJvcHM6IHt2YWx1ZTogcHJvcHMuZ2Fpbn0sXG5cdFx0Ly8gXHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCdnYWluJywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHQvLyB9KVxuXHRdKVxuXSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0c2VjdGlvbiwgc3BhbiwgYSwgZGl2LCBwcmUsIGltZywgaSxcblx0Zm9ybSwgaW5wdXQsIGJ1dHRvbiwgbGFiZWwsXG5cdHVsLCBsaSwgdGFibGUsIHRib2R5LCB0aGVhZCwgdHIsIHRkLCB0aFxufSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG5cbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe3N0YXRlLCBhY3Rpb25zfSkgPT4gc2VjdGlvbignI3dhdmVkaXRvcicsIFtcblx0ZGl2KCcjd2F2ZS10aW1lbGluZScpLFxuXHRkaXYoJyN3YXZlZm9ybScpLFxuXHRidXR0b24oe1xuXHRcdG9uOiB7XG5cdFx0XHRjbGljazogKCkgPT4gYWN0aW9ucy50b2dnbGUoWydzZXNzaW9uJywgJ3BsYXlpbmcnXSlcblx0XHR9XG5cdH0sIGkoYC5mYS5mYS0ke3N0YXRlLnNlc3Npb24ucGxheWluZyA/ICdwYXVzZScgOiAncGxheSd9YCkpLFxuXHRkaXYoJyN0b29scycsIFtcblx0XHRidXR0b24oJy5mYS5mYS1taWNyb3Bob25lJyksXG5cdFx0YnV0dG9uKCcuZmEuZmEtc2Npc3NvcnMnKSxcblx0XHRidXR0b24oJy5mYS5mYS1leGNoYW5nZScpLFxuXHRcdGJ1dHRvbignLmZhLmZhLXRpbWVzJylcblx0XSlcbl0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCB7YXJyLCBvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3Qgb2JzZXJ2ZSA9IHNvdXJjZSA9PiAoc291cmNlIGluc3RhbmNlb2YgUnguT2JzZXJ2YWJsZSlcbiAgPyBzb3VyY2VcbiAgOiAoc291cmNlLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICA/IFJ4Lk9ic2VydmFibGUuZnJvbVByb21pc2Uoc291cmNlKVxuICAgIDogUnguT2JzZXJ2YWJsZS5qdXN0KHNvdXJjZSk7XG5cbmNvbnN0IGFkYXB0ID0gKG8sIHAgPSBbXSkgPT4gT2JqZWN0LmtleXMobykuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdpbml0aWFsJykucmVkdWNlKChvMiwga2V5KSA9PiBPYmplY3QuYXNzaWduKHt9LCBvMixcblx0KG9ba2V5XSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiBvYmoua2V5VmFsdWUoa2V5LCBmdW5jdGlvbigpIHtcblx0XHRvYnNlcnZlKFxuXHRcdFx0b1trZXldLmFwcGx5KG51bGwsIEFycmF5LmZyb20oYXJndW1lbnRzKSlcblx0XHQpLnN1YnNjcmliZShyZXNwID0+IG8yLnN0cmVhbS5vbk5leHQoT2JqZWN0LmFzc2lnbihyZXNwLCB7XG5cdFx0XHRwYXRoOiBbXS5jb25jYXQocCwga2V5KSxcblx0XHRcdHBheWxvYWQ6IEFycmF5LmZyb20oYXJndW1lbnRzKVxuXHRcdH0pKSk7XG5cdH0pIHx8IChvW2tleV0gaW5zdGFuY2VvZiBPYmplY3QpICYmICgoKSA9PiB7XG5cdFx0bGV0IG8zID0gYWRhcHQob1trZXldLCBbXS5jb25jYXQocCwga2V5KSk7XG5cdFx0bzMuc3RyZWFtLnN1YnNjcmliZShyZXNwID0+IG8yLnN0cmVhbS5vbk5leHQocmVzcCkpO1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHtcblx0XHRcdGluaXRpYWw6IE9iamVjdC5hc3NpZ24oe30sIG8yLmluaXRpYWwsIG9iai5rZXlWYWx1ZShrZXksIG8zLmluaXRpYWwpKVxuXHRcdH0sIG9iai5rZXlWYWx1ZShrZXksIG8zKSk7XG5cdH0pKCkgfHwgb2JqLmtleVZhbHVlKGtleSwgb1trZXldKVxuKSwge3N0cmVhbTogbmV3IFJ4LlN1YmplY3QoKSwgaW5pdGlhbDogby5pbml0aWFsIHx8IHt9fSk7XG5cbmNvbnN0IGF0dGFjaCA9ICh0cmVlLCBwYXRoLCBub2RlKSA9PiBbYWRhcHQobm9kZSwgcGF0aCldLm1hcChhZGFwdGVkTm9kZSA9PiAoXG5cdGFkYXB0ZWROb2RlLnN0cmVhbS5zdWJzY3JpYmUocmVzcCA9PiB0cmVlLnN0cmVhbS5vbk5leHQocmVzcCkpLFxuXHRPYmplY3QuYXNzaWduKHt9LCBvYmoucGF0Y2godHJlZSwgcGF0aCwgYWRhcHRlZE5vZGUpLCB7XG5cdFx0aW5pdGlhbDogb2JqLnBhdGNoKHRyZWUuaW5pdGlhbCwgcGF0aCwgYWRhcHRlZE5vZGUuaW5pdGlhbClcblx0fSlcbikpLnBvcCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0YWRhcHQsXG5cdGF0dGFjaFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHtjb250ZXh0LCBjcmVhdGU6IF9jcmVhdGUsIHNldCwgY2hhaW4sIGR1cmF0aW9uLCBjaERhdGEsIHNjaGVkdWxlfSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuY29uc3QgY3JlYXRlID0gcHJlZnMgPT4gW3tcblx0cHJlZnM6IE9iamVjdC5hc3NpZ24oe1xuXHRcdHZvbHVtZTogMC40MSxcblx0XHRhdHRhY2s6IDAuMzEsXG5cdFx0ZGVjYXk6IDAuMTYsXG5cdFx0c3VzdGFpbjogMC44LFxuXHRcdHJlbGVhc2U6IDAuMjFcblx0fSwgcHJlZnMpLFxuXHR0aHJvdWdoOiBfY3JlYXRlKCdnYWluJylcbn1dLm1hcChuID0+IChcblx0c2V0KG4udGhyb3VnaC5nYWluLCAndmFsdWUnLCAwKSxcblx0blxuKSkucG9wKCk7XG5cbmNvbnN0IHVwZGF0ZSA9IChuLCBwcmVmcykgPT4gKFxuXHRzZXQobiwgJ3ByZWZzJywgT2JqZWN0LmFzc2lnbih7fSwgbi5wcmVmcywgcHJlZnMpKSxcblx0blxuKTtcblxuY29uc3Qgbm90ZU9uID0gKG5vZGUsIHZlbG9jaXR5LCB0aW1lKSA9PiB7XG5cdGNvbnN0IG5vdyA9IGNvbnRleHQuY3VycmVudFRpbWU7XG5cdHRpbWUgPSAodGltZSB8fCBub3cpICsgMC4wMDAxO1xuXG5cdG5vZGUudGhyb3VnaC5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcblxuXHRjb25zdCBjaGFuZ2VzID0gW10uY29uY2F0KFxuXHRcdC8vIGF0dGFja1xuXHRcdChub2RlLnByZWZzLmF0dGFjayA+IDApXG5cdFx0XHQ/IFtbMCwgdGltZV0sIFt2ZWxvY2l0eSAqIG5vZGUucHJlZnMudm9sdW1lLCBub2RlLnByZWZzLmF0dGFja11dXG5cdFx0XHQ6IFtbdmVsb2NpdHkgKiBub2RlLnByZWZzLnZvbHVtZSwgdGltZV1dLFxuXHRcdC8vIGRlY2F5XG5cdFx0KG5vZGUucHJlZnMuZGVjYXkgPiAwKVxuXHRcdFx0PyBbW25vZGUucHJlZnMuc3VzdGFpbiAqIHZlbG9jaXR5ICogbm9kZS5wcmVmcy52b2x1bWUsIG5vZGUucHJlZnMuZGVjYXldXSA6IFtdXG5cdCkucmVkdWNlKChhLCBjKSA9PiBbW10uY29uY2F0KGFbMF0sIGNbMF0pLCBbXS5jb25jYXQoYVsxXSwgY1sxXSldLCBbW10sIFtdXSk7XG5cblx0c2NoZWR1bGUobm9kZS50aHJvdWdoLCAnZ2FpbicsIGNoYW5nZXNbMF0sIGNoYW5nZXNbMV0pO1xuXHRyZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IG5vdGVPZmYgPSAobm9kZSwgdGltZSkgPT4ge1xuXHRjb25zdCBub3cgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuXHR0aW1lID0gdGltZSB8fCBub3cgKyAwLjAwMDE7XG5cblx0c2V0VGltZW91dCgoKSA9PiAoXG5cdFx0bm9kZS50aHJvdWdoLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApLFxuXHRcdG5vZGUudGhyb3VnaC5nYWluLnNldFZhbHVlQ3VydmVBdFRpbWUobmV3IEZsb2F0MzJBcnJheShbbm9kZS50aHJvdWdoLmdhaW4udmFsdWUsIDBdKSxcblx0XHRcdFx0dGltZSwgbm9kZS5wcmVmcy5yZWxlYXNlID4gMCAmJiBub2RlLnByZWZzLnJlbGVhc2UgfHwgMC4wMDAwMSlcblx0KSwgKHRpbWUgLSBub3cpICogMTAwMCk7XG5cdHJldHVybiBub2RlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRub3RlT24sXG5cdG5vdGVPZmZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IGNvbnRleHQgPSBuZXcgKFxuXHR3aW5kb3cuQXVkaW9Db250ZXh0XG5cdHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHRcblx0fHwgd2luZG93Lm1vekF1ZGlvQ29udGV4dFxuXHR8fCB3aW5kb3cub0F1ZGlvQ29udGV4dFxuXHR8fCB3aW5kb3cubXNBdWRpb0NvbnRleHRcbikoKTtcblxuY29uc3Qgc2V0ID0gKG8sIGssIHYpID0+IChvW2tdID0gdik7XG5jb25zdCBpc1NldCA9IHYgPT4gdiAhPT0gdW5kZWZpbmVkO1xuY29uc3QgaXNHZXQgPSB2ID0+IGlzU2V0KHYpID8gdiA6IG51bGw7XG5cbmNvbnN0IGFwcGx5ID0gKG8xLCBvMikgPT4gT2JqZWN0LmtleXMobzIpXG5cdC5yZWR1Y2UoKG8sIGspID0+IHNldChvLCBrLCBvMltrXSksIG8xKTtcblxuY29uc3QgY3JlYXRlID0gKHR5cGUsIC4uLmFyZ3MpID0+IChcblx0Ly8gY29uc29sZS5sb2codHlwZSksXG5cdG9iai5zd2l0Y2godHlwZSwge1xuXHRcdG9zY2lsbGF0b3I6ICgpID0+IGNvbnRleHQuY3JlYXRlT3NjaWxsYXRvciguLi5hcmdzKSxcblx0XHRnYWluOiAoKSA9PiBjb250ZXh0LmNyZWF0ZUdhaW4oLi4uYXJncyksXG5cdFx0YmlxdWFkRmlsdGVyOiAoKSA9PiBjb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlciguLi5hcmdzKSxcblx0XHRjb252b2x2ZXI6ICgpID0+IGNvbnRleHQuY3JlYXRlQ29udm9sdmVyKC4uLmFyZ3MpLFxuXHRcdGJ1ZmZlcjogKCkgPT4gY29udGV4dC5jcmVhdGVCdWZmZXIoLi4uYXJncyksXG5cdFx0YnVmZmVyU291cmNlOiAoKSA9PiBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSguLi5hcmdzKVxuXHR9KSgpKTtcblxuY29uc3QgdXBkYXRlID0gKG5vZGUsIHByZWZzKSA9PiBhcHBseShub2RlLCBwcmVmcyk7XG5cbmNvbnN0IGNvbm5lY3QgPSAobjEsIG4yKSA9PiAoXG5cdC8vIGNvbnNvbGUubG9nKG4xLCBuMiksXG5cdG4xLmNvbm5lY3QobjIpLFxuXHRuMVxuKTtcbmNvbnN0IGRpc2Nvbm5lY3QgPSAobjEsIG4yKSA9PiB7XG5cdC8vIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgY29ubmVjdGVkXG5cdHRyeSB7XG5cdFx0bjEuZGlzY29ubmVjdChuMik7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGNvbnNvbGUubG9nKGVycik7XG5cdH1cblx0cmV0dXJuIG4xO1xufTtcblxuY29uc3QgY2hhaW4gPSAoLi4ubm9kZXMpID0+IChcblx0bm9kZXMuZm9yRWFjaCgobiwgaSkgPT4gaXNTZXQobm9kZXNbaSArIDFdKSAmJiBjb25uZWN0KG4sIG5vZGVzW2kgKyAxXSkpLFxuXHRub2Rlc1swXVxuKTtcblxuY29uc3QgdW5jaGFpbiA9ICguLi5ub2RlcykgPT4gKFxuXHRub2Rlcy5zbGljZSgpLnJldmVyc2UoKVxuXHRcdC5mb3JFYWNoKChuLCBpKSA9PiBpc1NldChub2Rlc1tpIC0gMV0pICYmIGRpc2Nvbm5lY3Qobm9kZXNbaSAtIDFdLCBuKSksXG5cdG5vZGVzWzBdXG4pO1xuXG5jb25zdCBkdXJhdGlvbiA9IHNlY29uZHMgPT4gY29udGV4dC5zYW1wbGVSYXRlICogc2Vjb25kcztcbmNvbnN0IGNoRGF0YSA9IChub2RlLCAuLi5hcmdzKSA9PiAoXG5cdC8vIGNvbnNvbGUubG9nKG5vZGUsIGFyZ3MpLFxuXHRub2RlLmdldENoYW5uZWxEYXRhKC4uLmFyZ3MpXG4pO1xuXG5jb25zdCBzY2hlZHVsZSA9IChub2RlLCBwcmVmLCB2YWx1ZXMsIHRpbWVzKSA9PiAodmFsdWVzLmxlbmd0aCA9PT0gMSlcblx0PyBub2RlW3ByZWZdLnNldFZhbHVlQXRUaW1lKHZhbHVlc1swXSwgdGltZXNbMF0pXG5cdDogKG5vZGVbcHJlZl0uc2V0VmFsdWVDdXJ2ZUF0VGltZShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5zbGljZSgwLCAyKSksIHRpbWVzWzBdLCB0aW1lc1sxXSksXG5cdFx0KHZhbHVlcy5sZW5ndGggPiAyKSAmJiBzY2hlZHVsZShub2RlLCBwcmVmLCB2YWx1ZXMuc2xpY2UoMSksIFt0aW1lc1swXSArIHRpbWVzWzFdXS5jb25jYXQodGltZXMuc2xpY2UoMikpKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjb250ZXh0LFxuXHRzZXQsXG5cdGlzU2V0LFxuXHRpc0dldCxcblx0Y3JlYXRlLFxuXHR1cGRhdGUsXG5cdGNvbm5lY3QsXG5cdGRpc2Nvbm5lY3QsXG5cdGNoYWluLFxuXHR1bmNoYWluLFxuXHQvLyB1dGlsXG5cdGR1cmF0aW9uLFxuXHRjaERhdGEsXG5cdHNjaGVkdWxlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqLCBmbn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3Qge2NvbnRleHQsIGNyZWF0ZTogX2NyZWF0ZSwgc2V0LCBjaGFpbiwgZHVyYXRpb24sIGNoRGF0YX0gPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmNvbnN0IGNyZWF0ZSA9IHByZWZzID0+IFt7XG5cdHByZWZzOiBPYmplY3QuYXNzaWduKHtcblx0XHR0eXBlOiAnc2F3dG9vdGgnLFxuXHRcdGZyZXF1ZW5jeTogNSxcblx0XHRnYWluOiAxNVxuXHR9LCBwcmVmcyksXG5cdGVmZmVjdDogX2NyZWF0ZSgnb3NjaWxsYXRvcicpLFxuXHRvdXRwdXQ6IF9jcmVhdGUoJ2dhaW4nKVxufV0ubWFwKG4gPT4gKFxuXHRjaGFpbihuLmVmZmVjdCwgbi5vdXRwdXQpLFxuXHRzZXQobi5lZmZlY3QuZnJlcXVlbmN5LCAndmFsdWUnLCBuLnByZWZzLmZyZXF1ZW5jeSksXG5cdHNldChuLm91dHB1dC5nYWluLCAndmFsdWUnLCBuLnByZWZzLmdhaW4pLFxuXHRzZXQobi5lZmZlY3QsICd0eXBlJywgbi5wcmVmcy50eXBlKSxcblx0blxuKSkucG9wKCk7XG5cbmNvbnN0IHVwZGF0ZSA9IChuLCBwcmVmcykgPT4gKFxuXHRzZXQobiwgJ3ByZWZzJywgT2JqZWN0LmFzc2lnbih7fSwgbi5wcmVmcywgcHJlZnMpKSxcblx0c2V0KG4uZWZmZWN0LmZyZXF1ZW5jeSwgJ3ZhbHVlJywgbi5wcmVmcy5mcmVxdWVuY3kpLFxuXHRzZXQobi5vdXRwdXQuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy5nYWluKSxcblx0c2V0KG4uZWZmZWN0LCAndHlwZScsIG4ucHJlZnMudHlwZSksXG5cdG5cbik7XG5cbmNvbnN0IHN0YXJ0ID0gKG4sIC4uLmFyZ3MpID0+IChcblx0bi5lZmZlY3Quc3RhcnQoKSxcblx0blxuKTtcblxuLy8gY29uc3QgY2xvbmUgPSBuID0+IGNyZWF0ZShudWxsLCBuLm91dHB1dC5idWZmZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlLFxuXHR1cGRhdGUsXG5cdHN0YXJ0XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqLCBmbn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3Qge2NvbnRleHQsIGNyZWF0ZTogX2NyZWF0ZSwgc2V0LCBjaGFpbiwgZHVyYXRpb24sIGNoRGF0YX0gPSByZXF1aXJlKCcuLi9jb3JlJyk7XG4vLyBjb25zdCB7Y29udGV4dH0gPSBjb3JlO1xuXG5jb25zdCBidWlsZEltcHVsc2UgPSAoe3NlY29uZHMsIGRlY2F5fSkgPT4ge1xuXHRsZXQgaW1wdWxzZSA9IF9jcmVhdGUoJ2J1ZmZlcicsIDIsIGR1cmF0aW9uKHNlY29uZHMpLCBjb250ZXh0LnNhbXBsZVJhdGUpO1xuXHRsZXQgY2hhbm5lbERhdGEgPSBbXG5cdFx0Y2hEYXRhKGltcHVsc2UsIDApLFxuXHRcdGNoRGF0YShpbXB1bHNlLCAxKVxuXHRdO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGR1cmF0aW9uKHNlY29uZHMpOyBpKyspIHtcblx0XHRjaGFubmVsRGF0YVswXVtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIGkgLyBkdXJhdGlvbihzZWNvbmRzKSwgZGVjYXkpO1xuXHRcdGNoYW5uZWxEYXRhWzFdW2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gaSAvIGR1cmF0aW9uKHNlY29uZHMpLCBkZWNheSk7XG5cdH1cblx0cmV0dXJuIGltcHVsc2U7XG59O1xuXG5jb25zdCBjcmVhdGUgPSBwcmVmcyA9PiBbe1xuXHRwcmVmczogT2JqZWN0LmFzc2lnbih7c2Vjb25kczogMywgZGVjYXk6IDIsIHdldDogMCwgZHJ5OiAxfSwgcHJlZnMpLFxuXHRpbnB1dDogX2NyZWF0ZSgnZ2FpbicpLFxuXHRvdXRwdXQ6IF9jcmVhdGUoJ2dhaW4nKSxcblx0ZWZmZWN0OiBfY3JlYXRlKCdjb252b2x2ZXInKSxcblx0d2V0OiBfY3JlYXRlKCdnYWluJyksXG5cdGRyeTogX2NyZWF0ZSgnZ2FpbicpXG59XS5tYXAobiA9PiAoXG5cdGNoYWluKG4uaW5wdXQsIG4uZHJ5LCBuLm91dHB1dCksXG5cdGNoYWluKG4uaW5wdXQsIG4uZWZmZWN0LCBuLndldCwgbi5vdXRwdXQpLFxuXHRzZXQobi5kcnkuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy5kcnkpLFxuXHRzZXQobi53ZXQuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy53ZXQpLFxuXHRzZXQobi5lZmZlY3QsICdidWZmZXInLCBidWlsZEltcHVsc2Uobi5wcmVmcykpLFxuXHRuXG4pXG5cdC8vIG5cblxuXHQvKlxuXHRuLmlucHV0LmNvbm5lY3Qobi5lZmZlY3QpO1xuXHRuLmVmZmVjdC5jb25uZWN0KG4ud2V0KTtcblx0bi53ZXQuY29ubmVjdChuLm91dHB1dCk7XG5cblx0bi5pbnB1dC5jb25uZWN0KG4uZHJ5KTtcblx0bi5kcnkuY29ubmVjdChuLm91dHB1dCk7XG5cdCovXG5cdC8qXG5cdG4uZHJ5LmdhaW4udmFsdWUgPSBuLnByZWZzLmRyeTtcblx0bi53ZXQuZ2Fpbi52YWx1ZSA9IG4ucHJlZnMud2V0O1xuXHRuLmVmZmVjdC5idWZmZXIgPSBidWlsZEltcHVsc2Uobi5wcmVmcyk7XG5cdCovXG5cdC8vIHNldChuLndldC5nYWluLCAndmFsdWUnLCBuLnByZWZzLndldCksXG5cdC8vIHNldChuLmVmZmVjdCwgJ2J1ZmZlcicsIGJ1aWxkSW1wdWxzZShuLnByZWZzKSksXG5cdC8vIHJldHVybiBuO1xuKS5wb3AoKTtcblxuY29uc3QgdXBkYXRlID0gKG4sIHByZWZzKSA9PiAoXG4vL1x0Y29uc29sZS5sb2cocHJlZnMsIG4ucHJlZnMpLFxuXHQobi5wcmVmcy5zZWNvbmRzICE9PSBwcmVmcy5zZWNvbmRzIHx8IG4ucHJlZnMuZGVjYXkgIT09IHByZWZzLmRlY2F5KVxuXHRcdCYmIHNldChuLmVmZmVjdCwgJ2J1ZmZlcicsIGJ1aWxkSW1wdWxzZShuLnByZWZzKSksXG5cdChuLnByZWZzLmRyeSAhPT0gcHJlZnMuZHJ5KVxuXHRcdCYmIHNldChuLmRyeS5nYWluLCAndmFsdWUnLCBwcmVmcy5kcnkpLFxuXHQobi5wcmVmcy53ZXQgIT09IHByZWZzLndldClcblx0XHQmJiBzZXQobi53ZXQuZ2FpbiwgJ3ZhbHVlJywgcHJlZnMud2V0KSxcblx0c2V0KG4sICdwcmVmcycsIE9iamVjdC5hc3NpZ24oe30sIG4ucHJlZnMsIHByZWZzKSksXG5cdG5cbik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGUsXG5cdHVwZGF0ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3Qge1xuXHRjb250ZXh0LCBzZXQsIGlzU2V0LCBpc0dldCxcblx0c2NoZWR1bGU6IF9zY2hlZHVsZSxcblx0Y3JlYXRlOiBfY3JlYXRlLFxuXHRjb25uZWN0OiBfY29ubmVjdCwgZGlzY29ubmVjdDogX2Rpc2Nvbm5lY3Rcbn0gPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuY29uc3QgcmV2ZXJiID0gcmVxdWlyZSgnLi9lZmZlY3RzL3JldmVyYicpO1xuY29uc3QgbGZvID0gcmVxdWlyZSgnLi9lZmZlY3RzL2xmbycpO1xuY29uc3QgYWRzciA9IHJlcXVpcmUoJy4vY29udHJvbHMvYWRzcicpO1xuXG5jb25zdCBjcmVhdGUgPSAodHlwZSwgcHJlZnMgPSB7fSwgY3R4ID0gY29udGV4dCkgPT4gT2JqZWN0LmFzc2lnbih7fSxcblx0b2JqLnN3aXRjaCh0eXBlLCB7XG5cdFx0dmNvOiAoKSA9PiAoe291dHB1dDogX2NyZWF0ZSgnb3NjaWxsYXRvcicpfSksXG5cdFx0dmNhOiAoKSA9PiAoe3Rocm91Z2g6IF9jcmVhdGUoJ2dhaW4nKX0pLFxuXHRcdHZjZjogKCkgPT4gKHt0aHJvdWdoOiBfY3JlYXRlKCdiaXF1YWRGaWx0ZXInKX0pLFxuXHRcdGxmbzogKCkgPT4gbGZvLmNyZWF0ZShwcmVmcyksXG5cdFx0cmV2ZXJiOiAoKSA9PiByZXZlcmIuY3JlYXRlKHByZWZzKSxcblx0XHRhZHNyOiAoKSA9PiBhZHNyLmNyZWF0ZShwcmVmcylcblx0fSkoKSxcblx0e3R5cGUsIG91dDogW119XG4pO1xuXG5jb25zdCBjdXRvZmZUb0ZyZXEgPSBjdXRvZmYgPT4ge1xuXHRjb25zdCBtaW5WYWx1ZSA9IDQwO1xuXHRjb25zdCBtYXhWYWx1ZSA9IGNvbnRleHQuc2FtcGxlUmF0ZSAvIDI7XG5cdC8vIExvZ2FyaXRobSAoYmFzZSAyKSB0byBjb21wdXRlIGhvdyBtYW55IG9jdGF2ZXMgZmFsbCBpbiB0aGUgcmFuZ2UuXG5cdHZhciBudW1iZXJPZk9jdGF2ZXMgPSBNYXRoLmxvZyhtYXhWYWx1ZSAvIG1pblZhbHVlKSAvIE1hdGguTE4yO1xuXHQvLyBDb21wdXRlIGEgbXVsdGlwbGllciBmcm9tIDAgdG8gMSBiYXNlZCBvbiBhbiBleHBvbmVudGlhbCBzY2FsZS5cblx0dmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygyLCBudW1iZXJPZk9jdGF2ZXMgKiAoY3V0b2ZmIC0gMS4wKSk7XG5cdC8vIEdldCBiYWNrIHRvIHRoZSBmcmVxdWVuY3kgdmFsdWUgYmV0d2VlbiBtaW4gYW5kIG1heC5cblx0cmV0dXJuIG1heFZhbHVlICogbXVsdGlwbGllcjtcbn07XG5cbmNvbnN0IHVwZGF0ZSA9IChub2RlLCBwcmVmcykgPT4gb2JqLnN3aXRjaChub2RlLnR5cGUsIHtcblx0dmNvOiAoKSA9PiAoXG5cdFx0aXNTZXQocHJlZnMudHlwZSkgJiYgc2V0KG5vZGUub3V0cHV0LCAndHlwZScsIHByZWZzLnR5cGUpLFxuXHRcdGlzU2V0KHByZWZzLmZyZXEpICYmIHNldChub2RlLm91dHB1dC5mcmVxdWVuY3ksICd2YWx1ZScsIHByZWZzLmZyZXEpLFxuXHRcdGlzU2V0KHByZWZzLmRldHVuZSkgJiYgc2V0KG5vZGUub3V0cHV0LmRldHVuZSwgJ3ZhbHVlJywgcHJlZnMuZGV0dW5lKSxcblx0XHRPYmplY3QuYXNzaWduKG5vZGUsIHtwcmVmc30pXG5cdCksXG5cdHZjYTogKCkgPT4gKFxuXHRcdGlzU2V0KHByZWZzLmdhaW4pICYmIHNldChub2RlLnRocm91Z2guZ2FpbiwgJ3ZhbHVlJywgcHJlZnMuZ2FpbiksXG5cdFx0T2JqZWN0LmFzc2lnbihub2RlLCB7cHJlZnN9KVxuXHQpLFxuXHR2Y2Y6ICgpID0+IChcblx0XHRpc1NldChwcmVmcy50eXBlKSAmJiBzZXQobm9kZS50aHJvdWdoLCAndHlwZScsIHByZWZzLnR5cGUpLFxuXHRcdGlzU2V0KHByZWZzLmN1dG9mZilcblx0XHRcdCYmIF9zY2hlZHVsZShub2RlLnRocm91Z2gsICdmcmVxdWVuY3knLCBbY3V0b2ZmVG9GcmVxKHByZWZzLmN1dG9mZildLCBbY29udGV4dC5jdXJyZW50VGltZSArIDAuMDAwMV0pLFxuXHRcdFx0Ly8gc2V0KG5vZGUudGhyb3VnaC5mcmVxdWVuY3ksICd2YWx1ZScsIGN1dG9mZlRvRnJlcShwcmVmcy5jdXRvZmYpKSxcblx0XHRpc1NldChwcmVmcy5yZXNvbmFuY2UpXG5cdFx0XHQmJiBfc2NoZWR1bGUobm9kZS50aHJvdWdoLCAnUScsIFtwcmVmcy5yZXNvbmFuY2UgKiAzMF0sIFtjb250ZXh0LmN1cnJlbnRUaW1lICsgMC4wMDAxXSksXG5cdFx0T2JqZWN0LmFzc2lnbihub2RlLCB7cHJlZnN9KVxuXHQpLFxuXHRyZXZlcmI6ICgpID0+IHJldmVyYi51cGRhdGUobm9kZSwgcHJlZnMpLFxuXHRhZHNyOiAoKSA9PiBhZHNyLnVwZGF0ZShub2RlLCBwcmVmcyksXG5cdGxmbzogKCkgPT4gbGZvLnVwZGF0ZShub2RlLCBwcmVmcylcbn0pKCk7XG5cbmNvbnN0IGNvbm5lY3QgPSAobm9kZTEsIG5vZGUyKSA9PiAhKG5vZGUxLm91dCAmJiBub2RlMS5vdXQuaW5kZXhPZihub2RlMikgPiAtMSlcblx0PyAoX2Nvbm5lY3QoXG5cdFx0XHQvLyBpbnB1dFxuXHRcdFx0aXNHZXQobm9kZTEub3V0cHV0KVxuXHRcdFx0fHwgaXNHZXQobm9kZTEudGhyb3VnaClcblx0XHRcdHx8IGlzU2V0KG5vZGUxLmNvbm5lY3QpICYmIG5vZGUxLFxuXHRcdFx0Ly8gb3V0cHV0XG5cdFx0XHQobm9kZTIgaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSAmJiBub2RlMlxuXHRcdFx0fHwgaXNHZXQobm9kZTIuaW5wdXQpXG5cdFx0XHR8fCBpc0dldChub2RlMi50aHJvdWdoKVxuXHRcdFx0fHwgbm9kZTJcblx0XHQpLFxuXHRcdE9iamVjdC5hc3NpZ24oe30sIG5vZGUxLCB7XG5cdFx0XHRvdXQ6IFtdLmNvbmNhdChub2RlMS5vdXQgfHwgW10sIFtub2RlMl0pXG5cdFx0fSkpXG5cdDogbm9kZTE7XG5cbmNvbnN0IGRpc2Nvbm5lY3QgPSAobm9kZTEsIG5vZGUyKSA9PiAoXG5cdC8vIChjb25zb2xlLmxvZygnZGlzc2Nvbm5lY3RpbmcnLCBub2RlMSwgbm9kZTIpKSxcblx0KG5vZGUxLm91dC5pbmRleE9mKG5vZGUyKSA+IC0xKVxuXHQ/IChfZGlzY29ubmVjdChcblx0XHRcdC8vIGlucHV0XG5cdFx0XHRpc0dldChub2RlMS5vdXRwdXQpXG5cdFx0XHR8fCBpc0dldChub2RlMS50aHJvdWdoKVxuXHRcdFx0fHwgaXNTZXQobm9kZTEuY29ubmVjdCkgJiYgbm9kZTEsXG5cdFx0XHQvLyBvdXRwdXRcblx0XHRcdChub2RlMiBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pICYmIG5vZGUyXG5cdFx0XHR8fCBpc0dldChub2RlMi5pbnB1dClcblx0XHRcdHx8IGlzR2V0KG5vZGUyLnRocm91Z2gpXG5cdFx0XHR8fCBub2RlMlxuXHRcdCksXG5cdFx0T2JqZWN0LmFzc2lnbih7fSwgbm9kZTEsIHtcblx0XHRcdG91dDogW10uY29uY2F0KFxuXHRcdFx0XHRub2RlMS5vdXQuc2xpY2UoMCwgbm9kZTEub3V0LmluZGV4T2Yobm9kZTIpKSxcblx0XHRcdFx0bm9kZTEub3V0LnNsaWNlKG5vZGUxLm91dC5pbmRleE9mKG5vZGUyKSArIDEpXG5cdFx0XHQpXG5cdFx0fSkpXG5cdDogKHR5cGVvZiBub2RlMiA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0PyBub2RlMS5vdXQucmVkdWNlKChub2RlMSwgcHJldk5vZGUpID0+IGRpc2Nvbm5lY3Qobm9kZTEsIHByZXZOb2RlKSwgbm9kZTEpXG5cdFx0OiBub2RlMVxuKTtcblxuY29uc3QgcmVyb3V0ZSA9IChub2RlMSwgbm9kZTIpID0+IChub2RlMS5vdXQgJiYgbm9kZTEub3V0LmluZGV4T2Yobm9kZTIpID09PSAtMSlcblx0PyBjb25uZWN0KGRpc2Nvbm5lY3Qobm9kZTEpLCBub2RlMilcblx0OiBub2RlMTtcblxuY29uc3QgY2hhaW4gPSAoLi4ubm9kZXMpID0+IChcblx0bm9kZXMuZm9yRWFjaCgobiwgaSkgPT4gaXNTZXQobltpICsgMV0pICYmIGNvbm5lY3Qobiwgbm9kZXNbaSArIDFdKSksXG5cdG5vZGVzWzBdXG4pO1xuXG5jb25zdCB1bmNoYWluID0gKC4uLm5vZGVzKSA9PiAoXG5cdG5vZGVzLnNsaWNlKCkucmV2ZXJzZSgpXG5cdFx0LmZvckVhY2goKG4sIGkpID0+IGlzU2V0KG5baSAtIDFdKSAmJiBkaXNjb25uZWN0KG5vZGVzW2kgLSAxXSwgbikpLFxuXHRub2Rlc1swXVxuKTtcblxuY29uc3Qgc3RhcnQgPSAobm9kZSwgLi4uYXJncykgPT4gKG5vZGUudHlwZSA9PT0gJ2xmbycgJiYgbGZvLnN0YXJ0KG5vZGUsIC4uLmFyZ3MpIHx8IG5vZGUub3V0cHV0LnN0YXJ0KC4uLmFyZ3MpLCBub2RlKTtcblxuY29uc3Qgc3RvcCA9IChub2RlLCAuLi5hcmdzKSA9PiAobm9kZS5vdXRwdXQuc3RvcCguLi5hcmdzKSwgbm9kZSk7XG5cbmNvbnN0IHNjaGVkdWxlID0gKG5vZGUsIHByZWYsIHZhbHVlcywgdGltZXMpID0+ICh2YWx1ZXMubGVuZ3RoID09PSAxKVxuXHQ/IG5vZGUudGhyb3VnaFtwcmVmXS5zZXRWYWx1ZUF0VGltZSh2YWx1ZXNbMF0sIHRpbWVzWzBdKVxuXHQ6IChub2RlLnRocm91Z2hbcHJlZl0uc2V0VmFsdWVDdXJ2ZUF0VGltZShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5zbGljZSgwLCAyKSksIHRpbWVzWzBdLCB0aW1lc1sxXSksXG5cdFx0KHZhbHVlcy5sZW5ndGggPiAyKSAmJiBzY2hlZHVsZShub2RlLCBwcmVmLCB2YWx1ZXMuc2xpY2UoMSksIFt0aW1lc1swXSArIHRpbWVzWzFdXS5jb25jYXQodGltZXMuc2xpY2UoMikpKSk7XG5cbmNvbnN0IG5vdGVUb0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uKG5vdGUpIHtcblx0dmFyIG5vdGVzID0gWydBJywgJ0EjJywgJ0InLCAnQycsICdDIycsICdEJywgJ0QjJywgJ0UnLCAnRicsICdGIycsICdHJywgJ0cjJ107XG5cdHZhciBrZXlOdW1iZXI7XG5cdHZhciBvY3RhdmU7XG5cblx0aWYgKG5vdGUubGVuZ3RoID09PSAzKSB7XG5cdFx0b2N0YXZlID0gbm90ZS5jaGFyQXQoMik7XG5cdH0gZWxzZSB7XG5cdFx0b2N0YXZlID0gbm90ZS5jaGFyQXQoMSk7XG5cdH1cblxuXHRrZXlOdW1iZXIgPSBub3Rlcy5pbmRleE9mKG5vdGUuc2xpY2UoMCwgLTEpKTtcblxuXHRpZiAoa2V5TnVtYmVyIDwgMykge1xuXHRcdGtleU51bWJlciA9IGtleU51bWJlciArIDEyICsgKChvY3RhdmUgLSAxKSAqIDEyKSArIDE7XG5cdH0gZWxzZSB7XG5cdFx0a2V5TnVtYmVyID0ga2V5TnVtYmVyICsgKChvY3RhdmUgLSAxKSAqIDEyKSArIDE7XG5cdH1cblxuXHRyZXR1cm4gNDQwICogTWF0aC5wb3coMiwgKGtleU51bWJlciAtIDQ5KSAvIDEyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjb250ZXh0LFxuXHRjcmVhdGUsXG5cdHVwZGF0ZSxcblx0c2NoZWR1bGUsXG5cdGNvbm5lY3QsXG5cdGRpc2Nvbm5lY3QsXG5cdHJlcm91dGUsXG5cdGNoYWluLFxuXHR1bmNoYWluLFxuXHRub3RlVG9GcmVxdWVuY3ksXG5cdHN0YXJ0LFxuXHRzdG9wLFxuXHR2Y286IHByZWZzID0+IHVwZGF0ZShjcmVhdGUoJ3ZjbycsIHt9LCBjb250ZXh0KSwgcHJlZnMpLFxuXHR2Y2Y6IHByZWZzID0+IHVwZGF0ZShjcmVhdGUoJ3ZjZicsIHt9LCBjb250ZXh0KSwgcHJlZnMpLFxuXHRsZm86IHByZWZzID0+IHVwZGF0ZShjcmVhdGUoJ2xmbycsIHt9LCBjb250ZXh0KSwgcHJlZnMpLFxuXHR2Y2E6IHByZWZzID0+IHVwZGF0ZShjcmVhdGUoJ3ZjYScsIHt9LCBjb250ZXh0KSwgcHJlZnMpLFxuXHRhZHNyOiBwcmVmcyA9PiBjcmVhdGUoJ2Fkc3InLCBwcmVmcywgY29udGV4dCksXG5cdG5vdGVPbjogYWRzci5ub3RlT24sXG5cdG5vdGVPZmY6IGFkc3Iubm90ZU9mZlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHtjb250ZXh0LCBjcmVhdGU6IF9jcmVhdGUsIHNldCwgY2hhaW4sIGR1cmF0aW9uLCBjaERhdGF9ID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5jb25zdCBjcmVhdGUgPSAoZmlsZSwgYnVmZmVyKSA9PiBbe1xuXHRvdXRwdXQ6IF9jcmVhdGUoJ2J1ZmZlclNvdXJjZScpXG59XS5tYXAobiA9PiAoXG5cdCghYnVmZmVyKVxuXHRcdD8gZmV0Y2goZmlsZSlcblx0XHRcdC50aGVuKHJlcyA9PiByZXMuYXJyYXlCdWZmZXIoKSlcblx0XHRcdC50aGVuKGJ1ZmZlciA9PiBjb250ZXh0LmRlY29kZUF1ZGlvRGF0YShidWZmZXIsXG5cdFx0XHRcdGJ1ZmZlciA9PiBzZXQobi5vdXRwdXQsICdidWZmZXInLCBidWZmZXIpXG5cdFx0XHQpKVxuXHRcdDogc2V0KG4ub3V0cHV0LCAnYnVmZmVyJywgYnVmZmVyKSxcblx0XHRuKSkucG9wKCk7XG5cbmNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcblxufTtcblxuY29uc3QgY2xvbmUgPSBuID0+IGNyZWF0ZShudWxsLCBuLm91dHB1dC5idWZmZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlLFxuXHR1cGRhdGUsXG5cdGNsb25lXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcbmNvbnN0IGZpbGVTYXZlciA9IHJlcXVpcmUoJ2ZpbGUtc2F2ZXInKTtcbmNvbnN0IGpzWmlwID0gcmVxdWlyZShcImpzemlwXCIpO1xuY29uc3Qge2ZuLCBvYmp9ID0gcmVxdWlyZShcImlibG9rei1kYXRhXCIpO1xuXG5jb25zdCBsb2FkID0gKGZpbGUsIHJlYWRBcyA9ICd0ZXh0JykgPT4gJC5jcmVhdGUoc3RyZWFtID0+IHtcblx0Y29uc3QgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRmci5vbmxvYWQgPSBmdW5jdGlvbihldikge1xuXHRcdC8vIGNvbnNvbGUubG9nKHJlYWRBcywgZXYudGFyZ2V0LnJlc3VsdCk7XG5cdFx0c3RyZWFtLm9uTmV4dChcblx0XHRcdHJlYWRBcyA9PT0gJ2pzb24nXG5cdFx0XHRcdD8gSlNPTi5wYXJzZShldi50YXJnZXQucmVzdWx0KVxuXHRcdFx0XHQ6IGV2LnRhcmdldC5yZXN1bHRcblx0XHQpO1xuXHRcdHN0cmVhbS5vbkNvbXBsZXRlZCgpO1xuXHR9O1xuXHQvLyBjb25zb2xlLmxvZyhmaWxlLCByZWFkQXMpO1xuXHQoKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJylcblx0XHQ/ICQuZnJvbVByb21pc2UoZmV0Y2goZmlsZSkpLmZsYXRNYXAocmVzID0+IHJlcy5ibG9iKCkpXG5cdFx0OiAkLmp1c3QoZmlsZSkpXG5cdFx0LnN1YnNjcmliZShmID0+IGZuLnN3aXRjaChyZWFkQXMsIHtcblx0XHRcdGFycmF5QnVmZmVyOiBmID0+IGZyLnJlYWRBc0FycmF5QnVmZmVyKGYpLFxuXHRcdFx0ZGVmYXVsdDogZiA9PiBmci5yZWFkQXNUZXh0KGYpXG5cdFx0fSkoZikpO1xufSk7XG5cbmNvbnN0IGxvYWRaaXAgPSBmaWxlID0+IGxvYWQoZmlsZSwgJ2FycmF5QnVmZmVyJylcblx0LmZsYXRNYXAoZGF0YSA9PiAkLmZyb21Qcm9taXNlKGpzWmlwLmxvYWRBc3luYyhkYXRhKSkpXG5cdC5mbGF0TWFwKHpmID0+ICQuY29uY2F0KFxuXHRcdE9iamVjdC5rZXlzKHpmLmZpbGVzKVxuXHRcdFx0LmZpbHRlcihrID0+ICF6Zi5maWxlc1trXS5kaXIpXG5cdFx0XHQvLyAubWFwKGsgPT4gKGNvbnNvbGUubG9nKGspLCBrKSlcblx0XHRcdC5tYXAoayA9PiAkLmZyb21Qcm9taXNlKHpmLmZpbGVzW2tdLmFzeW5jKCdhcnJheWJ1ZmZlcicpKS5tYXAodiA9PiAoe2ssIHZ9KSkpXG5cdFx0KS5yZWR1Y2UoKG8sIHtrLCB2fSkgPT4gb2JqLnBhdGNoKG8sIGssIHYpLCB7fSlcblx0KTtcblxuY29uc3Qgc2F2ZSA9IChmaWxlTmFtZSwgY29udGVudCkgPT4gZmlsZVNhdmVyLnNhdmVBcyhcblx0bmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGNvbnRlbnQpXSwge3R5cGU6IFwidGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04XCJ9KSxcblx0ZmlsZU5hbWVcbik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRsb2FkLFxuXHRsb2FkWmlwLFxuXHRzYXZlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcblxuY29uc3QgYXJyaWZ5ID0gbyA9PiBvIGluc3RhbmNlb2YgT2JqZWN0XG4gID8gIShvIGluc3RhbmNlb2YgQXJyYXkpICYmIGtleXMobykuZmlsdGVyKGsgPT4gay5tYXRjaCgvXi0/WzAtOS5dKyQvKSkubGVuZ3RoID09PSBrZXlzKG8pLmxlbmd0aFxuICAgID8ga2V5cyhvKS5tYXAoayA9PiBhcnJpZnkob1trXSkpXG4gICAgOiBrZXlzKG8pLnJlZHVjZSgobzIsIGspID0+IG9iai5wYXRjaChvMiwgaywgYXJyaWZ5KG9ba10pKSwge30pXG4gIDogbztcblxuY29uc3QgdG9EYXRhID0gZm9ybSA9PiBhcnJpZnkoQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICAvLyAubWFwKGVsID0+IChjb25zb2xlLmxvZyhlbC5uYW1lKSwgZWwpKVxuICAuZmlsdGVyKGVsID0+IGVsLm5hbWUgIT09IHVuZGVmaW5lZCAmJiBlbC5uYW1lICE9PSAnJylcbiAgLnJlZHVjZSgobywgZWwpID0+IG9iai5wYXRjaChvLCBlbC5uYW1lLnNwbGl0KCcuJyksXG4gICAgZWwudHlwZSAmJiBlbC50eXBlID09PSAnbnVtYmVyJ1xuICAgICAgPyBOdW1iZXIoZWwudmFsdWUpXG4gICAgICA6IGVsLnZhbHVlXG4gICksIHt9KSk7XG5cbmNvbnN0IGNsZWFyID0gZm9ybSA9PiBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gIC5mb3JFYWNoKGVsID0+IChlbC52YWx1ZSA9IG51bGwpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHRvRGF0YSxcblx0Y2xlYXJcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbmNvbnN0IHBhcnNlUGFkID0gcGFkID0+IHBhZCAmJiAoe1xuXHRheGVzOiBwYWQuYXhlcyxcblx0YnV0dG9uczogcGFkLmJ1dHRvbnMubWFwKGJ1dHRvbiA9PiAoe1xuXHRcdHByZXNzZWQ6IGJ1dHRvbi5wcmVzc2VkLFxuXHRcdHZhbHVlOiBidXR0b24udmFsdWVcblx0fSkpLFxuXHRjb25uZWN0ZWQ6IHBhZC5jb25uZWN0ZWQsXG5cdGlkOiBwYWQuaWQsXG5cdGluZGV4OiBwYWQuaW5kZXgsXG5cdG1hcHBpbmc6IHBhZC5tYXBwaW5nLFxuXHR0aW1lc3RhbXA6IHBhZC50aW1lc3RhbXBcbn0pIHx8IHBhZDtcblxuY29uc3QgbGlzdCA9ICgpID0+IEFycmF5LmZyb20obmF2aWdhdG9yLmdldEdhbWVwYWRzKCkgfHwgbmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzKCkgfHwgW10pXG5cdC5tYXAocGFyc2VQYWQpO1xuXG5jb25zdCBjaGFuZ2VzID0gKCkgPT4gdGltZS5mcmFtZSgpXG5cdC5tYXAobGlzdClcblx0LmRpc3RpbmN0VW50aWxDaGFuZ2VkKHBhZHMgPT4gcGFkcylcblx0Ly9cdHBhZHMucmVkdWNlKChyLCBwYWQpID0+ICFwYWQgJiYgciB8fCAociArIChwYWQuYXhlcyB8fCAnJykgKyAocGFkLmJ1dHRvbnMgfHwgJycpKSwgJycpKVxuXHQuc2hhcmUoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGxpc3QsXG5cdGNoYW5nZXNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCBrZXlzID0gWydDJywgJ0MjJywgJ0QnLCAnRCMnLCAnRScsICdGJywgJ0YjJywgJ0cnLCAnRyMnLCAnQScsICdBIycsICdCJ107XG5cbmNvbnN0IG51bWJlclRvTm90ZSA9IG51bWJlciA9PiAoe1xuXHRrZXk6IGtleXNbbnVtYmVyICUgMTJdLFxuXHRvY3RhdmU6IHBhcnNlSW50KChudW1iZXIgLSBudW1iZXIgJSAxMikgLyAxMiwgMTApIC0gMSxcblx0bnVtYmVyXG59KTtcblxuY29uc3Qgbm90ZVRvTnVtYmVyID0gbm90ZSA9PiAoXG5cdGtleXMuaW5kZXhPZihub3RlLnJlcGxhY2UoL1swLTldKy8sICcnKSkgK1xuXHQocGFyc2VJbnQobm90ZS5yZXBsYWNlKC9bQS1aI2JdKy8sICcnKSwgMTApICsgMSkgKiAxMlxuKTtcblxuY29uc3QgcGFyc2VNaWRpTXNnID0gZXZlbnQgPT4ge1xuXHQvLyBNYXNrIG9mZiB0aGUgbG93ZXIgbmliYmxlIChNSURJIGNoYW5uZWwsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQpXG5cblx0Y29uc3Qgc3RhdHVzID0gZXZlbnQuZGF0YVswXSAmIDB4ZjA7XG5cdGNvbnN0IGJpbmFyeSA9IGV2ZW50LmRhdGFbMF0udG9TdHJpbmcoMik7XG5cdGNvbnN0IGNoYW5uZWwgPSBldmVudC5kYXRhWzBdIC0gc3RhdHVzICsgMTtcblx0bGV0IG1zZyA9IHt9O1xuXG5cdHN3aXRjaCAoYmluYXJ5LnNsaWNlKDAsIDQpKSB7XG5cdFx0Ly8gbm90ZW9mZlxuXHRcdGNhc2UgXCIxMDAwXCI6XG5cdFx0XHRtc2cgPSB7XG5cdFx0XHRcdHN0YXRlOiAnbm90ZU9mZicsXG5cdFx0XHRcdG5vdGU6IG51bWJlclRvTm90ZShldmVudC5kYXRhWzFdKVxuXHRcdFx0fTtcblx0XHRcdGJyZWFrO1xuXHRcdC8vIG5vdGVvblxuXHRcdGNhc2UgXCIxMDAxXCI6XG5cdFx0XHRtc2cgPSAoZXZlbnQuZGF0YVsyXSAhPT0gMCkgLy8gaWYgdmVsb2NpdHkgIT0gMCwgdGhpcyBpcyBhIG5vdGUtb24gbWVzc2FnZVxuXHRcdFx0XHQ/IHtcblx0XHRcdFx0XHRzdGF0ZTogJ25vdGVPbicsXG5cdFx0XHRcdFx0bm90ZTogbnVtYmVyVG9Ob3RlKGV2ZW50LmRhdGFbMV0pLFxuXHRcdFx0XHRcdHZlbG9jaXR5OiBwYXJzZUZsb2F0KChldmVudC5kYXRhWzJdIC8gMTI3KS50b0ZpeGVkKDIpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdDogeyAvLyBpZiB2ZWxvY2l0eSA9PSAwLCBmYWxsIHRocnU6IGl0J3MgYSBub3RlLW9mZi5cdE1JREkncyB3ZWlyZCwgeWEnbGwuXG5cdFx0XHRcdFx0c3RhdGU6ICdub3RlT2ZmJyxcblx0XHRcdFx0XHRub3RlOiBudW1iZXJUb05vdGUoZXZlbnQuZGF0YVsxXSlcblx0XHRcdFx0fTtcblx0XHRcdGJyZWFrO1xuXHRcdC8vIHBpdGNoIHdoZWVsXG5cdFx0Y2FzZSBcIjExMTBcIjpcblx0XHRcdG1zZyA9IHtcblx0XHRcdFx0c3RhdGU6ICdwaXRjaEJlbmQnLFxuXHRcdFx0XHRwaXRjaFZhbHVlOiAoZXZlbnQuZGF0YVsyXSA9PT0gNjQpID8gMCA6IHBhcnNlRmxvYXQoKGV2ZW50LmRhdGFbMl0gLyA2My41IC0gMSkudG9GaXhlZCgyKSlcblx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHQvLyBjb250cm9sbGVyXG5cdFx0Y2FzZSBcIjEwMTFcIjpcblx0XHRcdG1zZyA9IHtcblx0XHRcdFx0c3RhdGU6IFwiY29udHJvbGxlclwiLFxuXHRcdFx0XHRjb250cm9sbGVyOiBldmVudC5kYXRhWzFdLFxuXHRcdFx0XHR2YWx1ZTogcGFyc2VGbG9hdCgoZXZlbnQuZGF0YVsyXSAvIDEyNykudG9GaXhlZCgyKSlcblx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiMTEwMFwiOlxuXHRcdFx0bXNnID0ge1xuXHRcdFx0XHRzdGF0ZTogXCJiYW5rU2VsZWN0XCIsXG5cdFx0XHRcdGJhbms6IGV2ZW50LmRhdGFbMV1cblx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bXNnID0ge1xuXHRcdFx0XHRzdGF0ZTogZmFsc2Vcblx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBtc2csIHtcblx0XHRiaW5hcnksXG5cdFx0c3RhdHVzLFxuXHRcdGNoYW5uZWwsXG5cdFx0ZGF0YTogZXZlbnQuZGF0YVxuXHR9KTtcbn07XG4vL1xuLy8gY29uc3QgaG9va1VwTUlESUlucHV0ID0gbWlkaUFjY2VzcyA9PiB7XG4vLyBcdHZhciBoYXZlQXRMZWFzdE9uZURldmljZSA9IGZhbHNlO1xuLy8gXHR2YXIgaW5wdXRzID0gbWlkaUFjY2Vzcy5pbnB1dHMudmFsdWVzKCk7XG4vLyBcdGZvciAodmFyIGlucHV0ID0gaW5wdXRzLm5leHQoKTsgaW5wdXQgJiYgIWlucHV0LmRvbmU7IGlucHV0ID0gaW5wdXRzLm5leHQoKSkge1xuLy8gXHRcdGlucHV0LnZhbHVlLm9ubWlkaW1lc3NhZ2UgPSBNSURJTWVzc2FnZUV2ZW50SGFuZGxlcjtcbi8vIFx0XHRoYXZlQXRMZWFzdE9uZURldmljZSA9IHRydWU7XG4vLyBcdH1cbi8vIH07XG4vL1xuLy8gY29uc3Qgb25NSURJSW5pdCA9IG1pZGkgPT4ge1xuLy8gXHRob29rVXBNSURJSW5wdXQobWlkaSk7XG4vLyBcdG1pZGkub25zdGF0ZWNoYW5nZSA9IGhvb2tVcE1JRElJbnB1dDtcbi8vIH07XG4vL1xuLy8gY29uc3Qgb25NSURJUmVqZWN0ID0gZXJyID0+XG4vLyBcdGNvbnNvbGUubG9nKGVyciwgJ1RoZSBNSURJIHN5c3RlbSBmYWlsZWQgdG8gc3RhcnQuJyk7XG4vL1xuLy8gKG5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2Vzcylcbi8vIFx0XHQmJiBuYXZpZ2F0b3IucmVxdWVzdE1JRElBY2Nlc3MoKS50aGVuKG9uTUlESUluaXQsIG9uTUlESVJlamVjdCk7XG5cbmNvbnN0IHBhcnNlQWNjZXNzID0gYWNjZXNzID0+IHtcblx0bGV0IGlucHV0cyA9IFtdO1xuXHRsZXQgb3V0cHV0cyA9IFtdO1xuXG5cdC8vIGNvbnNvbGUubG9nKGFjY2Vzcyk7XG5cblx0YWNjZXNzLmlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0cy5wdXNoKGlucHV0KSk7XG5cdGFjY2Vzcy5vdXRwdXRzLmZvckVhY2gob3V0cHV0ID0+IG91dHB1dHMucHVzaChvdXRwdXQpKTtcblx0cmV0dXJuIHthY2Nlc3MsIGlucHV0cywgb3V0cHV0c307XG59O1xuXG5jb25zdCBpbml0ID0gKCkgPT4ge1xuXHRjb25zdCBkZXZpY2VzJCA9IG5ldyBSeC5TdWJqZWN0KCk7XG5cdCQuZnJvbVByb21pc2UobmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCkpXG5cdFx0LmZsYXRNYXAoYWNjZXNzID0+ICQuY3JlYXRlKHN0cmVhbSA9PiB7XG5cdFx0XHRhY2Nlc3Mub25zdGF0ZWNoYW5nZSA9IGNvbm5lY3Rpb24gPT4gc3RyZWFtLm9uTmV4dChjb25uZWN0aW9uLmN1cnJlbnRUYXJnZXQpO1xuXHRcdH0pLnN0YXJ0V2l0aChhY2Nlc3MpKVxuXHRcdC5tYXAocGFyc2VBY2Nlc3MpXG5cdFx0Ly8gLm1hcChkYXRhID0+IChjb25zb2xlLmxvZygnbWlkaSBhY2Nlc3MnLCBkYXRhKSwgZGF0YSkpXG5cdFx0LnN1YnNjcmliZShkZXZpY2UgPT4gZGV2aWNlcyQub25OZXh0KGRldmljZSkpO1xuXHRcdC8vIC5zaGFyZSgpO1xuXG5cdGNvbnN0IG1zZyQgPSBuZXcgUnguU3ViamVjdCgpO1xuXHRkZXZpY2VzJC5mbGF0TWFwKFxuXHRcdCh7YWNjZXNzLCBpbnB1dHN9KSA9PiBpbnB1dHMucmVkdWNlKFxuXHRcdFx0XHQobXNnU3RyZWFtLCBpbnB1dCkgPT4gbXNnU3RyZWFtLm1lcmdlKFxuXHRcdFx0XHRcdCQuZnJvbUV2ZW50UGF0dGVybihoID0+IHtcblx0XHRcdFx0XHRcdGlucHV0Lm9ubWlkaW1lc3NhZ2UgPSBoO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Lm1hcChtc2cgPT4gKHthY2Nlc3MsIGlucHV0LCBtc2d9KSlcblx0XHRcdFx0KSwgJC5lbXB0eSgpXG5cdFx0XHQpXG5cdCkuc3Vic2NyaWJlKG1zZyA9PiBtc2ckLm9uTmV4dChtc2cpKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRldmljZXMkLFxuXHRcdG1zZyRcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbml0LFxuXHRudW1iZXJUb05vdGUsXG5cdG5vdGVUb051bWJlcixcblx0cGFyc2VNaWRpTXNnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxubGV0IHBvY2tldDtcblxubGV0IHJlZHVjZXJzJCA9IG5ldyBSeC5TdWJqZWN0KCk7XG5sZXQgcG9ja2V0JCA9IG5ldyBSeC5CZWhhdmlvclN1YmplY3Qoe30pO1xuXG5yZWR1Y2VycyRcblx0LnNjYW4oKHBvY2tldCwgcmVkdWNlKSA9PiByZWR1Y2UocG9ja2V0KSwge30pXG5cdC5zdWJzY3JpYmUocG9ja2V0ID0+IHBvY2tldCQub25OZXh0KHBvY2tldCkpO1xuXG5wb2NrZXQkLnN1YnNjcmliZShfcG9ja2V0ID0+IHtcblx0Ly8gY29uc29sZS5sb2coe3BvY2tldH0pO1xuXHRwb2NrZXQgPSBfcG9ja2V0O1xufSk7XG5cbmNvbnN0IHB1dCA9IChwYXRoLCB2YWwpID0+IHJlZHVjZXJzJC5vbk5leHQocG9ja2V0ID0+IG9iai5wYXRjaChwb2NrZXQsIHBhdGgsIHZhbCkpO1xuY29uc3QgZ2V0ID0gcGF0aCA9PiBvYmouc3ViKHBvY2tldCwgcGF0aCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRwdXQsXG5cdGdldCxcblx0cmVkdWNlcnMkLFxuXHRzdHJlYW06IHBvY2tldCRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCByYWYgPSByZXF1aXJlKCdyYWYnKTtcblxuY29uc3QgdGljayA9IGNiID0+IHJhZihmdW5jdGlvbihkdCkge1xuXHRjYihkdCk7XG5cdHRpY2soY2IpO1xufSk7XG5cbmNvbnN0IGZyYW1lID0gKCkgPT4gJC5jcmVhdGUoXG5cdG9icyA9PiB0aWNrKGR0ID0+IG9icy5vbk5leHQoZHQpKVxuKVxuXHQuZmlsdGVyKGR0ID0+IGR0ICE9PSAwKVxuXHQuc2hhcmUoKTtcblxuY29uc3QgbG9vcCA9IChzdGF0ZSQsIG5vZGUpID0+IGZyYW1lKG5vZGUpLndpdGhMYXRlc3RGcm9tKHN0YXRlJCwgKGR0LCBzdGF0ZSkgPT4gKHtkdCwgc3RhdGV9KSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRmcmFtZSxcblx0bG9vcFxufTtcbiJdfQ==
