(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0; i < l; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

},{}],2:[function(require,module,exports){
"use strict";

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

var base64 = require('base64-js');
var ieee754 = require('ieee754');
var isArray = require('isarray');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":1,"ieee754":28,"isarray":32}],4:[function(require,module,exports){
'use strict';

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],5:[function(require,module,exports){
(function (Buffer){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":31}],6:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;

  if (!this._events) this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events || !this._events[type]) return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;

  if (!this._events) return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
(function (global){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (a, b) {
  if ("function" == typeof define && define.amd) define([], b);else if ("undefined" != typeof exports) b();else {
    b(), a.FileSaver = { exports: {} }.exports;
  }
})(undefined, function () {
  "use strict";
  function b(a, b) {
    return "undefined" == typeof b ? b = { autoBom: !1 } : "object" != (typeof b === "undefined" ? "undefined" : _typeof(b)) && (console.warn("Depricated: Expected third argument to be a object"), b = { autoBom: !b }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], { type: a.type }) : a;
  }function c(b, c, d) {
    var e = new XMLHttpRequest();e.open("GET", b), e.responseType = "blob", e.onload = function () {
      a(e.response, c, d);
    }, e.onerror = function () {
      console.error("could not download file");
    }, e.send();
  }function d(a) {
    var b = new XMLHttpRequest();return b.open("HEAD", a, !1), b.send(), 200 <= b.status && 299 >= b.status;
  }function e(a) {
    try {
      a.dispatchEvent(new MouseEvent("click"));
    } catch (c) {
      var b = document.createEvent("MouseEvents");b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
    }
  }var f = function () {
    try {
      return Function("return this")() || (42, eval)("this");
    } catch (a) {
      return "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.window === window ? window : "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self ? self : "object" == (typeof global === "undefined" ? "undefined" : _typeof(global)) && global.global === global ? global : this;
    }
  }(),
      a = f.saveAs || "object" != (typeof window === "undefined" ? "undefined" : _typeof(window)) || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype ? function (b, g, h) {
    var i = f.URL || f.webkitURL,
        j = document.createElement("a");g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
      i.revokeObjectURL(j.href);
    }, 4E4), setTimeout(function () {
      e(j);
    }, 0));
  } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
    if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
      var i = document.createElement("a");i.href = f, i.target = "_blank", setTimeout(function () {
        e(i);
      });
    }
  } : function (a, b, d, e) {
    if (e = e || open("", "_blank"), e && (e.document.title = e.document.body.innerText = "downloading..."), "string" == typeof a) return c(a, b, d);var g = "application/octet-stream" === a.type,
        h = /constructor/i.test(f.HTMLElement) || f.safari,
        i = /CriOS\/[\d]+/.test(navigator.userAgent);if ((i || g && h) && "object" == (typeof FileReader === "undefined" ? "undefined" : _typeof(FileReader))) {
      var j = new FileReader();j.onloadend = function () {
        var a = j.result;a = i ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), e ? e.location.href = a : location = a, e = null;
      }, j.readAsDataURL(a);
    } else {
      var k = f.URL || f.webkitURL,
          l = k.createObjectURL(a);e ? e.location = l : location.href = l, e = null, setTimeout(function () {
        k.revokeObjectURL(l);
      }, 4E4);
    }
  };f.saveAs = a.saveAs = a, "undefined" != typeof module && (module.exports = a);
});



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
module.exports=[
	"a",
	"abbr",
	"address",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"bdi",
	"bdo",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"cite",
	"code",
	"col",
	"colgroup",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"div",
	"dl",
	"dt",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"img",
	"input",
	"ins",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"main",
	"map",
	"mark",
	"math",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"nav",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"picture",
	"pre",
	"progress",
	"q",
	"rb",
	"rp",
	"rt",
	"rtc",
	"ruby",
	"s",
	"samp",
	"script",
	"section",
	"select",
	"slot",
	"small",
	"source",
	"span",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"svg",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"u",
	"ul",
	"var",
	"video",
	"wbr"
]

},{}],9:[function(require,module,exports){
'use strict';

module.exports = require('./html-tags.json');

},{"./html-tags.json":8}],10:[function(require,module,exports){
'use strict';

module.exports = {
	obj: require('./lib/obj'),
	arr: require('./lib/arr'),
	str: require('./lib/str'),
	fn: require('./lib/fn')
};

},{"./lib/arr":11,"./lib/fn":12,"./lib/obj":13,"./lib/str":14}],11:[function(require,module,exports){
'use strict';

var add = function add(arr, item) {
	return [].concat(arr, [item]);
};

var remove = function remove(arr, item) {
	return arr.indexOf(item) > -1 ? [].concat(arr.slice(0, arr.indexOf(item)), arr.slice(arr.indexOf(item) + 1)) : arr;
};

var toggle = function toggle(arr, item) {
	return arr.indexOf(item) > -1 ? remove(arr, item) : add(arr, item);
};

module.exports = {
	add: add,
	remove: remove,
	toggle: toggle
};

},{}],12:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var obj = require('./obj');

// (((a, b, …, n) → o), (o → p), …, (x → y), (y → z)) → ((a, b, …, n) → z)
var pipe = function pipe(a) {
	for (var _len = arguments.length, fns = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		fns[_key - 1] = arguments[_key];
	}

	return function () {
		return fns.reduce(function (res, fn) {
			return fn(res);
		}, a.apply(undefined, arguments));
	};
};

// ((y → z), (x → y), …, (o → p), ((a, b, …, n) → o)) → ((a, b, …, n) → z)
var compose = function compose() {
	for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		fns[_key2] = arguments[_key2];
	}

	return pipe.apply(undefined, [fns.slice(-1).pop()].concat(_toConsumableArray(fns.reverse().slice(1))));
};

// switch for backwards compatibility
module.exports = {
	compose: compose,
	pipe: pipe,
	switch: obj.switch
};

},{"./obj":13}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var keyValue = function keyValue(k, v) {
	var o = {};
	o[k] = v;
	return o;
};

var clone = function clone(o) {
	return _extends(Object.create(Object.getPrototypeOf(o) || {}), o);
};

var sub = function sub(o, p) {
	return p instanceof Array ? typeof o[p[0]] !== 'undefined' && p.length > 1 ? sub(o[p[0]], p.slice(1)) : o[p[0]] : o[p];
};

var patch = function patch(o, k, v) {
	return _extends(clone(o), k instanceof Array ? keyValue(k[0], k.length > 1 ? patch(o[k[0]] || {}, k.slice(1), v) : _typeof(o[k[0]]) === 'object' && o[k[0]].constructor === Object && _extends(clone(o[k[0]]), v) || v) : keyValue(k, _typeof(o[k]) === 'object' && o[k].constructor === Object && _extends(clone(o[k]), v) || v));
};

var reduce = function reduce(o, reduceFn, initial) {
	return Object.keys(o).reduce(function (accumulator, key, index) {
		return reduceFn(accumulator, key, o[key], index, o);
	}, typeof initial === 'undefined' ? o[Object.keys(o)[0]] // to confirm with the array reduce spec in this case the firts property is used
	: initial);
};

var map = function map(o, mapFn) {
	return reduce(o, function (o2, key, value, index) {
		return patch(o2, key, mapFn(key, value, index, o));
	}, {});
};

var filter = function filter(o, filterFn) {
	return reduce(o, function (o2, key, value, index) {
		return filterFn(key, value, index, o) ? patch(o2, key, value) : o2;
	}, {});
};

var traverse = function traverse(tree, fn) {
	return Object.keys(tree).reduce(function (o, k) {
		return patch(o, k, _typeof(tree[k]) === 'object' && tree[k].constructor === Object ? traverse(tree[k], fn) : fn(tree[k], k));
	}, {});
};

var chainCall = function chainCall(o, chain) {
	return chain.reduce(function (o, link) {
		return typeof link[1] === 'undefined' ? o[link[0]]() : o[link[0]](link[1]);
	}, o);
};

var _switch = function _switch(value, cases) {
	return sub(cases, value) && sub(cases, value)['default'] || sub(cases, value) || value instanceof Array && value.length > 1 && _switch(value.slice(0, value.length - 1), cases) || cases['default'] || false;
};

module.exports = {
	keyValue: keyValue,
	clone: clone,
	sub: sub,
	patch: patch,
	reduce: reduce,
	map: map,
	filter: filter,
	traverse: traverse,
	chainCall: chainCall,
	switch: _switch
};

},{}],14:[function(require,module,exports){
'use strict';

var capitalize = function capitalize(chunk) {
	return chunk.charAt(0).toUpperCase() + chunk.slice(1);
};

var toCamelCase = function toCamelCase(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	return str.split(glue).map(function (chunk, i) {
		return i === 0 ? chunk : capitalize(chunk);
	}).join('');
};

var fromCamelCase = function fromCamelCase(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	return str.replace(/([A-Z])/g, ' $1').split(' ').map(function (chunk) {
		return chunk.toLowerCase();
	}).join(glue);
};

var singularToPlural = function singularToPlural(str) {
	return str.replace(/y$/, 'ie').concat('s');
};

var pluralToSingular = function pluralToSingular(str) {
	return str.replace(/ies$/, 'y').replace(/s$/, '');
};

var toDocumentId = function toDocumentId(str) {
	var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
	var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Id';
	var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
	return prefix.concat(pluralToSingular(toCamelCase(str, glue)), suffix);
};

module.exports = {
	capitalize: capitalize,
	toCamelCase: toCamelCase,
	fromCamelCase: fromCamelCase,
	singularToPlural: singularToPlural,
	pluralToSingular: pluralToSingular,
	toDocumentId: toDocumentId
};

},{}],15:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var snabbdom = require('snabbdom');
var h = require('snabbdom/h').default;

var _require = require('iblokz-data'),
    obj = _require.obj;

var htmlTags = require('html-tags');

var attrs = require('./util/attrs');

var patch = snabbdom.init([// Init patch function with choosen modules
require('snabbdom/modules/class').default, // makes it easy to toggle classes
require('snabbdom/modules/props').default, // for setting properties on DOM elements
require('snabbdom/modules/attributes').default, // for setting properties on DOM elements
require('snabbdom/modules/style').default, // handles styling on elements with support for animations
require('snabbdom/modules/eventlisteners').default // attaches event listeners
]);

var patchStream = function patchStream(stream, dom) {
	dom = typeof dom === 'string' ? document.querySelector(dom) : dom;
	stream.scan(function (vnode, newVnode) {
		return patch(vnode, newVnode);
	}, dom).subscribe();
};

var hyperHelpers = htmlTags.reduce(function (o, tag) {
	o[tag] = function () {
		var _this = this;

		return [Array.from(arguments)].map(attrs.process).map(function (args) {
			return (
				// is the first argument a selector
				args[0] && typeof args[0] === 'string' && args[0].match(/^(\.|#)[a-zA-Z\-_0-9]+/ig) ? [].concat(tag + args[0], args.slice(1)) : [tag].concat(args)
			);
		}).map(function (args) {
			return h.apply(_this, args);
		}).pop();
	};
	return o;
}, {});

module.exports = _extends({
	h: h,
	patch: patch,
	patchStream: patchStream
}, hyperHelpers);

},{"./util/attrs":27,"html-tags":9,"iblokz-data":10,"snabbdom":24,"snabbdom/h":16,"snabbdom/modules/attributes":19,"snabbdom/modules/class":20,"snabbdom/modules/eventlisteners":21,"snabbdom/modules/props":22,"snabbdom/modules/style":23}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {},
        children,
        text,
        i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        } else if (is.primitive(c)) {
            text = c;
        } else if (c && c.sel) {
            children = [c];
        }
    } else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        } else if (is.primitive(b)) {
            text = b;
        } else if (b && b.sel) {
            children = [b];
        } else {
            data = b;
        }
    }
    if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i])) children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i]);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' && (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;


},{"./is":18,"./vnode":26}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
exports.htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment
};
exports.default = exports.htmlDomApi;


},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;


},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", "truespeed", "typemustmatch", "visible"];
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
var booleanAttrsDict = Object.create(null);
for (var i = 0, len = booleanAttrs.length; i < len; i++) {
    booleanAttrsDict[booleanAttrs[i]] = true;
}
function updateAttrs(oldVnode, vnode) {
    var key,
        elm = vnode.elm,
        oldAttrs = oldVnode.data.attrs,
        attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs) return;
    if (oldAttrs === attrs) return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (booleanAttrsDict[key]) {
                if (cur) {
                    elm.setAttribute(key, "");
                } else {
                    elm.removeAttribute(key);
                }
            } else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                } else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                } else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                } else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;


},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur,
        name,
        elm = vnode.elm,
        oldClass = oldVnode.data.class,
        klass = vnode.data.class;
    if (!oldClass && !klass) return;
    if (oldClass === klass) return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;


},{}],21:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    } else if ((typeof handler === "undefined" ? "undefined" : _typeof(handler)) === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            } else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        } else {
            // call multiple handlers
            for (var i = 0; i < handler.length; i++) {
                invokeHandler(handler[i]);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type,
        on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) {
        invokeHandler(on[name], vnode, event);
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on,
        oldListener = oldVnode.listener,
        oldElm = oldVnode.elm,
        on = vnode && vnode.data.on,
        elm = vnode && vnode.elm,
        name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                oldElm.removeEventListener(name, oldListener, false);
            }
        } else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                elm.addEventListener(name, listener, false);
            }
        } else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    elm.addEventListener(name, listener, false);
                }
            }
        }
    }
}
exports.eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
exports.default = exports.eventListenersModule;


},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key,
        cur,
        old,
        elm = vnode.elm,
        oldProps = oldVnode.data.props,
        props = vnode.data.props;
    if (!oldProps && !props) return;
    if (oldProps === props) return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;


},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var raf = typeof window !== 'undefined' && window.requestAnimationFrame || setTimeout;
var nextFrame = function nextFrame(fn) {
    raf(function () {
        raf(fn);
    });
};
function setNextFrame(obj, prop, val) {
    nextFrame(function () {
        obj[prop] = val;
    });
}
function updateStyle(oldVnode, vnode) {
    var cur,
        name,
        elm = vnode.elm,
        oldStyle = oldVnode.data.style,
        style = vnode.data.style;
    if (!oldStyle && !style) return;
    if (oldStyle === style) return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            } else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        } else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            } else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style,
        name,
        elm = vnode.elm,
        s = vnode.data.style;
    if (!s || !(style = s.destroy)) return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    var name,
        elm = vnode.elm,
        i = 0,
        compStyle,
        style = s.remove,
        amount = 0,
        applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1) amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm) --amount;
        if (amount === 0) rm();
    });
}
exports.styleModule = {
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;


},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
var htmldomapi_1 = require("./htmldomapi");
function isUndef(s) {
    return s === undefined;
}
function isDef(s) {
    return s !== undefined;
}
var emptyNode = vnode_1.default('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i,
        map = {},
        key,
        ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined) map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
var h_1 = require("./h");
exports.h = h_1.h;
var thunk_1 = require("./thunk");
exports.thunk = thunk_1.thunk;
function init(modules, domApi) {
    var i,
        j,
        cbs = {};
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i,
            data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children,
            sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        } else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag) : api.createElement(tag);
            if (hash < dot) elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, vnode);
            }if (is.array(children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            } else if (is.primitive(vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create) i.create(emptyNode, vnode);
                if (i.insert) insertedVnodeQueue.push(vnode);
            }
        } else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i,
            j,
            data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](vnode);
            }if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0,
                listeners = void 0,
                rm = void 0,
                ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1) {
                        cbs.remove[i_1](ch, rm);
                    }if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    } else {
                        rm();
                    }
                } else {
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0,
            newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            } else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            } else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                } else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    } else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx > oldEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode) return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i) {
                cbs.update[i](oldVnode, vnode);
            }i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        } else if (oldVnode.text !== vnode.text) {
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i) {
            cbs.pre[i]();
        }if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        } else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i) {
            cbs.post[i]();
        }return vnode;
    };
}
exports.init = init;


},{"./h":16,"./htmldomapi":17,"./is":18,"./thunk":25,"./vnode":26}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = require("./h");
function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i,
        old = oldVnode.data,
        cur = thunk.data;
    var oldArgs = old.args,
        args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
exports.thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return h_1.h(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
exports.default = exports.thunk;


},{"./h":16}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;


},{}],27:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('iblokz-data'),
    obj = _require.obj;

var strParse = function strParse(s) {
	return s.match(/^[0-9]+$/) ? parseInt(s, 10) : s.match(/^[0-9.]+$/) ? parseFloat(s) : s === 'true' ? true : s === 'false' ? false : s;
};

var process = function process(args) {
	var newArgs = args.slice();

	var selector = newArgs[0] && typeof newArgs[0] === 'string' && newArgs[0] || '';
	if (selector !== '') newArgs = newArgs.slice(1);

	var attrRegExp = /\[[a-z\-0-9]+=("[^"]+"|'[^']+'|[0-9.]+|true|false|[^\]^=^"^']+)\]/ig;

	var attrs = selector && selector.match(attrRegExp);
	selector = selector.replace(attrRegExp, '');

	attrs = attrs && attrs.map && attrs.map(function (c) {
		return c.replace(/[[\]("|')]/g, '').split('=');
	}).reduce(function (o, attr) {
		return obj.patch(o, attr[0], strParse(attr[1]));
	}, {}) || {};

	if (attrs && Object.keys(attrs).length > 0) {
		if (!newArgs[0] || newArgs[0] && _typeof(newArgs[0]) === 'object' && !(newArgs[0] instanceof Array)) {
			attrs = _extends({}, newArgs[0] && newArgs[0].attrs || {}, attrs);
			newArgs[0] = _extends({}, newArgs[0] || {}, { attrs: attrs });
		} else {
			newArgs = [{ attrs: attrs }].concat(newArgs);
		}
	}

	if (selector !== '') newArgs = [selector].concat(newArgs);

	// console.log(args, newArgs);
	return newArgs;
};

module.exports = {
	strParse: strParse,
	process: process
};

},{"iblokz-data":10}],28:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],29:[function(require,module,exports){
(function (global){
'use strict';

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function scheduleDrain() {
      element.data = called = ++called % 2;
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function scheduleDrain() {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function scheduleDrain() {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function scheduleDrain() {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
'use strict';

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],31:[function(require,module,exports){
'use strict';

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],32:[function(require,module,exports){
'use strict';

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],33:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

// public method for encoding
exports.encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0,
        len = input.length,
        remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }

    return output.join("");
};

// public method for decoding
exports.decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0,
        resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
    } else {
        output = new Array(totalLength | 0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }
    }

    return output;
};

},{"./support":62,"./utils":64}],34:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker: function getContentWorker() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker: function getCompressedWorker() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":38,"./stream/Crc32Probe":57,"./stream/DataLengthProbe":58,"./stream/DataWorker":59}],35:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function compressWorker(compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker: function uncompressWorker() {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":39,"./stream/GenericWorker":60}],36:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
    } else {
        return crc32str(crc | 0, input, input.length, 0);
    }
};

},{"./utils":64}],37:[function(require,module,exports){
'use strict';

exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],38:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)

var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":105}],39:[function(require,module,exports){
'use strict';

var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function (data) {
        self.push({
            data: data,
            meta: self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":60,"./utils":64,"pako":89}],40:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function decToHex(dec, bytes) {
    var hex = "",
        i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0) & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
        compression = streamInfo['compression'],
        useCustomEncoding = encodeFileName !== utf8.utf8encode,
        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
        comment = file.comment,
        encodedComment = utils.transformTo("string", encodeFileName(comment)),
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
        useUTF8ForComment = utfEncodedComment.length !== comment.length,
        dosTime,
        dosDate,
        extraFields = "",
        unicodePathExtraField = "",
        unicodeCommentExtraField = "",
        dir = file.dir,
        date = file.date;

    var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }

    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if (platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
        // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
        // Version
        decToHex(1, 1) +
        // NameCRC32
        decToHex(crc32(encodedFileName), 4) +
        // UnicodeName
        utfEncodedFileName;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x70" +
        // size
        decToHex(unicodePathExtraField.length, 2) +
        // content
        unicodePathExtraField;
    }

    if (useUTF8ForComment) {

        unicodeCommentExtraField =
        // Version
        decToHex(1, 1) +
        // CommentCRC32
        decToHex(crc32(encodedComment), 4) +
        // UnicodeName
        utfEncodedComment;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x63" +
        // size
        decToHex(unicodeCommentExtraField.length, 2) +
        // content
        unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);

    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
    // version made by (00: DOS)
    decToHex(versionMadeBy, 2) +
    // file header (common to file and central directory)
    header +
    // file comment length
    decToHex(encodedComment.length, 2) +
    // disk number start
    "\x00\x00" +
    // internal file attributes TODO
    "\x00\x00" +
    // external file attributes
    decToHex(extFileAttr, 4) +
    // relative offset of local header
    decToHex(offset, 4) +
    // file name
    encodedFileName +
    // extra field
    extraFields +
    // file comment
    encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
    // number of this disk
    "\x00\x00" +
    // number of the disk with the start of the central directory
    "\x00\x00" +
    // total number of entries in the central directory on this disk
    decToHex(entriesCount, 2) +
    // total number of entries in the central directory
    decToHex(entriesCount, 2) +
    // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) +
    // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) +
    // .ZIP file comment length
    decToHex(encodedComment.length, 2) +
    // .ZIP file comment
    encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function generateDataDescriptors(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
    // crc-32                          4 bytes
    decToHex(streamInfo['crc32'], 4) +
    // compressed size                 4 bytes
    decToHex(streamInfo['compressedSize'], 4) +
    // uncompressed size               4 bytes
    decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};

/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;

    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if (this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data: chunk.data,
            meta: {
                currentFile: this.currentFile,
                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data: generateDataDescriptors(streamInfo),
            meta: { percent: 100 }
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data: this.dirRecords[i],
            meta: { percent: 100 }
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data: dirEnd,
        meta: { percent: 100 }
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if (self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for (var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch (e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":36,"../signature":55,"../stream/GenericWorker":60,"../utf8":63,"../utils":64}],41:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function getCompression(fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir,
                date = file.date;

            file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                name: relativePath,
                dir: dir,
                date: date,
                comment: file.comment || "",
                unixPermissions: file.unixPermissions,
                dosPermissions: file.dosPermissions
            }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":35,"./ZipFileWorker":40}],42:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */

function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if (!(this instanceof JSZip)) {
        return new JSZip();
    }

    if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function () {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.5";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":37,"./external":38,"./load":43,"./object":47,"./support":62}],43:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        }).on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        }).resume();
    });
}

module.exports = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions: input.unixPermissions,
                dosPermissions: input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":38,"./nodejsUtils":46,"./stream/Crc32Probe":57,"./utf8":63,"./utils":64,"./zipEntries":65}],44:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function (chunk) {
        self.push({
            data: chunk,
            meta: {
                percent: 0
            }
        });
    }).on("error", function (e) {
        if (self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    }).on("end", function () {
        if (self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if (!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":60,"../utils":64}],45:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if (updateCb) {
            updateCb(meta);
        }
    }).on("error", function (e) {
        self.emit('error', e);
    }).on("end", function () {
        self.push(null);
    });
}

NodejsStreamOutputAdapter.prototype._read = function () {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":64,"readable-stream":48}],46:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode: typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function newBufferFrom(data, encoding) {
        // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`
        // in nodejs v4 (< v.4.5). It's not the expected implementation (and
        // has a different signature).
        // see https://github.com/nodejs/node/issues/8053
        // A condition on nodejs' version won't solve the issue as we don't
        // control the Buffer polyfills that may or may not be used.
        return new Buffer(data, encoding);
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function allocBuffer(size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            return new Buffer(size);
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer: function isBuffer(b) {
        return Buffer.isBuffer(b);
    },

    isStream: function isStream(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
};

}).call(this,require("buffer").Buffer)

},{"buffer":3}],47:[function(require,module,exports){
'use strict';

var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");

/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function fileAdd(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;

    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && o.unixPermissions & 0x4000) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && o.dosPermissions & 0x0010) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }

    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?
     return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function parentFolder(path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function forceTrailingSlash(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function folderAdd(name, createFolders) {
    createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function load() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function forEach(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) {
                // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function filter(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) {
                // the file matches the function
                result.push(entry);
            }
        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function file(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            } else {
                // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        } else {
            // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function folder(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function (relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function remove(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function (relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function generate(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function generateInternalStream(options) {
        var worker,
            opts = {};
        try {
            opts = utils.extend(options || {}, {
                streamFiles: false,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: 'application/zip',
                encodeFileName: utf8.utf8encode
            });

            opts.type = opts.type.toLowerCase();
            opts.compression = opts.compression.toUpperCase();

            // "binarystring" is prefered but the internals use "string".
            if (opts.type === "binarystring") {
                opts.type = "string";
            }

            if (!opts.type) {
                throw new Error("No output type specified.");
            }

            utils.checkSupport(opts.type);

            // accept nodejs `process.platform`
            if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
                opts.platform = "UNIX";
            }
            if (opts.platform === 'win32') {
                opts.platform = "DOS";
            }

            var comment = opts.comment || this.comment || "";
            worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
            worker = new GenericWorker("error");
            worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function generateAsync(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function generateNodeStream(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":34,"./defaults":37,"./generate":41,"./nodejs/NodejsStreamInputAdapter":44,"./nodejsUtils":46,"./stream/GenericWorker":60,"./stream/StreamHelper":61,"./utf8":63,"./utils":64,"./zipObject":67}],48:[function(require,module,exports){
"use strict";

/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":125}],49:[function(require,module,exports){
'use strict';

var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 0xFF;
    }
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function (i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":64,"./DataReader":50}],50:[function(require,module,exports){
'use strict';

var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function checkOffset(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function checkIndex(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function setIndex(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function skip(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function byteAt(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function readInt(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function readString(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function readData(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function lastIndexOfSignature(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function readAndCheckSignature(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function readDate() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
        (dostime >> 21 & 0x0f) - 1, // month
        dostime >> 16 & 0x1f, // day
        dostime >> 11 & 0x1f, // hour
        dostime >> 5 & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":64}],51:[function(require,module,exports){
'use strict';

var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":64,"./Uint8ArrayReader":53}],52:[function(require,module,exports){
'use strict';

var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function (i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function (sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function (size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":64,"./DataReader":50}],53:[function(require,module,exports){
'use strict';

var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":64,"./ArrayReader":49}],54:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":62,"../utils":64,"./ArrayReader":49,"./NodeBufferReader":51,"./StringReader":52,"./Uint8ArrayReader":53}],55:[function(require,module,exports){
'use strict';

exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],56:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":64,"./GenericWorker":60}],57:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
  GenericWorker.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
  this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":36,"../utils":64,"./GenericWorker":60}],58:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;

},{"../utils":64,"./GenericWorker":60}],59:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if (!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function () {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function () {

    if (this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null,
        nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch (this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
                break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
                break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
                break;
        }
        this.index = nextIndex;
        return this.push({
            data: data,
            meta: {
                percent: this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":64,"./GenericWorker":60}],60:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */

function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data': [],
        'end': [],
        'error': []
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push: function push(chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end: function end() {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error: function error(e) {
        if (this.isFinished) {
            return false;
        }

        if (this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if (this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on: function on(name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp: function cleanUp() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit: function emit(name, arg) {
        if (this._listeners[name]) {
            for (var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe: function pipe(next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious: function registerPrevious(previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous = previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause: function pause() {
        if (this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if (this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume: function resume() {
        if (!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if (this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if (this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush: function flush() {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk: function processChunk(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo: function withStreamInfo(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo: function mergeStreamInfo() {
        for (var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function lock() {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString: function toString() {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],61:[function(require,module,exports){
(function (Buffer){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch (e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch (type) {
        case "blob":
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
            return base64.encode(content);
        default:
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat(type, dataArray) {
    var i,
        index = 0,
        res = null,
        totalLength = 0;
    for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch (type) {
        case "string":
            return dataArray.join("");
        case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for (i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '" + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function _accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper.on('data', function (data, meta) {
            dataArray.push(data);
            if (updateCallback) {
                updateCallback(meta);
            }
        }).on('error', function (err) {
            dataArray = [];
            reject(err);
        }).on('end', function () {
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        }).resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
            break;
        case "base64":
            internalType = "string";
            break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate: function accumulate(updateCb) {
        return _accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on: function on(evt, fn) {
        var self = this;

        if (evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume: function resume() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause: function pause() {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream: function toNodejsStream(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
    }
};

module.exports = StreamHelper;

}).call(this,require("buffer").Buffer)

},{"../base64":33,"../external":38,"../nodejs/NodejsStreamOutputAdapter":45,"../support":62,"../utils":64,"./ConvertWorker":56,"./GenericWorker":60,"buffer":3}],62:[function(require,module,exports){
(function (Buffer){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
} else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    } catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        } catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch (e) {
    exports.nodestream = false;
}

}).call(this,require("buffer").Buffer)

},{"buffer":3,"readable-stream":48}],63:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function string2buf(str) {
    var buf,
        c,
        c2,
        m_pos,
        i,
        str_len = str.length,
        buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function utf8border(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) {
        max = buf.length;
    }

    // go back from last position, until start of sequence found
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
    }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) {
        return max;
    }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) {
        return max;
    }

    return pos + _utf8len[buf[pos]] > max ? pos : max;
};

// convert array to string
var buf2string = function buf2string(buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) {
            utf16buf[out++] = c;continue;
        }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
        }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;continue;
        }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};

// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};

/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if (this.leftOver && this.leftOver.length) {
        this.push({
            data: exports.utf8decode(this.leftOver),
            meta: {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":46,"./stream/GenericWorker":60,"./support":62,"./utils":64}],64:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('core-js/library/fn/set-immediate');
var external = require("./external");

/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
        result = new Uint8Array(str.length);
    } else {
        result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function (part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    } catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        } catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function stringifyByChunk(array, type, chunk) {
        var result = [],
            k = 0,
            len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function stringifyByChar(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        }()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;

/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function array(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function uint8array(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function nodebuffer(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function arraybuffer(input) {
        return new Uint8Array(input).buffer;
    },
    "uint8array": function uint8array(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function string(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function array(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function uint8array(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function arraybuffer(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function uint8array(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function (outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function (input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function (type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function (str) {
    var res = '',
        code,
        i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function (callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function Obj() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function () {
    var result = {},
        i,
        attr;
    for (i = 0; i < arguments.length; i++) {
        // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function (data) {

        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function (e) {
                    resolve(e.target.result);
                };
                reader.onerror = function (e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function (data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            } else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":33,"./external":38,"./nodejsUtils":46,"./support":62,"core-js/library/fn/set-immediate":68}],65:[function(require,module,exports){
'use strict';

var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function checkSignature(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function isSignature(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function readBlockEndOfCentral() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function readLocalFiles() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function readCentralDir() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function readEndOfCentral() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();

        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function prepareReader(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function load(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":54,"./signature":55,"./support":62,"./utf8":63,"./utils":64,"./zipEntry":66}],66:[function(require,module,exports){
'use strict';

var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function findCompression(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function isEncrypted() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function useUTF8() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function readLocalPart(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) {
            // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function readCentralPart(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function processAttributes() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if (madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function parseZIP64ExtraField(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function readExtraFields(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function handleUTF8() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":34,"./compressions":35,"./crc32":36,"./reader/readerFor":54,"./support":62,"./utf8":63,"./utils":64}],67:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function ZipObject(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function internalStream(type) {
        var result = null,
            outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function async(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function nodeStream(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function _compressWorker(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if (!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker: function _decompressWorker() {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function removedFn() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for (var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":34,"./stream/DataWorker":59,"./stream/GenericWorker":60,"./stream/StreamHelper":61,"./utf8":63}],68:[function(require,module,exports){
'use strict';

require('../modules/web.immediate');
module.exports = require('../modules/_core').setImmediate;

},{"../modules/_core":72,"../modules/web.immediate":88}],69:[function(require,module,exports){
'use strict';

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],70:[function(require,module,exports){
'use strict';

var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":83}],71:[function(require,module,exports){
"use strict";

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],72:[function(require,module,exports){
'use strict';

var core = module.exports = { version: '2.3.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],73:[function(require,module,exports){
'use strict';

// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":69}],74:[function(require,module,exports){
'use strict';

// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_fails":77}],75:[function(require,module,exports){
'use strict';

var isObject = require('./_is-object'),
    document = require('./_global').document
// in old IE typeof document.createElement is 'object'
,
    is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":78,"./_is-object":83}],76:[function(require,module,exports){
'use strict';

var global = require('./_global'),
    core = require('./_core'),
    ctx = require('./_ctx'),
    hide = require('./_hide'),
    PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      IS_WRAP = type & $export.W,
      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
      expProto = exports[PROTOTYPE],
      target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
      key,
      own,
      out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
          }return new C(a, b, c);
        }return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
      // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

},{"./_core":72,"./_ctx":73,"./_global":78,"./_hide":79}],77:[function(require,module,exports){
"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],78:[function(require,module,exports){
'use strict';

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],79:[function(require,module,exports){
'use strict';

var dP = require('./_object-dp'),
    createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":74,"./_object-dp":84,"./_property-desc":85}],80:[function(require,module,exports){
'use strict';

module.exports = require('./_global').document && document.documentElement;

},{"./_global":78}],81:[function(require,module,exports){
'use strict';

module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_descriptors":74,"./_dom-create":75,"./_fails":77}],82:[function(require,module,exports){
"use strict";

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
                  var un = that === undefined;
                  switch (args.length) {
                                    case 0:
                                                      return un ? fn() : fn.call(that);
                                    case 1:
                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
                                    case 2:
                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                    case 3:
                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                    case 4:
                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                  }return fn.apply(that, args);
};

},{}],83:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

},{}],84:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object'),
    IE8_DOM_DEFINE = require('./_ie8-dom-define'),
    toPrimitive = require('./_to-primitive'),
    dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":70,"./_descriptors":74,"./_ie8-dom-define":81,"./_to-primitive":87}],85:[function(require,module,exports){
"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],86:[function(require,module,exports){
'use strict';

var ctx = require('./_ctx'),
    invoke = require('./_invoke'),
    html = require('./_html'),
    cel = require('./_dom-create'),
    global = require('./_global'),
    process = global.process,
    setTask = global.setImmediate,
    clearTask = global.clearImmediate,
    MessageChannel = global.MessageChannel,
    counter = 0,
    queue = {},
    ONREADYSTATECHANGE = 'onreadystatechange',
    defer,
    channel,
    port;
var run = function run() {
  var id = +this;
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [],
        i = 1;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }queue[++counter] = function () {
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    };
    // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":71,"./_ctx":73,"./_dom-create":75,"./_global":78,"./_html":80,"./_invoke":82}],87:[function(require,module,exports){
'use strict';

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":83}],88:[function(require,module,exports){
'use strict';

var $export = require('./_export'),
    $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":76,"./_task":86}],89:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign = require('./lib/utils/common').assign;

var deflate = require('./lib/deflate');
var inflate = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":90,"./lib/inflate":91,"./lib/utils/common":92,"./lib/zlib/constants":95}],90:[function(require,module,exports){
'use strict';

var zlib_deflate = require('./zlib/deflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY = 0;

var Z_DEFLATED = 8;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }

  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":92,"./utils/strings":93,"./zlib/deflate":97,"./zlib/messages":102,"./zlib/zstream":104}],91:[function(require,module,exports){
'use strict';

var zlib_inflate = require('./zlib/inflate');
var utils = require('./utils/common');
var strings = require('./utils/strings');
var c = require('./zlib/constants');
var msg = require('./zlib/messages');
var ZStream = require('./zlib/zstream');
var GZheader = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }

  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

},{"./utils/common":92,"./utils/strings":93,"./zlib/constants":95,"./zlib/gzheader":98,"./zlib/inflate":100,"./zlib/messages":102,"./zlib/zstream":104}],92:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};

// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
};

// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],93:[function(require,module,exports){
// String encode/decode helpers
'use strict';

var utils = require('./common');

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}

// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};

// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};

// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;continue;
    }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

},{"./common":92}],94:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

},{}],95:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,

  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],96:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

},{}],97:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');
var trees = require('./trees');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var msg = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;

var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/* The deflate compression method */
var Z_DEFLATED = 8;

/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS = 256;
/* number of literal bytes 0..255 */
var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES = 30;
/* number of distance codes */
var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length; /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match; /* matched string */
  var len; /* length of current match */
  var best_len = s.prev_length; /* best match length so far */
  var nice_match = s.nice_match; /* stop if match long enough */
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head; /* head of the hash chain */
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head; /* head of hash chain */
  var bflush; /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {

          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush; /* set if current block must be flushed */
  var prev; /* byte at distance one to match */
  var scan, strend; /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0; /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0; /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;

        s.status = BUSY_STATE;
        putShortMSB(s, header);

        /* Save the adler32 of the preset dictionary: */
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }
        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  }

  //#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  //#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":92,"./adler32":94,"./crc32":96,"./messages":102,"./trees":103}],98:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}

module.exports = GZheader;

},{}],99:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js

var BAD = 30; /* got a data error -- remain here until reset */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in; /* local strm.input */
  var last; /* have enough input while in < last */
  var _out; /* local strm.output */
  var beg; /* inflate()'s initial strm.output */
  var end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  var dmax; /* maximum distance from zlib header */
  //#endif
  var wsize; /* window size or zero if not using window */
  var whave; /* valid bytes in the window */
  var wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window; /* allocated sliding window, if wsize != 0 */
  var hold; /* local strm.hold */
  var bits; /* local strm.bits */
  var lcode; /* local strm.lencode */
  var dcode; /* local strm.distcode */
  var lmask; /* mask for first level of length codes */
  var dmask; /* mask for first level of distance codes */
  var here; /* retrieved table entry */
  var op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  var len; /* match length, unused bytes */
  var dist; /* match distance */
  var from; /* where to copy match from */
  var from_source;

  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],100:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');
var adler32 = require('./adler32');
var crc32 = require('./crc32');
var inflate_fast = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED = 8;

/* STATES ====================================================================*/
/* ===========================================================================*/

var HEAD = 1; /* i: waiting for magic header */
var FLAGS = 2; /* i: waiting for method and flags (gzip) */
var TIME = 3; /* i: waiting for modification time (gzip) */
var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
var EXLEN = 5; /* i: waiting for extra length (gzip) */
var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
var NAME = 7; /* i: waiting for end of file name (gzip) */
var COMMENT = 8; /* i: waiting for end of comment (gzip) */
var HCRC = 9; /* i: waiting for header crc (gzip) */
var DICTID = 10; /* i: waiting for dictionary check value */
var DICT = 11; /* waiting for inflateSetDictionary() call */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
var STORED = 14; /* i: waiting for stored size (length and complement) */
var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
var COPY = 16; /* i/o: waiting for input or output to copy stored block */
var TABLE = 17; /* i: waiting for dynamic block table lengths */
var LENLENS = 18; /* i: waiting for code length code lengths */
var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
var LEN_ = 20; /* i: same as LEN below, but only first time in */
var LEN = 21; /* i: waiting for length/lit/eob code */
var LENEXT = 22; /* i: waiting for length extra bits */
var DIST = 23; /* i: waiting for distance code */
var DISTEXT = 24; /* i: waiting for distance extra bits */
var MATCH = 25; /* o: waiting for output space to copy string */
var LIT = 26; /* o: waiting for output space to write literal */
var CHECK = 27; /* i: waiting for 32-bit check value */
var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
var DONE = 29; /* finished check, done -- remain here until reset */
var BAD = 30; /* got a data error -- remain here until reset */
var MEM = 31; /* got an inflate() memory error -- remain here until reset */
var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib) */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null /*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers
  var next; /* next input INDEX */
  var put; /* next output INDEX */
  var have, left; /* available input and output */
  var hold; /* bit buffer */
  var bits; /* bits in bit buffer */
  var _in, _out; /* save starting available input and output */
  var copy; /* number of stored or match bytes to copy */
  var from; /* where to copy match bytes from */
  var from_source;
  var here = 0; /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len; /* length to copy for repeats, bits to drop */
  var ret; /* return code */
  var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0; /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff) << /*BITS(8)*/8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f) !== /*BITS(4)*/Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f) + /*BITS(4)*/8;
        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(state.head.extra, input, next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03) {/*BITS(2)*/case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f) + /*BITS(5)*/257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f) + /*BITS(5)*/1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f) + /*BITS(4)*/4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
      return Z_STREAM_ERROR;
    }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":92,"./adler32":94,"./crc32":96,"./inffast":99,"./inftrees":101}],101:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

var lext = [/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];

var dbase = [/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];

var dext = [/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  var len = 0; /* a code's length in bits */
  var sym = 0; /* index of code symbols */
  var min = 0,
      max = 0; /* minimum and maximum code lengths */
  var root = 0; /* number of index bits for root table */
  var curr = 0; /* number of index bits for current table */
  var drop = 0; /* code bits to drop for sub-table */
  var left = 0; /* number of prefix codes available */
  var used = 0; /* code entries in table used */
  var huff = 0; /* Huffman code */
  var incr; /* for incrementing code, index */
  var fill; /* index for replicating entries */
  var low; /* low bits for current root entry */
  var mask; /* mask for low root bits */
  var next; /* next available space in table */
  var base = null; /* base value table to use */
  var base_index = 0;
  //  var shoextra;    /* extra bits table to use */
  var end; /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work; /* dummy value--not used */
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":92}],102:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary', /* Z_NEED_DICT       2  */
  1: 'stream end', /* Z_STREAM_END      1  */
  0: '', /* Z_OK              0  */
  '-1': 'file error', /* Z_ERRNO         (-1) */
  '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error', /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],103:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/

//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY = 0;
var Z_TEXT = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/*============================================================================*/

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits = /* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

var extra_dbits = /* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

var extra_blbits = /* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h; /* heap index */
  var n, m; /* iterate over the tree elements */
  var bits; /* bit length */
  var xbits; /* extra bits */
  var f; /* frequency */
  var overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0; /* running code value */
  var bits; /* bit index */
  var n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n; /* iterates over tree elements */
  var bits; /* bit counter */
  var length; /* length value */
  var code; /* code value */
  var dist; /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}

/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }

  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s); /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  //  while (len--) {
  //    put_byte(s, *buf++);
  //  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}

// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist; /* distance of matched string */
  var lc; /* match length or unmatched char (if dist == 0) */
  var lx = 0; /* running index in l_buf */
  var code; /* the code to send */
  var extra; /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");
    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m; /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {

      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}

var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s) {

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}

/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  var max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility

  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif

  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":92}],104:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],105:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":29}],106:[function(require,module,exports){
(function (process){
"use strict";

// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(undefined);



}).call(this,require('_process'))

},{"_process":108}],107:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

}).call(this,require('_process'))

},{"_process":108}],108:[function(require,module,exports){
'use strict';

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],109:[function(require,module,exports){
(function (global){
'use strict';

var now = require('performance-now'),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
module.exports.cancel = function () {
  caf.apply(root, arguments);
};
module.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":106}],110:[function(require,module,exports){
'use strict';

module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":111}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":113,"./_stream_writable":115,"core-util-is":5,"inherits":30,"process-nextick-args":107}],112:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":114,"core-util-is":5,"inherits":30}],113:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":111,"./internal/streams/BufferList":116,"./internal/streams/destroy":117,"./internal/streams/stream":118,"_process":108,"core-util-is":5,"events":6,"inherits":30,"isarray":32,"process-nextick-args":107,"safe-buffer":124,"string_decoder/":126,"util":2}],114:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":111,"core-util-is":5,"inherits":30}],115:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":111,"./internal/streams/destroy":117,"./internal/streams/stream":118,"_process":108,"core-util-is":5,"inherits":30,"process-nextick-args":107,"safe-buffer":124,"util-deprecate":133}],116:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

},{"safe-buffer":124,"util":2}],117:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

},{"process-nextick-args":107}],118:[function(require,module,exports){
'use strict';

module.exports = require('events').EventEmitter;

},{"events":6}],119:[function(require,module,exports){
'use strict';

module.exports = require('./readable').PassThrough;

},{"./readable":120}],120:[function(require,module,exports){
'use strict';

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":111,"./lib/_stream_passthrough.js":112,"./lib/_stream_readable.js":113,"./lib/_stream_transform.js":114,"./lib/_stream_writable.js":115}],121:[function(require,module,exports){
'use strict';

module.exports = require('./readable').Transform;

},{"./readable":120}],122:[function(require,module,exports){
'use strict';

module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":115}],123:[function(require,module,exports){
(function (process,global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.

;(function (undefined) {

  var objectTypes = {
    'function': true,
    'object': true
  };

  function checkGlobal(value) {
    return value && value.Object === Object ? value : null;
  }

  var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : null;
  var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : null;
  var freeGlobal = checkGlobal(freeExports && freeModule && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global);
  var freeSelf = checkGlobal(objectTypes[typeof self === 'undefined' ? 'undefined' : _typeof(self)] && self);
  var freeWindow = checkGlobal(objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window);
  var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;
  var thisGlobal = checkGlobal(objectTypes[_typeof(this)] && this);
  var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();

  var Rx = {
    internals: {},
    config: {
      Promise: root.Promise
    },
    helpers: {}
  };

  // Defaults
  var noop = Rx.helpers.noop = function () {},
      identity = Rx.helpers.identity = function (x) {
    return x;
  },
      defaultNow = Rx.helpers.defaultNow = Date.now,
      defaultComparer = Rx.helpers.defaultComparer = function (x, y) {
    return isEqual(x, y);
  },
      defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) {
    return x > y ? 1 : x < y ? -1 : 0;
  },
      defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) {
    return x.toString();
  },
      defaultError = Rx.helpers.defaultError = function (err) {
    throw err;
  },
      isPromise = Rx.helpers.isPromise = function (p) {
    return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
  },
      isFunction = Rx.helpers.isFunction = function () {

    var isFn = function isFn(value) {
      return typeof value == 'function' || false;
    };

    // fallback for older versions of Chrome and Safari
    if (isFn(/x/)) {
      isFn = function isFn(value) {
        return typeof value == 'function' && toString.call(value) == '[object Function]';
      };
    }

    return isFn;
  }();

  function cloneArray(arr) {
    for (var a = [], i = 0, len = arr.length; i < len; i++) {
      a.push(arr[i]);
    }return a;
  }

  var errorObj = { e: {} };

  function tryCatcherGen(tryCatchTarget) {
    return function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    };
  }

  var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {
    if (!isFunction(fn)) {
      throw new TypeError('fn must be a function');
    }
    return tryCatcherGen(fn);
  };

  function thrower(e) {
    throw e;
  }

  Rx.config.longStackSupport = false;
  var hasStacks = false,
      stacks = tryCatch(function () {
    throw new Error();
  })();
  hasStacks = !!stacks.e && !!stacks.e.stack;

  // All code after this point will be filtered from stack traces reported by RxJS
  var rStartingLine = captureLine(),
      rFileName;

  var STACK_JUMP_SEPARATOR = 'From previous event:';

  function makeStackTraceLong(error, observable) {
    // If possible, transform the error stack trace by removing Node and RxJS
    // cruft, then concatenating with the stack trace of `observable`.
    if (hasStacks && observable.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
      var stacks = [];
      for (var o = observable; !!o; o = o.source) {
        if (o.stack) {
          stacks.unshift(o.stack);
        }
      }
      stacks.unshift(error.stack);

      var concatedStacks = stacks.join('\n' + STACK_JUMP_SEPARATOR + '\n');
      error.stack = filterStackString(concatedStacks);
    }
  }

  function filterStackString(stackString) {
    var lines = stackString.split('\n'),
        desiredLines = [];
    for (var i = 0, len = lines.length; i < len; i++) {
      var line = lines[i];

      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
        desiredLines.push(line);
      }
    }
    return desiredLines.join('\n');
  }

  function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    if (!fileNameAndLineNumber) {
      return false;
    }
    var fileName = fileNameAndLineNumber[0],
        lineNumber = fileNameAndLineNumber[1];

    return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
  }

  function isNodeFrame(stackLine) {
    return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
  }

  function captureLine() {
    if (!hasStacks) {
      return;
    }

    try {
      throw new Error();
    } catch (e) {
      var lines = e.stack.split('\n');
      var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];
      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
      if (!fileNameAndLineNumber) {
        return;
      }

      rFileName = fileNameAndLineNumber[0];
      return fileNameAndLineNumber[1];
    }
  }

  function getFileNameAndLineNumber(stackLine) {
    // Named functions: 'at functionName (filename:lineNumber:columnNumber)'
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
      return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: 'at filename:lineNumber:columnNumber'
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
      return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: 'function@filename:lineNumber or @filename:lineNumber'
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
      return [attempt3[1], Number(attempt3[2])];
    }
  }

  var EmptyError = Rx.EmptyError = function () {
    this.message = 'Sequence contains no elements.';
    Error.call(this);
  };
  EmptyError.prototype = Object.create(Error.prototype);
  EmptyError.prototype.name = 'EmptyError';

  var ObjectDisposedError = Rx.ObjectDisposedError = function () {
    this.message = 'Object has been disposed';
    Error.call(this);
  };
  ObjectDisposedError.prototype = Object.create(Error.prototype);
  ObjectDisposedError.prototype.name = 'ObjectDisposedError';

  var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function () {
    this.message = 'Argument out of range';
    Error.call(this);
  };
  ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);
  ArgumentOutOfRangeError.prototype.name = 'ArgumentOutOfRangeError';

  var NotSupportedError = Rx.NotSupportedError = function (message) {
    this.message = message || 'This operation is not supported';
    Error.call(this);
  };
  NotSupportedError.prototype = Object.create(Error.prototype);
  NotSupportedError.prototype.name = 'NotSupportedError';

  var NotImplementedError = Rx.NotImplementedError = function (message) {
    this.message = message || 'This operation is not implemented';
    Error.call(this);
  };
  NotImplementedError.prototype = Object.create(Error.prototype);
  NotImplementedError.prototype.name = 'NotImplementedError';

  var notImplemented = Rx.helpers.notImplemented = function () {
    throw new NotImplementedError();
  };

  var notSupported = Rx.helpers.notSupported = function () {
    throw new NotSupportedError();
  };

  // Shim in iterator support
  var $iterator$ = typeof Symbol === 'function' && Symbol.iterator || '_es6shim_iterator_';
  // Bug for mozilla version
  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };

  var isIterable = Rx.helpers.isIterable = function (o) {
    return o && o[$iterator$] !== undefined;
  };

  var isArrayLike = Rx.helpers.isArrayLike = function (o) {
    return o && o.length !== undefined;
  };

  Rx.helpers.iterator = $iterator$;

  var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {
    if (typeof thisArg === 'undefined') {
      return func;
    }
    switch (argCount) {
      case 0:
        return function () {
          return func.call(thisArg);
        };
      case 1:
        return function (arg) {
          return func.call(thisArg, arg);
        };
      case 2:
        return function (value, index) {
          return func.call(thisArg, value, index);
        };
      case 3:
        return function (value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
    }

    return function () {
      return func.apply(thisArg, arguments);
    };
  };

  /** Used to determine if values are of the language type Object */
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
      dontEnumsLength = dontEnums.length;

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  var objectProto = Object.prototype,
      hasOwnProperty = objectProto.hasOwnProperty,
      objToString = objectProto.toString,
      MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

  var keys = Object.keys || function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
        dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [],
          prop,
          i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }();

  function equalObjects(object, other, equalFunc, isLoose, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength !== othLength && !isLoose) {
      return false;
    }
    var index = objLength,
        key;
    while (index--) {
      key = objProps[index];
      if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var skipCtor = isLoose;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key],
          result;

      if (!(result === undefined ? equalFunc(objValue, othValue, isLoose, stackA, stackB) : result)) {
        return false;
      }
      skipCtor || (skipCtor = key === 'constructor');
    }
    if (!skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor !== othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }

  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        return +object === +other;

      case errorTag:
        return object.name === other.name && object.message === other.message;

      case numberTag:
        return object !== +object ? other !== +other : object === +other;

      case regexpTag:
      case stringTag:
        return object === other + '';
    }
    return false;
  }

  var isObject = Rx.internals.isObject = function (value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return !!value && (type === 'object' || type === 'function');
  };

  function isObjectLike(value) {
    return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
  }

  function isLength(value) {
    return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
  }

  var isHostObject = function () {
    try {
      Object({ 'toString': 0 } + '');
    } catch (e) {
      return function () {
        return false;
      };
    }
    return function (value) {
      return typeof value.toString !== 'function' && typeof (value + '') === 'string';
    };
  }();

  function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
  }

  var isArray = Array.isArray || function (value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) === arrayTag;
  };

  function arraySome(array, predicate) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  function equalArrays(array, other, equalFunc, isLoose, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength !== othLength && !(isLoose && othLength > arrLength)) {
      return false;
    }
    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index],
          result;

      if (result !== undefined) {
        if (result) {
          continue;
        }
        return false;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (isLoose) {
        if (!arraySome(other, function (othValue) {
          return arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB);
        })) {
          return false;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB))) {
        return false;
      }
    }
    return true;
  }

  function baseIsEqualDeep(object, other, equalFunc, isLoose, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;

    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag === argsTag) {
        objTag = objectTag;
      } else if (objTag !== objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag === argsTag) {
        othTag = objectTag;
      }
    }
    var objIsObj = objTag === objectTag && !isHostObject(object),
        othIsObj = othTag === objectTag && !isHostObject(other),
        isSameTag = objTag === othTag;

    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    if (!isLoose) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, isLoose, stackA, stackB);
      }
    }
    if (!isSameTag) {
      return false;
    }
    // Assume cyclic values are equal.
    // For more information on detecting circular references see https://es5.github.io/#JO.
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] === object) {
        return stackB[length] === other;
      }
    }
    // Add `object` and `other` to the stack of traversed objects.
    stackA.push(object);
    stackB.push(other);

    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, isLoose, stackA, stackB);

    stackA.pop();
    stackB.pop();

    return result;
  }

  function baseIsEqual(value, other, isLoose, stackA, stackB) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, isLoose, stackA, stackB);
  }

  var isEqual = Rx.internals.isEqual = function (value, other) {
    return baseIsEqual(value, other);
  };

  var hasProp = {}.hasOwnProperty,
      slice = Array.prototype.slice;

  var inherits = Rx.internals.inherits = function (child, parent) {
    function __() {
      this.constructor = child;
    }
    __.prototype = parent.prototype;
    child.prototype = new __();
  };

  var addProperties = Rx.internals.addProperties = function (obj) {
    for (var sources = [], i = 1, len = arguments.length; i < len; i++) {
      sources.push(arguments[i]);
    }
    for (var idx = 0, ln = sources.length; idx < ln; idx++) {
      var source = sources[idx];
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  };

  // Rx Utils
  var addRef = Rx.internals.addRef = function (xs, r) {
    return new AnonymousObservable(function (observer) {
      return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));
    });
  };

  function arrayInitialize(count, factory) {
    var a = new Array(count);
    for (var i = 0; i < count; i++) {
      a[i] = factory();
    }
    return a;
  }

  function IndexedItem(id, value) {
    this.id = id;
    this.value = value;
  }

  IndexedItem.prototype.compareTo = function (other) {
    var c = this.value.compareTo(other.value);
    c === 0 && (c = this.id - other.id);
    return c;
  };

  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {
    this.items = new Array(capacity);
    this.length = 0;
  };

  var priorityProto = PriorityQueue.prototype;
  priorityProto.isHigherPriority = function (left, right) {
    return this.items[left].compareTo(this.items[right]) < 0;
  };

  priorityProto.percolate = function (index) {
    if (index >= this.length || index < 0) {
      return;
    }
    var parent = index - 1 >> 1;
    if (parent < 0 || parent === index) {
      return;
    }
    if (this.isHigherPriority(index, parent)) {
      var temp = this.items[index];
      this.items[index] = this.items[parent];
      this.items[parent] = temp;
      this.percolate(parent);
    }
  };

  priorityProto.heapify = function (index) {
    +index || (index = 0);
    if (index >= this.length || index < 0) {
      return;
    }
    var left = 2 * index + 1,
        right = 2 * index + 2,
        first = index;
    if (left < this.length && this.isHigherPriority(left, first)) {
      first = left;
    }
    if (right < this.length && this.isHigherPriority(right, first)) {
      first = right;
    }
    if (first !== index) {
      var temp = this.items[index];
      this.items[index] = this.items[first];
      this.items[first] = temp;
      this.heapify(first);
    }
  };

  priorityProto.peek = function () {
    return this.items[0].value;
  };

  priorityProto.removeAt = function (index) {
    this.items[index] = this.items[--this.length];
    this.items[this.length] = undefined;
    this.heapify();
  };

  priorityProto.dequeue = function () {
    var result = this.peek();
    this.removeAt(0);
    return result;
  };

  priorityProto.enqueue = function (item) {
    var index = this.length++;
    this.items[index] = new IndexedItem(PriorityQueue.count++, item);
    this.percolate(index);
  };

  priorityProto.remove = function (item) {
    for (var i = 0; i < this.length; i++) {
      if (this.items[i].value === item) {
        this.removeAt(i);
        return true;
      }
    }
    return false;
  };
  PriorityQueue.count = 0;

  /**
   * Represents a group of disposable resources that are disposed together.
   * @constructor
   */
  var CompositeDisposable = Rx.CompositeDisposable = function () {
    var args = [],
        i,
        len;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      len = arguments.length;
      args = new Array(len);
      for (i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    this.disposables = args;
    this.isDisposed = false;
    this.length = args.length;
  };

  var CompositeDisposablePrototype = CompositeDisposable.prototype;

  /**
   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
   * @param {Mixed} item Disposable to add.
   */
  CompositeDisposablePrototype.add = function (item) {
    if (this.isDisposed) {
      item.dispose();
    } else {
      this.disposables.push(item);
      this.length++;
    }
  };

  /**
   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
   * @param {Mixed} item Disposable to remove.
   * @returns {Boolean} true if found; false otherwise.
   */
  CompositeDisposablePrototype.remove = function (item) {
    var shouldDispose = false;
    if (!this.isDisposed) {
      var idx = this.disposables.indexOf(item);
      if (idx !== -1) {
        shouldDispose = true;
        this.disposables.splice(idx, 1);
        this.length--;
        item.dispose();
      }
    }
    return shouldDispose;
  };

  /**
   *  Disposes all disposables in the group and removes them from the group.
   */
  CompositeDisposablePrototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var len = this.disposables.length,
          currentDisposables = new Array(len);
      for (var i = 0; i < len; i++) {
        currentDisposables[i] = this.disposables[i];
      }
      this.disposables = [];
      this.length = 0;

      for (i = 0; i < len; i++) {
        currentDisposables[i].dispose();
      }
    }
  };

  /**
   * Provides a set of static methods for creating Disposables.
   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
   */
  var Disposable = Rx.Disposable = function (action) {
    this.isDisposed = false;
    this.action = action || noop;
  };

  /** Performs the task of cleaning up resources. */
  Disposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.action();
      this.isDisposed = true;
    }
  };

  /**
   * Creates a disposable object that invokes the specified action when disposed.
   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
   * @return {Disposable} The disposable object that runs the given action upon disposal.
   */
  var disposableCreate = Disposable.create = function (action) {
    return new Disposable(action);
  };

  /**
   * Gets the disposable that does nothing when disposed.
   */
  var disposableEmpty = Disposable.empty = { dispose: noop };

  /**
   * Validates whether the given object is a disposable
   * @param {Object} Object to test whether it has a dispose method
   * @returns {Boolean} true if a disposable object, else false.
   */
  var isDisposable = Disposable.isDisposable = function (d) {
    return d && isFunction(d.dispose);
  };

  var checkDisposed = Disposable.checkDisposed = function (disposable) {
    if (disposable.isDisposed) {
      throw new ObjectDisposedError();
    }
  };

  var disposableFixup = Disposable._fixup = function (result) {
    return isDisposable(result) ? result : disposableEmpty;
  };

  // Single assignment
  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function () {
    this.isDisposed = false;
    this.current = null;
  };
  SingleAssignmentDisposable.prototype.getDisposable = function () {
    return this.current;
  };
  SingleAssignmentDisposable.prototype.setDisposable = function (value) {
    if (this.current) {
      throw new Error('Disposable has already been assigned');
    }
    var shouldDispose = this.isDisposed;
    !shouldDispose && (this.current = value);
    shouldDispose && value && value.dispose();
  };
  SingleAssignmentDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old = this.current;
      this.current = null;
      old && old.dispose();
    }
  };

  // Multiple assignment disposable
  var SerialDisposable = Rx.SerialDisposable = function () {
    this.isDisposed = false;
    this.current = null;
  };
  SerialDisposable.prototype.getDisposable = function () {
    return this.current;
  };
  SerialDisposable.prototype.setDisposable = function (value) {
    var shouldDispose = this.isDisposed;
    if (!shouldDispose) {
      var old = this.current;
      this.current = value;
    }
    old && old.dispose();
    shouldDispose && value && value.dispose();
  };
  SerialDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old = this.current;
      this.current = null;
    }
    old && old.dispose();
  };

  var BinaryDisposable = Rx.BinaryDisposable = function (first, second) {
    this._first = first;
    this._second = second;
    this.isDisposed = false;
  };

  BinaryDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      var old1 = this._first;
      this._first = null;
      old1 && old1.dispose();
      var old2 = this._second;
      this._second = null;
      old2 && old2.dispose();
    }
  };

  var NAryDisposable = Rx.NAryDisposable = function (disposables) {
    this._disposables = disposables;
    this.isDisposed = false;
  };

  NAryDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      for (var i = 0, len = this._disposables.length; i < len; i++) {
        this._disposables[i].dispose();
      }
      this._disposables.length = 0;
    }
  };

  /**
   * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
   */
  var RefCountDisposable = Rx.RefCountDisposable = function () {

    function InnerDisposable(disposable) {
      this.disposable = disposable;
      this.disposable.count++;
      this.isInnerDisposed = false;
    }

    InnerDisposable.prototype.dispose = function () {
      if (!this.disposable.isDisposed && !this.isInnerDisposed) {
        this.isInnerDisposed = true;
        this.disposable.count--;
        if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
          this.disposable.isDisposed = true;
          this.disposable.underlyingDisposable.dispose();
        }
      }
    };

    /**
     * Initializes a new instance of the RefCountDisposable with the specified disposable.
     * @constructor
     * @param {Disposable} disposable Underlying disposable.
      */
    function RefCountDisposable(disposable) {
      this.underlyingDisposable = disposable;
      this.isDisposed = false;
      this.isPrimaryDisposed = false;
      this.count = 0;
    }

    /**
     * Disposes the underlying disposable only when all dependent disposables have been disposed
     */
    RefCountDisposable.prototype.dispose = function () {
      if (!this.isDisposed && !this.isPrimaryDisposed) {
        this.isPrimaryDisposed = true;
        if (this.count === 0) {
          this.isDisposed = true;
          this.underlyingDisposable.dispose();
        }
      }
    };

    /**
     * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
     * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.
     */
    RefCountDisposable.prototype.getDisposable = function () {
      return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
    };

    return RefCountDisposable;
  }();

  function ScheduledDisposable(scheduler, disposable) {
    this.scheduler = scheduler;
    this.disposable = disposable;
    this.isDisposed = false;
  }

  function scheduleItem(s, self) {
    if (!self.isDisposed) {
      self.isDisposed = true;
      self.disposable.dispose();
    }
  }

  ScheduledDisposable.prototype.dispose = function () {
    this.scheduler.schedule(this, scheduleItem);
  };

  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
    this.scheduler = scheduler;
    this.state = state;
    this.action = action;
    this.dueTime = dueTime;
    this.comparer = comparer || defaultSubComparer;
    this.disposable = new SingleAssignmentDisposable();
  };

  ScheduledItem.prototype.invoke = function () {
    this.disposable.setDisposable(this.invokeCore());
  };

  ScheduledItem.prototype.compareTo = function (other) {
    return this.comparer(this.dueTime, other.dueTime);
  };

  ScheduledItem.prototype.isCancelled = function () {
    return this.disposable.isDisposed;
  };

  ScheduledItem.prototype.invokeCore = function () {
    return disposableFixup(this.action(this.scheduler, this.state));
  };

  /** Provides a set of static properties to access commonly used schedulers. */
  var Scheduler = Rx.Scheduler = function () {

    function Scheduler() {}

    /** Determines whether the given object is a scheduler */
    Scheduler.isScheduler = function (s) {
      return s instanceof Scheduler;
    };

    var schedulerProto = Scheduler.prototype;

    /**
    * Schedules an action to be executed.
    * @param state State passed to the action to be executed.
    * @param {Function} action Action to be executed.
    * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
    */
    schedulerProto.schedule = function (state, action) {
      throw new NotImplementedError();
    };

    /**
     * Schedules an action to be executed after dueTime.
     * @param state State passed to the action to be executed.
     * @param {Function} action Action to be executed.
     * @param {Number} dueTime Relative time after which to execute the action.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleFuture = function (state, dueTime, action) {
      var dt = dueTime;
      dt instanceof Date && (dt = dt - this.now());
      dt = Scheduler.normalize(dt);

      if (dt === 0) {
        return this.schedule(state, action);
      }

      return this._scheduleFuture(state, dt, action);
    };

    schedulerProto._scheduleFuture = function (state, dueTime, action) {
      throw new NotImplementedError();
    };

    /** Gets the current time according to the local machine's system clock. */
    Scheduler.now = defaultNow;

    /** Gets the current time according to the local machine's system clock. */
    Scheduler.prototype.now = defaultNow;

    /**
     * Normalizes the specified TimeSpan value to a positive value.
     * @param {Number} timeSpan The time span value to normalize.
     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0
     */
    Scheduler.normalize = function (timeSpan) {
      timeSpan < 0 && (timeSpan = 0);
      return timeSpan;
    };

    return Scheduler;
  }();

  var normalizeTime = Scheduler.normalize,
      isScheduler = Scheduler.isScheduler;

  (function (schedulerProto) {

    function invokeRecImmediate(scheduler, pair) {
      var state = pair[0],
          action = pair[1],
          group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2) {
        var isAdded = false,
            isDone = false;

        var d = scheduler.schedule(state2, scheduleWork);
        if (!isDone) {
          group.add(d);
          isAdded = true;
        }

        function scheduleWork(_, state3) {
          if (isAdded) {
            group.remove(d);
          } else {
            isDone = true;
          }
          action(state3, innerAction);
          return disposableEmpty;
        }
      }
    }

    function invokeRecDate(scheduler, pair) {
      var state = pair[0],
          action = pair[1],
          group = new CompositeDisposable();
      action(state, innerAction);
      return group;

      function innerAction(state2, dueTime1) {
        var isAdded = false,
            isDone = false;

        var d = scheduler.scheduleFuture(state2, dueTime1, scheduleWork);
        if (!isDone) {
          group.add(d);
          isAdded = true;
        }

        function scheduleWork(_, state3) {
          if (isAdded) {
            group.remove(d);
          } else {
            isDone = true;
          }
          action(state3, innerAction);
          return disposableEmpty;
        }
      }
    }

    /**
     * Schedules an action to be executed recursively.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleRecursive = function (state, action) {
      return this.schedule([state, action], invokeRecImmediate);
    };

    /**
     * Schedules an action to be executed recursively after a specified relative or absolute due time.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
     * @param {Number | Date} dueTime Relative or absolute time after which to execute the action for the first time.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    schedulerProto.scheduleRecursiveFuture = function (state, dueTime, action) {
      return this.scheduleFuture([state, action], dueTime, invokeRecDate);
    };
  })(Scheduler.prototype);

  (function (schedulerProto) {

    /**
     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
     * @param {Mixed} state Initial state passed to the action upon the first iteration.
     * @param {Number} period Period for running the work periodically.
     * @param {Function} action Action to be executed, potentially updating the state.
     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
     */
    schedulerProto.schedulePeriodic = function (state, period, action) {
      if (typeof root.setInterval === 'undefined') {
        throw new NotSupportedError();
      }
      period = normalizeTime(period);
      var s = state,
          id = root.setInterval(function () {
        s = action(s);
      }, period);
      return disposableCreate(function () {
        root.clearInterval(id);
      });
    };
  })(Scheduler.prototype);

  (function (schedulerProto) {
    /**
     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.
     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.
     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.
     */
    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {
      return new CatchScheduler(this, handler);
    };
  })(Scheduler.prototype);

  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = function () {
    function createTick(self) {
      return function tick(command, recurse) {
        recurse(0, self._period);
        var state = tryCatch(self._action)(self._state);
        if (state === errorObj) {
          self._cancel.dispose();
          thrower(state.e);
        }
        self._state = state;
      };
    }

    function SchedulePeriodicRecursive(scheduler, state, period, action) {
      this._scheduler = scheduler;
      this._state = state;
      this._period = period;
      this._action = action;
    }

    SchedulePeriodicRecursive.prototype.start = function () {
      var d = new SingleAssignmentDisposable();
      this._cancel = d;
      d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));

      return d;
    };

    return SchedulePeriodicRecursive;
  }();

  /** Gets a scheduler that schedules work immediately on the current thread. */
  var ImmediateScheduler = function (__super__) {
    inherits(ImmediateScheduler, __super__);
    function ImmediateScheduler() {
      __super__.call(this);
    }

    ImmediateScheduler.prototype.schedule = function (state, action) {
      return disposableFixup(action(this, state));
    };

    return ImmediateScheduler;
  }(Scheduler);

  var immediateScheduler = Scheduler.immediate = new ImmediateScheduler();

  /**
   * Gets a scheduler that schedules work as soon as possible on the current thread.
   */
  var CurrentThreadScheduler = function (__super__) {
    var queue;

    function runTrampoline() {
      while (queue.length > 0) {
        var item = queue.dequeue();
        !item.isCancelled() && item.invoke();
      }
    }

    inherits(CurrentThreadScheduler, __super__);
    function CurrentThreadScheduler() {
      __super__.call(this);
    }

    CurrentThreadScheduler.prototype.schedule = function (state, action) {
      var si = new ScheduledItem(this, state, action, this.now());

      if (!queue) {
        queue = new PriorityQueue(4);
        queue.enqueue(si);

        var result = tryCatch(runTrampoline)();
        queue = null;
        if (result === errorObj) {
          thrower(result.e);
        }
      } else {
        queue.enqueue(si);
      }
      return si.disposable;
    };

    CurrentThreadScheduler.prototype.scheduleRequired = function () {
      return !queue;
    };

    return CurrentThreadScheduler;
  }(Scheduler);

  var currentThreadScheduler = Scheduler.currentThread = new CurrentThreadScheduler();

  var scheduleMethod, clearMethod;

  var localTimer = function () {
    var localSetTimeout,
        localClearTimeout = noop;
    if (!!root.setTimeout) {
      localSetTimeout = root.setTimeout;
      localClearTimeout = root.clearTimeout;
    } else if (!!root.WScript) {
      localSetTimeout = function localSetTimeout(fn, time) {
        root.WScript.Sleep(time);
        fn();
      };
    } else {
      throw new NotSupportedError();
    }

    return {
      setTimeout: localSetTimeout,
      clearTimeout: localClearTimeout
    };
  }();
  var localSetTimeout = localTimer.setTimeout,
      localClearTimeout = localTimer.clearTimeout;

  (function () {

    var nextHandle = 1,
        tasksByHandle = {},
        currentlyRunning = false;

    clearMethod = function clearMethod(handle) {
      delete tasksByHandle[handle];
    };

    function runTask(handle) {
      if (currentlyRunning) {
        localSetTimeout(function () {
          runTask(handle);
        }, 0);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunning = true;
          var result = tryCatch(task)();
          clearMethod(handle);
          currentlyRunning = false;
          if (result === errorObj) {
            thrower(result.e);
          }
        }
      }
    }

    var reNative = new RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');

    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;

    function postMessageSupported() {
      // Ensure not in a worker
      if (!root.postMessage || root.importScripts) {
        return false;
      }
      var isAsync = false,
          oldHandler = root.onmessage;
      // Test for async
      root.onmessage = function () {
        isAsync = true;
      };
      root.postMessage('', '*');
      root.onmessage = oldHandler;

      return isAsync;
    }

    // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout
    if (isFunction(setImmediate)) {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        setImmediate(function () {
          runTask(id);
        });

        return id;
      };
    } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        process.nextTick(function () {
          runTask(id);
        });

        return id;
      };
    } else if (postMessageSupported()) {
      var MSG_PREFIX = 'ms.rx.schedule' + Math.random();

      var onGlobalPostMessage = function onGlobalPostMessage(event) {
        // Only if we're a match to avoid any other global events
        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
          runTask(event.data.substring(MSG_PREFIX.length));
        }
      };

      root.addEventListener('message', onGlobalPostMessage, false);

      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        root.postMessage(MSG_PREFIX + id, '*');
        return id;
      };
    } else if (!!root.MessageChannel) {
      var channel = new root.MessageChannel();

      channel.port1.onmessage = function (e) {
        runTask(e.data);
      };

      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        channel.port2.postMessage(id);
        return id;
      };
    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {

      scheduleMethod = function scheduleMethod(action) {
        var scriptElement = root.document.createElement('script');
        var id = nextHandle++;
        tasksByHandle[id] = action;

        scriptElement.onreadystatechange = function () {
          runTask(id);
          scriptElement.onreadystatechange = null;
          scriptElement.parentNode.removeChild(scriptElement);
          scriptElement = null;
        };
        root.document.documentElement.appendChild(scriptElement);
        return id;
      };
    } else {
      scheduleMethod = function scheduleMethod(action) {
        var id = nextHandle++;
        tasksByHandle[id] = action;
        localSetTimeout(function () {
          runTask(id);
        }, 0);

        return id;
      };
    }
  })();

  /**
   * Gets a scheduler that schedules work via a timed callback based upon platform.
   */
  var DefaultScheduler = function (__super__) {
    inherits(DefaultScheduler, __super__);
    function DefaultScheduler() {
      __super__.call(this);
    }

    function scheduleAction(disposable, action, scheduler, state) {
      return function schedule() {
        disposable.setDisposable(Disposable._fixup(action(scheduler, state)));
      };
    }

    function ClearDisposable(id) {
      this._id = id;
      this.isDisposed = false;
    }

    ClearDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        clearMethod(this._id);
      }
    };

    function LocalClearDisposable(id) {
      this._id = id;
      this.isDisposed = false;
    }

    LocalClearDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        localClearTimeout(this._id);
      }
    };

    DefaultScheduler.prototype.schedule = function (state, action) {
      var disposable = new SingleAssignmentDisposable(),
          id = scheduleMethod(scheduleAction(disposable, action, this, state));
      return new BinaryDisposable(disposable, new ClearDisposable(id));
    };

    DefaultScheduler.prototype._scheduleFuture = function (state, dueTime, action) {
      if (dueTime === 0) {
        return this.schedule(state, action);
      }
      var disposable = new SingleAssignmentDisposable(),
          id = localSetTimeout(scheduleAction(disposable, action, this, state), dueTime);
      return new BinaryDisposable(disposable, new LocalClearDisposable(id));
    };

    function scheduleLongRunning(state, action, disposable) {
      return function () {
        action(state, disposable);
      };
    }

    DefaultScheduler.prototype.scheduleLongRunning = function (state, action) {
      var disposable = disposableCreate(noop);
      scheduleMethod(scheduleLongRunning(state, action, disposable));
      return disposable;
    };

    return DefaultScheduler;
  }(Scheduler);

  var defaultScheduler = Scheduler['default'] = Scheduler.async = new DefaultScheduler();

  var CatchScheduler = function (__super__) {
    inherits(CatchScheduler, __super__);

    function CatchScheduler(scheduler, handler) {
      this._scheduler = scheduler;
      this._handler = handler;
      this._recursiveOriginal = null;
      this._recursiveWrapper = null;
      __super__.call(this);
    }

    CatchScheduler.prototype.schedule = function (state, action) {
      return this._scheduler.schedule(state, this._wrap(action));
    };

    CatchScheduler.prototype._scheduleFuture = function (state, dueTime, action) {
      return this._scheduler.schedule(state, dueTime, this._wrap(action));
    };

    CatchScheduler.prototype.now = function () {
      return this._scheduler.now();
    };

    CatchScheduler.prototype._clone = function (scheduler) {
      return new CatchScheduler(scheduler, this._handler);
    };

    CatchScheduler.prototype._wrap = function (action) {
      var parent = this;
      return function (self, state) {
        var res = tryCatch(action)(parent._getRecursiveWrapper(self), state);
        if (res === errorObj) {
          if (!parent._handler(res.e)) {
            thrower(res.e);
          }
          return disposableEmpty;
        }
        return disposableFixup(res);
      };
    };

    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {
      if (this._recursiveOriginal !== scheduler) {
        this._recursiveOriginal = scheduler;
        var wrapper = this._clone(scheduler);
        wrapper._recursiveOriginal = scheduler;
        wrapper._recursiveWrapper = wrapper;
        this._recursiveWrapper = wrapper;
      }
      return this._recursiveWrapper;
    };

    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {
      var self = this,
          failed = false,
          d = new SingleAssignmentDisposable();

      d.setDisposable(this._scheduler.schedulePeriodic(state, period, function (state1) {
        if (failed) {
          return null;
        }
        var res = tryCatch(action)(state1);
        if (res === errorObj) {
          failed = true;
          if (!self._handler(res.e)) {
            thrower(res.e);
          }
          d.dispose();
          return null;
        }
        return res;
      }));

      return d;
    };

    return CatchScheduler;
  }(Scheduler);

  /**
   *  Represents a notification to an observer.
   */
  var Notification = Rx.Notification = function () {
    function Notification() {}

    Notification.prototype._accept = function (onNext, onError, onCompleted) {
      throw new NotImplementedError();
    };

    Notification.prototype._acceptObserver = function (onNext, onError, onCompleted) {
      throw new NotImplementedError();
    };

    /**
     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.
     * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification on..
     * @param {Function} onError Function to invoke for an OnError notification.
     * @param {Function} onCompleted Function to invoke for an OnCompleted notification.
     * @returns {Any} Result produced by the observation.
     */
    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
      return observerOrOnNext && (typeof observerOrOnNext === 'undefined' ? 'undefined' : _typeof(observerOrOnNext)) === 'object' ? this._acceptObserver(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
    };

    /**
     * Returns an observable sequence with a single notification.
     *
     * @memberOf Notifications
     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.
     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.
     */
    Notification.prototype.toObservable = function (scheduler) {
      var self = this;
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function (o) {
        return scheduler.schedule(self, function (_, notification) {
          notification._acceptObserver(o);
          notification.kind === 'N' && o.onCompleted();
        });
      });
    };

    return Notification;
  }();

  var OnNextNotification = function (__super__) {
    inherits(OnNextNotification, __super__);
    function OnNextNotification(value) {
      this.value = value;
      this.kind = 'N';
    }

    OnNextNotification.prototype._accept = function (onNext) {
      return onNext(this.value);
    };

    OnNextNotification.prototype._acceptObserver = function (o) {
      return o.onNext(this.value);
    };

    OnNextNotification.prototype.toString = function () {
      return 'OnNext(' + this.value + ')';
    };

    return OnNextNotification;
  }(Notification);

  var OnErrorNotification = function (__super__) {
    inherits(OnErrorNotification, __super__);
    function OnErrorNotification(error) {
      this.error = error;
      this.kind = 'E';
    }

    OnErrorNotification.prototype._accept = function (onNext, onError) {
      return onError(this.error);
    };

    OnErrorNotification.prototype._acceptObserver = function (o) {
      return o.onError(this.error);
    };

    OnErrorNotification.prototype.toString = function () {
      return 'OnError(' + this.error + ')';
    };

    return OnErrorNotification;
  }(Notification);

  var OnCompletedNotification = function (__super__) {
    inherits(OnCompletedNotification, __super__);
    function OnCompletedNotification() {
      this.kind = 'C';
    }

    OnCompletedNotification.prototype._accept = function (onNext, onError, onCompleted) {
      return onCompleted();
    };

    OnCompletedNotification.prototype._acceptObserver = function (o) {
      return o.onCompleted();
    };

    OnCompletedNotification.prototype.toString = function () {
      return 'OnCompleted()';
    };

    return OnCompletedNotification;
  }(Notification);

  /**
   * Creates an object that represents an OnNext notification to an observer.
   * @param {Any} value The value contained in the notification.
   * @returns {Notification} The OnNext notification containing the value.
   */
  var notificationCreateOnNext = Notification.createOnNext = function (value) {
    return new OnNextNotification(value);
  };

  /**
   * Creates an object that represents an OnError notification to an observer.
   * @param {Any} error The exception contained in the notification.
   * @returns {Notification} The OnError notification containing the exception.
   */
  var notificationCreateOnError = Notification.createOnError = function (error) {
    return new OnErrorNotification(error);
  };

  /**
   * Creates an object that represents an OnCompleted notification to an observer.
   * @returns {Notification} The OnCompleted notification.
   */
  var notificationCreateOnCompleted = Notification.createOnCompleted = function () {
    return new OnCompletedNotification();
  };

  /**
   * Supports push-style iteration over an observable sequence.
   */
  var Observer = Rx.Observer = function () {};

  /**
   *  Creates a notification callback from an observer.
   * @returns The action that forwards its input notification to the underlying observer.
   */
  Observer.prototype.toNotifier = function () {
    var observer = this;
    return function (n) {
      return n.accept(observer);
    };
  };

  /**
   *  Hides the identity of an observer.
   * @returns An observer that hides the identity of the specified observer.
   */
  Observer.prototype.asObserver = function () {
    var self = this;
    return new AnonymousObserver(function (x) {
      self.onNext(x);
    }, function (err) {
      self.onError(err);
    }, function () {
      self.onCompleted();
    });
  };

  /**
   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
   *  If a violation is detected, an Error is thrown from the offending observer method call.
   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
   */
  Observer.prototype.checked = function () {
    return new CheckedObserver(this);
  };

  /**
   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.
   * @param {Function} [onNext] Observer's OnNext action implementation.
   * @param {Function} [onError] Observer's OnError action implementation.
   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.
   * @returns {Observer} The observer object implemented using the given actions.
   */
  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {
    onNext || (onNext = noop);
    onError || (onError = defaultError);
    onCompleted || (onCompleted = noop);
    return new AnonymousObserver(onNext, onError, onCompleted);
  };

  /**
   *  Creates an observer from a notification callback.
   * @param {Function} handler Action that handles a notification.
   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.
   */
  Observer.fromNotifier = function (handler, thisArg) {
    var cb = bindCallback(handler, thisArg, 1);
    return new AnonymousObserver(function (x) {
      return cb(notificationCreateOnNext(x));
    }, function (e) {
      return cb(notificationCreateOnError(e));
    }, function () {
      return cb(notificationCreateOnCompleted());
    });
  };

  /**
   * Schedules the invocation of observer methods on the given scheduler.
   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.
   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.
   */
  Observer.prototype.notifyOn = function (scheduler) {
    return new ObserveOnObserver(scheduler, this);
  };

  Observer.prototype.makeSafe = function (disposable) {
    return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
  };

  /**
   * Abstract base class for implementations of the Observer class.
   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.
   */
  var AbstractObserver = Rx.internals.AbstractObserver = function (__super__) {
    inherits(AbstractObserver, __super__);

    /**
     * Creates a new observer in a non-stopped state.
     */
    function AbstractObserver() {
      this.isStopped = false;
    }

    // Must be implemented by other observers
    AbstractObserver.prototype.next = notImplemented;
    AbstractObserver.prototype.error = notImplemented;
    AbstractObserver.prototype.completed = notImplemented;

    /**
     * Notifies the observer of a new element in the sequence.
     * @param {Any} value Next element in the sequence.
     */
    AbstractObserver.prototype.onNext = function (value) {
      !this.isStopped && this.next(value);
    };

    /**
     * Notifies the observer that an exception has occurred.
     * @param {Any} error The error that has occurred.
     */
    AbstractObserver.prototype.onError = function (error) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.error(error);
      }
    };

    /**
     * Notifies the observer of the end of the sequence.
     */
    AbstractObserver.prototype.onCompleted = function () {
      if (!this.isStopped) {
        this.isStopped = true;
        this.completed();
      }
    };

    /**
     * Disposes the observer, causing it to transition to the stopped state.
     */
    AbstractObserver.prototype.dispose = function () {
      this.isStopped = true;
    };

    AbstractObserver.prototype.fail = function (e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.error(e);
        return true;
      }

      return false;
    };

    return AbstractObserver;
  }(Observer);

  /**
   * Class to create an Observer instance from delegate-based implementations of the on* methods.
   */
  var AnonymousObserver = Rx.AnonymousObserver = function (__super__) {
    inherits(AnonymousObserver, __super__);

    /**
     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
     * @param {Any} onNext Observer's OnNext action implementation.
     * @param {Any} onError Observer's OnError action implementation.
     * @param {Any} onCompleted Observer's OnCompleted action implementation.
     */
    function AnonymousObserver(onNext, onError, onCompleted) {
      __super__.call(this);
      this._onNext = onNext;
      this._onError = onError;
      this._onCompleted = onCompleted;
    }

    /**
     * Calls the onNext action.
     * @param {Any} value Next element in the sequence.
     */
    AnonymousObserver.prototype.next = function (value) {
      this._onNext(value);
    };

    /**
     * Calls the onError action.
     * @param {Any} error The error that has occurred.
     */
    AnonymousObserver.prototype.error = function (error) {
      this._onError(error);
    };

    /**
     *  Calls the onCompleted action.
     */
    AnonymousObserver.prototype.completed = function () {
      this._onCompleted();
    };

    return AnonymousObserver;
  }(AbstractObserver);

  var CheckedObserver = function (__super__) {
    inherits(CheckedObserver, __super__);

    function CheckedObserver(observer) {
      __super__.call(this);
      this._observer = observer;
      this._state = 0; // 0 - idle, 1 - busy, 2 - done
    }

    var CheckedObserverPrototype = CheckedObserver.prototype;

    CheckedObserverPrototype.onNext = function (value) {
      this.checkAccess();
      var res = tryCatch(this._observer.onNext).call(this._observer, value);
      this._state = 0;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.onError = function (err) {
      this.checkAccess();
      var res = tryCatch(this._observer.onError).call(this._observer, err);
      this._state = 2;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.onCompleted = function () {
      this.checkAccess();
      var res = tryCatch(this._observer.onCompleted).call(this._observer);
      this._state = 2;
      res === errorObj && thrower(res.e);
    };

    CheckedObserverPrototype.checkAccess = function () {
      if (this._state === 1) {
        throw new Error('Re-entrancy detected');
      }
      if (this._state === 2) {
        throw new Error('Observer completed');
      }
      if (this._state === 0) {
        this._state = 1;
      }
    };

    return CheckedObserver;
  }(Observer);

  var ScheduledObserver = Rx.internals.ScheduledObserver = function (__super__) {
    inherits(ScheduledObserver, __super__);

    function ScheduledObserver(scheduler, observer) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.observer = observer;
      this.isAcquired = false;
      this.hasFaulted = false;
      this.queue = [];
      this.disposable = new SerialDisposable();
    }

    function enqueueNext(observer, x) {
      return function () {
        observer.onNext(x);
      };
    }
    function enqueueError(observer, e) {
      return function () {
        observer.onError(e);
      };
    }
    function enqueueCompleted(observer) {
      return function () {
        observer.onCompleted();
      };
    }

    ScheduledObserver.prototype.next = function (x) {
      this.queue.push(enqueueNext(this.observer, x));
    };

    ScheduledObserver.prototype.error = function (e) {
      this.queue.push(enqueueError(this.observer, e));
    };

    ScheduledObserver.prototype.completed = function () {
      this.queue.push(enqueueCompleted(this.observer));
    };

    function scheduleMethod(state, recurse) {
      var work;
      if (state.queue.length > 0) {
        work = state.queue.shift();
      } else {
        state.isAcquired = false;
        return;
      }
      var res = tryCatch(work)();
      if (res === errorObj) {
        state.queue = [];
        state.hasFaulted = true;
        return thrower(res.e);
      }
      recurse(state);
    }

    ScheduledObserver.prototype.ensureActive = function () {
      var isOwner = false;
      if (!this.hasFaulted && this.queue.length > 0) {
        isOwner = !this.isAcquired;
        this.isAcquired = true;
      }
      isOwner && this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));
    };

    ScheduledObserver.prototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this.disposable.dispose();
    };

    return ScheduledObserver;
  }(AbstractObserver);

  var ObserveOnObserver = function (__super__) {
    inherits(ObserveOnObserver, __super__);

    function ObserveOnObserver(scheduler, observer, cancel) {
      __super__.call(this, scheduler, observer);
      this._cancel = cancel;
    }

    ObserveOnObserver.prototype.next = function (value) {
      __super__.prototype.next.call(this, value);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.error = function (e) {
      __super__.prototype.error.call(this, e);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.completed = function () {
      __super__.prototype.completed.call(this);
      this.ensureActive();
    };

    ObserveOnObserver.prototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this._cancel && this._cancel.dispose();
      this._cancel = null;
    };

    return ObserveOnObserver;
  }(ScheduledObserver);

  var observableProto;

  /**
   * Represents a push-style collection.
   */
  var Observable = Rx.Observable = function () {

    function makeSubscribe(self, subscribe) {
      return function (o) {
        var oldOnError = o.onError;
        o.onError = function (e) {
          makeStackTraceLong(e, self);
          oldOnError.call(o, e);
        };

        return subscribe.call(self, o);
      };
    }

    function Observable() {
      if (Rx.config.longStackSupport && hasStacks) {
        var oldSubscribe = this._subscribe;
        var e = tryCatch(thrower)(new Error()).e;
        this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
        this._subscribe = makeSubscribe(this, oldSubscribe);
      }
    }

    observableProto = Observable.prototype;

    /**
    * Determines whether the given object is an Observable
    * @param {Any} An object to determine whether it is an Observable
    * @returns {Boolean} true if an Observable, else false.
    */
    Observable.isObservable = function (o) {
      return o && isFunction(o.subscribe);
    };

    /**
     *  Subscribes an o to the observable sequence.
     *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.
     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
      return this._subscribe((typeof oOrOnNext === 'undefined' ? 'undefined' : _typeof(oOrOnNext)) === 'object' ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));
    };

    /**
     * Subscribes to the next value in the sequence with an optional "this" argument.
     * @param {Function} onNext The function to invoke on each element in the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnNext = function (onNext, thisArg) {
      return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function (x) {
        onNext.call(thisArg, x);
      } : onNext));
    };

    /**
     * Subscribes to an exceptional condition in the sequence with an optional "this" argument.
     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnError = function (onError, thisArg) {
      return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function (e) {
        onError.call(thisArg, e);
      } : onError));
    };

    /**
     * Subscribes to the next value in the sequence with an optional "this" argument.
     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.
     * @param {Any} [thisArg] Object to use as this when executing callback.
     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
     */
    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {
      return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function () {
        onCompleted.call(thisArg);
      } : onCompleted));
    };

    return Observable;
  }();

  var ObservableBase = Rx.ObservableBase = function (__super__) {
    inherits(ObservableBase, __super__);

    function fixSubscriber(subscriber) {
      return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
    }

    function setDisposable(s, state) {
      var ado = state[0],
          self = state[1];
      var sub = tryCatch(self.subscribeCore).call(self, ado);
      if (sub === errorObj && !ado.fail(errorObj.e)) {
        thrower(errorObj.e);
      }
      ado.setDisposable(fixSubscriber(sub));
    }

    function ObservableBase() {
      __super__.call(this);
    }

    ObservableBase.prototype._subscribe = function (o) {
      var ado = new AutoDetachObserver(o),
          state = [ado, this];

      if (currentThreadScheduler.scheduleRequired()) {
        currentThreadScheduler.schedule(state, setDisposable);
      } else {
        setDisposable(null, state);
      }
      return ado;
    };

    ObservableBase.prototype.subscribeCore = notImplemented;

    return ObservableBase;
  }(Observable);

  var FlatMapObservable = Rx.FlatMapObservable = function (__super__) {

    inherits(FlatMapObservable, __super__);

    function FlatMapObservable(source, selector, resultSelector, thisArg) {
      this.resultSelector = isFunction(resultSelector) ? resultSelector : null;
      this.selector = bindCallback(isFunction(selector) ? selector : function () {
        return selector;
      }, thisArg, 3);
      this.source = source;
      __super__.call(this);
    }

    FlatMapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(observer, selector, resultSelector, source) {
      this.i = 0;
      this.selector = selector;
      this.resultSelector = resultSelector;
      this.source = source;
      this.o = observer;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype._wrapResult = function (result, x, i) {
      return this.resultSelector ? result.map(function (y, i2) {
        return this.resultSelector(x, y, i, i2);
      }, this) : result;
    };

    InnerObserver.prototype.next = function (x) {
      var i = this.i++;
      var result = tryCatch(this.selector)(x, i, this.source);
      if (result === errorObj) {
        return this.o.onError(result.e);
      }

      isPromise(result) && (result = observableFromPromise(result));
      (isArrayLike(result) || isIterable(result)) && (result = Observable.from(result));
      this.o.onNext(this._wrapResult(result, x, i));
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return FlatMapObservable;
  }(ObservableBase);

  var Enumerable = Rx.internals.Enumerable = function () {};

  function IsDisposedDisposable(state) {
    this._s = state;
    this.isDisposed = false;
  }

  IsDisposedDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this.isDisposed = true;
      this._s.isDisposed = true;
    }
  };

  var ConcatEnumerableObservable = function (__super__) {
    inherits(ConcatEnumerableObservable, __super__);
    function ConcatEnumerableObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    function scheduleMethod(state, recurse) {
      if (state.isDisposed) {
        return;
      }
      var currentItem = tryCatch(state.e.next).call(state.e);
      if (currentItem === errorObj) {
        return state.o.onError(currentItem.e);
      }
      if (currentItem.done) {
        return state.o.onCompleted();
      }

      // Check if promise
      var currentValue = currentItem.value;
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));
    }

    ConcatEnumerableObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var state = {
        isDisposed: false,
        o: o,
        subscription: subscription,
        e: this.sources[$iterator$]()
      };

      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);
      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);
    };

    function InnerObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      AbstractObserver.call(this);
    }

    inherits(InnerObserver, AbstractObserver);

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this._recurse(this._state);
    };

    return ConcatEnumerableObservable;
  }(ObservableBase);

  Enumerable.prototype.concat = function () {
    return new ConcatEnumerableObservable(this);
  };

  var CatchErrorObservable = function (__super__) {
    function CatchErrorObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    inherits(CatchErrorObservable, __super__);

    function scheduleMethod(state, recurse) {
      if (state.isDisposed) {
        return;
      }
      var currentItem = tryCatch(state.e.next).call(state.e);
      if (currentItem === errorObj) {
        return state.o.onError(currentItem.e);
      }
      if (currentItem.done) {
        return state.lastError !== null ? state.o.onError(state.lastError) : state.o.onCompleted();
      }

      var currentValue = currentItem.value;
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));
    }

    CatchErrorObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var state = {
        isDisposed: false,
        e: this.sources[$iterator$](),
        subscription: subscription,
        lastError: null,
        o: o
      };

      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);
      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);
    };

    function InnerObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      AbstractObserver.call(this);
    }

    inherits(InnerObserver, AbstractObserver);

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.lastError = e;this._recurse(this._state);
    };
    InnerObserver.prototype.completed = function () {
      this._state.o.onCompleted();
    };

    return CatchErrorObservable;
  }(ObservableBase);

  Enumerable.prototype.catchError = function () {
    return new CatchErrorObservable(this);
  };

  var RepeatEnumerable = function (__super__) {
    inherits(RepeatEnumerable, __super__);
    function RepeatEnumerable(v, c) {
      this.v = v;
      this.c = c == null ? -1 : c;
    }

    RepeatEnumerable.prototype[$iterator$] = function () {
      return new RepeatEnumerator(this);
    };

    function RepeatEnumerator(p) {
      this.v = p.v;
      this.l = p.c;
    }

    RepeatEnumerator.prototype.next = function () {
      if (this.l === 0) {
        return doneEnumerator;
      }
      if (this.l > 0) {
        this.l--;
      }
      return { done: false, value: this.v };
    };

    return RepeatEnumerable;
  }(Enumerable);

  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {
    return new RepeatEnumerable(value, repeatCount);
  };

  var OfEnumerable = function (__super__) {
    inherits(OfEnumerable, __super__);
    function OfEnumerable(s, fn, thisArg) {
      this.s = s;
      this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
    }
    OfEnumerable.prototype[$iterator$] = function () {
      return new OfEnumerator(this);
    };

    function OfEnumerator(p) {
      this.i = -1;
      this.s = p.s;
      this.l = this.s.length;
      this.fn = p.fn;
    }

    OfEnumerator.prototype.next = function () {
      return ++this.i < this.l ? { done: false, value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s) } : doneEnumerator;
    };

    return OfEnumerable;
  }(Enumerable);

  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {
    return new OfEnumerable(source, selector, thisArg);
  };

  var ObserveOnObservable = function (__super__) {
    inherits(ObserveOnObservable, __super__);
    function ObserveOnObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    ObserveOnObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ObserveOnObserver(this._s, o));
    };

    return ObserveOnObservable;
  }(ObservableBase);

  /**
  *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
  *
  *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects
  *  that require to be run on a scheduler, use subscribeOn.
  *
  *  @param {Scheduler} scheduler Scheduler to notify observers on.
  *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.
  */
  observableProto.observeOn = function (scheduler) {
    return new ObserveOnObservable(this, scheduler);
  };

  var SubscribeOnObservable = function (__super__) {
    inherits(SubscribeOnObservable, __super__);
    function SubscribeOnObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    function scheduleMethod(scheduler, state) {
      var source = state[0],
          d = state[1],
          o = state[2];
      d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(o)));
    }

    SubscribeOnObservable.prototype.subscribeCore = function (o) {
      var m = new SingleAssignmentDisposable(),
          d = new SerialDisposable();
      d.setDisposable(m);
      m.setDisposable(this._s.schedule([this.source, d, o], scheduleMethod));
      return d;
    };

    return SubscribeOnObservable;
  }(ObservableBase);

  /**
  *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
  *  see the remarks section for more information on the distinction between subscribeOn and observeOn.
   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer
  *  callbacks on a scheduler, use observeOn.
   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.
  *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
  */
  observableProto.subscribeOn = function (scheduler) {
    return new SubscribeOnObservable(this, scheduler);
  };

  var FromPromiseObservable = function (__super__) {
    inherits(FromPromiseObservable, __super__);
    function FromPromiseObservable(p, s) {
      this._p = p;
      this._s = s;
      __super__.call(this);
    }

    function scheduleNext(s, state) {
      var o = state[0],
          data = state[1];
      o.onNext(data);
      o.onCompleted();
    }

    function scheduleError(s, state) {
      var o = state[0],
          err = state[1];
      o.onError(err);
    }

    FromPromiseObservable.prototype.subscribeCore = function (o) {
      var sad = new SingleAssignmentDisposable(),
          self = this,
          p = this._p;

      if (isFunction(p)) {
        p = tryCatch(p)();
        if (p === errorObj) {
          o.onError(p.e);
          return sad;
        }
      }

      p.then(function (data) {
        sad.setDisposable(self._s.schedule([o, data], scheduleNext));
      }, function (err) {
        sad.setDisposable(self._s.schedule([o, err], scheduleError));
      });

      return sad;
    };

    return FromPromiseObservable;
  }(ObservableBase);

  /**
  * Converts a Promise to an Observable sequence
  * @param {Promise} An ES6 Compliant promise.
  * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.
  */
  var observableFromPromise = Observable.fromPromise = function (promise, scheduler) {
    scheduler || (scheduler = defaultScheduler);
    return new FromPromiseObservable(promise, scheduler);
  };

  /*
   * Converts an existing observable sequence to an ES6 Compatible Promise
   * @example
   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
   *
   * // With config
   * Rx.config.Promise = RSVP.Promise;
   * var promise = Rx.Observable.return(42).toPromise();
   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
   */
  observableProto.toPromise = function (promiseCtor) {
    promiseCtor || (promiseCtor = Rx.config.Promise);
    if (!promiseCtor) {
      throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
    }
    var source = this;
    return new promiseCtor(function (resolve, reject) {
      // No cancellation can be done
      var value;
      source.subscribe(function (v) {
        value = v;
      }, reject, function () {
        resolve(value);
      });
    });
  };

  var ToArrayObservable = function (__super__) {
    inherits(ToArrayObservable, __super__);
    function ToArrayObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    ToArrayObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o) {
      this.o = o;
      this.a = [];
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this.a.push(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.o.onNext(this.a);this.o.onCompleted();
    };

    return ToArrayObservable;
  }(ObservableBase);

  /**
  * Creates an array from an observable sequence.
  * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.
  */
  observableProto.toArray = function () {
    return new ToArrayObservable(this);
  };

  /**
   *  Creates an observable sequence from a specified subscribe method implementation.
   * @example
   *  var res = Rx.Observable.create(function (observer) { return function () { } );
   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );
   *  var res = Rx.Observable.create(function (observer) { } );
   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.
   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.
   */
  Observable.create = function (subscribe, parent) {
    return new AnonymousObservable(subscribe, parent);
  };

  var Defer = function (__super__) {
    inherits(Defer, __super__);
    function Defer(factory) {
      this._f = factory;
      __super__.call(this);
    }

    Defer.prototype.subscribeCore = function (o) {
      var result = tryCatch(this._f)();
      if (result === errorObj) {
        return observableThrow(result.e).subscribe(o);
      }
      isPromise(result) && (result = observableFromPromise(result));
      return result.subscribe(o);
    };

    return Defer;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
   *
   * @example
   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });
   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.
   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
   */
  var observableDefer = Observable.defer = function (observableFactory) {
    return new Defer(observableFactory);
  };

  var EmptyObservable = function (__super__) {
    inherits(EmptyObservable, __super__);
    function EmptyObservable(scheduler) {
      this.scheduler = scheduler;
      __super__.call(this);
    }

    EmptyObservable.prototype.subscribeCore = function (observer) {
      var sink = new EmptySink(observer, this.scheduler);
      return sink.run();
    };

    function EmptySink(observer, scheduler) {
      this.observer = observer;
      this.scheduler = scheduler;
    }

    function scheduleItem(s, state) {
      state.onCompleted();
      return disposableEmpty;
    }

    EmptySink.prototype.run = function () {
      var state = this.observer;
      return this.scheduler === immediateScheduler ? scheduleItem(null, state) : this.scheduler.schedule(state, scheduleItem);
    };

    return EmptyObservable;
  }(ObservableBase);

  var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);

  /**
   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
   *
   * @example
   *  var res = Rx.Observable.empty();
   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);
   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.
   * @returns {Observable} An observable sequence with no elements.
   */
  var observableEmpty = Observable.empty = function (scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);
  };

  var FromObservable = function (__super__) {
    inherits(FromObservable, __super__);
    function FromObservable(iterable, fn, scheduler) {
      this._iterable = iterable;
      this._fn = fn;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function createScheduleMethod(o, it, fn) {
      return function loopRecursive(i, recurse) {
        var next = tryCatch(it.next).call(it);
        if (next === errorObj) {
          return o.onError(next.e);
        }
        if (next.done) {
          return o.onCompleted();
        }

        var result = next.value;

        if (isFunction(fn)) {
          result = tryCatch(fn)(result, i);
          if (result === errorObj) {
            return o.onError(result.e);
          }
        }

        o.onNext(result);
        recurse(i + 1);
      };
    }

    FromObservable.prototype.subscribeCore = function (o) {
      var list = Object(this._iterable),
          it = getIterable(list);

      return this._scheduler.scheduleRecursive(0, createScheduleMethod(o, it, this._fn));
    };

    return FromObservable;
  }(ObservableBase);

  var maxSafeInteger = Math.pow(2, 53) - 1;

  function StringIterable(s) {
    this._s = s;
  }

  StringIterable.prototype[$iterator$] = function () {
    return new StringIterator(this._s);
  };

  function StringIterator(s) {
    this._s = s;
    this._l = s.length;
    this._i = 0;
  }

  StringIterator.prototype[$iterator$] = function () {
    return this;
  };

  StringIterator.prototype.next = function () {
    return this._i < this._l ? { done: false, value: this._s.charAt(this._i++) } : doneEnumerator;
  };

  function ArrayIterable(a) {
    this._a = a;
  }

  ArrayIterable.prototype[$iterator$] = function () {
    return new ArrayIterator(this._a);
  };

  function ArrayIterator(a) {
    this._a = a;
    this._l = toLength(a);
    this._i = 0;
  }

  ArrayIterator.prototype[$iterator$] = function () {
    return this;
  };

  ArrayIterator.prototype.next = function () {
    return this._i < this._l ? { done: false, value: this._a[this._i++] } : doneEnumerator;
  };

  function numberIsFinite(value) {
    return typeof value === 'number' && root.isFinite(value);
  }

  function isNan(n) {
    return n !== n;
  }

  function getIterable(o) {
    var i = o[$iterator$],
        it;
    if (!i && typeof o === 'string') {
      it = new StringIterable(o);
      return it[$iterator$]();
    }
    if (!i && o.length !== undefined) {
      it = new ArrayIterable(o);
      return it[$iterator$]();
    }
    if (!i) {
      throw new TypeError('Object is not iterable');
    }
    return o[$iterator$]();
  }

  function sign(value) {
    var number = +value;
    if (number === 0) {
      return number;
    }
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? -1 : 1;
  }

  function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
      return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
      return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
      return 0;
    }
    if (len > maxSafeInteger) {
      return maxSafeInteger;
    }
    return len;
  }

  /**
  * This method creates a new Observable sequence from an array-like or iterable object.
  * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.
  * @param {Function} [mapFn] Map function to call on every element of the array.
  * @param {Any} [thisArg] The context to use calling the mapFn if provided.
  * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
  */
  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {
    if (iterable == null) {
      throw new Error('iterable cannot be null.');
    }
    if (mapFn && !isFunction(mapFn)) {
      throw new Error('mapFn when provided must be a function');
    }
    if (mapFn) {
      var mapper = bindCallback(mapFn, thisArg, 2);
    }
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromObservable(iterable, mapper, scheduler);
  };

  var FromArrayObservable = function (__super__) {
    inherits(FromArrayObservable, __super__);
    function FromArrayObservable(args, scheduler) {
      this._args = args;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(o, args) {
      var len = args.length;
      return function loopRecursive(i, recurse) {
        if (i < len) {
          o.onNext(args[i]);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    FromArrayObservable.prototype.subscribeCore = function (o) {
      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._args));
    };

    return FromArrayObservable;
  }(ObservableBase);

  /**
  *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.
  * @deprecated use Observable.from or Observable.of
  * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
  * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.
  */
  var observableFromArray = Observable.fromArray = function (array, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromArrayObservable(array, scheduler);
  };

  var GenerateObservable = function (__super__) {
    inherits(GenerateObservable, __super__);
    function GenerateObservable(state, cndFn, itrFn, resFn, s) {
      this._initialState = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }
      var hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (hasResult === errorObj) {
        return state.o.onError(hasResult.e);
      }
      if (hasResult) {
        var result = tryCatch(state.self._resFn)(state.newState);
        if (result === errorObj) {
          return state.o.onError(result.e);
        }
        state.o.onNext(result);
        recurse(state);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        first: true,
        newState: this._initialState
      };
      return this._s.scheduleRecursive(state, scheduleRecursive);
    };

    return GenerateObservable;
  }(ObservableBase);

  /**
   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
   *
   * @example
   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });
   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.
   * @returns {Observable} The generated sequence.
   */
  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);
  };

  function observableOf(scheduler, array) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new FromArrayObservable(array, scheduler);
  }

  /**
  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
  */
  Observable.of = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return new FromArrayObservable(args, currentThreadScheduler);
  };

  /**
  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
  * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.
  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
  */
  Observable.ofWithScheduler = function (scheduler) {
    var len = arguments.length,
        args = new Array(len - 1);
    for (var i = 1; i < len; i++) {
      args[i - 1] = arguments[i];
    }
    return new FromArrayObservable(args, scheduler);
  };

  /**
   * Creates an Observable sequence from changes to an array using Array.observe.
   * @param {Array} array An array to observe changes.
   * @returns {Observable} An observable sequence containing changes to an array from Array.observe.
   */
  Observable.ofArrayChanges = function (array) {
    if (!Array.isArray(array)) {
      throw new TypeError('Array.observe only accepts arrays.');
    }
    if (typeof Array.observe !== 'function' && typeof Array.unobserve !== 'function') {
      throw new TypeError('Array.observe is not supported on your platform');
    }
    return new AnonymousObservable(function (observer) {
      function observerFn(changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          observer.onNext(changes[i]);
        }
      }

      Array.observe(array, observerFn);

      return function () {
        Array.unobserve(array, observerFn);
      };
    });
  };

  /**
   * Creates an Observable sequence from changes to an object using Object.observe.
   * @param {Object} obj An object to observe changes.
   * @returns {Observable} An observable sequence containing changes to an object from Object.observe.
   */
  Observable.ofObjectChanges = function (obj) {
    if (obj == null) {
      throw new TypeError('object must not be null or undefined.');
    }
    if (typeof Object.observe !== 'function' && typeof Object.unobserve !== 'function') {
      throw new TypeError('Object.observe is not supported on your platform');
    }
    return new AnonymousObservable(function (observer) {
      function observerFn(changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          observer.onNext(changes[i]);
        }
      }

      Object.observe(obj, observerFn);

      return function () {
        Object.unobserve(obj, observerFn);
      };
    });
  };

  var NeverObservable = function (__super__) {
    inherits(NeverObservable, __super__);
    function NeverObservable() {
      __super__.call(this);
    }

    NeverObservable.prototype.subscribeCore = function (observer) {
      return disposableEmpty;
    };

    return NeverObservable;
  }(ObservableBase);

  var NEVER_OBSERVABLE = new NeverObservable();

  /**
   * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
   * @returns {Observable} An observable sequence whose observers will never get called.
   */
  var observableNever = Observable.never = function () {
    return NEVER_OBSERVABLE;
  };

  var PairsObservable = function (__super__) {
    inherits(PairsObservable, __super__);
    function PairsObservable(o, scheduler) {
      this._o = o;
      this._keys = Object.keys(o);
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(o, obj, keys) {
      return function loopRecursive(i, recurse) {
        if (i < keys.length) {
          var key = keys[i];
          o.onNext([key, obj[key]]);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    PairsObservable.prototype.subscribeCore = function (o) {
      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._o, this._keys));
    };

    return PairsObservable;
  }(ObservableBase);

  /**
   * Convert an object into an observable sequence of [key, value] pairs.
   * @param {Object} obj The object to inspect.
   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
   * @returns {Observable} An observable sequence of [key, value] pairs from the object.
   */
  Observable.pairs = function (obj, scheduler) {
    scheduler || (scheduler = currentThreadScheduler);
    return new PairsObservable(obj, scheduler);
  };

  var RangeObservable = function (__super__) {
    inherits(RangeObservable, __super__);
    function RangeObservable(start, count, scheduler) {
      this.start = start;
      this.rangeCount = count;
      this.scheduler = scheduler;
      __super__.call(this);
    }

    function loopRecursive(start, count, o) {
      return function loop(i, recurse) {
        if (i < count) {
          o.onNext(start + i);
          recurse(i + 1);
        } else {
          o.onCompleted();
        }
      };
    }

    RangeObservable.prototype.subscribeCore = function (o) {
      return this.scheduler.scheduleRecursive(0, loopRecursive(this.start, this.rangeCount, o));
    };

    return RangeObservable;
  }(ObservableBase);

  /**
  *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.
  * @param {Number} start The value of the first integer in the sequence.
  * @param {Number} count The number of sequential integers to generate.
  * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.
  * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.
  */
  Observable.range = function (start, count, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new RangeObservable(start, count, scheduler);
  };

  var RepeatObservable = function (__super__) {
    inherits(RepeatObservable, __super__);
    function RepeatObservable(value, repeatCount, scheduler) {
      this.value = value;
      this.repeatCount = repeatCount == null ? -1 : repeatCount;
      this.scheduler = scheduler;
      __super__.call(this);
    }

    RepeatObservable.prototype.subscribeCore = function (observer) {
      var sink = new RepeatSink(observer, this);
      return sink.run();
    };

    return RepeatObservable;
  }(ObservableBase);

  function RepeatSink(observer, parent) {
    this.observer = observer;
    this.parent = parent;
  }

  RepeatSink.prototype.run = function () {
    var observer = this.observer,
        value = this.parent.value;
    function loopRecursive(i, recurse) {
      if (i === -1 || i > 0) {
        observer.onNext(value);
        i > 0 && i--;
      }
      if (i === 0) {
        return observer.onCompleted();
      }
      recurse(i);
    }

    return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount, loopRecursive);
  };

  /**
   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.
   * @param {Mixed} value Element to repeat.
   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.
   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.
   */
  Observable.repeat = function (value, repeatCount, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new RepeatObservable(value, repeatCount, scheduler);
  };

  var JustObservable = function (__super__) {
    inherits(JustObservable, __super__);
    function JustObservable(value, scheduler) {
      this._value = value;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    JustObservable.prototype.subscribeCore = function (o) {
      var state = [this._value, o];
      return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);
    };

    function scheduleItem(s, state) {
      var value = state[0],
          observer = state[1];
      observer.onNext(value);
      observer.onCompleted();
      return disposableEmpty;
    }

    return JustObservable;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.
   *  There is an alias called 'just' or browsers <IE9.
   * @param {Mixed} value Single element in the resulting observable sequence.
   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} An observable sequence containing the single specified element.
   */
  var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return new JustObservable(value, scheduler);
  };

  var ThrowObservable = function (__super__) {
    inherits(ThrowObservable, __super__);
    function ThrowObservable(error, scheduler) {
      this._error = error;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    ThrowObservable.prototype.subscribeCore = function (o) {
      var state = [this._error, o];
      return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);
    };

    function scheduleItem(s, state) {
      var e = state[0],
          o = state[1];
      o.onError(e);
      return disposableEmpty;
    }

    return ThrowObservable;
  }(ObservableBase);

  /**
   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.
   *  There is an alias to this method called 'throwError' for browsers <IE9.
   * @param {Mixed} error An object used for the sequence's termination.
   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.
   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.
   */
  var observableThrow = Observable['throw'] = function (error, scheduler) {
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    return new ThrowObservable(error, scheduler);
  };

  var UsingObservable = function (__super__) {
    inherits(UsingObservable, __super__);
    function UsingObservable(resFn, obsFn) {
      this._resFn = resFn;
      this._obsFn = obsFn;
      __super__.call(this);
    }

    UsingObservable.prototype.subscribeCore = function (o) {
      var disposable = disposableEmpty;
      var resource = tryCatch(this._resFn)();
      if (resource === errorObj) {
        return new BinaryDisposable(observableThrow(resource.e).subscribe(o), disposable);
      }
      resource && (disposable = resource);
      var source = tryCatch(this._obsFn)(resource);
      if (source === errorObj) {
        return new BinaryDisposable(observableThrow(source.e).subscribe(o), disposable);
      }
      return new BinaryDisposable(source.subscribe(o), disposable);
    };

    return UsingObservable;
  }(ObservableBase);

  /**
   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
   * @param {Function} resourceFactory Factory function to obtain a resource object.
   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.
   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.
   */
  Observable.using = function (resourceFactory, observableFactory) {
    return new UsingObservable(resourceFactory, observableFactory);
  };

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @param {Observable} rightSource Second observable sequence or Promise.
   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.
   */
  observableProto.amb = function (rightSource) {
    var leftSource = this;
    return new AnonymousObservable(function (observer) {
      var choice,
          leftChoice = 'L',
          rightChoice = 'R',
          leftSubscription = new SingleAssignmentDisposable(),
          rightSubscription = new SingleAssignmentDisposable();

      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));

      function choiceL() {
        if (!choice) {
          choice = leftChoice;
          rightSubscription.dispose();
        }
      }

      function choiceR() {
        if (!choice) {
          choice = rightChoice;
          leftSubscription.dispose();
        }
      }

      var leftSubscribe = observerCreate(function (left) {
        choiceL();
        choice === leftChoice && observer.onNext(left);
      }, function (e) {
        choiceL();
        choice === leftChoice && observer.onError(e);
      }, function () {
        choiceL();
        choice === leftChoice && observer.onCompleted();
      });
      var rightSubscribe = observerCreate(function (right) {
        choiceR();
        choice === rightChoice && observer.onNext(right);
      }, function (e) {
        choiceR();
        choice === rightChoice && observer.onError(e);
      }, function () {
        choiceR();
        choice === rightChoice && observer.onCompleted();
      });

      leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
      rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));

      return new BinaryDisposable(leftSubscription, rightSubscription);
    });
  };

  function amb(p, c) {
    return p.amb(c);
  }

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
   */
  Observable.amb = function () {
    var acc = observableNever(),
        items;
    if (Array.isArray(arguments[0])) {
      items = arguments[0];
    } else {
      var len = arguments.length;
      items = new Array(items);
      for (var i = 0; i < len; i++) {
        items[i] = arguments[i];
      }
    }
    for (var i = 0, len = items.length; i < len; i++) {
      acc = amb(acc, items[i]);
    }
    return acc;
  };

  var CatchObservable = function (__super__) {
    inherits(CatchObservable, __super__);
    function CatchObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    CatchObservable.prototype.subscribeCore = function (o) {
      var d1 = new SingleAssignmentDisposable(),
          subscription = new SerialDisposable();
      subscription.setDisposable(d1);
      d1.setDisposable(this.source.subscribe(new CatchObserver(o, subscription, this._fn)));
      return subscription;
    };

    return CatchObservable;
  }(ObservableBase);

  var CatchObserver = function (__super__) {
    inherits(CatchObserver, __super__);
    function CatchObserver(o, s, fn) {
      this._o = o;
      this._s = s;
      this._fn = fn;
      __super__.call(this);
    }

    CatchObserver.prototype.next = function (x) {
      this._o.onNext(x);
    };
    CatchObserver.prototype.completed = function () {
      return this._o.onCompleted();
    };
    CatchObserver.prototype.error = function (e) {
      var result = tryCatch(this._fn)(e);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      isPromise(result) && (result = observableFromPromise(result));

      var d = new SingleAssignmentDisposable();
      this._s.setDisposable(d);
      d.setDisposable(result.subscribe(this._o));
    };

    return CatchObserver;
  }(AbstractObserver);

  /**
   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.
   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.
   */
  observableProto['catch'] = function (handlerOrSecond) {
    return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
  };

  /**
   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.
   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
   */
  var observableCatch = Observable['catch'] = function () {
    var items;
    if (Array.isArray(arguments[0])) {
      items = arguments[0];
    } else {
      var len = arguments.length;
      items = new Array(len);
      for (var i = 0; i < len; i++) {
        items[i] = arguments[i];
      }
    }
    return enumerableOf(items).catchError();
  };

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
   * This can be in the form of an argument list of observables or an array.
   *
   * @example
   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.combineLatest = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args[0].unshift(this);
    } else {
      args.unshift(this);
    }
    return combineLatest.apply(this, args);
  };

  function falseFactory() {
    return false;
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var CombineLatestObservable = function (__super__) {
    inherits(CombineLatestObservable, __super__);
    function CombineLatestObservable(params, cb) {
      this._params = params;
      this._cb = cb;
      __super__.call(this);
    }

    CombineLatestObservable.prototype.subscribeCore = function (observer) {
      var len = this._params.length,
          subscriptions = new Array(len);

      var state = {
        hasValue: arrayInitialize(len, falseFactory),
        hasValueAll: false,
        isDone: arrayInitialize(len, falseFactory),
        values: new Array(len)
      };

      for (var i = 0; i < len; i++) {
        var source = this._params[i],
            sad = new SingleAssignmentDisposable();
        subscriptions[i] = sad;
        isPromise(source) && (source = observableFromPromise(source));
        sad.setDisposable(source.subscribe(new CombineLatestObserver(observer, i, this._cb, state)));
      }

      return new NAryDisposable(subscriptions);
    };

    return CombineLatestObservable;
  }(ObservableBase);

  var CombineLatestObserver = function (__super__) {
    inherits(CombineLatestObserver, __super__);
    function CombineLatestObserver(o, i, cb, state) {
      this._o = o;
      this._i = i;
      this._cb = cb;
      this._state = state;
      __super__.call(this);
    }

    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    CombineLatestObserver.prototype.next = function (x) {
      this._state.values[this._i] = x;
      this._state.hasValue[this._i] = true;
      if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.every(identity))) {
        var res = tryCatch(this._cb).apply(null, this._state.values);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._o.onNext(res);
      } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {
        this._o.onCompleted();
      }
    };

    CombineLatestObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    CombineLatestObserver.prototype.completed = function () {
      this._state.isDone[this._i] = true;
      this._state.isDone.every(identity) && this._o.onCompleted();
    };

    return CombineLatestObserver;
  }(AbstractObserver);

  /**
  * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
  *
  * @example
  * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
  * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
  * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  */
  var combineLatest = Observable.combineLatest = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);
    return new CombineLatestObservable(args, resultSelector);
  };

  /**
   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.
   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
   */
  observableProto.concat = function () {
    for (var args = [], i = 0, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    args.unshift(this);
    return observableConcat.apply(null, args);
  };

  var ConcatObserver = function (__super__) {
    inherits(ConcatObserver, __super__);
    function ConcatObserver(s, fn) {
      this._s = s;
      this._fn = fn;
      __super__.call(this);
    }

    ConcatObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
    };
    ConcatObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    ConcatObserver.prototype.completed = function () {
      this._s.i++;this._fn(this._s);
    };

    return ConcatObserver;
  }(AbstractObserver);

  var ConcatObservable = function (__super__) {
    inherits(ConcatObservable, __super__);
    function ConcatObservable(sources) {
      this._sources = sources;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      if (state.disposable.isDisposed) {
        return;
      }
      if (state.i === state.sources.length) {
        return state.o.onCompleted();
      }

      // Check if promise
      var currentValue = state.sources[state.i];
      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

      var d = new SingleAssignmentDisposable();
      state.subscription.setDisposable(d);
      d.setDisposable(currentValue.subscribe(new ConcatObserver(state, recurse)));
    }

    ConcatObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable();
      var disposable = disposableCreate(noop);
      var state = {
        o: o,
        i: 0,
        subscription: subscription,
        disposable: disposable,
        sources: this._sources
      };

      var cancelable = immediateScheduler.scheduleRecursive(state, scheduleRecursive);
      return new NAryDisposable([subscription, disposable, cancelable]);
    };

    return ConcatObservable;
  }(ObservableBase);

  /**
   * Concatenates all the observable sequences.
   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.
   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
   */
  var observableConcat = Observable.concat = function () {
    var args;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      args = new Array(arguments.length);
      for (var i = 0, len = arguments.length; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    return new ConcatObservable(args);
  };

  /**
   * Concatenates an observable sequence of observable sequences.
   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.
   */
  observableProto.concatAll = function () {
    return this.merge(1);
  };

  var MergeObservable = function (__super__) {
    inherits(MergeObservable, __super__);

    function MergeObservable(source, maxConcurrent) {
      this.source = source;
      this.maxConcurrent = maxConcurrent;
      __super__.call(this);
    }

    MergeObservable.prototype.subscribeCore = function (observer) {
      var g = new CompositeDisposable();
      g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
      return g;
    };

    return MergeObservable;
  }(ObservableBase);

  var MergeObserver = function (__super__) {
    function MergeObserver(o, max, g) {
      this.o = o;
      this.max = max;
      this.g = g;
      this.done = false;
      this.q = [];
      this.activeCount = 0;
      __super__.call(this);
    }

    inherits(MergeObserver, __super__);

    MergeObserver.prototype.handleSubscribe = function (xs) {
      var sad = new SingleAssignmentDisposable();
      this.g.add(sad);
      isPromise(xs) && (xs = observableFromPromise(xs));
      sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
    };

    MergeObserver.prototype.next = function (innerSource) {
      if (this.activeCount < this.max) {
        this.activeCount++;
        this.handleSubscribe(innerSource);
      } else {
        this.q.push(innerSource);
      }
    };
    MergeObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    MergeObserver.prototype.completed = function () {
      this.done = true;this.activeCount === 0 && this.o.onCompleted();
    };

    function InnerObserver(parent, sad) {
      this.parent = parent;
      this.sad = sad;
      __super__.call(this);
    }

    inherits(InnerObserver, __super__);

    InnerObserver.prototype.next = function (x) {
      this.parent.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.parent.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.parent.g.remove(this.sad);
      if (this.parent.q.length > 0) {
        this.parent.handleSubscribe(this.parent.q.shift());
      } else {
        this.parent.activeCount--;
        this.parent.done && this.parent.activeCount === 0 && this.parent.o.onCompleted();
      }
    };

    return MergeObserver;
  }(AbstractObserver);

  /**
  * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.
  * Or merges two observable sequences into a single observable sequence.
  * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.
  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
  */
  observableProto.merge = function (maxConcurrentOrOther) {
    return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
  };

  /**
   * Merges all the observable sequences into a single observable sequence.
   * The scheduler is optional and if not specified, the immediate scheduler is used.
   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.
   */
  var observableMerge = Observable.merge = function () {
    var scheduler,
        sources = [],
        i,
        len = arguments.length;
    if (!arguments[0]) {
      scheduler = immediateScheduler;
      for (i = 1; i < len; i++) {
        sources.push(arguments[i]);
      }
    } else if (isScheduler(arguments[0])) {
      scheduler = arguments[0];
      for (i = 1; i < len; i++) {
        sources.push(arguments[i]);
      }
    } else {
      scheduler = immediateScheduler;
      for (i = 0; i < len; i++) {
        sources.push(arguments[i]);
      }
    }
    if (Array.isArray(sources[0])) {
      sources = sources[0];
    }
    return observableOf(scheduler, sources).mergeAll();
  };

  var MergeAllObservable = function (__super__) {
    inherits(MergeAllObservable, __super__);

    function MergeAllObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    MergeAllObservable.prototype.subscribeCore = function (o) {
      var g = new CompositeDisposable(),
          m = new SingleAssignmentDisposable();
      g.add(m);
      m.setDisposable(this.source.subscribe(new MergeAllObserver(o, g)));
      return g;
    };

    return MergeAllObservable;
  }(ObservableBase);

  var MergeAllObserver = function (__super__) {
    function MergeAllObserver(o, g) {
      this.o = o;
      this.g = g;
      this.done = false;
      __super__.call(this);
    }

    inherits(MergeAllObserver, __super__);

    MergeAllObserver.prototype.next = function (innerSource) {
      var sad = new SingleAssignmentDisposable();
      this.g.add(sad);
      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
      sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));
    };

    MergeAllObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    MergeAllObserver.prototype.completed = function () {
      this.done = true;
      this.g.length === 1 && this.o.onCompleted();
    };

    function InnerObserver(parent, sad) {
      this.parent = parent;
      this.sad = sad;
      __super__.call(this);
    }

    inherits(InnerObserver, __super__);

    InnerObserver.prototype.next = function (x) {
      this.parent.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this.parent.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this.parent.g.remove(this.sad);
      this.parent.done && this.parent.g.length === 1 && this.parent.o.onCompleted();
    };

    return MergeAllObserver;
  }(AbstractObserver);

  /**
  * Merges an observable sequence of observable sequences into an observable sequence.
  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
  */
  observableProto.mergeAll = function () {
    return new MergeAllObservable(this);
  };

  var CompositeError = Rx.CompositeError = function (errors) {
    this.innerErrors = errors;
    this.message = 'This contains multiple errors. Check the innerErrors';
    Error.call(this);
  };
  CompositeError.prototype = Object.create(Error.prototype);
  CompositeError.prototype.name = 'CompositeError';

  var MergeDelayErrorObservable = function (__super__) {
    inherits(MergeDelayErrorObservable, __super__);
    function MergeDelayErrorObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    MergeDelayErrorObservable.prototype.subscribeCore = function (o) {
      var group = new CompositeDisposable(),
          m = new SingleAssignmentDisposable(),
          state = { isStopped: false, errors: [], o: o };

      group.add(m);
      m.setDisposable(this.source.subscribe(new MergeDelayErrorObserver(group, state)));

      return group;
    };

    return MergeDelayErrorObservable;
  }(ObservableBase);

  var MergeDelayErrorObserver = function (__super__) {
    inherits(MergeDelayErrorObserver, __super__);
    function MergeDelayErrorObserver(group, state) {
      this._group = group;
      this._state = state;
      __super__.call(this);
    }

    function setCompletion(o, errors) {
      if (errors.length === 0) {
        o.onCompleted();
      } else if (errors.length === 1) {
        o.onError(errors[0]);
      } else {
        o.onError(new CompositeError(errors));
      }
    }

    MergeDelayErrorObserver.prototype.next = function (x) {
      var inner = new SingleAssignmentDisposable();
      this._group.add(inner);

      // Check for promises support
      isPromise(x) && (x = observableFromPromise(x));
      inner.setDisposable(x.subscribe(new InnerObserver(inner, this._group, this._state)));
    };

    MergeDelayErrorObserver.prototype.error = function (e) {
      this._state.errors.push(e);
      this._state.isStopped = true;
      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    MergeDelayErrorObserver.prototype.completed = function () {
      this._state.isStopped = true;
      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    inherits(InnerObserver, __super__);
    function InnerObserver(inner, group, state) {
      this._inner = inner;
      this._group = group;
      this._state = state;
      __super__.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._state.errors.push(e);
      this._group.remove(this._inner);
      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };
    InnerObserver.prototype.completed = function () {
      this._group.remove(this._inner);
      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);
    };

    return MergeDelayErrorObserver;
  }(AbstractObserver);

  /**
  * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
  * receive all successfully emitted items from all of the source Observables without being interrupted by
  * an error notification from one of them.
  *
  * This behaves like Observable.prototype.mergeAll except that if any of the merged Observables notify of an
  * error via the Observer's onError, mergeDelayError will refrain from propagating that
  * error notification until all of the merged Observables have finished emitting items.
  * @param {Array | Arguments} args Arguments or an array to merge.
  * @returns {Observable} an Observable that emits all of the items emitted by the Observables emitted by the Observable
  */
  Observable.mergeDelayError = function () {
    var args;
    if (Array.isArray(arguments[0])) {
      args = arguments[0];
    } else {
      var len = arguments.length;
      args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
    }
    var source = observableOf(null, args);
    return new MergeDelayErrorObservable(source);
  };

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.
   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
   */
  observableProto.onErrorResumeNext = function (second) {
    if (!second) {
      throw new Error('Second observable is required');
    }
    return onErrorResumeNext([this, second]);
  };

  var OnErrorResumeNextObservable = function (__super__) {
    inherits(OnErrorResumeNextObservable, __super__);
    function OnErrorResumeNextObservable(sources) {
      this.sources = sources;
      __super__.call(this);
    }

    function scheduleMethod(state, recurse) {
      if (state.pos < state.sources.length) {
        var current = state.sources[state.pos++];
        isPromise(current) && (current = observableFromPromise(current));
        var d = new SingleAssignmentDisposable();
        state.subscription.setDisposable(d);
        d.setDisposable(current.subscribe(new OnErrorResumeNextObserver(state, recurse)));
      } else {
        state.o.onCompleted();
      }
    }

    OnErrorResumeNextObservable.prototype.subscribeCore = function (o) {
      var subscription = new SerialDisposable(),
          state = { pos: 0, subscription: subscription, o: o, sources: this.sources },
          cancellable = immediateScheduler.scheduleRecursive(state, scheduleMethod);

      return new BinaryDisposable(subscription, cancellable);
    };

    return OnErrorResumeNextObservable;
  }(ObservableBase);

  var OnErrorResumeNextObserver = function (__super__) {
    inherits(OnErrorResumeNextObserver, __super__);
    function OnErrorResumeNextObserver(state, recurse) {
      this._state = state;
      this._recurse = recurse;
      __super__.call(this);
    }

    OnErrorResumeNextObserver.prototype.next = function (x) {
      this._state.o.onNext(x);
    };
    OnErrorResumeNextObserver.prototype.error = function () {
      this._recurse(this._state);
    };
    OnErrorResumeNextObserver.prototype.completed = function () {
      this._recurse(this._state);
    };

    return OnErrorResumeNextObserver;
  }(AbstractObserver);

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
   */
  var onErrorResumeNext = Observable.onErrorResumeNext = function () {
    var sources = [];
    if (Array.isArray(arguments[0])) {
      sources = arguments[0];
    } else {
      var len = arguments.length;
      sources = new Array(len);
      for (var i = 0; i < len; i++) {
        sources[i] = arguments[i];
      }
    }
    return new OnErrorResumeNextObservable(sources);
  };

  var SkipUntilObservable = function (__super__) {
    inherits(SkipUntilObservable, __super__);

    function SkipUntilObservable(source, other) {
      this._s = source;
      this._o = isPromise(other) ? observableFromPromise(other) : other;
      this._open = false;
      __super__.call(this);
    }

    SkipUntilObservable.prototype.subscribeCore = function (o) {
      var leftSubscription = new SingleAssignmentDisposable();
      leftSubscription.setDisposable(this._s.subscribe(new SkipUntilSourceObserver(o, this)));

      isPromise(this._o) && (this._o = observableFromPromise(this._o));

      var rightSubscription = new SingleAssignmentDisposable();
      rightSubscription.setDisposable(this._o.subscribe(new SkipUntilOtherObserver(o, this, rightSubscription)));

      return new BinaryDisposable(leftSubscription, rightSubscription);
    };

    return SkipUntilObservable;
  }(ObservableBase);

  var SkipUntilSourceObserver = function (__super__) {
    inherits(SkipUntilSourceObserver, __super__);
    function SkipUntilSourceObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipUntilSourceObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };

    SkipUntilSourceObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    SkipUntilSourceObserver.prototype.onCompleted = function () {
      this._p._open && this._o.onCompleted();
    };

    return SkipUntilSourceObserver;
  }(AbstractObserver);

  var SkipUntilOtherObserver = function (__super__) {
    inherits(SkipUntilOtherObserver, __super__);
    function SkipUntilOtherObserver(o, p, r) {
      this._o = o;
      this._p = p;
      this._r = r;
      __super__.call(this);
    }

    SkipUntilOtherObserver.prototype.next = function () {
      this._p._open = true;
      this._r.dispose();
    };

    SkipUntilOtherObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    SkipUntilOtherObserver.prototype.onCompleted = function () {
      this._r.dispose();
    };

    return SkipUntilOtherObserver;
  }(AbstractObserver);

  /**
   * Returns the values from the source observable sequence only after the other observable sequence produces a value.
   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.
   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.
   */
  observableProto.skipUntil = function (other) {
    return new SkipUntilObservable(this, other);
  };

  var SwitchObservable = function (__super__) {
    inherits(SwitchObservable, __super__);
    function SwitchObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    SwitchObservable.prototype.subscribeCore = function (o) {
      var inner = new SerialDisposable(),
          s = this.source.subscribe(new SwitchObserver(o, inner));
      return new BinaryDisposable(s, inner);
    };

    inherits(SwitchObserver, AbstractObserver);
    function SwitchObserver(o, inner) {
      this.o = o;
      this.inner = inner;
      this.stopped = false;
      this.latest = 0;
      this.hasLatest = false;
      AbstractObserver.call(this);
    }

    SwitchObserver.prototype.next = function (innerSource) {
      var d = new SingleAssignmentDisposable(),
          id = ++this.latest;
      this.hasLatest = true;
      this.inner.setDisposable(d);
      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
      d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
    };

    SwitchObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    SwitchObserver.prototype.completed = function () {
      this.stopped = true;
      !this.hasLatest && this.o.onCompleted();
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(parent, id) {
      this.parent = parent;
      this.id = id;
      AbstractObserver.call(this);
    }
    InnerObserver.prototype.next = function (x) {
      this.parent.latest === this.id && this.parent.o.onNext(x);
    };

    InnerObserver.prototype.error = function (e) {
      this.parent.latest === this.id && this.parent.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      if (this.parent.latest === this.id) {
        this.parent.hasLatest = false;
        this.parent.stopped && this.parent.o.onCompleted();
      }
    };

    return SwitchObservable;
  }(ObservableBase);

  /**
  * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
  * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
  */
  observableProto['switch'] = observableProto.switchLatest = function () {
    return new SwitchObservable(this);
  };

  var TakeUntilObservable = function (__super__) {
    inherits(TakeUntilObservable, __super__);

    function TakeUntilObservable(source, other) {
      this.source = source;
      this.other = isPromise(other) ? observableFromPromise(other) : other;
      __super__.call(this);
    }

    TakeUntilObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this.source.subscribe(o), this.other.subscribe(new TakeUntilObserver(o)));
    };

    return TakeUntilObservable;
  }(ObservableBase);

  var TakeUntilObserver = function (__super__) {
    inherits(TakeUntilObserver, __super__);
    function TakeUntilObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    TakeUntilObserver.prototype.next = function () {
      this._o.onCompleted();
    };

    TakeUntilObserver.prototype.error = function (err) {
      this._o.onError(err);
    };

    TakeUntilObserver.prototype.onCompleted = noop;

    return TakeUntilObserver;
  }(AbstractObserver);

  /**
   * Returns the values from the source observable sequence until the other observable sequence produces a value.
   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.
   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
   */
  observableProto.takeUntil = function (other) {
    return new TakeUntilObservable(this, other);
  };

  function falseFactory() {
    return false;
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var WithLatestFromObservable = function (__super__) {
    inherits(WithLatestFromObservable, __super__);
    function WithLatestFromObservable(source, sources, resultSelector) {
      this._s = source;
      this._ss = sources;
      this._cb = resultSelector;
      __super__.call(this);
    }

    WithLatestFromObservable.prototype.subscribeCore = function (o) {
      var len = this._ss.length;
      var state = {
        hasValue: arrayInitialize(len, falseFactory),
        hasValueAll: false,
        values: new Array(len)
      };

      var n = this._ss.length,
          subscriptions = new Array(n + 1);
      for (var i = 0; i < n; i++) {
        var other = this._ss[i],
            sad = new SingleAssignmentDisposable();
        isPromise(other) && (other = observableFromPromise(other));
        sad.setDisposable(other.subscribe(new WithLatestFromOtherObserver(o, i, state)));
        subscriptions[i] = sad;
      }

      var outerSad = new SingleAssignmentDisposable();
      outerSad.setDisposable(this._s.subscribe(new WithLatestFromSourceObserver(o, this._cb, state)));
      subscriptions[n] = outerSad;

      return new NAryDisposable(subscriptions);
    };

    return WithLatestFromObservable;
  }(ObservableBase);

  var WithLatestFromOtherObserver = function (__super__) {
    inherits(WithLatestFromOtherObserver, __super__);
    function WithLatestFromOtherObserver(o, i, state) {
      this._o = o;
      this._i = i;
      this._state = state;
      __super__.call(this);
    }

    WithLatestFromOtherObserver.prototype.next = function (x) {
      this._state.values[this._i] = x;
      this._state.hasValue[this._i] = true;
      this._state.hasValueAll = this._state.hasValue.every(identity);
    };

    WithLatestFromOtherObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    WithLatestFromOtherObserver.prototype.completed = noop;

    return WithLatestFromOtherObserver;
  }(AbstractObserver);

  var WithLatestFromSourceObserver = function (__super__) {
    inherits(WithLatestFromSourceObserver, __super__);
    function WithLatestFromSourceObserver(o, cb, state) {
      this._o = o;
      this._cb = cb;
      this._state = state;
      __super__.call(this);
    }

    WithLatestFromSourceObserver.prototype.next = function (x) {
      var allValues = [x].concat(this._state.values);
      if (!this._state.hasValueAll) {
        return;
      }
      var res = tryCatch(this._cb).apply(null, allValues);
      if (res === errorObj) {
        return this._o.onError(res.e);
      }
      this._o.onNext(res);
    };

    WithLatestFromSourceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    WithLatestFromSourceObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return WithLatestFromSourceObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.withLatestFrom = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);

    return new WithLatestFromObservable(this, args, resultSelector);
  };

  function falseFactory() {
    return false;
  }
  function emptyArrayFactory() {
    return [];
  }

  var ZipObservable = function (__super__) {
    inherits(ZipObservable, __super__);
    function ZipObservable(sources, resultSelector) {
      this._s = sources;
      this._cb = resultSelector;
      __super__.call(this);
    }

    ZipObservable.prototype.subscribeCore = function (observer) {
      var n = this._s.length,
          subscriptions = new Array(n),
          done = arrayInitialize(n, falseFactory),
          q = arrayInitialize(n, emptyArrayFactory);

      for (var i = 0; i < n; i++) {
        var source = this._s[i],
            sad = new SingleAssignmentDisposable();
        subscriptions[i] = sad;
        isPromise(source) && (source = observableFromPromise(source));
        sad.setDisposable(source.subscribe(new ZipObserver(observer, i, this, q, done)));
      }

      return new NAryDisposable(subscriptions);
    };

    return ZipObservable;
  }(ObservableBase);

  var ZipObserver = function (__super__) {
    inherits(ZipObserver, __super__);
    function ZipObserver(o, i, p, q, d) {
      this._o = o;
      this._i = i;
      this._p = p;
      this._q = q;
      this._d = d;
      __super__.call(this);
    }

    function notEmpty(x) {
      return x.length > 0;
    }
    function shiftEach(x) {
      return x.shift();
    }
    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    ZipObserver.prototype.next = function (x) {
      this._q[this._i].push(x);
      if (this._q.every(notEmpty)) {
        var queuedValues = this._q.map(shiftEach);
        var res = tryCatch(this._p._cb).apply(null, queuedValues);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._o.onNext(res);
      } else if (this._d.filter(notTheSame(this._i)).every(identity)) {
        this._o.onCompleted();
      }
    };

    ZipObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ZipObserver.prototype.completed = function () {
      this._d[this._i] = true;
      this._d.every(identity) && this._o.onCompleted();
    };

    return ZipObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.
   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.
   */
  observableProto.zip = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);

    var parent = this;
    args.unshift(parent);

    return new ZipObservable(args, resultSelector);
  };

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   * @param arguments Observable sources.
   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.
   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  Observable.zip = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];
    }
    var first = args.shift();
    return first.zip.apply(first, args);
  };

  function falseFactory() {
    return false;
  }
  function emptyArrayFactory() {
    return [];
  }
  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var ZipIterableObservable = function (__super__) {
    inherits(ZipIterableObservable, __super__);
    function ZipIterableObservable(sources, cb) {
      this.sources = sources;
      this._cb = cb;
      __super__.call(this);
    }

    ZipIterableObservable.prototype.subscribeCore = function (o) {
      var sources = this.sources,
          len = sources.length,
          subscriptions = new Array(len);

      var state = {
        q: arrayInitialize(len, emptyArrayFactory),
        done: arrayInitialize(len, falseFactory),
        cb: this._cb,
        o: o
      };

      for (var i = 0; i < len; i++) {
        (function (i) {
          var source = sources[i],
              sad = new SingleAssignmentDisposable();
          (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));

          subscriptions[i] = sad;
          sad.setDisposable(source.subscribe(new ZipIterableObserver(state, i)));
        })(i);
      }

      return new NAryDisposable(subscriptions);
    };

    return ZipIterableObservable;
  }(ObservableBase);

  var ZipIterableObserver = function (__super__) {
    inherits(ZipIterableObserver, __super__);
    function ZipIterableObserver(s, i) {
      this._s = s;
      this._i = i;
      __super__.call(this);
    }

    function notEmpty(x) {
      return x.length > 0;
    }
    function shiftEach(x) {
      return x.shift();
    }
    function notTheSame(i) {
      return function (x, j) {
        return j !== i;
      };
    }

    ZipIterableObserver.prototype.next = function (x) {
      this._s.q[this._i].push(x);
      if (this._s.q.every(notEmpty)) {
        var queuedValues = this._s.q.map(shiftEach),
            res = tryCatch(this._s.cb).apply(null, queuedValues);
        if (res === errorObj) {
          return this._s.o.onError(res.e);
        }
        this._s.o.onNext(res);
      } else if (this._s.done.filter(notTheSame(this._i)).every(identity)) {
        this._s.o.onCompleted();
      }
    };

    ZipIterableObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    ZipIterableObserver.prototype.completed = function () {
      this._s.done[this._i] = true;
      this._s.done.every(identity) && this._s.o.onCompleted();
    };

    return ZipIterableObserver;
  }(AbstractObserver);

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.
   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.
   */
  observableProto.zipIterable = function () {
    if (arguments.length === 0) {
      throw new Error('invalid arguments');
    }

    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;

    var parent = this;
    args.unshift(parent);
    return new ZipIterableObservable(args, resultSelector);
  };

  function asObservable(source) {
    return function subscribe(o) {
      return source.subscribe(o);
    };
  }

  /**
   *  Hides the identity of an observable sequence.
   * @returns {Observable} An observable sequence that hides the identity of the source sequence.
   */
  observableProto.asObservable = function () {
    return new AnonymousObservable(asObservable(this), this);
  };

  function toArray(x) {
    return x.toArray();
  }
  function notEmpty(x) {
    return x.length > 0;
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
   * @param {Number} count Length of each buffer.
   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithCount = observableProto.bufferCount = function (count, skip) {
    typeof skip !== 'number' && (skip = count);
    return this.windowWithCount(count, skip).flatMap(toArray).filter(notEmpty);
  };

  var DematerializeObservable = function (__super__) {
    inherits(DematerializeObservable, __super__);
    function DematerializeObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    DematerializeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DematerializeObserver(o));
    };

    return DematerializeObservable;
  }(ObservableBase);

  var DematerializeObserver = function (__super__) {
    inherits(DematerializeObserver, __super__);

    function DematerializeObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    DematerializeObserver.prototype.next = function (x) {
      x.accept(this._o);
    };
    DematerializeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    DematerializeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return DematerializeObserver;
  }(AbstractObserver);

  /**
   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
   */
  observableProto.dematerialize = function () {
    return new DematerializeObservable(this);
  };

  var DistinctUntilChangedObservable = function (__super__) {
    inherits(DistinctUntilChangedObservable, __super__);
    function DistinctUntilChangedObservable(source, keyFn, comparer) {
      this.source = source;
      this.keyFn = keyFn;
      this.comparer = comparer;
      __super__.call(this);
    }

    DistinctUntilChangedObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));
    };

    return DistinctUntilChangedObservable;
  }(ObservableBase);

  var DistinctUntilChangedObserver = function (__super__) {
    inherits(DistinctUntilChangedObserver, __super__);
    function DistinctUntilChangedObserver(o, keyFn, comparer) {
      this.o = o;
      this.keyFn = keyFn;
      this.comparer = comparer;
      this.hasCurrentKey = false;
      this.currentKey = null;
      __super__.call(this);
    }

    DistinctUntilChangedObserver.prototype.next = function (x) {
      var key = x,
          comparerEquals;
      if (isFunction(this.keyFn)) {
        key = tryCatch(this.keyFn)(x);
        if (key === errorObj) {
          return this.o.onError(key.e);
        }
      }
      if (this.hasCurrentKey) {
        comparerEquals = tryCatch(this.comparer)(this.currentKey, key);
        if (comparerEquals === errorObj) {
          return this.o.onError(comparerEquals.e);
        }
      }
      if (!this.hasCurrentKey || !comparerEquals) {
        this.hasCurrentKey = true;
        this.currentKey = key;
        this.o.onNext(x);
      }
    };
    DistinctUntilChangedObserver.prototype.error = function (e) {
      this.o.onError(e);
    };
    DistinctUntilChangedObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return DistinctUntilChangedObserver;
  }(AbstractObserver);

  /**
  *  Returns an observable sequence that contains only distinct contiguous elements according to the keyFn and the comparer.
  * @param {Function} [keyFn] A function to compute the comparison key for each element. If not provided, it projects the value.
  * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.
  * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
  */
  observableProto.distinctUntilChanged = function (keyFn, comparer) {
    comparer || (comparer = defaultComparer);
    return new DistinctUntilChangedObservable(this, keyFn, comparer);
  };

  var TapObservable = function (__super__) {
    inherits(TapObservable, __super__);
    function TapObservable(source, observerOrOnNext, onError, onCompleted) {
      this.source = source;
      this._oN = observerOrOnNext;
      this._oE = onError;
      this._oC = onCompleted;
      __super__.call(this);
    }

    TapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, p) {
      this.o = o;
      this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;
      this.isStopped = false;
      AbstractObserver.call(this);
    }
    InnerObserver.prototype.next = function (x) {
      var res = tryCatch(this.t.onNext).call(this.t, x);
      if (res === errorObj) {
        this.o.onError(res.e);
      }
      this.o.onNext(x);
    };
    InnerObserver.prototype.error = function (err) {
      var res = tryCatch(this.t.onError).call(this.t, err);
      if (res === errorObj) {
        return this.o.onError(res.e);
      }
      this.o.onError(err);
    };
    InnerObserver.prototype.completed = function () {
      var res = tryCatch(this.t.onCompleted).call(this.t);
      if (res === errorObj) {
        return this.o.onError(res.e);
      }
      this.o.onCompleted();
    };

    return TapObservable;
  }(ObservableBase);

  /**
  *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an o.
  * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
  * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto['do'] = observableProto.tap = observableProto.doAction = function (observerOrOnNext, onError, onCompleted) {
    return new TapObservable(this, observerOrOnNext, onError, onCompleted);
  };

  /**
  *  Invokes an action for each element in the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onNext Action to invoke for each element in the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
    return this.tap(typeof thisArg !== 'undefined' ? function (x) {
      onNext.call(thisArg, x);
    } : onNext);
  };

  /**
  *  Invokes an action upon exceptional termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {
    return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) {
      onError.call(thisArg, e);
    } : onError);
  };

  /**
  *  Invokes an action upon graceful termination of the observable sequence.
  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
  * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} The source sequence with the side-effecting behavior applied.
  */
  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {
    return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () {
      onCompleted.call(thisArg);
    } : onCompleted);
  };

  var FinallyObservable = function (__super__) {
    inherits(FinallyObservable, __super__);
    function FinallyObservable(source, fn, thisArg) {
      this.source = source;
      this._fn = bindCallback(fn, thisArg, 0);
      __super__.call(this);
    }

    FinallyObservable.prototype.subscribeCore = function (o) {
      var d = tryCatch(this.source.subscribe).call(this.source, o);
      if (d === errorObj) {
        this._fn();
        thrower(d.e);
      }

      return new FinallyDisposable(d, this._fn);
    };

    function FinallyDisposable(s, fn) {
      this.isDisposed = false;
      this._s = s;
      this._fn = fn;
    }
    FinallyDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        var res = tryCatch(this._s.dispose).call(this._s);
        this._fn();
        res === errorObj && thrower(res.e);
      }
    };

    return FinallyObservable;
  }(ObservableBase);

  /**
   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.
   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.
   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.
   */
  observableProto['finally'] = function (action, thisArg) {
    return new FinallyObservable(this, action, thisArg);
  };

  var IgnoreElementsObservable = function (__super__) {
    inherits(IgnoreElementsObservable, __super__);

    function IgnoreElementsObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    IgnoreElementsObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o));
    };

    function InnerObserver(o) {
      this.o = o;
      this.isStopped = false;
    }
    InnerObserver.prototype.onNext = noop;
    InnerObserver.prototype.onError = function (err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.o.onError(err);
      }
    };
    InnerObserver.prototype.onCompleted = function () {
      if (!this.isStopped) {
        this.isStopped = true;
        this.o.onCompleted();
      }
    };
    InnerObserver.prototype.dispose = function () {
      this.isStopped = true;
    };
    InnerObserver.prototype.fail = function (e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }

      return false;
    };

    return IgnoreElementsObservable;
  }(ObservableBase);

  /**
   *  Ignores all elements in an observable sequence leaving only the termination messages.
   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.
   */
  observableProto.ignoreElements = function () {
    return new IgnoreElementsObservable(this);
  };

  var MaterializeObservable = function (__super__) {
    inherits(MaterializeObservable, __super__);
    function MaterializeObservable(source, fn) {
      this.source = source;
      __super__.call(this);
    }

    MaterializeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new MaterializeObserver(o));
    };

    return MaterializeObservable;
  }(ObservableBase);

  var MaterializeObserver = function (__super__) {
    inherits(MaterializeObserver, __super__);

    function MaterializeObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    MaterializeObserver.prototype.next = function (x) {
      this._o.onNext(notificationCreateOnNext(x));
    };
    MaterializeObserver.prototype.error = function (e) {
      this._o.onNext(notificationCreateOnError(e));this._o.onCompleted();
    };
    MaterializeObserver.prototype.completed = function () {
      this._o.onNext(notificationCreateOnCompleted());this._o.onCompleted();
    };

    return MaterializeObserver;
  }(AbstractObserver);

  /**
   *  Materializes the implicit notifications of an observable sequence as explicit notification values.
   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.
   */
  observableProto.materialize = function () {
    return new MaterializeObservable(this);
  };

  /**
   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.
   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.
   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.
   */
  observableProto.repeat = function (repeatCount) {
    return enumerableRepeat(this, repeatCount).concat();
  };

  /**
   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.
   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
   *
   * @example
   *  var res = retried = retry.repeat();
   *  var res = retried = retry.repeat(2);
   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
   */
  observableProto.retry = function (retryCount) {
    return enumerableRepeat(this, retryCount).catchError();
  };

  function repeat(value) {
    return {
      '@@iterator': function iterator() {
        return {
          next: function next() {
            return { done: false, value: value };
          }
        };
      }
    };
  }

  var RetryWhenObservable = function (__super__) {
    function createDisposable(state) {
      return {
        isDisposed: false,
        dispose: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            state.isDisposed = true;
          }
        }
      };
    }

    function RetryWhenObservable(source, notifier) {
      this.source = source;
      this._notifier = notifier;
      __super__.call(this);
    }

    inherits(RetryWhenObservable, __super__);

    RetryWhenObservable.prototype.subscribeCore = function (o) {
      var exceptions = new Subject(),
          notifier = new Subject(),
          handled = this._notifier(exceptions),
          notificationDisposable = handled.subscribe(notifier);

      var e = this.source['@@iterator']();

      var state = { isDisposed: false },
          lastError,
          subscription = new SerialDisposable();
      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, recurse) {
        if (state.isDisposed) {
          return;
        }
        var currentItem = e.next();

        if (currentItem.done) {
          if (lastError) {
            o.onError(lastError);
          } else {
            o.onCompleted();
          }
          return;
        }

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new BinaryDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(function (x) {
          o.onNext(x);
        }, function (exn) {
          inner.setDisposable(notifier.subscribe(recurse, function (ex) {
            o.onError(ex);
          }, function () {
            o.onCompleted();
          }));

          exceptions.onNext(exn);
          outer.dispose();
        }, function () {
          o.onCompleted();
        }));
      });

      return new NAryDisposable([notificationDisposable, subscription, cancelable, createDisposable(state)]);
    };

    return RetryWhenObservable;
  }(ObservableBase);

  observableProto.retryWhen = function (notifier) {
    return new RetryWhenObservable(repeat(this), notifier);
  };

  function repeat(value) {
    return {
      '@@iterator': function iterator() {
        return {
          next: function next() {
            return { done: false, value: value };
          }
        };
      }
    };
  }

  var RepeatWhenObservable = function (__super__) {
    function createDisposable(state) {
      return {
        isDisposed: false,
        dispose: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            state.isDisposed = true;
          }
        }
      };
    }

    function RepeatWhenObservable(source, notifier) {
      this.source = source;
      this._notifier = notifier;
      __super__.call(this);
    }

    inherits(RepeatWhenObservable, __super__);

    RepeatWhenObservable.prototype.subscribeCore = function (o) {
      var completions = new Subject(),
          notifier = new Subject(),
          handled = this._notifier(completions),
          notificationDisposable = handled.subscribe(notifier);

      var e = this.source['@@iterator']();

      var state = { isDisposed: false },
          lastError,
          subscription = new SerialDisposable();
      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, recurse) {
        if (state.isDisposed) {
          return;
        }
        var currentItem = e.next();

        if (currentItem.done) {
          if (lastError) {
            o.onError(lastError);
          } else {
            o.onCompleted();
          }
          return;
        }

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new BinaryDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(function (x) {
          o.onNext(x);
        }, function (exn) {
          o.onError(exn);
        }, function () {
          inner.setDisposable(notifier.subscribe(recurse, function (ex) {
            o.onError(ex);
          }, function () {
            o.onCompleted();
          }));

          completions.onNext(null);
          outer.dispose();
        }));
      });

      return new NAryDisposable([notificationDisposable, subscription, cancelable, createDisposable(state)]);
    };

    return RepeatWhenObservable;
  }(ObservableBase);

  observableProto.repeatWhen = function (notifier) {
    return new RepeatWhenObservable(repeat(this), notifier);
  };

  var ScanObservable = function (__super__) {
    inherits(ScanObservable, __super__);
    function ScanObservable(source, accumulator, hasSeed, seed) {
      this.source = source;
      this.accumulator = accumulator;
      this.hasSeed = hasSeed;
      this.seed = seed;
      __super__.call(this);
    }

    ScanObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ScanObserver(o, this));
    };

    return ScanObservable;
  }(ObservableBase);

  var ScanObserver = function (__super__) {
    inherits(ScanObserver, __super__);
    function ScanObserver(o, parent) {
      this._o = o;
      this._p = parent;
      this._fn = parent.accumulator;
      this._hs = parent.hasSeed;
      this._s = parent.seed;
      this._ha = false;
      this._a = null;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    ScanObserver.prototype.next = function (x) {
      !this._hv && (this._hv = true);
      if (this._ha) {
        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);
      } else {
        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;
        this._ha = true;
      }
      if (this._a === errorObj) {
        return this._o.onError(this._a.e);
      }
      this._o.onNext(this._a);
      this._i++;
    };

    ScanObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ScanObserver.prototype.completed = function () {
      !this._hv && this._hs && this._o.onNext(this._s);
      this._o.onCompleted();
    };

    return ScanObserver;
  }(AbstractObserver);

  /**
  *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
  *  For aggregation behavior with no intermediate results, see Observable.aggregate.
  * @param {Mixed} [seed] The initial accumulator value.
  * @param {Function} accumulator An accumulator function to be invoked on each element.
  * @returns {Observable} An observable sequence containing the accumulated values.
  */
  observableProto.scan = function () {
    var hasSeed = false,
        seed,
        accumulator = arguments[0];
    if (arguments.length === 2) {
      hasSeed = true;
      seed = arguments[1];
    }
    return new ScanObservable(this, accumulator, hasSeed, seed);
  };

  var SkipLastObservable = function (__super__) {
    inherits(SkipLastObservable, __super__);
    function SkipLastObservable(source, c) {
      this.source = source;
      this._c = c;
      __super__.call(this);
    }

    SkipLastObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipLastObserver(o, this._c));
    };

    return SkipLastObservable;
  }(ObservableBase);

  var SkipLastObserver = function (__super__) {
    inherits(SkipLastObserver, __super__);
    function SkipLastObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    SkipLastObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._o.onNext(this._q.shift());
    };

    SkipLastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    SkipLastObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipLastObserver;
  }(AbstractObserver);

  /**
   *  Bypasses a specified number of elements at the end of an observable sequence.
   * @description
   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are
   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.
   * @param count Number of elements to bypass at the end of the source sequence.
   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.
   */
  observableProto.skipLast = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new SkipLastObservable(this, count);
  };

  /**
   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.
   *  @example
   *  var res = source.startWith(1, 2, 3);
   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);
   * @param {Arguments} args The specified values to prepend to the observable sequence
   * @returns {Observable} The source sequence prepended with the specified values.
   */
  observableProto.startWith = function () {
    var values,
        scheduler,
        start = 0;
    if (!!arguments.length && isScheduler(arguments[0])) {
      scheduler = arguments[0];
      start = 1;
    } else {
      scheduler = immediateScheduler;
    }
    for (var args = [], i = start, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    return observableConcat.apply(null, [observableFromArray(args, scheduler), this]);
  };

  var TakeLastObserver = function (__super__) {
    inherits(TakeLastObserver, __super__);
    function TakeLastObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    TakeLastObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._q.shift();
    };

    TakeLastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TakeLastObserver.prototype.completed = function () {
      while (this._q.length > 0) {
        this._o.onNext(this._q.shift());
      }
      this._o.onCompleted();
    };

    return TakeLastObserver;
  }(AbstractObserver);

  /**
   *  Returns a specified number of contiguous elements from the end of an observable sequence.
   * @description
   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of
   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
   * @param {Number} count Number of elements to take from the end of the source sequence.
   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLast = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      return source.subscribe(new TakeLastObserver(o, count));
    }, source);
  };

  var TakeLastBufferObserver = function (__super__) {
    inherits(TakeLastBufferObserver, __super__);
    function TakeLastBufferObserver(o, c) {
      this._o = o;
      this._c = c;
      this._q = [];
      __super__.call(this);
    }

    TakeLastBufferObserver.prototype.next = function (x) {
      this._q.push(x);
      this._q.length > this._c && this._q.shift();
    };

    TakeLastBufferObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TakeLastBufferObserver.prototype.completed = function () {
      this._o.onNext(this._q);
      this._o.onCompleted();
    };

    return TakeLastBufferObserver;
  }(AbstractObserver);

  /**
   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.
   *
   * @description
   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the
   *  source sequence, this buffer is produced on the result sequence.
   * @param {Number} count Number of elements to take from the end of the source sequence.
   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLastBuffer = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      return source.subscribe(new TakeLastBufferObserver(o, count));
    }, source);
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
   * @param {Number} count Length of each window.
   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithCount = observableProto.windowCount = function (count, skip) {
    var source = this;
    +count || (count = 0);
    Math.abs(count) === Infinity && (count = 0);
    if (count <= 0) {
      throw new ArgumentOutOfRangeError();
    }
    skip == null && (skip = count);
    +skip || (skip = 0);
    Math.abs(skip) === Infinity && (skip = 0);

    if (skip <= 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new AnonymousObservable(function (observer) {
      var m = new SingleAssignmentDisposable(),
          refCountDisposable = new RefCountDisposable(m),
          n = 0,
          q = [];

      function createWindow() {
        var s = new Subject();
        q.push(s);
        observer.onNext(addRef(s, refCountDisposable));
      }

      createWindow();

      m.setDisposable(source.subscribe(function (x) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onNext(x);
        }
        var c = n - count + 1;
        c >= 0 && c % skip === 0 && q.shift().onCompleted();
        ++n % skip === 0 && createWindow();
      }, function (e) {
        while (q.length > 0) {
          q.shift().onError(e);
        }
        observer.onError(e);
      }, function () {
        while (q.length > 0) {
          q.shift().onCompleted();
        }
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  function concatMap(source, selector, thisArg) {
    var selectorFunc = bindCallback(selector, thisArg, 3);
    return source.map(function (x, i) {
      var result = selectorFunc(x, i, source);
      isPromise(result) && (result = observableFromPromise(result));
      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
      return result;
    }).concatAll();
  }

  /**
   *  One of the Following:
   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   *
   * @example
   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });
   *  Or:
   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
   *
   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
   *  Or:
   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
   *
   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));
   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the
   * source sequence onto which could be either an observable or Promise.
   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
   */
  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {
    if (isFunction(selector) && isFunction(resultSelector)) {
      return this.concatMap(function (x, i) {
        var selectorResult = selector(x, i);
        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));

        return selectorResult.map(function (y, i2) {
          return resultSelector(x, y, i, i2);
        });
      });
    }
    return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function () {
      return selector;
    });
  };

  /**
   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.
   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
   */
  observableProto.concatMapObserver = observableProto.selectConcatObserver = function (onNext, onError, onCompleted, thisArg) {
    var source = this,
        onNextFunc = bindCallback(onNext, thisArg, 2),
        onErrorFunc = bindCallback(onError, thisArg, 1),
        onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
    return new AnonymousObservable(function (observer) {
      var index = 0;
      return source.subscribe(function (x) {
        var result;
        try {
          result = onNextFunc(x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
      }, function (err) {
        var result;
        try {
          result = onErrorFunc(err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      }, function () {
        var result;
        try {
          result = onCompletedFunc();
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
    }, this).concatAll();
  };

  var DefaultIfEmptyObserver = function (__super__) {
    inherits(DefaultIfEmptyObserver, __super__);
    function DefaultIfEmptyObserver(o, d) {
      this._o = o;
      this._d = d;
      this._f = false;
      __super__.call(this);
    }

    DefaultIfEmptyObserver.prototype.next = function (x) {
      this._f = true;
      this._o.onNext(x);
    };

    DefaultIfEmptyObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    DefaultIfEmptyObserver.prototype.completed = function () {
      !this._f && this._o.onNext(this._d);
      this._o.onCompleted();
    };

    return DefaultIfEmptyObserver;
  }(AbstractObserver);

  /**
   *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
   *
   *  var res = obs = xs.defaultIfEmpty();
   *  2 - obs = xs.defaultIfEmpty(false);
   *
   * @memberOf Observable#
   * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
   * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
   */
  observableProto.defaultIfEmpty = function (defaultValue) {
    var source = this;
    defaultValue === undefined && (defaultValue = null);
    return new AnonymousObservable(function (o) {
      return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));
    }, source);
  };

  // Swap out for Array.findIndex
  function arrayIndexOfComparer(array, item, comparer) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (comparer(array[i], item)) {
        return i;
      }
    }
    return -1;
  }

  function HashSet(comparer) {
    this.comparer = comparer;
    this.set = [];
  }
  HashSet.prototype.push = function (value) {
    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
    retValue && this.set.push(value);
    return retValue;
  };

  var DistinctObservable = function (__super__) {
    inherits(DistinctObservable, __super__);
    function DistinctObservable(source, keyFn, cmpFn) {
      this.source = source;
      this._keyFn = keyFn;
      this._cmpFn = cmpFn;
      __super__.call(this);
    }

    DistinctObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new DistinctObserver(o, this._keyFn, this._cmpFn));
    };

    return DistinctObservable;
  }(ObservableBase);

  var DistinctObserver = function (__super__) {
    inherits(DistinctObserver, __super__);
    function DistinctObserver(o, keyFn, cmpFn) {
      this._o = o;
      this._keyFn = keyFn;
      this._h = new HashSet(cmpFn);
      __super__.call(this);
    }

    DistinctObserver.prototype.next = function (x) {
      var key = x;
      if (isFunction(this._keyFn)) {
        key = tryCatch(this._keyFn)(x);
        if (key === errorObj) {
          return this._o.onError(key.e);
        }
      }
      this._h.push(key) && this._o.onNext(x);
    };

    DistinctObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    DistinctObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return DistinctObserver;
  }(AbstractObserver);

  /**
   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.
   *
   * @example
   *  var res = obs = xs.distinct();
   *  2 - obs = xs.distinct(function (x) { return x.id; });
   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });
   * @param {Function} [keySelector]  A function to compute the comparison key for each element.
   * @param {Function} [comparer]  Used to compare items in the collection.
   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
   */
  observableProto.distinct = function (keySelector, comparer) {
    comparer || (comparer = defaultComparer);
    return new DistinctObservable(this, keySelector, comparer);
  };

  /**
   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
   *
   * @example
   *  var res = observable.groupBy(function (x) { return x.id; });
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   */
  observableProto.groupBy = function (keySelector, elementSelector) {
    return this.groupByUntil(keySelector, elementSelector, observableNever);
  };

  /**
   *  Groups the elements of an observable sequence according to a specified key selector function.
   *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
   *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
   *
   * @example
   *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });
   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });
   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });
   * @param {Function} keySelector A function to extract the key for each element.
   * @param {Function} durationSelector A function to signal the expiration of a group.
   * @returns {Observable}
   *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
   *
   */
  observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var map = new Map(),
          groupDisposable = new CompositeDisposable(),
          refCountDisposable = new RefCountDisposable(groupDisposable),
          handleError = function handleError(e) {
        return function (item) {
          item.onError(e);
        };
      };

      groupDisposable.add(source.subscribe(function (x) {
        var key = tryCatch(keySelector)(x);
        if (key === errorObj) {
          map.forEach(handleError(key.e));
          return o.onError(key.e);
        }

        var fireNewMapEntry = false,
            writer = map.get(key);
        if (writer === undefined) {
          writer = new Subject();
          map.set(key, writer);
          fireNewMapEntry = true;
        }

        if (fireNewMapEntry) {
          var group = new GroupedObservable(key, writer, refCountDisposable),
              durationGroup = new GroupedObservable(key, writer);
          var duration = tryCatch(durationSelector)(durationGroup);
          if (duration === errorObj) {
            map.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }

          o.onNext(group);

          var md = new SingleAssignmentDisposable();
          groupDisposable.add(md);

          md.setDisposable(duration.take(1).subscribe(noop, function (e) {
            map.forEach(handleError(e));
            o.onError(e);
          }, function () {
            if (map['delete'](key)) {
              writer.onCompleted();
            }
            groupDisposable.remove(md);
          }));
        }

        var element = x;
        if (isFunction(elementSelector)) {
          element = tryCatch(elementSelector)(x);
          if (element === errorObj) {
            map.forEach(handleError(element.e));
            return o.onError(element.e);
          }
        }

        writer.onNext(element);
      }, function (e) {
        map.forEach(handleError(e));
        o.onError(e);
      }, function () {
        map.forEach(function (item) {
          item.onCompleted();
        });
        o.onCompleted();
      }));

      return refCountDisposable;
    }, source);
  };

  var MapObservable = function (__super__) {
    inherits(MapObservable, __super__);

    function MapObservable(source, selector, thisArg) {
      this.source = source;
      this.selector = bindCallback(selector, thisArg, 3);
      __super__.call(this);
    }

    function innerMap(selector, self) {
      return function (x, i, o) {
        return selector.call(this, self.selector(x, i, o), i, o);
      };
    }

    MapObservable.prototype.internalMap = function (selector, thisArg) {
      return new MapObservable(this.source, innerMap(selector, this), thisArg);
    };

    MapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.selector, this));
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, selector, source) {
      this.o = o;
      this.selector = selector;
      this.source = source;
      this.i = 0;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      var result = tryCatch(this.selector)(x, this.i++, this.source);
      if (result === errorObj) {
        return this.o.onError(result.e);
      }
      this.o.onNext(result);
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return MapObservable;
  }(ObservableBase);

  /**
  * Projects each element of an observable sequence into a new form by incorporating the element's index.
  * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.
  */
  observableProto.map = observableProto.select = function (selector, thisArg) {
    var selectorFn = typeof selector === 'function' ? selector : function () {
      return selector;
    };
    return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
  };

  function plucker(args, len) {
    return function mapper(x) {
      var currentProp = x;
      for (var i = 0; i < len; i++) {
        var p = currentProp[args[i]];
        if (typeof p !== 'undefined') {
          currentProp = p;
        } else {
          return undefined;
        }
      }
      return currentProp;
    };
  }

  /**
   * Retrieves the value of a specified nested property from all elements in
   * the Observable sequence.
   * @param {Arguments} arguments The nested properties to pluck.
   * @returns {Observable} Returns a new Observable sequence of property values.
   */
  observableProto.pluck = function () {
    var len = arguments.length,
        args = new Array(len);
    if (len === 0) {
      throw new Error('List of properties cannot be empty.');
    }
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return this.map(plucker(args, len));
  };

  observableProto.flatMap = observableProto.selectMany = observableProto.mergeMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
  };

  /**
   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
   */
  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var index = 0;

      return source.subscribe(function (x) {
        var result;
        try {
          result = onNext.call(thisArg, x, index++);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
      }, function (err) {
        var result;
        try {
          result = onError.call(thisArg, err);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      }, function () {
        var result;
        try {
          result = onCompleted.call(thisArg);
        } catch (e) {
          observer.onError(e);
          return;
        }
        isPromise(result) && (result = observableFromPromise(result));
        observer.onNext(result);
        observer.onCompleted();
      });
    }, source).mergeAll();
  };

  observableProto.flatMapLatest = observableProto.switchMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
  };

  var SkipObservable = function (__super__) {
    inherits(SkipObservable, __super__);
    function SkipObservable(source, count) {
      this.source = source;
      this._count = count;
      __super__.call(this);
    }

    SkipObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipObserver(o, this._count));
    };

    function SkipObserver(o, c) {
      this._o = o;
      this._r = c;
      AbstractObserver.call(this);
    }

    inherits(SkipObserver, AbstractObserver);

    SkipObserver.prototype.next = function (x) {
      if (this._r <= 0) {
        this._o.onNext(x);
      } else {
        this._r--;
      }
    };
    SkipObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipObservable;
  }(ObservableBase);

  /**
   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
   * @param {Number} count The number of elements to skip before returning the remaining elements.
   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.
   */
  observableProto.skip = function (count) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new SkipObservable(this, count);
  };

  var SkipWhileObservable = function (__super__) {
    inherits(SkipWhileObservable, __super__);
    function SkipWhileObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SkipWhileObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipWhileObserver(o, this));
    };

    return SkipWhileObservable;
  }(ObservableBase);

  var SkipWhileObserver = function (__super__) {
    inherits(SkipWhileObserver, __super__);

    function SkipWhileObserver(o, p) {
      this._o = o;
      this._p = p;
      this._i = 0;
      this._r = false;
      __super__.call(this);
    }

    SkipWhileObserver.prototype.next = function (x) {
      if (!this._r) {
        var res = tryCatch(this._p._fn)(x, this._i++, this._p);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        this._r = !res;
      }
      this._r && this._o.onNext(x);
    };
    SkipWhileObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipWhileObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipWhileObserver;
  }(AbstractObserver);

  /**
   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
   *  The element's index is used in the logic of the predicate function.
   *
   *  var res = source.skipWhile(function (value) { return value < 10; });
   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });
   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
   */
  observableProto.skipWhile = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new SkipWhileObservable(this, fn);
  };

  var TakeObservable = function (__super__) {
    inherits(TakeObservable, __super__);
    function TakeObservable(source, count) {
      this.source = source;
      this._count = count;
      __super__.call(this);
    }

    TakeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeObserver(o, this._count));
    };

    function TakeObserver(o, c) {
      this._o = o;
      this._c = c;
      this._r = c;
      AbstractObserver.call(this);
    }

    inherits(TakeObserver, AbstractObserver);

    TakeObserver.prototype.next = function (x) {
      if (this._r-- > 0) {
        this._o.onNext(x);
        this._r <= 0 && this._o.onCompleted();
      }
    };

    TakeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TakeObservable;
  }(ObservableBase);

  /**
   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).
   * @param {Number} count The number of elements to return.
   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name="count count</paramref> is set to 0.
   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.
   */
  observableProto.take = function (count, scheduler) {
    if (count < 0) {
      throw new ArgumentOutOfRangeError();
    }
    if (count === 0) {
      return observableEmpty(scheduler);
    }
    return new TakeObservable(this, count);
  };

  var TakeWhileObservable = function (__super__) {
    inherits(TakeWhileObservable, __super__);
    function TakeWhileObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    TakeWhileObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeWhileObserver(o, this));
    };

    return TakeWhileObservable;
  }(ObservableBase);

  var TakeWhileObserver = function (__super__) {
    inherits(TakeWhileObserver, __super__);

    function TakeWhileObserver(o, p) {
      this._o = o;
      this._p = p;
      this._i = 0;
      this._r = true;
      __super__.call(this);
    }

    TakeWhileObserver.prototype.next = function (x) {
      if (this._r) {
        this._r = tryCatch(this._p._fn)(x, this._i++, this._p);
        if (this._r === errorObj) {
          return this._o.onError(this._r.e);
        }
      }
      if (this._r) {
        this._o.onNext(x);
      } else {
        this._o.onCompleted();
      }
    };
    TakeWhileObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeWhileObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TakeWhileObserver;
  }(AbstractObserver);

  /**
   *  Returns elements from an observable sequence as long as a specified condition is true.
   *  The element's index is used in the logic of the predicate function.
   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   */
  observableProto.takeWhile = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new TakeWhileObservable(this, fn);
  };

  var FilterObservable = function (__super__) {
    inherits(FilterObservable, __super__);

    function FilterObservable(source, predicate, thisArg) {
      this.source = source;
      this.predicate = bindCallback(predicate, thisArg, 3);
      __super__.call(this);
    }

    FilterObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new InnerObserver(o, this.predicate, this));
    };

    function innerPredicate(predicate, self) {
      return function (x, i, o) {
        return self.predicate(x, i, o) && predicate.call(this, x, i, o);
      };
    }

    FilterObservable.prototype.internalFilter = function (predicate, thisArg) {
      return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
    };

    inherits(InnerObserver, AbstractObserver);
    function InnerObserver(o, predicate, source) {
      this.o = o;
      this.predicate = predicate;
      this.source = source;
      this.i = 0;
      AbstractObserver.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
      if (shouldYield === errorObj) {
        return this.o.onError(shouldYield.e);
      }
      shouldYield && this.o.onNext(x);
    };

    InnerObserver.prototype.error = function (e) {
      this.o.onError(e);
    };

    InnerObserver.prototype.completed = function () {
      this.o.onCompleted();
    };

    return FilterObservable;
  }(ObservableBase);

  /**
  *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
  * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
  * @param {Any} [thisArg] Object to use as this when executing callback.
  * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.
  */
  observableProto.filter = observableProto.where = function (predicate, thisArg) {
    return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
  };

  var ExtremaByObservable = function (__super__) {
    inherits(ExtremaByObservable, __super__);
    function ExtremaByObservable(source, k, c) {
      this.source = source;
      this._k = k;
      this._c = c;
      __super__.call(this);
    }

    ExtremaByObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ExtremaByObserver(o, this._k, this._c));
    };

    return ExtremaByObservable;
  }(ObservableBase);

  var ExtremaByObserver = function (__super__) {
    inherits(ExtremaByObserver, __super__);
    function ExtremaByObserver(o, k, c) {
      this._o = o;
      this._k = k;
      this._c = c;
      this._v = null;
      this._hv = false;
      this._l = [];
      __super__.call(this);
    }

    ExtremaByObserver.prototype.next = function (x) {
      var key = tryCatch(this._k)(x);
      if (key === errorObj) {
        return this._o.onError(key.e);
      }
      var comparison = 0;
      if (!this._hv) {
        this._hv = true;
        this._v = key;
      } else {
        comparison = tryCatch(this._c)(key, this._v);
        if (comparison === errorObj) {
          return this._o.onError(comparison.e);
        }
      }
      if (comparison > 0) {
        this._v = key;
        this._l = [];
      }
      if (comparison >= 0) {
        this._l.push(x);
      }
    };

    ExtremaByObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ExtremaByObserver.prototype.completed = function () {
      this._o.onNext(this._l);
      this._o.onCompleted();
    };

    return ExtremaByObserver;
  }(AbstractObserver);

  function firstOnly(x) {
    if (x.length === 0) {
      throw new EmptyError();
    }
    return x[0];
  }

  var ReduceObservable = function (__super__) {
    inherits(ReduceObservable, __super__);
    function ReduceObservable(source, accumulator, hasSeed, seed) {
      this.source = source;
      this.accumulator = accumulator;
      this.hasSeed = hasSeed;
      this.seed = seed;
      __super__.call(this);
    }

    ReduceObservable.prototype.subscribeCore = function (observer) {
      return this.source.subscribe(new ReduceObserver(observer, this));
    };

    return ReduceObservable;
  }(ObservableBase);

  var ReduceObserver = function (__super__) {
    inherits(ReduceObserver, __super__);
    function ReduceObserver(o, parent) {
      this._o = o;
      this._p = parent;
      this._fn = parent.accumulator;
      this._hs = parent.hasSeed;
      this._s = parent.seed;
      this._ha = false;
      this._a = null;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    ReduceObserver.prototype.next = function (x) {
      !this._hv && (this._hv = true);
      if (this._ha) {
        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);
      } else {
        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;
        this._ha = true;
      }
      if (this._a === errorObj) {
        return this._o.onError(this._a.e);
      }
      this._i++;
    };

    ReduceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ReduceObserver.prototype.completed = function () {
      this._hv && this._o.onNext(this._a);
      !this._hv && this._hs && this._o.onNext(this._s);
      !this._hv && !this._hs && this._o.onError(new EmptyError());
      this._o.onCompleted();
    };

    return ReduceObserver;
  }(AbstractObserver);

  /**
  * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
  * For aggregation behavior with incremental intermediate results, see Observable.scan.
  * @param {Function} accumulator An accumulator function to be invoked on each element.
  * @param {Any} [seed] The initial accumulator value.
  * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
  */
  observableProto.reduce = function () {
    var hasSeed = false,
        seed,
        accumulator = arguments[0];
    if (arguments.length === 2) {
      hasSeed = true;
      seed = arguments[1];
    }
    return new ReduceObservable(this, accumulator, hasSeed, seed);
  };

  var SomeObservable = function (__super__) {
    inherits(SomeObservable, __super__);
    function SomeObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SomeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SomeObserver(o, this._fn, this.source));
    };

    return SomeObservable;
  }(ObservableBase);

  var SomeObserver = function (__super__) {
    inherits(SomeObserver, __super__);

    function SomeObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    SomeObserver.prototype.next = function (x) {
      var result = tryCatch(this._fn)(x, this._i++, this._s);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      if (Boolean(result)) {
        this._o.onNext(true);
        this._o.onCompleted();
      }
    };
    SomeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SomeObserver.prototype.completed = function () {
      this._o.onNext(false);
      this._o.onCompleted();
    };

    return SomeObserver;
  }(AbstractObserver);

  /**
   * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.
   * @param {Function} [predicate] A function to test each element for a condition.
   * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.
   */
  observableProto.some = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new SomeObservable(this, fn);
  };

  var IsEmptyObservable = function (__super__) {
    inherits(IsEmptyObservable, __super__);
    function IsEmptyObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    IsEmptyObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new IsEmptyObserver(o));
    };

    return IsEmptyObservable;
  }(ObservableBase);

  var IsEmptyObserver = function (__super__) {
    inherits(IsEmptyObserver, __super__);
    function IsEmptyObserver(o) {
      this._o = o;
      __super__.call(this);
    }

    IsEmptyObserver.prototype.next = function () {
      this._o.onNext(false);
      this._o.onCompleted();
    };
    IsEmptyObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IsEmptyObserver.prototype.completed = function () {
      this._o.onNext(true);
      this._o.onCompleted();
    };

    return IsEmptyObserver;
  }(AbstractObserver);

  /**
   * Determines whether an observable sequence is empty.
   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.
   */
  observableProto.isEmpty = function () {
    return new IsEmptyObservable(this);
  };

  var EveryObservable = function (__super__) {
    inherits(EveryObservable, __super__);
    function EveryObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    EveryObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new EveryObserver(o, this._fn, this.source));
    };

    return EveryObservable;
  }(ObservableBase);

  var EveryObserver = function (__super__) {
    inherits(EveryObserver, __super__);

    function EveryObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    EveryObserver.prototype.next = function (x) {
      var result = tryCatch(this._fn)(x, this._i++, this._s);
      if (result === errorObj) {
        return this._o.onError(result.e);
      }
      if (!Boolean(result)) {
        this._o.onNext(false);
        this._o.onCompleted();
      }
    };
    EveryObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    EveryObserver.prototype.completed = function () {
      this._o.onNext(true);
      this._o.onCompleted();
    };

    return EveryObserver;
  }(AbstractObserver);

  /**
   * Determines whether all elements of an observable sequence satisfy a condition.
   * @param {Function} [predicate] A function to test each element for a condition.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.
   */
  observableProto.every = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new EveryObservable(this, fn);
  };

  var IncludesObservable = function (__super__) {
    inherits(IncludesObservable, __super__);
    function IncludesObservable(source, elem, idx) {
      var n = +idx || 0;
      Math.abs(n) === Infinity && (n = 0);

      this.source = source;
      this._elem = elem;
      this._n = n;
      __super__.call(this);
    }

    IncludesObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(false);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new IncludesObserver(o, this._elem, this._n));
    };

    return IncludesObservable;
  }(ObservableBase);

  var IncludesObserver = function (__super__) {
    inherits(IncludesObserver, __super__);
    function IncludesObserver(o, elem, n) {
      this._o = o;
      this._elem = elem;
      this._n = n;
      this._i = 0;
      __super__.call(this);
    }

    function comparer(a, b) {
      return a === 0 && b === 0 || a === b || isNaN(a) && isNaN(b);
    }

    IncludesObserver.prototype.next = function (x) {
      if (this._i++ >= this._n && comparer(x, this._elem)) {
        this._o.onNext(true);
        this._o.onCompleted();
      }
    };
    IncludesObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IncludesObserver.prototype.completed = function () {
      this._o.onNext(false);this._o.onCompleted();
    };

    return IncludesObserver;
  }(AbstractObserver);

  /**
   * Determines whether an observable sequence includes a specified element with an optional equality comparer.
   * @param searchElement The value to locate in the source sequence.
   * @param {Number} [fromIndex] An equality comparer to compare elements.
   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence includes an element that has the specified value from the given index.
   */
  observableProto.includes = function (searchElement, fromIndex) {
    return new IncludesObservable(this, searchElement, fromIndex);
  };

  var CountObservable = function (__super__) {
    inherits(CountObservable, __super__);
    function CountObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    CountObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new CountObserver(o, this._fn, this.source));
    };

    return CountObservable;
  }(ObservableBase);

  var CountObserver = function (__super__) {
    inherits(CountObserver, __super__);

    function CountObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      this._c = 0;
      __super__.call(this);
    }

    CountObserver.prototype.next = function (x) {
      if (this._fn) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        Boolean(result) && this._c++;
      } else {
        this._c++;
      }
    };
    CountObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    CountObserver.prototype.completed = function () {
      this._o.onNext(this._c);
      this._o.onCompleted();
    };

    return CountObserver;
  }(AbstractObserver);

  /**
   * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.
   * @example
   * res = source.count();
   * res = source.count(function (x) { return x > 3; });
   * @param {Function} [predicate]A function to test each element for a condition.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.
   */
  observableProto.count = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return new CountObservable(this, fn);
  };

  var IndexOfObservable = function (__super__) {
    inherits(IndexOfObservable, __super__);
    function IndexOfObservable(source, e, n) {
      this.source = source;
      this._e = e;
      this._n = n;
      __super__.call(this);
    }

    IndexOfObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(-1);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new IndexOfObserver(o, this._e, this._n));
    };

    return IndexOfObservable;
  }(ObservableBase);

  var IndexOfObserver = function (__super__) {
    inherits(IndexOfObserver, __super__);
    function IndexOfObserver(o, e, n) {
      this._o = o;
      this._e = e;
      this._n = n;
      this._i = 0;
      __super__.call(this);
    }

    IndexOfObserver.prototype.next = function (x) {
      if (this._i >= this._n && x === this._e) {
        this._o.onNext(this._i);
        this._o.onCompleted();
      }
      this._i++;
    };
    IndexOfObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    IndexOfObserver.prototype.completed = function () {
      this._o.onNext(-1);this._o.onCompleted();
    };

    return IndexOfObserver;
  }(AbstractObserver);

  /**
   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
   * @param {Any} searchElement Element to locate in the array.
   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
   */
  observableProto.indexOf = function (searchElement, fromIndex) {
    var n = +fromIndex || 0;
    Math.abs(n) === Infinity && (n = 0);
    return new IndexOfObservable(this, searchElement, n);
  };

  var SumObservable = function (__super__) {
    inherits(SumObservable, __super__);
    function SumObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    SumObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SumObserver(o, this._fn, this.source));
    };

    return SumObservable;
  }(ObservableBase);

  var SumObserver = function (__super__) {
    inherits(SumObserver, __super__);

    function SumObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._i = 0;
      this._c = 0;
      __super__.call(this);
    }

    SumObserver.prototype.next = function (x) {
      if (this._fn) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        this._c += result;
      } else {
        this._c += x;
      }
    };
    SumObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SumObserver.prototype.completed = function () {
      this._o.onNext(this._c);
      this._o.onCompleted();
    };

    return SumObserver;
  }(AbstractObserver);

  /**
   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.
   * @param {Function} [selector] A transform function to apply to each element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.
   */
  observableProto.sum = function (keySelector, thisArg) {
    var fn = bindCallback(keySelector, thisArg, 3);
    return new SumObservable(this, fn);
  };

  /**
   * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
   * @example
   * var res = source.minBy(function (x) { return x.value; });
   * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });
   * @param {Function} keySelector Key selector function.
   * @param {Function} [comparer] Comparer used to compare key values.
   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.
   */
  observableProto.minBy = function (keySelector, comparer) {
    comparer || (comparer = defaultSubComparer);
    return new ExtremaByObservable(this, keySelector, function (x, y) {
      return comparer(x, y) * -1;
    });
  };

  /**
   * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.
   * @example
   * var res = source.min();
   * var res = source.min(function (x, y) { return x.value - y.value; });
   * @param {Function} [comparer] Comparer used to compare elements.
   * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.
   */
  observableProto.min = function (comparer) {
    return this.minBy(identity, comparer).map(firstOnly);
  };

  /**
   * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.
   * @example
   * var res = source.maxBy(function (x) { return x.value; });
   * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });
   * @param {Function} keySelector Key selector function.
   * @param {Function} [comparer]  Comparer used to compare key values.
   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.
   */
  observableProto.maxBy = function (keySelector, comparer) {
    comparer || (comparer = defaultSubComparer);
    return new ExtremaByObservable(this, keySelector, comparer);
  };

  /**
   * Returns the maximum value in an observable sequence according to the specified comparer.
   * @example
   * var res = source.max();
   * var res = source.max(function (x, y) { return x.value - y.value; });
   * @param {Function} [comparer] Comparer used to compare elements.
   * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.
   */
  observableProto.max = function (comparer) {
    return this.maxBy(identity, comparer).map(firstOnly);
  };

  var AverageObservable = function (__super__) {
    inherits(AverageObservable, __super__);
    function AverageObservable(source, fn) {
      this.source = source;
      this._fn = fn;
      __super__.call(this);
    }

    AverageObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new AverageObserver(o, this._fn, this.source));
    };

    return AverageObservable;
  }(ObservableBase);

  var AverageObserver = function (__super__) {
    inherits(AverageObserver, __super__);
    function AverageObserver(o, fn, s) {
      this._o = o;
      this._fn = fn;
      this._s = s;
      this._c = 0;
      this._t = 0;
      __super__.call(this);
    }

    AverageObserver.prototype.next = function (x) {
      if (this._fn) {
        var r = tryCatch(this._fn)(x, this._c++, this._s);
        if (r === errorObj) {
          return this._o.onError(r.e);
        }
        this._t += r;
      } else {
        this._c++;
        this._t += x;
      }
    };
    AverageObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    AverageObserver.prototype.completed = function () {
      if (this._c === 0) {
        return this._o.onError(new EmptyError());
      }
      this._o.onNext(this._t / this._c);
      this._o.onCompleted();
    };

    return AverageObserver;
  }(AbstractObserver);

  /**
   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.
   * @param {Function} [selector] A transform function to apply to each element.
   * @param {Any} [thisArg] Object to use as this when executing callback.
   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.
   */
  observableProto.average = function (keySelector, thisArg) {
    var source = this,
        fn;
    if (isFunction(keySelector)) {
      fn = bindCallback(keySelector, thisArg, 3);
    }
    return new AverageObservable(source, fn);
  };

  /**
   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
   *
   * @example
   * var res = res = source.sequenceEqual([1,2,3]);
   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });
   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));
   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });
   * @param {Observable} second Second observable sequence or array to compare.
   * @param {Function} [comparer] Comparer used to compare elements of both sequences.
   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
   */
  observableProto.sequenceEqual = function (second, comparer) {
    var first = this;
    comparer || (comparer = defaultComparer);
    return new AnonymousObservable(function (o) {
      var donel = false,
          doner = false,
          ql = [],
          qr = [];
      var subscription1 = first.subscribe(function (x) {
        if (qr.length > 0) {
          var v = qr.shift();
          var equal = tryCatch(comparer)(v, x);
          if (equal === errorObj) {
            return o.onError(equal.e);
          }
          if (!equal) {
            o.onNext(false);
            o.onCompleted();
          }
        } else if (doner) {
          o.onNext(false);
          o.onCompleted();
        } else {
          ql.push(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        donel = true;
        if (ql.length === 0) {
          if (qr.length > 0) {
            o.onNext(false);
            o.onCompleted();
          } else if (doner) {
            o.onNext(true);
            o.onCompleted();
          }
        }
      });

      (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
      isPromise(second) && (second = observableFromPromise(second));
      var subscription2 = second.subscribe(function (x) {
        if (ql.length > 0) {
          var v = ql.shift();
          var equal = tryCatch(comparer)(v, x);
          if (equal === errorObj) {
            return o.onError(equal.e);
          }
          if (!equal) {
            o.onNext(false);
            o.onCompleted();
          }
        } else if (donel) {
          o.onNext(false);
          o.onCompleted();
        } else {
          qr.push(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        doner = true;
        if (qr.length === 0) {
          if (ql.length > 0) {
            o.onNext(false);
            o.onCompleted();
          } else if (donel) {
            o.onNext(true);
            o.onCompleted();
          }
        }
      });
      return new BinaryDisposable(subscription1, subscription2);
    }, first);
  };

  var ElementAtObservable = function (__super__) {
    inherits(ElementAtObservable, __super__);
    function ElementAtObservable(source, i, d) {
      this.source = source;
      this._i = i;
      this._d = d;
      __super__.call(this);
    }

    ElementAtObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ElementAtObserver(o, this._i, this._d));
    };

    return ElementAtObservable;
  }(ObservableBase);

  var ElementAtObserver = function (__super__) {
    inherits(ElementAtObserver, __super__);

    function ElementAtObserver(o, i, d) {
      this._o = o;
      this._i = i;
      this._d = d;
      __super__.call(this);
    }

    ElementAtObserver.prototype.next = function (x) {
      if (this._i-- === 0) {
        this._o.onNext(x);
        this._o.onCompleted();
      }
    };
    ElementAtObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    ElementAtObserver.prototype.completed = function () {
      if (this._d === undefined) {
        this._o.onError(new ArgumentOutOfRangeError());
      } else {
        this._o.onNext(this._d);
        this._o.onCompleted();
      }
    };

    return ElementAtObserver;
  }(AbstractObserver);

  /**
   * Returns the element at a specified index in a sequence or default value if not found.
   * @param {Number} index The zero-based index of the element to retrieve.
   * @param {Any} [defaultValue] The default value to use if elementAt does not find a value.
   * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.
   */
  observableProto.elementAt = function (index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError();
    }
    return new ElementAtObservable(this, index, defaultValue);
  };

  var SingleObserver = function (__super__) {
    inherits(SingleObserver, __super__);
    function SingleObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      this._hv = false;
      this._v = null;
      __super__.call(this);
    }

    SingleObserver.prototype.next = function (x) {
      var shouldYield = false;
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        Boolean(res) && (shouldYield = true);
      } else if (!this._obj.predicate) {
        shouldYield = true;
      }
      if (shouldYield) {
        if (this._hv) {
          return this._o.onError(new Error('Sequence contains more than one matching element'));
        }
        this._hv = true;
        this._v = x;
      }
    };
    SingleObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SingleObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
        this._o.onCompleted();
      } else if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return SingleObserver;
  }(AbstractObserver);

  /**
   * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.
   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.
   */
  observableProto.single = function (predicate, thisArg) {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new AnonymousObservable(function (o) {
      return source.subscribe(new SingleObserver(o, obj, source));
    }, source);
  };

  var FirstObservable = function (__super__) {
    inherits(FirstObservable, __super__);
    function FirstObservable(source, obj) {
      this.source = source;
      this._obj = obj;
      __super__.call(this);
    }

    FirstObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new FirstObserver(o, this._obj, this.source));
    };

    return FirstObservable;
  }(ObservableBase);

  var FirstObserver = function (__super__) {
    inherits(FirstObserver, __super__);
    function FirstObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      __super__.call(this);
    }

    FirstObserver.prototype.next = function (x) {
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        if (Boolean(res)) {
          this._o.onNext(x);
          this._o.onCompleted();
        }
      } else if (!this._obj.predicate) {
        this._o.onNext(x);
        this._o.onCompleted();
      }
    };
    FirstObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    FirstObserver.prototype.completed = function () {
      if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return FirstObserver;
  }(AbstractObserver);

  /**
   * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.
   * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.
   */
  observableProto.first = function () {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new FirstObservable(this, obj);
  };

  var LastObservable = function (__super__) {
    inherits(LastObservable, __super__);
    function LastObservable(source, obj) {
      this.source = source;
      this._obj = obj;
      __super__.call(this);
    }

    LastObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new LastObserver(o, this._obj, this.source));
    };

    return LastObservable;
  }(ObservableBase);

  var LastObserver = function (__super__) {
    inherits(LastObserver, __super__);
    function LastObserver(o, obj, s) {
      this._o = o;
      this._obj = obj;
      this._s = s;
      this._i = 0;
      this._hv = false;
      this._v = null;
      __super__.call(this);
    }

    LastObserver.prototype.next = function (x) {
      var shouldYield = false;
      if (this._obj.predicate) {
        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }
        Boolean(res) && (shouldYield = true);
      } else if (!this._obj.predicate) {
        shouldYield = true;
      }
      if (shouldYield) {
        this._hv = true;
        this._v = x;
      }
    };
    LastObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    LastObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
        this._o.onCompleted();
      } else if (this._obj.defaultValue === undefined) {
        this._o.onError(new EmptyError());
      } else {
        this._o.onNext(this._obj.defaultValue);
        this._o.onCompleted();
      }
    };

    return LastObserver;
  }(AbstractObserver);

  /**
   * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.
   * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.
   */
  observableProto.last = function () {
    var obj = {},
        source = this;
    if (_typeof(arguments[0]) === 'object') {
      obj = arguments[0];
    } else {
      obj = {
        predicate: arguments[0],
        thisArg: arguments[1],
        defaultValue: arguments[2]
      };
    }
    if (isFunction(obj.predicate)) {
      var fn = obj.predicate;
      obj.predicate = bindCallback(fn, obj.thisArg, 3);
    }
    return new LastObservable(this, obj);
  };

  var FindValueObserver = function (__super__) {
    inherits(FindValueObserver, __super__);
    function FindValueObserver(observer, source, callback, yieldIndex) {
      this._o = observer;
      this._s = source;
      this._cb = callback;
      this._y = yieldIndex;
      this._i = 0;
      __super__.call(this);
    }

    FindValueObserver.prototype.next = function (x) {
      var shouldRun = tryCatch(this._cb)(x, this._i, this._s);
      if (shouldRun === errorObj) {
        return this._o.onError(shouldRun.e);
      }
      if (shouldRun) {
        this._o.onNext(this._y ? this._i : x);
        this._o.onCompleted();
      } else {
        this._i++;
      }
    };

    FindValueObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    FindValueObserver.prototype.completed = function () {
      this._y && this._o.onNext(-1);
      this._o.onCompleted();
    };

    return FindValueObserver;
  }(AbstractObserver);

  function findValue(source, predicate, thisArg, yieldIndex) {
    var callback = bindCallback(predicate, thisArg, 3);
    return new AnonymousObservable(function (o) {
      return source.subscribe(new FindValueObserver(o, source, callback, yieldIndex));
    }, source);
  }

  /**
   * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.
   * @param {Function} predicate The predicate that defines the conditions of the element to search for.
   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
   * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.
   */
  observableProto.find = function (predicate, thisArg) {
    return findValue(this, predicate, thisArg, false);
  };

  /**
   * Searches for an element that matches the conditions defined by the specified predicate, and returns
   * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.
   * @param {Function} predicate The predicate that defines the conditions of the element to search for.
   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
   * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.
  */
  observableProto.findIndex = function (predicate, thisArg) {
    return findValue(this, predicate, thisArg, true);
  };

  var ToSetObservable = function (__super__) {
    inherits(ToSetObservable, __super__);
    function ToSetObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    ToSetObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ToSetObserver(o));
    };

    return ToSetObservable;
  }(ObservableBase);

  var ToSetObserver = function (__super__) {
    inherits(ToSetObserver, __super__);
    function ToSetObserver(o) {
      this._o = o;
      this._s = new root.Set();
      __super__.call(this);
    }

    ToSetObserver.prototype.next = function (x) {
      this._s.add(x);
    };

    ToSetObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ToSetObserver.prototype.completed = function () {
      this._o.onNext(this._s);
      this._o.onCompleted();
    };

    return ToSetObserver;
  }(AbstractObserver);

  /**
   * Converts the observable sequence to a Set if it exists.
   * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.
   */
  observableProto.toSet = function () {
    if (typeof root.Set === 'undefined') {
      throw new TypeError();
    }
    return new ToSetObservable(this);
  };

  var ToMapObservable = function (__super__) {
    inherits(ToMapObservable, __super__);
    function ToMapObservable(source, k, e) {
      this.source = source;
      this._k = k;
      this._e = e;
      __super__.call(this);
    }

    ToMapObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new ToMapObserver(o, this._k, this._e));
    };

    return ToMapObservable;
  }(ObservableBase);

  var ToMapObserver = function (__super__) {
    inherits(ToMapObserver, __super__);
    function ToMapObserver(o, k, e) {
      this._o = o;
      this._k = k;
      this._e = e;
      this._m = new root.Map();
      __super__.call(this);
    }

    ToMapObserver.prototype.next = function (x) {
      var key = tryCatch(this._k)(x);
      if (key === errorObj) {
        return this._o.onError(key.e);
      }
      var elem = x;
      if (this._e) {
        elem = tryCatch(this._e)(x);
        if (elem === errorObj) {
          return this._o.onError(elem.e);
        }
      }

      this._m.set(key, elem);
    };

    ToMapObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    ToMapObserver.prototype.completed = function () {
      this._o.onNext(this._m);
      this._o.onCompleted();
    };

    return ToMapObserver;
  }(AbstractObserver);

  /**
  * Converts the observable sequence to a Map if it exists.
  * @param {Function} keySelector A function which produces the key for the Map.
  * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.
  * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.
  */
  observableProto.toMap = function (keySelector, elementSelector) {
    if (typeof root.Map === 'undefined') {
      throw new TypeError();
    }
    return new ToMapObservable(this, keySelector, elementSelector);
  };

  var SliceObservable = function (__super__) {
    inherits(SliceObservable, __super__);
    function SliceObservable(source, b, e) {
      this.source = source;
      this._b = b;
      this._e = e;
      __super__.call(this);
    }

    SliceObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SliceObserver(o, this._b, this._e));
    };

    return SliceObservable;
  }(ObservableBase);

  var SliceObserver = function (__super__) {
    inherits(SliceObserver, __super__);

    function SliceObserver(o, b, e) {
      this._o = o;
      this._b = b;
      this._e = e;
      this._i = 0;
      __super__.call(this);
    }

    SliceObserver.prototype.next = function (x) {
      if (this._i >= this._b) {
        if (this._e === this._i) {
          this._o.onCompleted();
        } else {
          this._o.onNext(x);
        }
      }
      this._i++;
    };
    SliceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SliceObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SliceObserver;
  }(AbstractObserver);

  /*
  * The slice() method returns a shallow copy of a portion of an Observable into a new Observable object.
  * Unlike the array version, this does not support negative numbers for being or end.
  * @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.
  * @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.
  * If omitted, this will emit the rest of the Observable object.
  * @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.
  */
  observableProto.slice = function (begin, end) {
    var start = begin || 0;
    if (start < 0) {
      throw new Rx.ArgumentOutOfRangeError();
    }
    if (typeof end === 'number' && end < start) {
      throw new Rx.ArgumentOutOfRangeError();
    }
    return new SliceObservable(this, start, end);
  };

  var LastIndexOfObservable = function (__super__) {
    inherits(LastIndexOfObservable, __super__);
    function LastIndexOfObservable(source, e, n) {
      this.source = source;
      this._e = e;
      this._n = n;
      __super__.call(this);
    }

    LastIndexOfObservable.prototype.subscribeCore = function (o) {
      if (this._n < 0) {
        o.onNext(-1);
        o.onCompleted();
        return disposableEmpty;
      }

      return this.source.subscribe(new LastIndexOfObserver(o, this._e, this._n));
    };

    return LastIndexOfObservable;
  }(ObservableBase);

  var LastIndexOfObserver = function (__super__) {
    inherits(LastIndexOfObserver, __super__);
    function LastIndexOfObserver(o, e, n) {
      this._o = o;
      this._e = e;
      this._n = n;
      this._v = 0;
      this._hv = false;
      this._i = 0;
      __super__.call(this);
    }

    LastIndexOfObserver.prototype.next = function (x) {
      if (this._i >= this._n && x === this._e) {
        this._hv = true;
        this._v = this._i;
      }
      this._i++;
    };
    LastIndexOfObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    LastIndexOfObserver.prototype.completed = function () {
      if (this._hv) {
        this._o.onNext(this._v);
      } else {
        this._o.onNext(-1);
      }
      this._o.onCompleted();
    };

    return LastIndexOfObserver;
  }(AbstractObserver);

  /**
   * Returns the last index at which a given element can be found in the observable sequence, or -1 if it is not present.
   * @param {Any} searchElement Element to locate in the array.
   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
   * @returns {Observable} And observable sequence containing the last index at which a given element can be found in the observable sequence, or -1 if it is not present.
   */
  observableProto.lastIndexOf = function (searchElement, fromIndex) {
    var n = +fromIndex || 0;
    Math.abs(n) === Infinity && (n = 0);
    return new LastIndexOfObservable(this, searchElement, n);
  };

  Observable.wrap = function (fn) {
    function createObservable() {
      return Observable.spawn.call(this, fn.apply(this, arguments));
    }

    createObservable.__generatorFunction__ = fn;
    return createObservable;
  };

  var spawn = Observable.spawn = function () {
    var gen = arguments[0],
        self = this,
        args = [];
    for (var i = 1, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }

    return new AnonymousObservable(function (o) {
      var g = new CompositeDisposable();

      if (isFunction(gen)) {
        gen = gen.apply(self, args);
      }
      if (!gen || !isFunction(gen.next)) {
        o.onNext(gen);
        return o.onCompleted();
      }

      function processGenerator(res) {
        var ret = tryCatch(gen.next).call(gen, res);
        if (ret === errorObj) {
          return o.onError(ret.e);
        }
        next(ret);
      }

      processGenerator();

      function onError(err) {
        var ret = tryCatch(gen.next).call(gen, err);
        if (ret === errorObj) {
          return o.onError(ret.e);
        }
        next(ret);
      }

      function next(ret) {
        if (ret.done) {
          o.onNext(ret.value);
          o.onCompleted();
          return;
        }
        var obs = toObservable.call(self, ret.value);
        var value = null;
        var hasValue = false;
        if (Observable.isObservable(obs)) {
          g.add(obs.subscribe(function (val) {
            hasValue = true;
            value = val;
          }, onError, function () {
            hasValue && processGenerator(value);
          }));
        } else {
          onError(new TypeError('type not supported'));
        }
      }

      return g;
    });
  };

  function toObservable(obj) {
    if (!obj) {
      return obj;
    }
    if (Observable.isObservable(obj)) {
      return obj;
    }
    if (isPromise(obj)) {
      return Observable.fromPromise(obj);
    }
    if (isGeneratorFunction(obj) || isGenerator(obj)) {
      return spawn.call(this, obj);
    }
    if (isFunction(obj)) {
      return thunkToObservable.call(this, obj);
    }
    if (isArrayLike(obj) || isIterable(obj)) {
      return arrayToObservable.call(this, obj);
    }
    if (isObject(obj)) {
      return objectToObservable.call(this, obj);
    }
    return obj;
  }

  function arrayToObservable(obj) {
    return Observable.from(obj).concatMap(function (o) {
      if (Observable.isObservable(o) || isObject(o)) {
        return toObservable.call(null, o);
      } else {
        return Rx.Observable.just(o);
      }
    }).toArray();
  }

  function objectToObservable(obj) {
    var results = new obj.constructor(),
        keys = Object.keys(obj),
        observables = [];
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      var observable = toObservable.call(this, obj[key]);

      if (observable && Observable.isObservable(observable)) {
        defer(observable, key);
      } else {
        results[key] = obj[key];
      }
    }

    return Observable.forkJoin.apply(Observable, observables).map(function () {
      return results;
    });

    function defer(observable, key) {
      results[key] = undefined;
      observables.push(observable.map(function (next) {
        results[key] = next;
      }));
    }
  }

  function thunkToObservable(fn) {
    var self = this;
    return new AnonymousObservable(function (o) {
      fn.call(self, function () {
        var err = arguments[0],
            res = arguments[1];
        if (err) {
          return o.onError(err);
        }
        if (arguments.length > 2) {
          var args = [];
          for (var i = 1, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
          }
          res = args;
        }
        o.onNext(res);
        o.onCompleted();
      });
    });
  }

  function isGenerator(obj) {
    return isFunction(obj.next) && isFunction(obj['throw']);
  }

  function isGeneratorFunction(obj) {
    var ctor = obj.constructor;
    if (!ctor) {
      return false;
    }
    if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') {
      return true;
    }
    return isGenerator(ctor.prototype);
  }

  function isObject(val) {
    return Object == val.constructor;
  }

  /**
   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.
   *
   * @example
   * var res = Rx.Observable.start(function () { console.log('hello'); });
   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
   *
   * @param {Function} func Function to run asynchronously.
   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
   *
   * Remarks
   * * The function is called immediately, not during the subscription of the resulting sequence.
   * * Multiple subscriptions to the resulting sequence can observe the function's result.
   */
  Observable.start = function (func, context, scheduler) {
    return observableToAsync(func, context, scheduler)();
  };

  /**
   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.
   * @param {Function} function Function to convert to an asynchronous function.
   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns {Function} Asynchronous function.
   */
  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return function () {
      var args = arguments,
          subject = new AsyncSubject();

      scheduler.schedule(null, function () {
        var result;
        try {
          result = func.apply(context, args);
        } catch (e) {
          subject.onError(e);
          return;
        }
        subject.onNext(result);
        subject.onCompleted();
      });
      return subject.asObservable();
    };
  };

  function createCbObservable(fn, ctx, selector, args) {
    var o = new AsyncSubject();

    args.push(createCbHandler(o, ctx, selector));
    fn.apply(ctx, args);

    return o.asObservable();
  }

  function createCbHandler(o, ctx, selector) {
    return function handler() {
      var len = arguments.length,
          results = new Array(len);
      for (var i = 0; i < len; i++) {
        results[i] = arguments[i];
      }

      if (isFunction(selector)) {
        results = tryCatch(selector).apply(ctx, results);
        if (results === errorObj) {
          return o.onError(results.e);
        }
        o.onNext(results);
      } else {
        if (results.length <= 1) {
          o.onNext(results[0]);
        } else {
          o.onNext(results);
        }
      }

      o.onCompleted();
    };
  }

  /**
   * Converts a callback function to an observable sequence.
   *
   * @param {Function} fn Function with a callback as the last parameter to convert to an Observable sequence.
   * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.
   * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.
   */
  Observable.fromCallback = function (fn, ctx, selector) {
    return function () {
      typeof ctx === 'undefined' && (ctx = this);

      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return createCbObservable(fn, ctx, selector, args);
    };
  };

  function createNodeObservable(fn, ctx, selector, args) {
    var o = new AsyncSubject();

    args.push(createNodeHandler(o, ctx, selector));
    fn.apply(ctx, args);

    return o.asObservable();
  }

  function createNodeHandler(o, ctx, selector) {
    return function handler() {
      var err = arguments[0];
      if (err) {
        return o.onError(err);
      }

      var len = arguments.length,
          results = [];
      for (var i = 1; i < len; i++) {
        results[i - 1] = arguments[i];
      }

      if (isFunction(selector)) {
        var results = tryCatch(selector).apply(ctx, results);
        if (results === errorObj) {
          return o.onError(results.e);
        }
        o.onNext(results);
      } else {
        if (results.length <= 1) {
          o.onNext(results[0]);
        } else {
          o.onNext(results);
        }
      }

      o.onCompleted();
    };
  }

  /**
   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
   * @param {Function} fn The function to call
   * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.
   * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.
   */
  Observable.fromNodeCallback = function (fn, ctx, selector) {
    return function () {
      typeof ctx === 'undefined' && (ctx = this);
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return createNodeObservable(fn, ctx, selector, args);
    };
  };

  function isNodeList(el) {
    if (root.StaticNodeList) {
      // IE8 Specific
      // instanceof is slower than Object#toString, but Object#toString will not work as intended in IE8
      return el instanceof root.StaticNodeList || el instanceof root.NodeList;
    } else {
      return Object.prototype.toString.call(el) === '[object NodeList]';
    }
  }

  function ListenDisposable(e, n, fn) {
    this._e = e;
    this._n = n;
    this._fn = fn;
    this._e.addEventListener(this._n, this._fn, false);
    this.isDisposed = false;
  }
  ListenDisposable.prototype.dispose = function () {
    if (!this.isDisposed) {
      this._e.removeEventListener(this._n, this._fn, false);
      this.isDisposed = true;
    }
  };

  function createEventListener(el, eventName, handler) {
    var disposables = new CompositeDisposable();

    // Asume NodeList or HTMLCollection
    var elemToString = Object.prototype.toString.call(el);
    if (isNodeList(el) || elemToString === '[object HTMLCollection]') {
      for (var i = 0, len = el.length; i < len; i++) {
        disposables.add(createEventListener(el.item(i), eventName, handler));
      }
    } else if (el) {
      disposables.add(new ListenDisposable(el, eventName, handler));
    }

    return disposables;
  }

  /**
   * Configuration option to determine whether to use native events only
   */
  Rx.config.useNativeEvents = false;

  var EventObservable = function (__super__) {
    inherits(EventObservable, __super__);
    function EventObservable(el, name, fn) {
      this._el = el;
      this._n = name;
      this._fn = fn;
      __super__.call(this);
    }

    function createHandler(o, fn) {
      return function handler() {
        var results = arguments[0];
        if (isFunction(fn)) {
          results = tryCatch(fn).apply(null, arguments);
          if (results === errorObj) {
            return o.onError(results.e);
          }
        }
        o.onNext(results);
      };
    }

    EventObservable.prototype.subscribeCore = function (o) {
      return createEventListener(this._el, this._n, createHandler(o, this._fn));
    };

    return EventObservable;
  }(ObservableBase);

  /**
   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
   * @param {Object} element The DOMElement or NodeList to attach a listener.
   * @param {String} eventName The event name to attach the observable sequence.
   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns {Observable} An observable sequence of events from the specified element and the specified event.
   */
  Observable.fromEvent = function (element, eventName, selector) {
    // Node.js specific
    if (element.addListener) {
      return fromEventPattern(function (h) {
        element.addListener(eventName, h);
      }, function (h) {
        element.removeListener(eventName, h);
      }, selector);
    }

    // Use only if non-native events are allowed
    if (!Rx.config.useNativeEvents) {
      // Handles jq, Angular.js, Zepto, Marionette, Ember.js
      if (typeof element.on === 'function' && typeof element.off === 'function') {
        return fromEventPattern(function (h) {
          element.on(eventName, h);
        }, function (h) {
          element.off(eventName, h);
        }, selector);
      }
    }

    return new EventObservable(element, eventName, selector).publish().refCount();
  };

  var EventPatternObservable = function (__super__) {
    inherits(EventPatternObservable, __super__);
    function EventPatternObservable(add, del, fn) {
      this._add = add;
      this._del = del;
      this._fn = fn;
      __super__.call(this);
    }

    function createHandler(o, fn) {
      return function handler() {
        var results = arguments[0];
        if (isFunction(fn)) {
          results = tryCatch(fn).apply(null, arguments);
          if (results === errorObj) {
            return o.onError(results.e);
          }
        }
        o.onNext(results);
      };
    }

    EventPatternObservable.prototype.subscribeCore = function (o) {
      var fn = createHandler(o, this._fn);
      var returnValue = this._add(fn);
      return new EventPatternDisposable(this._del, fn, returnValue);
    };

    function EventPatternDisposable(del, fn, ret) {
      this._del = del;
      this._fn = fn;
      this._ret = ret;
      this.isDisposed = false;
    }

    EventPatternDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        isFunction(this._del) && this._del(this._fn, this._ret);
        this.isDisposed = true;
      }
    };

    return EventPatternObservable;
  }(ObservableBase);

  /**
   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.
   * @param {Function} addHandler The function to add a handler to the emitter.
   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.
   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns {Observable} An observable sequence which wraps an event from an event emitter
   */
  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {
    return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();
  };

  /**
   * Invokes the asynchronous function, surfacing the result through an observable sequence.
   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.
   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
   */
  Observable.startAsync = function (functionAsync) {
    var promise = tryCatch(functionAsync)();
    if (promise === errorObj) {
      return observableThrow(promise.e);
    }
    return observableFromPromise(promise);
  };

  var PausableObservable = function (__super__) {
    inherits(PausableObservable, __super__);
    function PausableObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      this.paused = true;

      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }

      __super__.call(this);
    }

    PausableObservable.prototype._subscribe = function (o) {
      var conn = this.source.publish(),
          subscription = conn.subscribe(o),
          connection = disposableEmpty;

      var pausable = this.pauser.startWith(!this.paused).distinctUntilChanged().subscribe(function (b) {
        if (b) {
          connection = conn.connect();
        } else {
          connection.dispose();
          connection = disposableEmpty;
        }
      });

      return new NAryDisposable([subscription, connection, pausable]);
    };

    PausableObservable.prototype.pause = function () {
      this.paused = true;
      this.controller.onNext(false);
    };

    PausableObservable.prototype.resume = function () {
      this.paused = false;
      this.controller.onNext(true);
    };

    return PausableObservable;
  }(Observable);

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausable(pauser);
   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
   * @returns {Observable} The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausable = function (pauser) {
    return new PausableObservable(this, pauser);
  };

  function combineLatestSource(source, subject, resultSelector) {
    return new AnonymousObservable(function (o) {
      var hasValue = [false, false],
          hasValueAll = false,
          isDone = false,
          values = new Array(2),
          err;

      function next(x, i) {
        values[i] = x;
        hasValue[i] = true;
        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
          if (err) {
            return o.onError(err);
          }
          var res = tryCatch(resultSelector).apply(null, values);
          if (res === errorObj) {
            return o.onError(res.e);
          }
          o.onNext(res);
        }
        isDone && values[1] && o.onCompleted();
      }

      return new BinaryDisposable(source.subscribe(function (x) {
        next(x, 0);
      }, function (e) {
        if (values[1]) {
          o.onError(e);
        } else {
          err = e;
        }
      }, function () {
        isDone = true;
        values[1] && o.onCompleted();
      }), subject.subscribe(function (x) {
        next(x, 1);
      }, function (e) {
        o.onError(e);
      }, function () {
        isDone = true;
        next(true, 1);
      }));
    }, source);
  }

  var PausableBufferedObservable = function (__super__) {
    inherits(PausableBufferedObservable, __super__);
    function PausableBufferedObservable(source, pauser) {
      this.source = source;
      this.controller = new Subject();
      this.paused = true;

      if (pauser && pauser.subscribe) {
        this.pauser = this.controller.merge(pauser);
      } else {
        this.pauser = this.controller;
      }

      __super__.call(this);
    }

    PausableBufferedObservable.prototype._subscribe = function (o) {
      var q = [],
          previousShouldFire;

      function drainQueue() {
        while (q.length > 0) {
          o.onNext(q.shift());
        }
      }

      var subscription = combineLatestSource(this.source, this.pauser.startWith(!this.paused).distinctUntilChanged(), function (data, shouldFire) {
        return { data: data, shouldFire: shouldFire };
      }).subscribe(function (results) {
        if (previousShouldFire !== undefined && results.shouldFire !== previousShouldFire) {
          previousShouldFire = results.shouldFire;
          // change in shouldFire
          if (results.shouldFire) {
            drainQueue();
          }
        } else {
          previousShouldFire = results.shouldFire;
          // new data
          if (results.shouldFire) {
            o.onNext(results.data);
          } else {
            q.push(results.data);
          }
        }
      }, function (err) {
        drainQueue();
        o.onError(err);
      }, function () {
        drainQueue();
        o.onCompleted();
      });
      return subscription;
    };

    PausableBufferedObservable.prototype.pause = function () {
      this.paused = true;
      this.controller.onNext(false);
    };

    PausableBufferedObservable.prototype.resume = function () {
      this.paused = false;
      this.controller.onNext(true);
    };

    return PausableBufferedObservable;
  }(Observable);

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
   * and yields the values that were buffered while paused.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
   * @returns {Observable} The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausableBuffered = function (pauser) {
    return new PausableBufferedObservable(this, pauser);
  };

  var ControlledObservable = function (__super__) {
    inherits(ControlledObservable, __super__);
    function ControlledObservable(source, enableQueue, scheduler) {
      __super__.call(this);
      this.subject = new ControlledSubject(enableQueue, scheduler);
      this.source = source.multicast(this.subject).refCount();
    }

    ControlledObservable.prototype._subscribe = function (o) {
      return this.source.subscribe(o);
    };

    ControlledObservable.prototype.request = function (numberOfItems) {
      return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
    };

    return ControlledObservable;
  }(Observable);

  var ControlledSubject = function (__super__) {
    inherits(ControlledSubject, __super__);
    function ControlledSubject(enableQueue, scheduler) {
      enableQueue == null && (enableQueue = true);

      __super__.call(this);
      this.subject = new Subject();
      this.enableQueue = enableQueue;
      this.queue = enableQueue ? [] : null;
      this.requestedCount = 0;
      this.requestedDisposable = null;
      this.error = null;
      this.hasFailed = false;
      this.hasCompleted = false;
      this.scheduler = scheduler || currentThreadScheduler;
    }

    addProperties(ControlledSubject.prototype, Observer, {
      _subscribe: function _subscribe(o) {
        return this.subject.subscribe(o);
      },
      onCompleted: function onCompleted() {
        this.hasCompleted = true;
        if (!this.enableQueue || this.queue.length === 0) {
          this.subject.onCompleted();
          this.disposeCurrentRequest();
        } else {
          this.queue.push(Notification.createOnCompleted());
        }
      },
      onError: function onError(error) {
        this.hasFailed = true;
        this.error = error;
        if (!this.enableQueue || this.queue.length === 0) {
          this.subject.onError(error);
          this.disposeCurrentRequest();
        } else {
          this.queue.push(Notification.createOnError(error));
        }
      },
      onNext: function onNext(value) {
        if (this.requestedCount <= 0) {
          this.enableQueue && this.queue.push(Notification.createOnNext(value));
        } else {
          this.requestedCount-- === 0 && this.disposeCurrentRequest();
          this.subject.onNext(value);
        }
      },
      _processRequest: function _processRequest(numberOfItems) {
        if (this.enableQueue) {
          while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {
            var first = this.queue.shift();
            first.accept(this.subject);
            if (first.kind === 'N') {
              numberOfItems--;
            } else {
              this.disposeCurrentRequest();
              this.queue = [];
            }
          }
        }

        return numberOfItems;
      },
      request: function request(number) {
        this.disposeCurrentRequest();
        var self = this;

        this.requestedDisposable = this.scheduler.schedule(number, function (s, i) {
          var remaining = self._processRequest(i);
          var stopped = self.hasCompleted || self.hasFailed;
          if (!stopped && remaining > 0) {
            self.requestedCount = remaining;

            return disposableCreate(function () {
              self.requestedCount = 0;
            });
            // Scheduled item is still in progress. Return a new
            // disposable to allow the request to be interrupted
            // via dispose.
          }
        });

        return this.requestedDisposable;
      },
      disposeCurrentRequest: function disposeCurrentRequest() {
        if (this.requestedDisposable) {
          this.requestedDisposable.dispose();
          this.requestedDisposable = null;
        }
      }
    });

    return ControlledSubject;
  }(Observable);

  /**
   * Attaches a controller to the observable sequence with the ability to queue.
   * @example
   * var source = Rx.Observable.interval(100).controlled();
   * source.request(3); // Reads 3 values
   * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request
   * @param {Scheduler} scheduler determines how the requests will be scheduled
   * @returns {Observable} The observable sequence which only propagates values on request.
   */
  observableProto.controlled = function (enableQueue, scheduler) {

    if (enableQueue && isScheduler(enableQueue)) {
      scheduler = enableQueue;
      enableQueue = true;
    }

    if (enableQueue == null) {
      enableQueue = true;
    }
    return new ControlledObservable(this, enableQueue, scheduler);
  };

  var StopAndWaitObservable = function (__super__) {
    inherits(StopAndWaitObservable, __super__);
    function StopAndWaitObservable(source) {
      __super__.call(this);
      this.source = source;
    }

    function scheduleMethod(s, self) {
      return self.source.request(1);
    }

    StopAndWaitObservable.prototype._subscribe = function (o) {
      this.subscription = this.source.subscribe(new StopAndWaitObserver(o, this, this.subscription));
      return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));
    };

    var StopAndWaitObserver = function (__sub__) {
      inherits(StopAndWaitObserver, __sub__);
      function StopAndWaitObserver(observer, observable, cancel) {
        __sub__.call(this);
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.scheduleDisposable = null;
      }

      StopAndWaitObserver.prototype.completed = function () {
        this.observer.onCompleted();
        this.dispose();
      };

      StopAndWaitObserver.prototype.error = function (error) {
        this.observer.onError(error);
        this.dispose();
      };

      function innerScheduleMethod(s, self) {
        return self.observable.source.request(1);
      }

      StopAndWaitObserver.prototype.next = function (value) {
        this.observer.onNext(value);
        this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod);
      };

      StopAndWaitObserver.dispose = function () {
        this.observer = null;
        if (this.cancel) {
          this.cancel.dispose();
          this.cancel = null;
        }
        if (this.scheduleDisposable) {
          this.scheduleDisposable.dispose();
          this.scheduleDisposable = null;
        }
        __sub__.prototype.dispose.call(this);
      };

      return StopAndWaitObserver;
    }(AbstractObserver);

    return StopAndWaitObservable;
  }(Observable);

  /**
   * Attaches a stop and wait observable to the current observable.
   * @returns {Observable} A stop and wait observable.
   */
  ControlledObservable.prototype.stopAndWait = function () {
    return new StopAndWaitObservable(this);
  };

  var WindowedObservable = function (__super__) {
    inherits(WindowedObservable, __super__);
    function WindowedObservable(source, windowSize) {
      __super__.call(this);
      this.source = source;
      this.windowSize = windowSize;
    }

    function scheduleMethod(s, self) {
      return self.source.request(self.windowSize);
    }

    WindowedObservable.prototype._subscribe = function (o) {
      this.subscription = this.source.subscribe(new WindowedObserver(o, this, this.subscription));
      return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));
    };

    var WindowedObserver = function (__sub__) {
      inherits(WindowedObserver, __sub__);
      function WindowedObserver(observer, observable, cancel) {
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.received = 0;
        this.scheduleDisposable = null;
        __sub__.call(this);
      }

      WindowedObserver.prototype.completed = function () {
        this.observer.onCompleted();
        this.dispose();
      };

      WindowedObserver.prototype.error = function (error) {
        this.observer.onError(error);
        this.dispose();
      };

      function innerScheduleMethod(s, self) {
        return self.observable.source.request(self.observable.windowSize);
      }

      WindowedObserver.prototype.next = function (value) {
        this.observer.onNext(value);
        this.received = ++this.received % this.observable.windowSize;
        this.received === 0 && (this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod));
      };

      WindowedObserver.prototype.dispose = function () {
        this.observer = null;
        if (this.cancel) {
          this.cancel.dispose();
          this.cancel = null;
        }
        if (this.scheduleDisposable) {
          this.scheduleDisposable.dispose();
          this.scheduleDisposable = null;
        }
        __sub__.prototype.dispose.call(this);
      };

      return WindowedObserver;
    }(AbstractObserver);

    return WindowedObservable;
  }(Observable);

  /**
   * Creates a sliding windowed observable based upon the window size.
   * @param {Number} windowSize The number of items in the window
   * @returns {Observable} A windowed observable based upon the window size.
   */
  ControlledObservable.prototype.windowed = function (windowSize) {
    return new WindowedObservable(this, windowSize);
  };

  /**
   * Pipes the existing Observable sequence into a Node.js Stream.
   * @param {Stream} dest The destination Node.js stream.
   * @returns {Stream} The destination stream.
   */
  observableProto.pipe = function (dest) {
    var source = this.pausableBuffered();

    function onDrain() {
      source.resume();
    }

    dest.addListener('drain', onDrain);

    source.subscribe(function (x) {
      !dest.write(x) && source.pause();
    }, function (err) {
      dest.emit('error', err);
    }, function () {
      // Hack check because STDIO is not closable
      !dest._isStdio && dest.end();
      dest.removeListener('drain', onDrain);
    });

    source.resume();

    return dest;
  };

  var MulticastObservable = function (__super__) {
    inherits(MulticastObservable, __super__);
    function MulticastObservable(source, fn1, fn2) {
      this.source = source;
      this._fn1 = fn1;
      this._fn2 = fn2;
      __super__.call(this);
    }

    MulticastObservable.prototype.subscribeCore = function (o) {
      var connectable = this.source.multicast(this._fn1());
      return new BinaryDisposable(this._fn2(connectable).subscribe(o), connectable.connect());
    };

    return MulticastObservable;
  }(ObservableBase);

  /**
   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each
   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's
   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
   *
   * @example
   * 1 - res = source.multicast(observable);
   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });
   *
   * @param {Function|Subject} subjectOrSubjectSelector
   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
   * Or:
   * Subject to push source elements into.
   *
   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name="subjectOrSubjectSelector" is a factory function.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.multicast = function (subjectOrSubjectSelector, selector) {
    return isFunction(subjectOrSubjectSelector) ? new MulticastObservable(this, subjectOrSubjectSelector, selector) : new ConnectableObservable(this, subjectOrSubjectSelector);
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.
   * This operator is a specialization of Multicast using a regular Subject.
   *
   * @example
   * var resres = source.publish();
   * var res = source.publish(function (x) { return x; });
   *
   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publish = function (selector) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new Subject();
    }, selector) : this.multicast(new Subject());
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence.
   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.share = function () {
    return this.publish().refCount();
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
   * This operator is a specialization of Multicast using a AsyncSubject.
   *
   * @example
   * var res = source.publishLast();
   * var res = source.publishLast(function (x) { return x; });
   *
   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publishLast = function (selector) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new AsyncSubject();
    }, selector) : this.multicast(new AsyncSubject());
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
   * This operator is a specialization of Multicast using a BehaviorSubject.
   *
   * @example
   * var res = source.publishValue(42);
   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);
   *
   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.
   * @param {Mixed} initialValue Initial value received by observers upon subscription.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.publishValue = function (initialValueOrSelector, initialValue) {
    return arguments.length === 2 ? this.multicast(function () {
      return new BehaviorSubject(initialValue);
    }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.
   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   * @param {Mixed} initialValue Initial value received by observers upon subscription.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.shareValue = function (initialValue) {
    return this.publishValue(initialValue).refCount();
  };

  /**
   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
   * This operator is a specialization of Multicast using a ReplaySubject.
   *
   * @example
   * var res = source.replay(null, 3);
   * var res = source.replay(null, 3, 500);
   * var res = source.replay(null, 3, 500, scheduler);
   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);
   *
   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
   * @param bufferSize [Optional] Maximum element count of the replay buffer.
   * @param windowSize [Optional] Maximum time length of the replay buffer.
   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.replay = function (selector, bufferSize, windowSize, scheduler) {
    return selector && isFunction(selector) ? this.multicast(function () {
      return new ReplaySubject(bufferSize, windowSize, scheduler);
    }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
  };

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
   *
   * @example
   * var res = source.shareReplay(3);
   * var res = source.shareReplay(3, 500);
   * var res = source.shareReplay(3, 500, scheduler);
   *
    * @param bufferSize [Optional] Maximum element count of the replay buffer.
   * @param window [Optional] Maximum time length of the replay buffer.
   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
   */
  observableProto.shareReplay = function (bufferSize, windowSize, scheduler) {
    return this.replay(null, bufferSize, windowSize, scheduler).refCount();
  };

  var InnerSubscription = function InnerSubscription(s, o) {
    this._s = s;
    this._o = o;
  };

  InnerSubscription.prototype.dispose = function () {
    if (!this._s.isDisposed && this._o !== null) {
      var idx = this._s.observers.indexOf(this._o);
      this._s.observers.splice(idx, 1);
      this._o = null;
    }
  };

  var RefCountObservable = function (__super__) {
    inherits(RefCountObservable, __super__);
    function RefCountObservable(source) {
      this.source = source;
      this._count = 0;
      this._connectableSubscription = null;
      __super__.call(this);
    }

    RefCountObservable.prototype.subscribeCore = function (o) {
      var subscription = this.source.subscribe(o);
      ++this._count === 1 && (this._connectableSubscription = this.source.connect());
      return new RefCountDisposable(this, subscription);
    };

    function RefCountDisposable(p, s) {
      this._p = p;
      this._s = s;
      this.isDisposed = false;
    }

    RefCountDisposable.prototype.dispose = function () {
      if (!this.isDisposed) {
        this.isDisposed = true;
        this._s.dispose();
        --this._p._count === 0 && this._p._connectableSubscription.dispose();
      }
    };

    return RefCountObservable;
  }(ObservableBase);

  var ConnectableObservable = Rx.ConnectableObservable = function (__super__) {
    inherits(ConnectableObservable, __super__);
    function ConnectableObservable(source, subject) {
      this.source = source;
      this._connection = null;
      this._source = source.asObservable();
      this._subject = subject;
      __super__.call(this);
    }

    function ConnectDisposable(parent, subscription) {
      this._p = parent;
      this._s = subscription;
    }

    ConnectDisposable.prototype.dispose = function () {
      if (this._s) {
        this._s.dispose();
        this._s = null;
        this._p._connection = null;
      }
    };

    ConnectableObservable.prototype.connect = function () {
      if (!this._connection) {
        if (this._subject.isStopped) {
          return disposableEmpty;
        }
        var subscription = this._source.subscribe(this._subject);
        this._connection = new ConnectDisposable(this, subscription);
      }
      return this._connection;
    };

    ConnectableObservable.prototype._subscribe = function (o) {
      return this._subject.subscribe(o);
    };

    ConnectableObservable.prototype.refCount = function () {
      return new RefCountObservable(this);
    };

    return ConnectableObservable;
  }(Observable);

  /**
   * Returns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence
   * can be resubscribed to, even if all prior subscriptions have ended. (unlike `.publish().refCount()`)
   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source.
   */
  observableProto.singleInstance = function () {
    var source = this,
        hasObservable = false,
        observable;

    function getObservable() {
      if (!hasObservable) {
        hasObservable = true;
        observable = source['finally'](function () {
          hasObservable = false;
        }).publish().refCount();
      }
      return observable;
    }

    return new AnonymousObservable(function (o) {
      return getObservable().subscribe(o);
    });
  };

  /**
   *  Correlates the elements of two sequences based on overlapping durations.
   *
   *  @param {Observable} right The right observable sequence to join elements for.
   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.
   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
   */
  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
    var left = this;
    return new AnonymousObservable(function (o) {
      var group = new CompositeDisposable();
      var leftDone = false,
          rightDone = false;
      var leftId = 0,
          rightId = 0;
      var leftMap = new Map(),
          rightMap = new Map();
      var handleError = function handleError(e) {
        o.onError(e);
      };

      group.add(left.subscribe(function (value) {
        var id = leftId++,
            md = new SingleAssignmentDisposable();

        leftMap.set(id, value);
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, handleError, function () {
          leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();
          group.remove(md);
        }));

        rightMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(value, v);
          if (result === errorObj) {
            return o.onError(result.e);
          }
          o.onNext(result);
        });
      }, handleError, function () {
        leftDone = true;
        (rightDone || leftMap.size === 0) && o.onCompleted();
      }));

      group.add(right.subscribe(function (value) {
        var id = rightId++,
            md = new SingleAssignmentDisposable();

        rightMap.set(id, value);
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, handleError, function () {
          rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();
          group.remove(md);
        }));

        leftMap.forEach(function (v) {
          var result = tryCatch(resultSelector)(v, value);
          if (result === errorObj) {
            return o.onError(result.e);
          }
          o.onNext(result);
        });
      }, handleError, function () {
        rightDone = true;
        (leftDone || rightMap.size === 0) && o.onCompleted();
      }));
      return group;
    }, left);
  };

  /**
   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.
   *
   *  @param {Observable} right The right observable sequence to join elements for.
   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.
   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
   */
  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
    var left = this;
    return new AnonymousObservable(function (o) {
      var group = new CompositeDisposable();
      var r = new RefCountDisposable(group);
      var leftMap = new Map(),
          rightMap = new Map();
      var leftId = 0,
          rightId = 0;
      var handleError = function handleError(e) {
        return function (v) {
          v.onError(e);
        };
      };

      function handleError(e) {};

      group.add(left.subscribe(function (value) {
        var s = new Subject();
        var id = leftId++;
        leftMap.set(id, s);

        var result = tryCatch(resultSelector)(value, addRef(s, r));
        if (result === errorObj) {
          leftMap.forEach(handleError(result.e));
          return o.onError(result.e);
        }
        o.onNext(result);

        rightMap.forEach(function (v) {
          s.onNext(v);
        });

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(leftDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, function (e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function () {
          leftMap['delete'](id) && s.onCompleted();
          group.remove(md);
        }));
      }, function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      }, function () {
        o.onCompleted();
      }));

      group.add(right.subscribe(function (value) {
        var id = rightId++;
        rightMap.set(id, value);

        var md = new SingleAssignmentDisposable();
        group.add(md);

        var duration = tryCatch(rightDurationSelector)(value);
        if (duration === errorObj) {
          leftMap.forEach(handleError(duration.e));
          return o.onError(duration.e);
        }

        md.setDisposable(duration.take(1).subscribe(noop, function (e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function () {
          rightMap['delete'](id);
          group.remove(md);
        }));

        leftMap.forEach(function (v) {
          v.onNext(value);
        });
      }, function (e) {
        leftMap.forEach(handleError(e));
        o.onError(e);
      }));

      return r;
    }, left);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers.
   *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns {Observable} An observable sequence of windows.
   */
  observableProto.buffer = function () {
    return this.window.apply(this, arguments).flatMap(toArray);
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows.
   *
   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns {Observable} An observable sequence of windows.
   */
  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {
    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
      return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
    }
    return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
  };

  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {
      return win;
    });
  }

  function observableWindowWithBoundaries(windowBoundaries) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var win = new Subject(),
          d = new CompositeDisposable(),
          r = new RefCountDisposable(d);

      observer.onNext(addRef(win, r));

      d.add(source.subscribe(function (x) {
        win.onNext(x);
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));

      d.add(windowBoundaries.subscribe(function (w) {
        win.onCompleted();
        win = new Subject();
        observer.onNext(addRef(win, r));
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      return r;
    }, source);
  }

  function observableWindowWithClosingSelector(windowClosingSelector) {
    var source = this;
    return new AnonymousObservable(function (observer) {
      var m = new SerialDisposable(),
          d = new CompositeDisposable(m),
          r = new RefCountDisposable(d),
          win = new Subject();
      observer.onNext(addRef(win, r));
      d.add(source.subscribe(function (x) {
        win.onNext(x);
      }, function (err) {
        win.onError(err);
        observer.onError(err);
      }, function () {
        win.onCompleted();
        observer.onCompleted();
      }));

      function createWindowClose() {
        var windowClose;
        try {
          windowClose = windowClosingSelector();
        } catch (e) {
          observer.onError(e);
          return;
        }

        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));

        var m1 = new SingleAssignmentDisposable();
        m.setDisposable(m1);
        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {
          win.onError(err);
          observer.onError(err);
        }, function () {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
          createWindowClose();
        }));
      }

      createWindowClose();
      return r;
    }, source);
  }

  var PairwiseObservable = function (__super__) {
    inherits(PairwiseObservable, __super__);
    function PairwiseObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    PairwiseObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new PairwiseObserver(o));
    };

    return PairwiseObservable;
  }(ObservableBase);

  var PairwiseObserver = function (__super__) {
    inherits(PairwiseObserver, __super__);
    function PairwiseObserver(o) {
      this._o = o;
      this._p = null;
      this._hp = false;
      __super__.call(this);
    }

    PairwiseObserver.prototype.next = function (x) {
      if (this._hp) {
        this._o.onNext([this._p, x]);
      } else {
        this._hp = true;
      }
      this._p = x;
    };
    PairwiseObserver.prototype.error = function (err) {
      this._o.onError(err);
    };
    PairwiseObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return PairwiseObserver;
  }(AbstractObserver);

  /**
   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.
   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.
   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.
   */
  observableProto.pairwise = function () {
    return new PairwiseObservable(this);
  };

  /**
   * Returns two observables which partition the observations of the source by the given function.
   * The first will trigger observations for those values for which the predicate returns true.
   * The second will trigger observations for those values where the predicate returns false.
   * The predicate is executed once for each subscribed observer.
   * Both also propagate all error observations arising from the source and each completes
   * when the source completes.
   * @param {Function} predicate
   *    The function to determine which output Observable will trigger a particular observation.
   * @returns {Array}
   *    An array of observables. The first triggers when the predicate returns true,
   *    and the second triggers when the predicate returns false.
  */
  observableProto.partition = function (predicate, thisArg) {
    var fn = bindCallback(predicate, thisArg, 3);
    return [this.filter(predicate, thisArg), this.filter(function (x, i, o) {
      return !fn(x, i, o);
    })];
  };

  var WhileEnumerable = function (__super__) {
    inherits(WhileEnumerable, __super__);
    function WhileEnumerable(c, s) {
      this.c = c;
      this.s = s;
    }
    WhileEnumerable.prototype[$iterator$] = function () {
      var self = this;
      return {
        next: function next() {
          return self.c() ? { done: false, value: self.s } : { done: true, value: void 0 };
        }
      };
    };
    return WhileEnumerable;
  }(Enumerable);

  function enumerableWhile(condition, source) {
    return new WhileEnumerable(condition, source);
  }

  /**
  *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
  *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
  *
  * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
  * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
  */
  observableProto.letBind = observableProto['let'] = function (func) {
    return func(this);
  };

  /**
  *  Determines whether an observable collection contains values. 
  *
  * @example
  *  1 - res = Rx.Observable.if(condition, obs1);
  *  2 - res = Rx.Observable.if(condition, obs1, obs2);
  *  3 - res = Rx.Observable.if(condition, obs1, scheduler);
  * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.
  * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.
  * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
  * @returns {Observable} An observable sequence which is either the thenSource or elseSource.
  */
  Observable['if'] = function (condition, thenSource, elseSourceOrScheduler) {
    return observableDefer(function () {
      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());

      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));

      // Assume a scheduler for empty only
      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
      return condition() ? thenSource : elseSourceOrScheduler;
    });
  };

  /**
  *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
  * There is an alias for this method called 'forIn' for browsers <IE9
  * @param {Array} sources An array of values to turn into an observable sequence.
  * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
  * @returns {Observable} An observable sequence from the concatenated observable sequences.
  */
  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {
    return enumerableOf(sources, resultSelector, thisArg).concat();
  };

  /**
  *  Repeats source as long as condition holds emulating a while loop.
  * There is an alias for this method called 'whileDo' for browsers <IE9
  *
  * @param {Function} condition The condition which determines if the source will be repeated.
  * @param {Observable} source The observable sequence that will be run if the condition function returns true.
  * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
  */
  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {
    isPromise(source) && (source = observableFromPromise(source));
    return enumerableWhile(condition, source).concat();
  };

  /**
  *  Repeats source as long as condition holds emulating a do while loop.
  *
  * @param {Function} condition The condition which determines if the source will be repeated.
  * @param {Observable} source The observable sequence that will be run if the condition function returns true.
  * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
  */
  observableProto.doWhile = function (condition) {
    return observableConcat([this, observableWhileDo(condition, this)]);
  };

  /**
  *  Uses selector to determine which source in sources to use.
  * @param {Function} selector The function which extracts the value for to test in a case statement.
  * @param {Array} sources A object which has keys which correspond to the case statement labels.
  * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.
  *
  * @returns {Observable} An observable sequence which is determined by a case statement.
  */
  Observable['case'] = function (selector, sources, defaultSourceOrScheduler) {
    return observableDefer(function () {
      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());

      isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));

      var result = sources[selector()];
      isPromise(result) && (result = observableFromPromise(result));

      return result || defaultSourceOrScheduler;
    });
  };

  var ExpandObservable = function (__super__) {
    inherits(ExpandObservable, __super__);
    function ExpandObservable(source, fn, scheduler) {
      this.source = source;
      this._fn = fn;
      this._scheduler = scheduler;
      __super__.call(this);
    }

    function scheduleRecursive(args, recurse) {
      var state = args[0],
          self = args[1];
      var work;
      if (state.q.length > 0) {
        work = state.q.shift();
      } else {
        state.isAcquired = false;
        return;
      }
      var m1 = new SingleAssignmentDisposable();
      state.d.add(m1);
      m1.setDisposable(work.subscribe(new ExpandObserver(state, self, m1)));
      recurse([state, self]);
    }

    ExpandObservable.prototype._ensureActive = function (state) {
      var isOwner = false;
      if (state.q.length > 0) {
        isOwner = !state.isAcquired;
        state.isAcquired = true;
      }
      isOwner && state.m.setDisposable(this._scheduler.scheduleRecursive([state, this], scheduleRecursive));
    };

    ExpandObservable.prototype.subscribeCore = function (o) {
      var m = new SerialDisposable(),
          d = new CompositeDisposable(m),
          state = {
        q: [],
        m: m,
        d: d,
        activeCount: 0,
        isAcquired: false,
        o: o
      };

      state.q.push(this.source);
      state.activeCount++;
      this._ensureActive(state);
      return d;
    };

    return ExpandObservable;
  }(ObservableBase);

  var ExpandObserver = function (__super__) {
    inherits(ExpandObserver, __super__);
    function ExpandObserver(state, parent, m1) {
      this._s = state;
      this._p = parent;
      this._m1 = m1;
      __super__.call(this);
    }

    ExpandObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
      var result = tryCatch(this._p._fn)(x);
      if (result === errorObj) {
        return this._s.o.onError(result.e);
      }
      this._s.q.push(result);
      this._s.activeCount++;
      this._p._ensureActive(this._s);
    };

    ExpandObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    ExpandObserver.prototype.completed = function () {
      this._s.d.remove(this._m1);
      this._s.activeCount--;
      this._s.activeCount === 0 && this._s.o.onCompleted();
    };

    return ExpandObserver;
  }(AbstractObserver);

  /**
  *  Expands an observable sequence by recursively invoking selector.
  *
  * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
  * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
  * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.
  */
  observableProto.expand = function (selector, scheduler) {
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new ExpandObservable(this, selector, scheduler);
  };

  function argumentsToArray() {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    return args;
  }

  var ForkJoinObservable = function (__super__) {
    inherits(ForkJoinObservable, __super__);
    function ForkJoinObservable(sources, cb) {
      this._sources = sources;
      this._cb = cb;
      __super__.call(this);
    }

    ForkJoinObservable.prototype.subscribeCore = function (o) {
      if (this._sources.length === 0) {
        o.onCompleted();
        return disposableEmpty;
      }

      var count = this._sources.length;
      var state = {
        finished: false,
        hasResults: new Array(count),
        hasCompleted: new Array(count),
        results: new Array(count)
      };

      var subscriptions = new CompositeDisposable();
      for (var i = 0, len = this._sources.length; i < len; i++) {
        var source = this._sources[i];
        isPromise(source) && (source = observableFromPromise(source));
        subscriptions.add(source.subscribe(new ForkJoinObserver(o, state, i, this._cb, subscriptions)));
      }

      return subscriptions;
    };

    return ForkJoinObservable;
  }(ObservableBase);

  var ForkJoinObserver = function (__super__) {
    inherits(ForkJoinObserver, __super__);
    function ForkJoinObserver(o, s, i, cb, subs) {
      this._o = o;
      this._s = s;
      this._i = i;
      this._cb = cb;
      this._subs = subs;
      __super__.call(this);
    }

    ForkJoinObserver.prototype.next = function (x) {
      if (!this._s.finished) {
        this._s.hasResults[this._i] = true;
        this._s.results[this._i] = x;
      }
    };

    ForkJoinObserver.prototype.error = function (e) {
      this._s.finished = true;
      this._o.onError(e);
      this._subs.dispose();
    };

    ForkJoinObserver.prototype.completed = function () {
      if (!this._s.finished) {
        if (!this._s.hasResults[this._i]) {
          return this._o.onCompleted();
        }
        this._s.hasCompleted[this._i] = true;
        for (var i = 0; i < this._s.results.length; i++) {
          if (!this._s.hasCompleted[i]) {
            return;
          }
        }
        this._s.finished = true;

        var res = tryCatch(this._cb).apply(null, this._s.results);
        if (res === errorObj) {
          return this._o.onError(res.e);
        }

        this._o.onNext(res);
        this._o.onCompleted();
      }
    };

    return ForkJoinObserver;
  }(AbstractObserver);

  /**
  *  Runs all observable sequences in parallel and collect their last elements.
  *
  * @example
  *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);
  *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
  * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
  */
  Observable.forkJoin = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
    Array.isArray(args[0]) && (args = args[0]);
    return new ForkJoinObservable(args, resultSelector);
  };

  /**
  *  Runs two observable sequences in parallel and combines their last elemenets.
  * @param {Observable} second Second observable sequence.
  * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.
  * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.
  */
  observableProto.forkJoin = function () {
    var len = arguments.length,
        args = new Array(len);
    for (var i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    if (Array.isArray(args[0])) {
      args[0].unshift(this);
    } else {
      args.unshift(this);
    }
    return Observable.forkJoin.apply(null, args);
  };

  /**
   * Comonadic bind operator.
   * @param {Function} selector A transform function to apply to each element.
   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.
   * @returns {Observable} An observable sequence which results from the comonadic bind operation.
   */
  observableProto.manySelect = observableProto.extend = function (selector, scheduler) {
    isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);
    var source = this;
    return observableDefer(function () {
      var chain;

      return source.map(function (x) {
        var curr = new ChainObservable(x);

        chain && chain.onNext(x);
        chain = curr;

        return curr;
      }).tap(noop, function (e) {
        chain && chain.onError(e);
      }, function () {
        chain && chain.onCompleted();
      }).observeOn(scheduler).map(selector);
    }, source);
  };

  var ChainObservable = function (__super__) {
    inherits(ChainObservable, __super__);
    function ChainObservable(head) {
      __super__.call(this);
      this.head = head;
      this.tail = new AsyncSubject();
    }

    addProperties(ChainObservable.prototype, Observer, {
      _subscribe: function _subscribe(o) {
        var g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(this, function (_, self) {
          o.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(o));
        }));

        return g;
      },
      onCompleted: function onCompleted() {
        this.onNext(Observable.empty());
      },
      onError: function onError(e) {
        this.onNext(Observable['throw'](e));
      },
      onNext: function onNext(v) {
        this.tail.onNext(v);
        this.tail.onCompleted();
      }
    });

    return ChainObservable;
  }(Observable);

  var Map = root.Map || function () {
    function Map() {
      this.size = 0;
      this._values = [];
      this._keys = [];
    }

    Map.prototype['delete'] = function (key) {
      var i = this._keys.indexOf(key);
      if (i === -1) {
        return false;
      }
      this._values.splice(i, 1);
      this._keys.splice(i, 1);
      this.size--;
      return true;
    };

    Map.prototype.get = function (key) {
      var i = this._keys.indexOf(key);
      return i === -1 ? undefined : this._values[i];
    };

    Map.prototype.set = function (key, value) {
      var i = this._keys.indexOf(key);
      if (i === -1) {
        this._keys.push(key);
        this._values.push(value);
        this.size++;
      } else {
        this._values[i] = value;
      }
      return this;
    };

    Map.prototype.forEach = function (cb, thisArg) {
      for (var i = 0; i < this.size; i++) {
        cb.call(thisArg, this._values[i], this._keys[i]);
      }
    };

    return Map;
  }();

  /**
   * @constructor
   * Represents a join pattern over observable sequences.
   */
  function Pattern(patterns) {
    this.patterns = patterns;
  }

  /**
   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.
   *  @param other Observable sequence to match in addition to the current pattern.
   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.
   */
  Pattern.prototype.and = function (other) {
    return new Pattern(this.patterns.concat(other));
  };

  /**
   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.
   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.
   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  Pattern.prototype.thenDo = function (selector) {
    return new Plan(this, selector);
  };

  function Plan(expression, selector) {
    this.expression = expression;
    this.selector = selector;
  }

  function handleOnError(o) {
    return function (e) {
      o.onError(e);
    };
  }
  function handleOnNext(self, observer) {
    return function onNext() {
      var result = tryCatch(self.selector).apply(self, arguments);
      if (result === errorObj) {
        return observer.onError(result.e);
      }
      observer.onNext(result);
    };
  }

  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {
    var joinObservers = [],
        errHandler = handleOnError(observer);
    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {
      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], errHandler));
    }
    var activePlan = new ActivePlan(joinObservers, handleOnNext(this, observer), function () {
      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {
        joinObservers[j].removeActivePlan(activePlan);
      }
      deactivate(activePlan);
    });
    for (i = 0, len = joinObservers.length; i < len; i++) {
      joinObservers[i].addActivePlan(activePlan);
    }
    return activePlan;
  };

  function planCreateObserver(externalSubscriptions, observable, onError) {
    var entry = externalSubscriptions.get(observable);
    if (!entry) {
      var observer = new JoinObserver(observable, onError);
      externalSubscriptions.set(observable, observer);
      return observer;
    }
    return entry;
  }

  function ActivePlan(joinObserverArray, onNext, onCompleted) {
    this.joinObserverArray = joinObserverArray;
    this.onNext = onNext;
    this.onCompleted = onCompleted;
    this.joinObservers = new Map();
    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {
      var joinObserver = this.joinObserverArray[i];
      this.joinObservers.set(joinObserver, joinObserver);
    }
  }

  ActivePlan.prototype.dequeue = function () {
    this.joinObservers.forEach(function (v) {
      v.queue.shift();
    });
  };

  ActivePlan.prototype.match = function () {
    var i,
        len,
        hasValues = true;
    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
      if (this.joinObserverArray[i].queue.length === 0) {
        hasValues = false;
        break;
      }
    }
    if (hasValues) {
      var firstValues = [],
          isCompleted = false;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        firstValues.push(this.joinObserverArray[i].queue[0]);
        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
      }
      if (isCompleted) {
        this.onCompleted();
      } else {
        this.dequeue();
        var values = [];
        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
          values.push(firstValues[i].value);
        }
        this.onNext.apply(this, values);
      }
    }
  };

  var JoinObserver = function (__super__) {
    inherits(JoinObserver, __super__);

    function JoinObserver(source, onError) {
      __super__.call(this);
      this.source = source;
      this.onError = onError;
      this.queue = [];
      this.activePlans = [];
      this.subscription = new SingleAssignmentDisposable();
      this.isDisposed = false;
    }

    var JoinObserverPrototype = JoinObserver.prototype;

    JoinObserverPrototype.next = function (notification) {
      if (!this.isDisposed) {
        if (notification.kind === 'E') {
          return this.onError(notification.error);
        }
        this.queue.push(notification);
        var activePlans = this.activePlans.slice(0);
        for (var i = 0, len = activePlans.length; i < len; i++) {
          activePlans[i].match();
        }
      }
    };

    JoinObserverPrototype.error = noop;
    JoinObserverPrototype.completed = noop;

    JoinObserverPrototype.addActivePlan = function (activePlan) {
      this.activePlans.push(activePlan);
    };

    JoinObserverPrototype.subscribe = function () {
      this.subscription.setDisposable(this.source.materialize().subscribe(this));
    };

    JoinObserverPrototype.removeActivePlan = function (activePlan) {
      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
      this.activePlans.length === 0 && this.dispose();
    };

    JoinObserverPrototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      if (!this.isDisposed) {
        this.isDisposed = true;
        this.subscription.dispose();
      }
    };

    return JoinObserver;
  }(AbstractObserver);

  /**
   *  Creates a pattern that matches when both observable sequences have an available value.
   *
   *  @param right Observable sequence to match with the current sequence.
   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.
   */
  observableProto.and = function (right) {
    return new Pattern([this, right]);
  };

  /**
   *  Matches when the observable sequence has an available value and projects the value.
   *
   *  @param {Function} selector Selector that will be invoked for values in the source sequence.
   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  observableProto.thenDo = function (selector) {
    return new Pattern([this]).thenDo(selector);
  };

  /**
   *  Joins together the results from several patterns.
   *
   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.
   *  @returns {Observable} Observable sequence with the results form matching several patterns.
   */
  Observable.when = function () {
    var len = arguments.length,
        plans;
    if (Array.isArray(arguments[0])) {
      plans = arguments[0];
    } else {
      plans = new Array(len);
      for (var i = 0; i < len; i++) {
        plans[i] = arguments[i];
      }
    }
    return new AnonymousObservable(function (o) {
      var activePlans = [],
          externalSubscriptions = new Map();
      var outObserver = observerCreate(function (x) {
        o.onNext(x);
      }, function (err) {
        externalSubscriptions.forEach(function (v) {
          v.onError(err);
        });
        o.onError(err);
      }, function (x) {
        o.onCompleted();
      });
      try {
        for (var i = 0, len = plans.length; i < len; i++) {
          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {
            var idx = activePlans.indexOf(activePlan);
            activePlans.splice(idx, 1);
            activePlans.length === 0 && o.onCompleted();
          }));
        }
      } catch (e) {
        return observableThrow(e).subscribe(o);
      }
      var group = new CompositeDisposable();
      externalSubscriptions.forEach(function (joinObserver) {
        joinObserver.subscribe();
        group.add(joinObserver);
      });

      return group;
    });
  };

  var TimerObservable = function (__super__) {
    inherits(TimerObservable, __super__);
    function TimerObservable(dt, s) {
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    TimerObservable.prototype.subscribeCore = function (o) {
      return this._s.scheduleFuture(o, this._dt, scheduleMethod);
    };

    function scheduleMethod(s, o) {
      o.onNext(0);
      o.onCompleted();
    }

    return TimerObservable;
  }(ObservableBase);

  function _observableTimer(dueTime, scheduler) {
    return new TimerObservable(dueTime, scheduler);
  }

  function observableTimerDateAndPeriod(dueTime, period, scheduler) {
    return new AnonymousObservable(function (observer) {
      var d = dueTime,
          p = normalizeTime(period);
      return scheduler.scheduleRecursiveFuture(0, d, function (count, self) {
        if (p > 0) {
          var now = scheduler.now();
          d = new Date(d.getTime() + p);
          d.getTime() <= now && (d = new Date(now + p));
        }
        observer.onNext(count);
        self(count + 1, new Date(d));
      });
    });
  }

  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
    return dueTime === period ? new AnonymousObservable(function (observer) {
      return scheduler.schedulePeriodic(0, period, function (count) {
        observer.onNext(count);
        return count + 1;
      });
    }) : observableDefer(function () {
      return observableTimerDateAndPeriod(new Date(scheduler.now() + dueTime), period, scheduler);
    });
  }

  /**
   *  Returns an observable sequence that produces a value after each period.
   *
   * @example
   *  1 - res = Rx.Observable.interval(1000);
   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);
   *
   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).
   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.
   * @returns {Observable} An observable sequence that produces a value after each period.
   */
  var observableinterval = Observable.interval = function (period, scheduler) {
    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);
  };

  /**
   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.
   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.
   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.
   */
  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {
    var period;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {
      period = periodOrScheduler;
    } else if (isScheduler(periodOrScheduler)) {
      scheduler = periodOrScheduler;
    }
    if ((dueTime instanceof Date || typeof dueTime === 'number') && period === undefined) {
      return _observableTimer(dueTime, scheduler);
    }
    if (dueTime instanceof Date && period !== undefined) {
      return observableTimerDateAndPeriod(dueTime, periodOrScheduler, scheduler);
    }
    return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
  };

  function observableDelayRelative(source, dueTime, scheduler) {
    return new AnonymousObservable(function (o) {
      var active = false,
          cancelable = new SerialDisposable(),
          exception = null,
          q = [],
          running = false,
          subscription;
      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {
        var d, shouldRun;
        if (notification.value.kind === 'E') {
          q = [];
          q.push(notification);
          exception = notification.value.error;
          shouldRun = !running;
        } else {
          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });
          shouldRun = !active;
          active = true;
        }
        if (shouldRun) {
          if (exception !== null) {
            o.onError(exception);
          } else {
            d = new SingleAssignmentDisposable();
            cancelable.setDisposable(d);
            d.setDisposable(scheduler.scheduleRecursiveFuture(null, dueTime, function (_, self) {
              var e, recurseDueTime, result, shouldRecurse;
              if (exception !== null) {
                return;
              }
              running = true;
              do {
                result = null;
                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                  result = q.shift().value;
                }
                if (result !== null) {
                  result.accept(o);
                }
              } while (result !== null);
              shouldRecurse = false;
              recurseDueTime = 0;
              if (q.length > 0) {
                shouldRecurse = true;
                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
              } else {
                active = false;
              }
              e = exception;
              running = false;
              if (e !== null) {
                o.onError(e);
              } else if (shouldRecurse) {
                self(null, recurseDueTime);
              }
            }));
          }
        }
      });
      return new BinaryDisposable(subscription, cancelable);
    }, source);
  }

  function observableDelayAbsolute(source, dueTime, scheduler) {
    return observableDefer(function () {
      return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);
    });
  }

  function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {
    var subDelay, selector;
    if (isFunction(subscriptionDelay)) {
      selector = subscriptionDelay;
    } else {
      subDelay = subscriptionDelay;
      selector = delayDurationSelector;
    }
    return new AnonymousObservable(function (o) {
      var delays = new CompositeDisposable(),
          atEnd = false,
          subscription = new SerialDisposable();

      function start() {
        subscription.setDisposable(source.subscribe(function (x) {
          var delay = tryCatch(selector)(x);
          if (delay === errorObj) {
            return o.onError(delay.e);
          }
          var d = new SingleAssignmentDisposable();
          delays.add(d);
          d.setDisposable(delay.subscribe(function () {
            o.onNext(x);
            delays.remove(d);
            done();
          }, function (e) {
            o.onError(e);
          }, function () {
            o.onNext(x);
            delays.remove(d);
            done();
          }));
        }, function (e) {
          o.onError(e);
        }, function () {
          atEnd = true;
          subscription.dispose();
          done();
        }));
      }

      function done() {
        atEnd && delays.length === 0 && o.onCompleted();
      }

      if (!subDelay) {
        start();
      } else {
        subscription.setDisposable(subDelay.subscribe(start, function (e) {
          o.onError(e);
        }, start));
      }

      return new BinaryDisposable(subscription, delays);
    }, source);
  }

  /**
   *  Time shifts the observable sequence by dueTime.
   *  The relative time intervals between the values are preserved.
   *
   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.
   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Time-shifted sequence.
   */
  observableProto.delay = function () {
    var firstArg = arguments[0];
    if (typeof firstArg === 'number' || firstArg instanceof Date) {
      var dueTime = firstArg,
          scheduler = arguments[1];
      isScheduler(scheduler) || (scheduler = defaultScheduler);
      return dueTime instanceof Date ? observableDelayAbsolute(this, dueTime, scheduler) : observableDelayRelative(this, dueTime, scheduler);
    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
      return delayWithSelector(this, firstArg, arguments[1]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  var DebounceObservable = function (__super__) {
    inherits(DebounceObservable, __super__);
    function DebounceObservable(source, dt, s) {
      isScheduler(s) || (s = defaultScheduler);
      this.source = source;
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    DebounceObservable.prototype.subscribeCore = function (o) {
      var cancelable = new SerialDisposable();
      return new BinaryDisposable(this.source.subscribe(new DebounceObserver(o, this._dt, this._s, cancelable)), cancelable);
    };

    return DebounceObservable;
  }(ObservableBase);

  var DebounceObserver = function (__super__) {
    inherits(DebounceObserver, __super__);
    function DebounceObserver(observer, dueTime, scheduler, cancelable) {
      this._o = observer;
      this._d = dueTime;
      this._scheduler = scheduler;
      this._c = cancelable;
      this._v = null;
      this._hv = false;
      this._id = 0;
      __super__.call(this);
    }

    function scheduleFuture(s, state) {
      state.self._hv && state.self._id === state.currentId && state.self._o.onNext(state.x);
      state.self._hv = false;
    }

    DebounceObserver.prototype.next = function (x) {
      this._hv = true;
      this._v = x;
      var currentId = ++this._id,
          d = new SingleAssignmentDisposable();
      this._c.setDisposable(d);
      d.setDisposable(this._scheduler.scheduleFuture(this, this._d, function (_, self) {
        self._hv && self._id === currentId && self._o.onNext(x);
        self._hv = false;
      }));
    };

    DebounceObserver.prototype.error = function (e) {
      this._c.dispose();
      this._o.onError(e);
      this._hv = false;
      this._id++;
    };

    DebounceObserver.prototype.completed = function () {
      this._c.dispose();
      this._hv && this._o.onNext(this._v);
      this._o.onCompleted();
      this._hv = false;
      this._id++;
    };

    return DebounceObserver;
  }(AbstractObserver);

  function debounceWithSelector(source, durationSelector) {
    return new AnonymousObservable(function (o) {
      var value,
          hasValue = false,
          cancelable = new SerialDisposable(),
          id = 0;
      var subscription = source.subscribe(function (x) {
        var throttle = tryCatch(durationSelector)(x);
        if (throttle === errorObj) {
          return o.onError(throttle.e);
        }

        isPromise(throttle) && (throttle = observableFromPromise(throttle));

        hasValue = true;
        value = x;
        id++;
        var currentid = id,
            d = new SingleAssignmentDisposable();
        cancelable.setDisposable(d);
        d.setDisposable(throttle.subscribe(function () {
          hasValue && id === currentid && o.onNext(value);
          hasValue = false;
          d.dispose();
        }, function (e) {
          o.onError(e);
        }, function () {
          hasValue && id === currentid && o.onNext(value);
          hasValue = false;
          d.dispose();
        }));
      }, function (e) {
        cancelable.dispose();
        o.onError(e);
        hasValue = false;
        id++;
      }, function () {
        cancelable.dispose();
        hasValue && o.onNext(value);
        o.onCompleted();
        hasValue = false;
        id++;
      });
      return new BinaryDisposable(subscription, cancelable);
    }, source);
  }

  observableProto.debounce = function () {
    if (isFunction(arguments[0])) {
      return debounceWithSelector(this, arguments[0]);
    } else if (typeof arguments[0] === 'number') {
      return new DebounceObservable(this, arguments[0], arguments[1]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.
   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).
   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.
   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithTime = observableProto.windowTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
    var source = this,
        timeShift;
    timeShiftOrScheduler == null && (timeShift = timeSpan);
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    if (typeof timeShiftOrScheduler === 'number') {
      timeShift = timeShiftOrScheduler;
    } else if (isScheduler(timeShiftOrScheduler)) {
      timeShift = timeSpan;
      scheduler = timeShiftOrScheduler;
    }
    return new AnonymousObservable(function (observer) {
      var groupDisposable,
          nextShift = timeShift,
          nextSpan = timeSpan,
          q = [],
          refCountDisposable,
          timerD = new SerialDisposable(),
          totalTime = 0;
      groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);

      function createTimer() {
        var m = new SingleAssignmentDisposable(),
            isSpan = false,
            isShift = false;
        timerD.setDisposable(m);
        if (nextSpan === nextShift) {
          isSpan = true;
          isShift = true;
        } else if (nextSpan < nextShift) {
          isSpan = true;
        } else {
          isShift = true;
        }
        var newTotalTime = isSpan ? nextSpan : nextShift,
            ts = newTotalTime - totalTime;
        totalTime = newTotalTime;
        if (isSpan) {
          nextSpan += timeShift;
        }
        if (isShift) {
          nextShift += timeShift;
        }
        m.setDisposable(scheduler.scheduleFuture(null, ts, function () {
          if (isShift) {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          isSpan && q.shift().onCompleted();
          createTimer();
        }));
      };
      q.push(new Subject());
      observer.onNext(addRef(q[0], refCountDisposable));
      createTimer();
      groupDisposable.add(source.subscribe(function (x) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onNext(x);
        }
      }, function (e) {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onError(e);
        }
        observer.onError(e);
      }, function () {
        for (var i = 0, len = q.length; i < len; i++) {
          q[i].onCompleted();
        }
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  /**
   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.
   * @param {Number} timeSpan Maximum time length of a window.
   * @param {Number} count Maximum element count of a window.
   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of windows.
   */
  observableProto.windowWithTimeOrCount = observableProto.windowTimeOrCount = function (timeSpan, count, scheduler) {
    var source = this;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new AnonymousObservable(function (observer) {
      var timerD = new SerialDisposable(),
          groupDisposable = new CompositeDisposable(timerD),
          refCountDisposable = new RefCountDisposable(groupDisposable),
          n = 0,
          windowId = 0,
          s = new Subject();

      function createTimer(id) {
        var m = new SingleAssignmentDisposable();
        timerD.setDisposable(m);
        m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {
          if (id !== windowId) {
            return;
          }
          n = 0;
          var newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
          createTimer(newId);
        }));
      }

      observer.onNext(addRef(s, refCountDisposable));
      createTimer(0);

      groupDisposable.add(source.subscribe(function (x) {
        var newId = 0,
            newWindow = false;
        s.onNext(x);
        if (++n === count) {
          newWindow = true;
          n = 0;
          newId = ++windowId;
          s.onCompleted();
          s = new Subject();
          observer.onNext(addRef(s, refCountDisposable));
        }
        newWindow && createTimer(newId);
      }, function (e) {
        s.onError(e);
        observer.onError(e);
      }, function () {
        s.onCompleted();
        observer.onCompleted();
      }));
      return refCountDisposable;
    }, source);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
   * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).
   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.
   * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithTime = observableProto.bufferTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
    return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
  };

  function toArray(x) {
    return x.toArray();
  }

  /**
   *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.
   * @param {Number} timeSpan Maximum time length of a buffer.
   * @param {Number} count Maximum element count of a buffer.
   * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence of buffers.
   */
  observableProto.bufferWithTimeOrCount = observableProto.bufferTimeOrCount = function (timeSpan, count, scheduler) {
    return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
  };

  var TimeIntervalObservable = function (__super__) {
    inherits(TimeIntervalObservable, __super__);
    function TimeIntervalObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    TimeIntervalObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TimeIntervalObserver(o, this._s));
    };

    return TimeIntervalObservable;
  }(ObservableBase);

  var TimeIntervalObserver = function (__super__) {
    inherits(TimeIntervalObserver, __super__);

    function TimeIntervalObserver(o, s) {
      this._o = o;
      this._s = s;
      this._l = s.now();
      __super__.call(this);
    }

    TimeIntervalObserver.prototype.next = function (x) {
      var now = this._s.now(),
          span = now - this._l;
      this._l = now;
      this._o.onNext({ value: x, interval: span });
    };
    TimeIntervalObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TimeIntervalObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TimeIntervalObserver;
  }(AbstractObserver);

  /**
   *  Records the time interval between consecutive values in an observable sequence.
   *
   * @example
   *  1 - res = source.timeInterval();
   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);
   *
   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.
   * @returns {Observable} An observable sequence with time interval information on values.
   */
  observableProto.timeInterval = function (scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TimeIntervalObservable(this, scheduler);
  };

  var TimestampObservable = function (__super__) {
    inherits(TimestampObservable, __super__);
    function TimestampObservable(source, s) {
      this.source = source;
      this._s = s;
      __super__.call(this);
    }

    TimestampObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TimestampObserver(o, this._s));
    };

    return TimestampObservable;
  }(ObservableBase);

  var TimestampObserver = function (__super__) {
    inherits(TimestampObserver, __super__);
    function TimestampObserver(o, s) {
      this._o = o;
      this._s = s;
      __super__.call(this);
    }

    TimestampObserver.prototype.next = function (x) {
      this._o.onNext({ value: x, timestamp: this._s.now() });
    };

    TimestampObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TimestampObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return TimestampObserver;
  }(AbstractObserver);

  /**
   *  Records the timestamp for each value in an observable sequence.
   *
   * @example
   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }
   *  2 - res = source.timestamp(Rx.Scheduler.default);
   *
   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the default scheduler is used.
   * @returns {Observable} An observable sequence with timestamp information on values.
   */
  observableProto.timestamp = function (scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TimestampObservable(this, scheduler);
  };

  var SampleObservable = function (__super__) {
    inherits(SampleObservable, __super__);
    function SampleObservable(source, sampler) {
      this.source = source;
      this._sampler = sampler;
      __super__.call(this);
    }

    SampleObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        atEnd: false,
        value: null,
        hasValue: false,
        sourceSubscription: new SingleAssignmentDisposable()
      };

      state.sourceSubscription.setDisposable(this.source.subscribe(new SampleSourceObserver(state)));
      return new BinaryDisposable(state.sourceSubscription, this._sampler.subscribe(new SamplerObserver(state)));
    };

    return SampleObservable;
  }(ObservableBase);

  var SamplerObserver = function (__super__) {
    inherits(SamplerObserver, __super__);
    function SamplerObserver(s) {
      this._s = s;
      __super__.call(this);
    }

    SamplerObserver.prototype._handleMessage = function () {
      if (this._s.hasValue) {
        this._s.hasValue = false;
        this._s.o.onNext(this._s.value);
      }
      this._s.atEnd && this._s.o.onCompleted();
    };

    SamplerObserver.prototype.next = function () {
      this._handleMessage();
    };
    SamplerObserver.prototype.error = function (e) {
      this._s.onError(e);
    };
    SamplerObserver.prototype.completed = function () {
      this._handleMessage();
    };

    return SamplerObserver;
  }(AbstractObserver);

  var SampleSourceObserver = function (__super__) {
    inherits(SampleSourceObserver, __super__);
    function SampleSourceObserver(s) {
      this._s = s;
      __super__.call(this);
    }

    SampleSourceObserver.prototype.next = function (x) {
      this._s.hasValue = true;
      this._s.value = x;
    };
    SampleSourceObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    SampleSourceObserver.prototype.completed = function () {
      this._s.atEnd = true;
      this._s.sourceSubscription.dispose();
    };

    return SampleSourceObserver;
  }(AbstractObserver);

  /**
   *  Samples the observable sequence at each interval.
   *
   * @example
   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence
   *  2 - res = source.sample(5000); // 5 seconds
   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds
   *
   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.
   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Sampled observable sequence.
   */
  observableProto.sample = function (intervalOrSampler, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return typeof intervalOrSampler === 'number' ? new SampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : new SampleObservable(this, intervalOrSampler);
  };

  var TimeoutError = Rx.TimeoutError = function (message) {
    this.message = message || 'Timeout has occurred';
    this.name = 'TimeoutError';
    Error.call(this);
  };
  TimeoutError.prototype = Object.create(Error.prototype);

  function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {
    if (isFunction(firstTimeout)) {
      other = timeoutDurationSelector;
      timeoutDurationSelector = firstTimeout;
      firstTimeout = observableNever();
    }
    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));
    return new AnonymousObservable(function (o) {
      var subscription = new SerialDisposable(),
          timer = new SerialDisposable(),
          original = new SingleAssignmentDisposable();

      subscription.setDisposable(original);

      var id = 0,
          switched = false;

      function setTimer(timeout) {
        var myId = id,
            d = new SingleAssignmentDisposable();

        function timerWins() {
          switched = myId === id;
          return switched;
        }

        timer.setDisposable(d);
        d.setDisposable(timeout.subscribe(function () {
          timerWins() && subscription.setDisposable(other.subscribe(o));
          d.dispose();
        }, function (e) {
          timerWins() && o.onError(e);
        }, function () {
          timerWins() && subscription.setDisposable(other.subscribe(o));
        }));
      };

      setTimer(firstTimeout);

      function oWins() {
        var res = !switched;
        if (res) {
          id++;
        }
        return res;
      }

      original.setDisposable(source.subscribe(function (x) {
        if (oWins()) {
          o.onNext(x);
          var timeout = tryCatch(timeoutDurationSelector)(x);
          if (timeout === errorObj) {
            return o.onError(timeout.e);
          }
          setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
        }
      }, function (e) {
        oWins() && o.onError(e);
      }, function () {
        oWins() && o.onCompleted();
      }));
      return new BinaryDisposable(subscription, timer);
    }, source);
  }

  function timeout(source, dueTime, other, scheduler) {
    if (isScheduler(other)) {
      scheduler = other;
      other = observableThrow(new TimeoutError());
    }
    if (other instanceof Error) {
      other = observableThrow(other);
    }
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));
    return new AnonymousObservable(function (o) {
      var id = 0,
          original = new SingleAssignmentDisposable(),
          subscription = new SerialDisposable(),
          switched = false,
          timer = new SerialDisposable();

      subscription.setDisposable(original);

      function createTimer() {
        var myId = id;
        timer.setDisposable(scheduler.scheduleFuture(null, dueTime, function () {
          switched = id === myId;
          if (switched) {
            isPromise(other) && (other = observableFromPromise(other));
            subscription.setDisposable(other.subscribe(o));
          }
        }));
      }

      createTimer();

      original.setDisposable(source.subscribe(function (x) {
        if (!switched) {
          id++;
          o.onNext(x);
          createTimer();
        }
      }, function (e) {
        if (!switched) {
          id++;
          o.onError(e);
        }
      }, function () {
        if (!switched) {
          id++;
          o.onCompleted();
        }
      }));
      return new BinaryDisposable(subscription, timer);
    }, source);
  }

  observableProto.timeout = function () {
    var firstArg = arguments[0];
    if (firstArg instanceof Date || typeof firstArg === 'number') {
      return timeout(this, firstArg, arguments[1], arguments[2]);
    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
      return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);
    } else {
      throw new Error('Invalid arguments');
    }
  };

  var GenerateAbsoluteObservable = function (__super__) {
    inherits(GenerateAbsoluteObservable, __super__);
    function GenerateAbsoluteObservable(state, cndFn, itrFn, resFn, timeFn, s) {
      this._state = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._timeFn = timeFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      state.hasResult && state.o.onNext(state.result);

      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }
      state.hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (state.hasResult === errorObj) {
        return state.o.onError(state.hasResult.e);
      }
      if (state.hasResult) {
        state.result = tryCatch(state.self._resFn)(state.newState);
        if (state.result === errorObj) {
          return state.o.onError(state.result.e);
        }
        var time = tryCatch(state.self._timeFn)(state.newState);
        if (time === errorObj) {
          return state.o.onError(time.e);
        }
        recurse(state, time);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateAbsoluteObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        newState: this._state,
        first: true,
        hasResult: false
      };
      return this._s.scheduleRecursiveFuture(state, new Date(this._s.now()), scheduleRecursive);
    };

    return GenerateAbsoluteObservable;
  }(ObservableBase);

  /**
   *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithAbsoluteTime(0,
   *      function (x) { return return true; },
   *      function (x) { return x + 1; },
   *      function (x) { return x; },
   *      function (x) { return new Date(); }
   *  });
   *
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.
   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns {Observable} The generated sequence.
   */
  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
  };

  var GenerateRelativeObservable = function (__super__) {
    inherits(GenerateRelativeObservable, __super__);
    function GenerateRelativeObservable(state, cndFn, itrFn, resFn, timeFn, s) {
      this._state = state;
      this._cndFn = cndFn;
      this._itrFn = itrFn;
      this._resFn = resFn;
      this._timeFn = timeFn;
      this._s = s;
      __super__.call(this);
    }

    function scheduleRecursive(state, recurse) {
      state.hasResult && state.o.onNext(state.result);

      if (state.first) {
        state.first = false;
      } else {
        state.newState = tryCatch(state.self._itrFn)(state.newState);
        if (state.newState === errorObj) {
          return state.o.onError(state.newState.e);
        }
      }

      state.hasResult = tryCatch(state.self._cndFn)(state.newState);
      if (state.hasResult === errorObj) {
        return state.o.onError(state.hasResult.e);
      }
      if (state.hasResult) {
        state.result = tryCatch(state.self._resFn)(state.newState);
        if (state.result === errorObj) {
          return state.o.onError(state.result.e);
        }
        var time = tryCatch(state.self._timeFn)(state.newState);
        if (time === errorObj) {
          return state.o.onError(time.e);
        }
        recurse(state, time);
      } else {
        state.o.onCompleted();
      }
    }

    GenerateRelativeObservable.prototype.subscribeCore = function (o) {
      var state = {
        o: o,
        self: this,
        newState: this._state,
        first: true,
        hasResult: false
      };
      return this._s.scheduleRecursiveFuture(state, 0, scheduleRecursive);
    };

    return GenerateRelativeObservable;
  }(ObservableBase);

  /**
   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithRelativeTime(0,
   *      function (x) { return return true; },
   *      function (x) { return x + 1; },
   *      function (x) { return x; },
   *      function (x) { return 500; }
   *  );
   *
   * @param {Mixed} initialState Initial state.
   * @param {Function} condition Condition to terminate generation (upon returning false).
   * @param {Function} iterate Iteration step function.
   * @param {Function} resultSelector Selector function for results produced in the sequence.
   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.
   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns {Observable} The generated sequence.
   */
  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
  };

  var DelaySubscription = function (__super__) {
    inherits(DelaySubscription, __super__);
    function DelaySubscription(source, dt, s) {
      this.source = source;
      this._dt = dt;
      this._s = s;
      __super__.call(this);
    }

    DelaySubscription.prototype.subscribeCore = function (o) {
      var d = new SerialDisposable();

      d.setDisposable(this._s.scheduleFuture([this.source, o, d], this._dt, scheduleMethod));

      return d;
    };

    function scheduleMethod(s, state) {
      var source = state[0],
          o = state[1],
          d = state[2];
      d.setDisposable(source.subscribe(o));
    }

    return DelaySubscription;
  }(ObservableBase);

  /**
   *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
   *
   * @example
   *  1 - res = source.delaySubscription(5000); // 5s
   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds
   *
   * @param {Number} dueTime Relative or absolute time shift of the subscription.
   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.
   * @returns {Observable} Time-shifted sequence.
   */
  observableProto.delaySubscription = function (dueTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new DelaySubscription(this, dueTime, scheduler);
  };

  var SkipLastWithTimeObservable = function (__super__) {
    inherits(SkipLastWithTimeObservable, __super__);
    function SkipLastWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    SkipLastWithTimeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new SkipLastWithTimeObserver(o, this));
    };

    return SkipLastWithTimeObservable;
  }(ObservableBase);

  var SkipLastWithTimeObserver = function (__super__) {
    inherits(SkipLastWithTimeObserver, __super__);

    function SkipLastWithTimeObserver(o, p) {
      this._o = o;
      this._s = p._s;
      this._d = p._d;
      this._q = [];
      __super__.call(this);
    }

    SkipLastWithTimeObserver.prototype.next = function (x) {
      var now = this._s.now();
      this._q.push({ interval: now, value: x });
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._o.onNext(this._q.shift().value);
      }
    };
    SkipLastWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipLastWithTimeObserver.prototype.completed = function () {
      var now = this._s.now();
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._o.onNext(this._q.shift().value);
      }
      this._o.onCompleted();
    };

    return SkipLastWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for skipping elements from the end of the sequence.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout
   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
   */
  observableProto.skipLastWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipLastWithTimeObservable(this, duration, scheduler);
  };

  var TakeLastWithTimeObservable = function (__super__) {
    inherits(TakeLastWithTimeObservable, __super__);
    function TakeLastWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    TakeLastWithTimeObservable.prototype.subscribeCore = function (o) {
      return this.source.subscribe(new TakeLastWithTimeObserver(o, this._d, this._s));
    };

    return TakeLastWithTimeObservable;
  }(ObservableBase);

  var TakeLastWithTimeObserver = function (__super__) {
    inherits(TakeLastWithTimeObserver, __super__);

    function TakeLastWithTimeObserver(o, d, s) {
      this._o = o;
      this._d = d;
      this._s = s;
      this._q = [];
      __super__.call(this);
    }

    TakeLastWithTimeObserver.prototype.next = function (x) {
      var now = this._s.now();
      this._q.push({ interval: now, value: x });
      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {
        this._q.shift();
      }
    };
    TakeLastWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    TakeLastWithTimeObserver.prototype.completed = function () {
      var now = this._s.now();
      while (this._q.length > 0) {
        var next = this._q.shift();
        if (now - next.interval <= this._d) {
          this._o.onNext(next.value);
        }
      }
      this._o.onCompleted();
    };

    return TakeLastWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the end of the sequence.
   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.
   */
  observableProto.takeLastWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TakeLastWithTimeObservable(this, duration, scheduler);
  };

  /**
   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the end of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.
   */
  observableProto.takeLastBufferWithTime = function (duration, scheduler) {
    var source = this;
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new AnonymousObservable(function (o) {
      var q = [];
      return source.subscribe(function (x) {
        var now = scheduler.now();
        q.push({ interval: now, value: x });
        while (q.length > 0 && now - q[0].interval >= duration) {
          q.shift();
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        var now = scheduler.now(),
            res = [];
        while (q.length > 0) {
          var next = q.shift();
          now - next.interval <= duration && res.push(next.value);
        }
        o.onNext(res);
        o.onCompleted();
      });
    }, source);
  };

  var TakeWithTimeObservable = function (__super__) {
    inherits(TakeWithTimeObservable, __super__);
    function TakeWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      __super__.call(this);
    }

    function scheduleMethod(s, o) {
      o.onCompleted();
    }

    TakeWithTimeObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._s.scheduleFuture(o, this._d, scheduleMethod), this.source.subscribe(o));
    };

    return TakeWithTimeObservable;
  }(ObservableBase);

  /**
   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   *
   * @example
   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);
   * @description
   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
   *  result sequence. This causes elements to be delayed with duration.
   * @param {Number} duration Duration for taking elements from the start of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.
   */
  observableProto.takeWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new TakeWithTimeObservable(this, duration, scheduler);
  };

  var SkipWithTimeObservable = function (__super__) {
    inherits(SkipWithTimeObservable, __super__);
    function SkipWithTimeObservable(source, d, s) {
      this.source = source;
      this._d = d;
      this._s = s;
      this._open = false;
      __super__.call(this);
    }

    function scheduleMethod(s, self) {
      self._open = true;
    }

    SkipWithTimeObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._s.scheduleFuture(this, this._d, scheduleMethod), this.source.subscribe(new SkipWithTimeObserver(o, this)));
    };

    return SkipWithTimeObservable;
  }(ObservableBase);

  var SkipWithTimeObserver = function (__super__) {
    inherits(SkipWithTimeObserver, __super__);

    function SkipWithTimeObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipWithTimeObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };
    SkipWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipWithTimeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   * @description
   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.
   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded
   *  may not execute immediately, despite the zero due time.
   *
   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.
   * @param {Number} duration Duration for skipping elements from the start of the sequence.
   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
   */
  observableProto.skipWithTime = function (duration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipWithTimeObservable(this, duration, scheduler);
  };

  var SkipUntilWithTimeObservable = function (__super__) {
    inherits(SkipUntilWithTimeObservable, __super__);
    function SkipUntilWithTimeObservable(source, startTime, scheduler) {
      this.source = source;
      this._st = startTime;
      this._s = scheduler;
      __super__.call(this);
    }

    function scheduleMethod(s, state) {
      state._open = true;
    }

    SkipUntilWithTimeObservable.prototype.subscribeCore = function (o) {
      this._open = false;
      return new BinaryDisposable(this._s.scheduleFuture(this, this._st, scheduleMethod), this.source.subscribe(new SkipUntilWithTimeObserver(o, this)));
    };

    return SkipUntilWithTimeObservable;
  }(ObservableBase);

  var SkipUntilWithTimeObserver = function (__super__) {
    inherits(SkipUntilWithTimeObserver, __super__);

    function SkipUntilWithTimeObserver(o, p) {
      this._o = o;
      this._p = p;
      __super__.call(this);
    }

    SkipUntilWithTimeObserver.prototype.next = function (x) {
      this._p._open && this._o.onNext(x);
    };
    SkipUntilWithTimeObserver.prototype.error = function (e) {
      this._o.onError(e);
    };
    SkipUntilWithTimeObserver.prototype.completed = function () {
      this._o.onCompleted();
    };

    return SkipUntilWithTimeObserver;
  }(AbstractObserver);

  /**
   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.
   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.
   *
   * @examples
   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);
   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);
   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.
   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.
   */
  observableProto.skipUntilWithTime = function (startTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    return new SkipUntilWithTimeObservable(this, startTime, scheduler);
  };

  /**
   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.
   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.
   * @param {Scheduler} [scheduler] Scheduler to run the timer on.
   * @returns {Observable} An observable sequence with the elements taken until the specified end time.
   */
  observableProto.takeUntilWithTime = function (endTime, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    var source = this;
    return new AnonymousObservable(function (o) {
      return new BinaryDisposable(scheduler.scheduleFuture(o, endTime, function (_, o) {
        o.onCompleted();
      }), source.subscribe(o));
    }, source);
  };

  /**
   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.
   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item
   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.
   * @returns {Observable} An Observable that performs the throttle operation.
   */
  observableProto.throttle = function (windowDuration, scheduler) {
    isScheduler(scheduler) || (scheduler = defaultScheduler);
    var duration = +windowDuration || 0;
    if (duration <= 0) {
      throw new RangeError('windowDuration cannot be less or equal zero.');
    }
    var source = this;
    return new AnonymousObservable(function (o) {
      var lastOnNext = 0;
      return source.subscribe(function (x) {
        var now = scheduler.now();
        if (lastOnNext === 0 || now - lastOnNext >= duration) {
          lastOnNext = now;
          o.onNext(x);
        }
      }, function (e) {
        o.onError(e);
      }, function () {
        o.onCompleted();
      });
    }, source);
  };

  var TransduceObserver = function (__super__) {
    inherits(TransduceObserver, __super__);
    function TransduceObserver(o, xform) {
      this._o = o;
      this._xform = xform;
      __super__.call(this);
    }

    TransduceObserver.prototype.next = function (x) {
      var res = tryCatch(this._xform['@@transducer/step']).call(this._xform, this._o, x);
      if (res === errorObj) {
        this._o.onError(res.e);
      }
    };

    TransduceObserver.prototype.error = function (e) {
      this._o.onError(e);
    };

    TransduceObserver.prototype.completed = function () {
      this._xform['@@transducer/result'](this._o);
    };

    return TransduceObserver;
  }(AbstractObserver);

  function transformForObserver(o) {
    return {
      '@@transducer/init': function transducerInit() {
        return o;
      },
      '@@transducer/step': function transducerStep(obs, input) {
        return obs.onNext(input);
      },
      '@@transducer/result': function transducerResult(obs) {
        return obs.onCompleted();
      }
    };
  }

  /**
   * Executes a transducer to transform the observable sequence
   * @param {Transducer} transducer A transducer to execute
   * @returns {Observable} An Observable sequence containing the results from the transducer.
   */
  observableProto.transduce = function (transducer) {
    var source = this;
    return new AnonymousObservable(function (o) {
      var xform = transducer(transformForObserver(o));
      return source.subscribe(new TransduceObserver(o, xform));
    }, source);
  };

  var SwitchFirstObservable = function (__super__) {
    inherits(SwitchFirstObservable, __super__);
    function SwitchFirstObservable(source) {
      this.source = source;
      __super__.call(this);
    }

    SwitchFirstObservable.prototype.subscribeCore = function (o) {
      var m = new SingleAssignmentDisposable(),
          g = new CompositeDisposable(),
          state = {
        hasCurrent: false,
        isStopped: false,
        o: o,
        g: g
      };

      g.add(m);
      m.setDisposable(this.source.subscribe(new SwitchFirstObserver(state)));
      return g;
    };

    return SwitchFirstObservable;
  }(ObservableBase);

  var SwitchFirstObserver = function (__super__) {
    inherits(SwitchFirstObserver, __super__);
    function SwitchFirstObserver(state) {
      this._s = state;
      __super__.call(this);
    }

    SwitchFirstObserver.prototype.next = function (x) {
      if (!this._s.hasCurrent) {
        this._s.hasCurrent = true;
        isPromise(x) && (x = observableFromPromise(x));
        var inner = new SingleAssignmentDisposable();
        this._s.g.add(inner);
        inner.setDisposable(x.subscribe(new InnerObserver(this._s, inner)));
      }
    };

    SwitchFirstObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };

    SwitchFirstObserver.prototype.completed = function () {
      this._s.isStopped = true;
      !this._s.hasCurrent && this._s.g.length === 1 && this._s.o.onCompleted();
    };

    inherits(InnerObserver, __super__);
    function InnerObserver(state, inner) {
      this._s = state;
      this._i = inner;
      __super__.call(this);
    }

    InnerObserver.prototype.next = function (x) {
      this._s.o.onNext(x);
    };
    InnerObserver.prototype.error = function (e) {
      this._s.o.onError(e);
    };
    InnerObserver.prototype.completed = function () {
      this._s.g.remove(this._i);
      this._s.hasCurrent = false;
      this._s.isStopped && this._s.g.length === 1 && this._s.o.onCompleted();
    };

    return SwitchFirstObserver;
  }(AbstractObserver);

  /**
   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.
   */
  observableProto.switchFirst = function () {
    return new SwitchFirstObservable(this);
  };

  observableProto.flatMapFirst = observableProto.exhaustMap = function (selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
  };

  observableProto.flatMapWithMaxConcurrent = observableProto.flatMapMaxConcurrent = function (limit, selector, resultSelector, thisArg) {
    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
  };

  /** Provides a set of extension methods for virtual time scheduling. */
  var VirtualTimeScheduler = Rx.VirtualTimeScheduler = function (__super__) {
    inherits(VirtualTimeScheduler, __super__);

    /**
     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.
     *
     * @constructor
     * @param {Number} initialClock Initial value for the clock.
     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
     */
    function VirtualTimeScheduler(initialClock, comparer) {
      this.clock = initialClock;
      this.comparer = comparer;
      this.isEnabled = false;
      this.queue = new PriorityQueue(1024);
      __super__.call(this);
    }

    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

    VirtualTimeSchedulerPrototype.now = function () {
      return this.toAbsoluteTime(this.clock);
    };

    VirtualTimeSchedulerPrototype.schedule = function (state, action) {
      return this.scheduleAbsolute(state, this.clock, action);
    };

    VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {
      var dt = dueTime instanceof Date ? this.toRelativeTime(dueTime - this.now()) : this.toRelativeTime(dueTime);

      return this.scheduleRelative(state, dt, action);
    };

    /**
     * Adds a relative time value to an absolute time value.
     * @param {Number} absolute Absolute virtual time value.
     * @param {Number} relative Relative virtual time value to add.
     * @return {Number} Resulting absolute virtual time sum value.
     */
    VirtualTimeSchedulerPrototype.add = notImplemented;

    /**
     * Converts an absolute time to a number
     * @param {Any} The absolute time.
     * @returns {Number} The absolute time in ms
     */
    VirtualTimeSchedulerPrototype.toAbsoluteTime = notImplemented;

    /**
     * Converts the TimeSpan value to a relative virtual time value.
     * @param {Number} timeSpan TimeSpan value to convert.
     * @return {Number} Corresponding relative virtual time value.
     */
    VirtualTimeSchedulerPrototype.toRelativeTime = notImplemented;

    /**
     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.
     * @param {Mixed} state Initial state passed to the action upon the first iteration.
     * @param {Number} period Period for running the work periodically.
     * @param {Function} action Action to be executed, potentially updating the state.
     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
     */
    VirtualTimeSchedulerPrototype.schedulePeriodic = function (state, period, action) {
      var s = new SchedulePeriodicRecursive(this, state, period, action);
      return s.start();
    };

    /**
     * Schedules an action to be executed after dueTime.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Number} dueTime Relative time after which to execute the action.
     * @param {Function} action Action to be executed.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    VirtualTimeSchedulerPrototype.scheduleRelative = function (state, dueTime, action) {
      var runAt = this.add(this.clock, dueTime);
      return this.scheduleAbsolute(state, runAt, action);
    };

    /**
     * Starts the virtual time scheduler.
     */
    VirtualTimeSchedulerPrototype.start = function () {
      if (!this.isEnabled) {
        this.isEnabled = true;
        do {
          var next = this.getNext();
          if (next !== null) {
            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
            next.invoke();
          } else {
            this.isEnabled = false;
          }
        } while (this.isEnabled);
      }
    };

    /**
     * Stops the virtual time scheduler.
     */
    VirtualTimeSchedulerPrototype.stop = function () {
      this.isEnabled = false;
    };

    /**
     * Advances the scheduler's clock to the specified time, running all work till that point.
     * @param {Number} time Absolute time to advance the scheduler's clock to.
     */
    VirtualTimeSchedulerPrototype.advanceTo = function (time) {
      var dueToClock = this.comparer(this.clock, time);
      if (this.comparer(this.clock, time) > 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (dueToClock === 0) {
        return;
      }
      if (!this.isEnabled) {
        this.isEnabled = true;
        do {
          var next = this.getNext();
          if (next !== null && this.comparer(next.dueTime, time) <= 0) {
            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
            next.invoke();
          } else {
            this.isEnabled = false;
          }
        } while (this.isEnabled);
        this.clock = time;
      }
    };

    /**
     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.
     * @param {Number} time Relative time to advance the scheduler's clock by.
     */
    VirtualTimeSchedulerPrototype.advanceBy = function (time) {
      var dt = this.add(this.clock, time),
          dueToClock = this.comparer(this.clock, dt);
      if (dueToClock > 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (dueToClock === 0) {
        return;
      }

      this.advanceTo(dt);
    };

    /**
     * Advances the scheduler's clock by the specified relative time.
     * @param {Number} time Relative time to advance the scheduler's clock by.
     */
    VirtualTimeSchedulerPrototype.sleep = function (time) {
      var dt = this.add(this.clock, time);
      if (this.comparer(this.clock, dt) >= 0) {
        throw new ArgumentOutOfRangeError();
      }

      this.clock = dt;
    };

    /**
     * Gets the next scheduled item to be executed.
     * @returns {ScheduledItem} The next scheduled item.
     */
    VirtualTimeSchedulerPrototype.getNext = function () {
      while (this.queue.length > 0) {
        var next = this.queue.peek();
        if (next.isCancelled()) {
          this.queue.dequeue();
        } else {
          return next;
        }
      }
      return null;
    };

    /**
     * Schedules an action to be executed at dueTime.
     * @param {Mixed} state State passed to the action to be executed.
     * @param {Number} dueTime Absolute time at which to execute the action.
     * @param {Function} action Action to be executed.
     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
     */
    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (state, dueTime, action) {
      var self = this;

      function run(scheduler, state1) {
        self.queue.remove(si);
        return action(scheduler, state1);
      }

      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
      this.queue.enqueue(si);

      return si.disposable;
    };

    return VirtualTimeScheduler;
  }(Scheduler);

  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */
  Rx.HistoricalScheduler = function (__super__) {
    inherits(HistoricalScheduler, __super__);

    /**
     * Creates a new historical scheduler with the specified initial clock value.
     * @constructor
     * @param {Number} initialClock Initial value for the clock.
     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
     */
    function HistoricalScheduler(initialClock, comparer) {
      var clock = initialClock == null ? 0 : initialClock;
      var cmp = comparer || defaultSubComparer;
      __super__.call(this, clock, cmp);
    }

    var HistoricalSchedulerProto = HistoricalScheduler.prototype;

    /**
     * Adds a relative time value to an absolute time value.
     * @param {Number} absolute Absolute virtual time value.
     * @param {Number} relative Relative virtual time value to add.
     * @return {Number} Resulting absolute virtual time sum value.
     */
    HistoricalSchedulerProto.add = function (absolute, relative) {
      return absolute + relative;
    };

    HistoricalSchedulerProto.toAbsoluteTime = function (absolute) {
      return new Date(absolute).getTime();
    };

    /**
     * Converts the TimeSpan value to a relative virtual time value.
     * @memberOf HistoricalScheduler
     * @param {Number} timeSpan TimeSpan value to convert.
     * @return {Number} Corresponding relative virtual time value.
     */
    HistoricalSchedulerProto.toRelativeTime = function (timeSpan) {
      return timeSpan;
    };

    return HistoricalScheduler;
  }(Rx.VirtualTimeScheduler);

  function OnNextPredicate(predicate) {
    this.predicate = predicate;
  }

  OnNextPredicate.prototype.equals = function (other) {
    if (other === this) {
      return true;
    }
    if (other == null) {
      return false;
    }
    if (other.kind !== 'N') {
      return false;
    }
    return this.predicate(other.value);
  };

  function OnErrorPredicate(predicate) {
    this.predicate = predicate;
  }

  OnErrorPredicate.prototype.equals = function (other) {
    if (other === this) {
      return true;
    }
    if (other == null) {
      return false;
    }
    if (other.kind !== 'E') {
      return false;
    }
    return this.predicate(other.error);
  };

  var ReactiveTest = Rx.ReactiveTest = {
    /** Default virtual time used for creation of observable sequences in unit tests. */
    created: 100,
    /** Default virtual time used to subscribe to observable sequences in unit tests. */
    subscribed: 200,
    /** Default virtual time used to dispose subscriptions in unit tests. */
    disposed: 1000,

    /**
     * Factory method for an OnNext notification record at a given time with a given value or a predicate function.
     *
     * 1 - ReactiveTest.onNext(200, 42);
     * 2 - ReactiveTest.onNext(200, function (x) { return x.length == 2; });
     *
     * @param ticks Recorded virtual time the OnNext notification occurs.
     * @param value Recorded value stored in the OnNext notification or a predicate.
     * @return Recorded OnNext notification.
     */
    onNext: function onNext(ticks, value) {
      return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
    },
    /**
     * Factory method for an OnError notification record at a given time with a given error.
     *
     * 1 - ReactiveTest.onNext(200, new Error('error'));
     * 2 - ReactiveTest.onNext(200, function (e) { return e.message === 'error'; });
     *
     * @param ticks Recorded virtual time the OnError notification occurs.
     * @param exception Recorded exception stored in the OnError notification.
     * @return Recorded OnError notification.
     */
    onError: function onError(ticks, error) {
      return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
    },
    /**
     * Factory method for an OnCompleted notification record at a given time.
     *
     * @param ticks Recorded virtual time the OnCompleted notification occurs.
     * @return Recorded OnCompleted notification.
     */
    onCompleted: function onCompleted(ticks) {
      return new Recorded(ticks, Notification.createOnCompleted());
    },
    /**
     * Factory method for a subscription record based on a given subscription and disposal time.
     *
     * @param start Virtual time indicating when the subscription was created.
     * @param end Virtual time indicating when the subscription was disposed.
     * @return Subscription object.
     */
    subscribe: function subscribe(start, end) {
      return new Subscription(start, end);
    }
  };

  /**
   * Creates a new object recording the production of the specified value at the given virtual time.
   *
   * @constructor
   * @param {Number} time Virtual time the value was produced on.
   * @param {Mixed} value Value that was produced.
   * @param {Function} comparer An optional comparer.
   */
  var Recorded = Rx.Recorded = function (time, value, comparer) {
    this.time = time;
    this.value = value;
    this.comparer = comparer || defaultComparer;
  };

  /**
   * Checks whether the given recorded object is equal to the current instance.
   *
   * @param {Recorded} other Recorded object to check for equality.
   * @returns {Boolean} true if both objects are equal; false otherwise.
   */
  Recorded.prototype.equals = function (other) {
    return this.time === other.time && this.comparer(this.value, other.value);
  };

  /**
   * Returns a string representation of the current Recorded value.
   *
   * @returns {String} String representation of the current Recorded value.
   */
  Recorded.prototype.toString = function () {
    return this.value.toString() + '@' + this.time;
  };

  /**
   * Creates a new subscription object with the given virtual subscription and unsubscription time.
   *
   * @constructor
   * @param {Number} subscribe Virtual time at which the subscription occurred.
   * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.
   */
  var Subscription = Rx.Subscription = function (start, end) {
    this.subscribe = start;
    this.unsubscribe = end || Number.MAX_VALUE;
  };

  /**
   * Checks whether the given subscription is equal to the current instance.
   * @param other Subscription object to check for equality.
   * @returns {Boolean} true if both objects are equal; false otherwise.
   */
  Subscription.prototype.equals = function (other) {
    return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
  };

  /**
   * Returns a string representation of the current Subscription value.
   * @returns {String} String representation of the current Subscription value.
   */
  Subscription.prototype.toString = function () {
    return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
  };

  var MockDisposable = Rx.MockDisposable = function (scheduler) {
    this.scheduler = scheduler;
    this.disposes = [];
    this.disposes.push(this.scheduler.clock);
  };

  MockDisposable.prototype.dispose = function () {
    this.disposes.push(this.scheduler.clock);
  };

  var MockObserver = function (__super__) {
    inherits(MockObserver, __super__);

    function MockObserver(scheduler) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = [];
    }

    var MockObserverPrototype = MockObserver.prototype;

    MockObserverPrototype.onNext = function (value) {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
    };

    MockObserverPrototype.onError = function (e) {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(e)));
    };

    MockObserverPrototype.onCompleted = function () {
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
    };

    return MockObserver;
  }(Observer);

  function MockPromise(scheduler, messages) {
    var self = this;
    this.scheduler = scheduler;
    this.messages = messages;
    this.subscriptions = [];
    this.observers = [];
    for (var i = 0, len = this.messages.length; i < len; i++) {
      var message = this.messages[i],
          notification = message.value;
      (function (innerNotification) {
        scheduler.scheduleAbsolute(null, message.time, function () {
          var obs = self.observers.slice(0);

          for (var j = 0, jLen = obs.length; j < jLen; j++) {
            innerNotification.accept(obs[j]);
          }
          return disposableEmpty;
        });
      })(notification);
    }
  }

  MockPromise.prototype.then = function (onResolved, onRejected) {
    var self = this;

    this.subscriptions.push(new Subscription(this.scheduler.clock));
    var index = this.subscriptions.length - 1;

    var newPromise;

    var observer = Rx.Observer.create(function (x) {
      var retValue = onResolved(x);
      if (retValue && typeof retValue.then === 'function') {
        newPromise = retValue;
      } else {
        var ticks = self.scheduler.clock;
        newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
      }
      var idx = self.observers.indexOf(observer);
      self.observers.splice(idx, 1);
      self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
    }, function (err) {
      onRejected(err);
      var idx = self.observers.indexOf(observer);
      self.observers.splice(idx, 1);
      self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
    });
    this.observers.push(observer);

    return newPromise || new MockPromise(this.scheduler, this.messages);
  };

  var HotObservable = function (__super__) {
    inherits(HotObservable, __super__);

    function HotObservable(scheduler, messages) {
      __super__.call(this);
      var message,
          notification,
          observable = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0, len = this.messages.length; i < len; i++) {
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) {
          scheduler.scheduleAbsolute(null, message.time, function () {
            var obs = observable.observers.slice(0);

            for (var j = 0, jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }

    HotObservable.prototype._subscribe = function (o) {
      var observable = this;
      this.observers.push(o);
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      return disposableCreate(function () {
        var idx = observable.observers.indexOf(o);
        observable.observers.splice(idx, 1);
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
      });
    };

    return HotObservable;
  }(Observable);

  var ColdObservable = function (__super__) {
    inherits(ColdObservable, __super__);

    function ColdObservable(scheduler, messages) {
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
    }

    ColdObservable.prototype._subscribe = function (o) {
      var message,
          notification,
          observable = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var d = new CompositeDisposable();
      for (var i = 0, len = this.messages.length; i < len; i++) {
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) {
          d.add(observable.scheduler.scheduleRelative(null, message.time, function () {
            innerNotification.accept(o);
            return disposableEmpty;
          }));
        })(notification);
      }
      return disposableCreate(function () {
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        d.dispose();
      });
    };

    return ColdObservable;
  }(Observable);

  /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */
  Rx.TestScheduler = function (__super__) {
    inherits(TestScheduler, __super__);

    function baseComparer(x, y) {
      return x > y ? 1 : x < y ? -1 : 0;
    }

    function TestScheduler() {
      __super__.call(this, 0, baseComparer);
    }

    /**
     * Schedules an action to be executed at the specified virtual time.
     *
     * @param state State passed to the action to be executed.
     * @param dueTime Absolute virtual time at which to execute the action.
     * @param action Action to be executed.
     * @return Disposable object used to cancel the scheduled action (best effort).
     */
    TestScheduler.prototype.scheduleAbsolute = function (state, dueTime, action) {
      dueTime <= this.clock && (dueTime = this.clock + 1);
      return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);
    };
    /**
     * Adds a relative virtual time to an absolute virtual time value.
     *
     * @param absolute Absolute virtual time value.
     * @param relative Relative virtual time value to add.
     * @return Resulting absolute virtual time sum value.
     */
    TestScheduler.prototype.add = function (absolute, relative) {
      return absolute + relative;
    };
    /**
     * Converts the absolute virtual time value to a DateTimeOffset value.
     *
     * @param absolute Absolute virtual time value to convert.
     * @return Corresponding DateTimeOffset value.
     */
    TestScheduler.prototype.toAbsoluteTime = function (absolute) {
      return new Date(absolute).getTime();
    };
    /**
     * Converts the TimeSpan value to a relative virtual time value.
     *
     * @param timeSpan TimeSpan value to convert.
     * @return Corresponding relative virtual time value.
     */
    TestScheduler.prototype.toRelativeTime = function (timeSpan) {
      return timeSpan;
    };
    /**
     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
     *
     * @param create Factory method to create an observable sequence.
     * @param created Virtual time at which to invoke the factory to create an observable sequence.
     * @param subscribed Virtual time at which to subscribe to the created observable sequence.
     * @param disposed Virtual time at which to dispose the subscription.
     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.
     */
    TestScheduler.prototype.startScheduler = function (createFn, settings) {
      settings || (settings = {});
      settings.created == null && (settings.created = ReactiveTest.created);
      settings.subscribed == null && (settings.subscribed = ReactiveTest.subscribed);
      settings.disposed == null && (settings.disposed = ReactiveTest.disposed);

      var observer = this.createObserver(),
          source,
          subscription;

      this.scheduleAbsolute(null, settings.created, function () {
        source = createFn();
        return disposableEmpty;
      });

      this.scheduleAbsolute(null, settings.subscribed, function () {
        subscription = source.subscribe(observer);
        return disposableEmpty;
      });

      this.scheduleAbsolute(null, settings.disposed, function () {
        subscription.dispose();
        return disposableEmpty;
      });

      this.start();

      return observer;
    };

    /**
     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.
     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createHotObservable = function () {
      var len = arguments.length,
          args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return new HotObservable(this, args);
    };

    /**
     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.
     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createColdObservable = function () {
      var len = arguments.length,
          args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return new ColdObservable(this, args);
    };

    /**
     * Creates a resolved promise with the given value and ticks
     * @param {Number} ticks The absolute time of the resolution.
     * @param {Any} value The value to yield at the given tick.
     * @returns {MockPromise} A mock Promise which fulfills with the given value.
     */
    TestScheduler.prototype.createResolvedPromise = function (ticks, value) {
      return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
    };

    /**
     * Creates a rejected promise with the given reason and ticks
     * @param {Number} ticks The absolute time of the resolution.
     * @param {Any} reason The reason for rejection to yield at the given tick.
     * @returns {MockPromise} A mock Promise which rejects with the given reason.
     */
    TestScheduler.prototype.createRejectedPromise = function (ticks, reason) {
      return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
    };

    /**
     * Creates an observer that records received notification messages and timestamps those.
     * @return Observer that can be used to assert the timing of received notifications.
     */
    TestScheduler.prototype.createObserver = function () {
      return new MockObserver(this);
    };

    return TestScheduler;
  }(VirtualTimeScheduler);

  var AnonymousObservable = Rx.AnonymousObservable = function (__super__) {
    inherits(AnonymousObservable, __super__);

    // Fix subscriber to check for undefined or function returned to decorate as Disposable
    function fixSubscriber(subscriber) {
      return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
    }

    function setDisposable(s, state) {
      var ado = state[0],
          self = state[1];
      var sub = tryCatch(self.__subscribe).call(self, ado);
      if (sub === errorObj && !ado.fail(errorObj.e)) {
        thrower(errorObj.e);
      }
      ado.setDisposable(fixSubscriber(sub));
    }

    function AnonymousObservable(subscribe, parent) {
      this.source = parent;
      this.__subscribe = subscribe;
      __super__.call(this);
    }

    AnonymousObservable.prototype._subscribe = function (o) {
      var ado = new AutoDetachObserver(o),
          state = [ado, this];

      if (currentThreadScheduler.scheduleRequired()) {
        currentThreadScheduler.schedule(state, setDisposable);
      } else {
        setDisposable(null, state);
      }
      return ado;
    };

    return AnonymousObservable;
  }(Observable);

  var AutoDetachObserver = function (__super__) {
    inherits(AutoDetachObserver, __super__);

    function AutoDetachObserver(observer) {
      __super__.call(this);
      this.observer = observer;
      this.m = new SingleAssignmentDisposable();
    }

    var AutoDetachObserverPrototype = AutoDetachObserver.prototype;

    AutoDetachObserverPrototype.next = function (value) {
      var result = tryCatch(this.observer.onNext).call(this.observer, value);
      if (result === errorObj) {
        this.dispose();
        thrower(result.e);
      }
    };

    AutoDetachObserverPrototype.error = function (err) {
      var result = tryCatch(this.observer.onError).call(this.observer, err);
      this.dispose();
      result === errorObj && thrower(result.e);
    };

    AutoDetachObserverPrototype.completed = function () {
      var result = tryCatch(this.observer.onCompleted).call(this.observer);
      this.dispose();
      result === errorObj && thrower(result.e);
    };

    AutoDetachObserverPrototype.setDisposable = function (value) {
      this.m.setDisposable(value);
    };
    AutoDetachObserverPrototype.getDisposable = function () {
      return this.m.getDisposable();
    };

    AutoDetachObserverPrototype.dispose = function () {
      __super__.prototype.dispose.call(this);
      this.m.dispose();
    };

    return AutoDetachObserver;
  }(AbstractObserver);

  var UnderlyingObservable = function (__super__) {
    inherits(UnderlyingObservable, __super__);
    function UnderlyingObservable(m, u) {
      this._m = m;
      this._u = u;
      __super__.call(this);
    }

    UnderlyingObservable.prototype.subscribeCore = function (o) {
      return new BinaryDisposable(this._m.getDisposable(), this._u.subscribe(o));
    };

    return UnderlyingObservable;
  }(ObservableBase);

  var GroupedObservable = function (__super__) {
    inherits(GroupedObservable, __super__);
    function GroupedObservable(key, underlyingObservable, mergedDisposable) {
      __super__.call(this);
      this.key = key;
      this.underlyingObservable = !mergedDisposable ? underlyingObservable : new UnderlyingObservable(mergedDisposable, underlyingObservable);
    }

    GroupedObservable.prototype._subscribe = function (o) {
      return this.underlyingObservable.subscribe(o);
    };

    return GroupedObservable;
  }(Observable);

  /**
   *  Represents an object that is both an observable sequence as well as an observer.
   *  Each notification is broadcasted to all subscribed observers.
   */
  var Subject = Rx.Subject = function (__super__) {
    inherits(Subject, __super__);
    function Subject() {
      __super__.call(this);
      this.isDisposed = false;
      this.isStopped = false;
      this.observers = [];
      this.hasError = false;
    }

    addProperties(Subject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(o);
          return new InnerSubscription(this, o);
        }
        if (this.hasError) {
          o.onError(this.error);
          return disposableEmpty;
        }
        o.onCompleted();
        return disposableEmpty;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onCompleted();
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onError(error);
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (!this.isStopped) {
          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        }
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
      }
    });

    /**
     * Creates a subject from the specified observer and observable.
     * @param {Observer} observer The observer used to send messages to the subject.
     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.
     * @returns {Subject} Subject implemented using the given observer and observable.
     */
    Subject.create = function (observer, observable) {
      return new AnonymousSubject(observer, observable);
    };

    return Subject;
  }(Observable);

  /**
   *  Represents the result of an asynchronous operation.
   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
   */
  var AsyncSubject = Rx.AsyncSubject = function (__super__) {
    inherits(AsyncSubject, __super__);

    /**
     * Creates a subject that can only receive one value and that value is cached for all future observations.
     * @constructor
     */
    function AsyncSubject() {
      __super__.call(this);
      this.isDisposed = false;
      this.isStopped = false;
      this.hasValue = false;
      this.observers = [];
      this.hasError = false;
    }

    addProperties(AsyncSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);

        if (!this.isStopped) {
          this.observers.push(o);
          return new InnerSubscription(this, o);
        }

        if (this.hasError) {
          o.onError(this.error);
        } else if (this.hasValue) {
          o.onNext(this.value);
          o.onCompleted();
        } else {
          o.onCompleted();
        }

        return disposableEmpty;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
       */
      onCompleted: function onCompleted() {
        var i, len;
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          var os = cloneArray(this.observers),
              len = os.length;

          if (this.hasValue) {
            for (i = 0; i < len; i++) {
              var o = os[i];
              o.onNext(this.value);
              o.onCompleted();
            }
          } else {
            for (i = 0; i < len; i++) {
              os[i].onCompleted();
            }
          }

          this.observers.length = 0;
        }
      },
      /**
       * Notifies all subscribed observers about the error.
       * @param {Mixed} error The Error to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasError = true;
          this.error = error;

          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
            os[i].onError(error);
          }

          this.observers.length = 0;
        }
      },
      /**
       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
       * @param {Mixed} value The value to store in the subject.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.value = value;
        this.hasValue = true;
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
        this.error = null;
        this.value = null;
      }
    });

    return AsyncSubject;
  }(Observable);

  /**
   *  Represents a value that changes over time.
   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
   */
  var BehaviorSubject = Rx.BehaviorSubject = function (__super__) {
    inherits(BehaviorSubject, __super__);
    function BehaviorSubject(value) {
      __super__.call(this);
      this.value = value;
      this.observers = [];
      this.isDisposed = false;
      this.isStopped = false;
      this.hasError = false;
    }

    addProperties(BehaviorSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(o);
          o.onNext(this.value);
          return new InnerSubscription(this, o);
        }
        if (this.hasError) {
          o.onError(this.error);
        } else {
          o.onCompleted();
        }
        return disposableEmpty;
      },
      /**
       * Gets the current value or throws an exception.
       * Value is frozen after onCompleted is called.
       * After onError is called always throws the specified exception.
       * An exception is always thrown after dispose is called.
       * @returns {Mixed} The initial value passed to the constructor until onNext is called; after which, the last value passed to onNext.
       */
      getValue: function getValue() {
        checkDisposed(this);
        if (this.hasError) {
          thrower(this.error);
        }
        return this.value;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onCompleted();
        }

        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.hasError = true;
        this.error = error;

        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onError(error);
        }

        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.value = value;
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          os[i].onNext(value);
        }
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
        this.value = null;
        this.error = null;
      }
    });

    return BehaviorSubject;
  }(Observable);

  /**
   * Represents an object that is both an observable sequence as well as an observer.
   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
   */
  var ReplaySubject = Rx.ReplaySubject = function (__super__) {

    var maxSafeInteger = Math.pow(2, 53) - 1;

    function createRemovableDisposable(subject, observer) {
      return disposableCreate(function () {
        observer.dispose();
        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
      });
    }

    inherits(ReplaySubject, __super__);

    /**
     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.
     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.
     *  @param {Number} [windowSize] Maximum time length of the replay buffer.
     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.
     */
    function ReplaySubject(bufferSize, windowSize, scheduler) {
      this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
      this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
      this.scheduler = scheduler || currentThreadScheduler;
      this.q = [];
      this.observers = [];
      this.isStopped = false;
      this.isDisposed = false;
      this.hasError = false;
      this.error = null;
      __super__.call(this);
    }

    addProperties(ReplaySubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        checkDisposed(this);
        var so = new ScheduledObserver(this.scheduler, o),
            subscription = createRemovableDisposable(this, so);

        this._trim(this.scheduler.now());
        this.observers.push(so);

        for (var i = 0, len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }

        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }

        so.ensureActive();
        return subscription;
      },
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function hasObservers() {
        checkDisposed(this);return this.observers.length > 0;
      },
      _trim: function _trim(now) {
        while (this.q.length > this.bufferSize) {
          this.q.shift();
        }
        while (this.q.length > 0 && now - this.q[0].interval > this.windowSize) {
          this.q.shift();
        }
      },
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param {Mixed} value The value to send to all observers.
       */
      onNext: function onNext(value) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        var now = this.scheduler.now();
        this.q.push({ interval: now, value: value });
        this._trim(now);

        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onNext(value);
          observer.ensureActive();
        }
      },
      /**
       * Notifies all subscribed observers about the exception.
       * @param {Mixed} error The exception to send to all observers.
       */
      onError: function onError(error) {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        this.error = error;
        this.hasError = true;
        var now = this.scheduler.now();
        this._trim(now);
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onError(error);
          observer.ensureActive();
        }
        this.observers.length = 0;
      },
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function onCompleted() {
        checkDisposed(this);
        if (this.isStopped) {
          return;
        }
        this.isStopped = true;
        var now = this.scheduler.now();
        this._trim(now);
        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
          var observer = os[i];
          observer.onCompleted();
          observer.ensureActive();
        }
        this.observers.length = 0;
      },
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function dispose() {
        this.isDisposed = true;
        this.observers = null;
      }
    });

    return ReplaySubject;
  }(Observable);

  var AnonymousSubject = Rx.AnonymousSubject = function (__super__) {
    inherits(AnonymousSubject, __super__);
    function AnonymousSubject(observer, observable) {
      this.observer = observer;
      this.observable = observable;
      __super__.call(this);
    }

    addProperties(AnonymousSubject.prototype, Observer.prototype, {
      _subscribe: function _subscribe(o) {
        return this.observable.subscribe(o);
      },
      onCompleted: function onCompleted() {
        this.observer.onCompleted();
      },
      onError: function onError(error) {
        this.observer.onError(error);
      },
      onNext: function onNext(value) {
        this.observer.onNext(value);
      }
    });

    return AnonymousSubject;
  }(Observable);

  /**
  * Used to pause and resume streams.
  */
  Rx.Pauser = function (__super__) {
    inherits(Pauser, __super__);
    function Pauser() {
      __super__.call(this);
    }

    /**
     * Pauses the underlying sequence.
     */
    Pauser.prototype.pause = function () {
      this.onNext(false);
    };

    /**
    * Resumes the underlying sequence.
    */
    Pauser.prototype.resume = function () {
      this.onNext(true);
    };

    return Pauser;
  }(Subject);

  if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
    root.Rx = Rx;

    define(function () {
      return Rx;
    });
  } else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = Rx).Rx = Rx;
    } else {
      freeExports.Rx = Rx;
    }
  } else {
    // in a browser or Rhino
    root.Rx = Rx;
  }

  // All code before this point will be filtered from stack traces.
  var rEndingLine = captureLine();
}).call(undefined);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":108}],124:[function(require,module,exports){
'use strict';

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

},{"buffer":3}],125:[function(require,module,exports){
'use strict';

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":30,"readable-stream/duplex.js":110,"readable-stream/passthrough.js":119,"readable-stream/readable.js":120,"readable-stream/transform.js":121,"readable-stream/writable.js":122}],126:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":124}],127:[function(require,module,exports){
"use strict";

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function () /*varargs*/{
    this._defaults.push({ fn: fn, arguments: arguments });
    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, def.arguments);
  });
};

module.exports = Agent;

},{}],128:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = undefined;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop() {};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function (method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  } else {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP.6.0');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP.3.0');
    } catch (e) {}
    try {
      return new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return (/[\/+]json($|[^-\w])/.test(mime)
  );
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function (user, pass, options) {
  if (1 === arguments.length) pass = '';
  if ((typeof pass === 'undefined' ? 'undefined' : _typeof(pass)) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function (val) {
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function () {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function () {
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch (e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function () {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function (url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":127,"./is-object":129,"./request-base":130,"./response-base":131,"component-emitter":4}],129:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(obj) {
  return null !== obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj));
}

module.exports = isObject;

},{}],130:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options) {
  if (!options || 'object' !== (typeof options === 'undefined' ? 'undefined' : _typeof(options))) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function () {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function (n) {
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data ? this._data + '&' + data : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function () {
  console.trace("Unsupported");
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":129}],131:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util

  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct);

  // params
  var params = utils.params(ct);
  for (var key in params) {
    this[key] = params[key];
  }this.links = {};

  // links
  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {
    // ignore
  }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.redirect = 3 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = 4 == type || 5 == type ? this.toError() : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.forbidden = 403 == status;
  this.notFound = 404 == status;
};

},{"./utils":132}],132:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],133:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],134:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:54 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("timeline", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.timeline = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.timeline = t());
}(window, function () {
  return function (a) {
    var r = {};function n(e) {
      if (r[e]) return r[e].exports;var t = r[e] = { i: e, l: !1, exports: {} };return a[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports;
    }return n.m = a, n.c = r, n.d = function (e, t, a) {
      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: a });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, n.t = function (t, e) {
      if (1 & e && (t = n(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var a = Object.create(null);if (n.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) {
        n.d(a, r, function (e) {
          return t[e];
        }.bind(null, r));
      }return a;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "localhost:8080/dist/plugin/", n(n.s = 0);
  }([function (e, t, a) {
    "use strict";
    function r(e, t) {
      for (var a = 0; a < t.length; a++) {
        var r = t[a];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
      }
    }function n(e, t, a) {
      return t && r(e.prototype, t), a && r(e, a), e;
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var i = function () {
      function r(e, t) {
        var a = this;if (function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, r), o.call(this), this.container = "string" == typeof e.container ? document.querySelector(e.container) : e.container, !this.container) throw new Error("No container for wavesurfer timeline");this.wavesurfer = t, this.util = t.util, this.params = this.util.extend({}, { height: 20, notchPercentHeight: 90, labelPadding: 5, unlabeledNotchColor: "#c0c0c0", primaryColor: "#000", secondaryColor: "#c0c0c0", primaryFontColor: "#000", secondaryFontColor: "#000", fontFamily: "Arial", fontSize: 10, zoomDebounce: !1, formatTimeCallback: this.defaultFormatTimeCallback, timeInterval: this.defaultTimeInterval, primaryLabelInterval: this.defaultPrimaryLabelInterval, secondaryLabelInterval: this.defaultSecondaryLabelInterval }, e), this.canvases = [], this.wrapper = null, this.drawer = null, this.pixelRatio = null, this.maxCanvasWidth = null, this.maxCanvasElementWidth = null, this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {
          return a.render();
        }, this.params.zoomDebounce) : function () {
          return a.render();
        };
      }return n(r, null, [{ key: "create", value: function value(e) {
          return { name: "timeline", deferInit: !(!e || !e.deferInit) && e.deferInit, params: e, instance: r };
        } }]), n(r, [{ key: "init", value: function value() {
          this.wavesurfer.on("ready", this._onReady), this.wavesurfer.isReady && this._onReady();
        } }, { key: "destroy", value: function value() {
          this.unAll(), this.wavesurfer.un("redraw", this._onRedraw), this.wavesurfer.un("zoom", this._onZoom), this.wavesurfer.un("ready", this._onReady), this.wavesurfer.drawer.wrapper.removeEventListener("scroll", this._onScroll), this.wrapper && this.wrapper.parentNode && (this.wrapper.removeEventListener("click", this._onWrapperClick), this.wrapper.parentNode.removeChild(this.wrapper), this.wrapper = null);
        } }, { key: "createWrapper", value: function value() {
          var e = this.wavesurfer.params;this.container.innerHTML = "", this.wrapper = this.container.appendChild(document.createElement("timeline")), this.util.style(this.wrapper, { display: "block", position: "relative", userSelect: "none", webkitUserSelect: "none", height: "".concat(this.params.height, "px") }), (e.fillParent || e.scrollParent) && this.util.style(this.wrapper, { width: "100%", overflowX: "hidden", overflowY: "hidden" }), this.wrapper.addEventListener("click", this._onWrapperClick);
        } }, { key: "render", value: function value() {
          this.wrapper || this.createWrapper(), this.updateCanvases(), this.updateCanvasesPositioning(), this.renderCanvases();
        } }, { key: "updateCanvases", value: function value() {
          for (var e, t, a = this, r = Math.round(this.drawer.wrapper.scrollWidth), n = Math.ceil(r / this.maxCanvasElementWidth); this.canvases.length < n;) {
            void 0, e = a.wrapper.appendChild(document.createElement("canvas")), a.canvases.push(e), a.util.style(e, { position: "absolute", zIndex: 4 });
          }for (; this.canvases.length > n;) {
            t = void 0, (t = a.canvases.pop()).parentElement.removeChild(t);
          }
        } }, { key: "updateCanvasesPositioning", value: function value() {
          var r = this,
              n = this.canvases.length;this.canvases.forEach(function (e, t) {
            var a = t === n - 1 ? r.drawer.wrapper.scrollWidth - r.maxCanvasElementWidth * (n - 1) : r.maxCanvasElementWidth;e.width = a * r.pixelRatio, e.height = (r.params.height + 1) * r.pixelRatio, r.util.style(e, { width: "".concat(a, "px"), height: "".concat(r.params.height, "px"), left: "".concat(t * r.maxCanvasElementWidth, "px") });
          });
        } }, { key: "renderCanvases", value: function value() {
          var r = this,
              e = this.wavesurfer.backend.getDuration();if (!(e <= 0)) {
            var t,
                a = this.wavesurfer.params,
                n = this.params.fontSize * a.pixelRatio,
                i = parseInt(e, 10) + 1,
                o = a.fillParent && !a.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * a.pixelRatio,
                s = this.params.height * this.pixelRatio,
                l = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio,
                c = o / e,
                u = this.params.formatTimeCallback,
                h = function h(e) {
              return "function" == typeof e ? e(c) : e;
            },
                p = h(this.params.timeInterval),
                f = h(this.params.primaryLabelInterval),
                d = h(this.params.secondaryLabelInterval),
                v = 0,
                m = 0,
                y = [];for (t = 0; t < i / p; t++) {
              y.push([t, m, v]), m += p, v += c * p;
            }var w = function w(t) {
              y.forEach(function (e) {
                t(e[0], e[1], e[2]);
              });
            };this.setFillStyles(this.params.primaryColor), this.setFonts("".concat(n, "px ").concat(this.params.fontFamily)), this.setFillStyles(this.params.primaryFontColor), w(function (e, t, a) {
              e % f == 0 && (r.fillRect(a, 0, 1, s), r.fillText(u(t, c), a + r.params.labelPadding * r.pixelRatio, s));
            }), this.setFillStyles(this.params.secondaryColor), this.setFonts("".concat(n, "px ").concat(this.params.fontFamily)), this.setFillStyles(this.params.secondaryFontColor), w(function (e, t, a) {
              e % d == 0 && (r.fillRect(a, 0, 1, s), r.fillText(u(t, c), a + r.params.labelPadding * r.pixelRatio, s));
            }), this.setFillStyles(this.params.unlabeledNotchColor), w(function (e, t, a) {
              e % d != 0 && e % f != 0 && r.fillRect(a, 0, 1, l);
            });
          }
        } }, { key: "setFillStyles", value: function value(t) {
          this.canvases.forEach(function (e) {
            e.getContext("2d").fillStyle = t;
          });
        } }, { key: "setFonts", value: function value(t) {
          this.canvases.forEach(function (e) {
            e.getContext("2d").font = t;
          });
        } }, { key: "fillRect", value: function value(n, i, o, s) {
          var l = this;this.canvases.forEach(function (e, t) {
            var a = t * l.maxCanvasWidth,
                r = { x1: Math.max(n, t * l.maxCanvasWidth), y1: i, x2: Math.min(n + o, t * l.maxCanvasWidth + e.width), y2: i + s };r.x1 < r.x2 && e.getContext("2d").fillRect(r.x1 - a, r.y1, r.x2 - r.x1, r.y2 - r.y1);
          });
        } }, { key: "fillText", value: function value(r, n, i) {
          var o,
              s = 0;this.canvases.forEach(function (e) {
            var t = e.getContext("2d"),
                a = t.canvas.width;n + o < s || (n < s + a && (o = t.measureText(r).width, t.fillText(r, n - s, i)), s += a);
          });
        } }, { key: "defaultFormatTimeCallback", value: function value(e, t) {
          if (1 < e / 60) {
            var a = parseInt(e / 60, 10);return e = (e = parseInt(e % 60, 10)) < 10 ? "0" + e : e, "".concat(a, ":").concat(e);
          }return Math.round(1e3 * e) / 1e3;
        } }, { key: "defaultTimeInterval", value: function value(e) {
          return 25 <= e ? 1 : 25 <= 5 * e ? 5 : 25 <= 15 * e ? 15 : 60 * Math.ceil(.5 / e);
        } }, { key: "defaultPrimaryLabelInterval", value: function value(e) {
          return 25 <= e ? 10 : 25 <= 5 * e ? 6 : 4;
        } }, { key: "defaultSecondaryLabelInterval", value: function value(e) {
          return 25 <= e ? 5 : 2;
        } }]), r;
    }();t.default = i;var o = function o() {
      var a = this;this._onScroll = function () {
        a.wrapper && a.drawer.wrapper && (a.wrapper.scrollLeft = a.drawer.wrapper.scrollLeft);
      }, this._onRedraw = function () {
        return a.render();
      }, this._onReady = function () {
        var e = a.wavesurfer;a.drawer = e.drawer, a.pixelRatio = e.drawer.params.pixelRatio, a.maxCanvasWidth = e.drawer.maxCanvasWidth || e.drawer.width, a.maxCanvasElementWidth = e.drawer.maxCanvasElementWidth || Math.round(a.maxCanvasWidth / a.pixelRatio), e.drawer.wrapper.addEventListener("scroll", a._onScroll), e.on("redraw", a._onRedraw), e.on("zoom", a._onZoom), a.render();
      }, this._onWrapperClick = function (e) {
        e.preventDefault();var t = "offsetX" in e ? e.offsetX : e.layerX;a.fireEvent("click", t / a.wrapper.scrollWidth || 0);
      };
    };e.exports = t.default;
  }]);
});


},{}],135:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 2.1.0 (Mon Oct 01 2018 11:34:49 GMT+0200 (Central European Summer Time))
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("WaveSurfer", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.WaveSurfer = t() : e.WaveSurfer = t();
}(window, function () {
  return function (r) {
    var n = {};function i(e) {
      if (n[e]) return n[e].exports;var t = n[e] = { i: e, l: !1, exports: {} };return r[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports;
    }return i.m = r, i.c = n, i.d = function (e, t, r) {
      i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r });
    }, i.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    }, i.t = function (t, e) {
      if (1 & e && (t = i(t)), 8 & e) return t;if (4 & e && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t && t.__esModule) return t;var r = Object.create(null);if (i.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var n in t) {
        i.d(r, n, function (e) {
          return t[e];
        }.bind(null, n));
      }return r;
    }, i.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };return i.d(t, "a", t), t;
    }, i.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, i.p = "", i(i.s = 4);
  }([function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "ajax", { enumerable: !0, get: function get() {
        return n.default;
      } }), Object.defineProperty(t, "getId", { enumerable: !0, get: function get() {
        return i.default;
      } }), Object.defineProperty(t, "max", { enumerable: !0, get: function get() {
        return a.default;
      } }), Object.defineProperty(t, "min", { enumerable: !0, get: function get() {
        return s.default;
      } }), Object.defineProperty(t, "Observer", { enumerable: !0, get: function get() {
        return o.default;
      } }), Object.defineProperty(t, "extend", { enumerable: !0, get: function get() {
        return u.default;
      } }), Object.defineProperty(t, "style", { enumerable: !0, get: function get() {
        return l.default;
      } }), Object.defineProperty(t, "requestAnimationFrame", { enumerable: !0, get: function get() {
        return c.default;
      } }), Object.defineProperty(t, "frame", { enumerable: !0, get: function get() {
        return h.default;
      } }), Object.defineProperty(t, "debounce", { enumerable: !0, get: function get() {
        return f.default;
      } }), Object.defineProperty(t, "preventClick", { enumerable: !0, get: function get() {
        return d.default;
      } });var n = p(r(5)),
        i = p(r(6)),
        a = p(r(7)),
        s = p(r(8)),
        o = p(r(1)),
        u = p(r(9)),
        l = p(r(10)),
        c = p(r(2)),
        h = p(r(11)),
        f = p(r(12)),
        d = p(r(13));function p(e) {
      return e && e.__esModule ? e : { default: e };
    }
  }, function (e, t, r) {
    "use strict";
    function i(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function () {
      function e() {
        !function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, e), this.handlers = null;
      }var t, r, n;return t = e, (r = [{ key: "on", value: function value(e, t) {
          var r = this;this.handlers || (this.handlers = {});var n = this.handlers[e];return n || (n = this.handlers[e] = []), n.push(t), { name: e, callback: t, un: function un(e, t) {
              return r.un(e, t);
            } };
        } }, { key: "un", value: function value(e, t) {
          if (this.handlers) {
            var r,
                n = this.handlers[e];if (n) if (t) for (r = n.length - 1; 0 <= r; r--) {
              n[r] == t && n.splice(r, 1);
            } else n.length = 0;
          }
        } }, { key: "unAll", value: function value() {
          this.handlers = null;
        } }, { key: "once", value: function value(i, a) {
          var s = this;return this.on(i, function e() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) {
              r[n] = arguments[n];
            }a.apply(s, r), setTimeout(function () {
              s.un(i, e);
            }, 0);
          });
        } }, { key: "fireEvent", value: function value(e) {
          for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), n = 1; n < t; n++) {
            r[n - 1] = arguments[n];
          }if (this.handlers) {
            var i = this.handlers[e];i && i.forEach(function (e) {
              e.apply(void 0, r);
            });
          }
        } }]) && i(t.prototype, r), n && i(t, n), e;
    }();t.default = n, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e, t) {
      return setTimeout(e, 1e3 / 60);
    }).bind(window);t.default = n, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function a(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
    }function s(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function o(e) {
      return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function u(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function l(e, t, r) {
      return t && u(e.prototype, t), r && u(e, r), e;
    }function c(e, t) {
      return (c = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var h = "playing",
        f = "paused",
        d = "finished",
        p = function (e) {
      function i(e) {
        var t, r, n;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, i), (n = s(this, o(i).call(this))).audioContext = null, n.offlineAudioContext = null, n.stateBehaviors = (a(t = {}, h, { init: function init() {
            this.addOnAudioProcess();
          }, getPlayedPercents: function getPlayedPercents() {
            var e = this.getDuration();return this.getCurrentTime() / e || 0;
          }, getCurrentTime: function getCurrentTime() {
            return this.startPosition + this.getPlayedTime();
          } }), a(t, f, { init: function init() {
            this.removeOnAudioProcess();
          }, getPlayedPercents: function getPlayedPercents() {
            var e = this.getDuration();return this.getCurrentTime() / e || 0;
          }, getCurrentTime: function getCurrentTime() {
            return this.startPosition;
          } }), a(t, d, { init: function init() {
            this.removeOnAudioProcess(), this.fireEvent("finish");
          }, getPlayedPercents: function getPlayedPercents() {
            return 1;
          }, getCurrentTime: function getCurrentTime() {
            return this.getDuration();
          } }), t), n.params = e, n.ac = e.audioContext || n.getAudioContext(), n.lastPlay = n.ac.currentTime, n.startPosition = 0, n.scheduledPause = null, n.states = (a(r = {}, h, Object.create(n.stateBehaviors[h])), a(r, f, Object.create(n.stateBehaviors[f])), a(r, d, Object.create(n.stateBehaviors[d])), r), n.analyser = null, n.buffer = null, n.filters = [], n.gainNode = null, n.mergedPeaks = null, n.offlineAc = null, n.peaks = null, n.playbackRate = 1, n.analyser = null, n.scriptNode = null, n.source = null, n.splitPeaks = [], n.state = null, n.explicitDuration = null, n;
      }return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && c(e, t);
      }(i, n.Observer), l(i, [{ key: "supportsWebAudio", value: function value() {
          return !(!window.AudioContext && !window.webkitAudioContext);
        } }, { key: "getAudioContext", value: function value() {
          return window.WaveSurferAudioContext || (window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)()), window.WaveSurferAudioContext;
        } }, { key: "getOfflineAudioContext", value: function value(e) {
          return window.WaveSurferOfflineAudioContext || (window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, e)), window.WaveSurferOfflineAudioContext;
        } }]), l(i, [{ key: "init", value: function value() {
          this.createVolumeNode(), this.createScriptNode(), this.createAnalyserNode(), this.setState(f), this.setPlaybackRate(this.params.audioRate), this.setLength(0);
        } }, { key: "disconnectFilters", value: function value() {
          this.filters && (this.filters.forEach(function (e) {
            e && e.disconnect();
          }), this.filters = null, this.analyser.connect(this.gainNode));
        } }, { key: "setState", value: function value(e) {
          this.state !== this.states[e] && (this.state = this.states[e], this.state.init.call(this));
        } }, { key: "setFilter", value: function value() {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
            t[r] = arguments[r];
          }this.setFilters(t);
        } }, { key: "setFilters", value: function value(e) {
          this.disconnectFilters(), e && e.length && (this.filters = e, this.analyser.disconnect(), e.reduce(function (e, t) {
            return e.connect(t), t;
          }, this.analyser).connect(this.gainNode));
        } }, { key: "createScriptNode", value: function value() {
          this.params.audioScriptProcessor ? this.scriptNode = this.params.audioScriptProcessor : this.ac.createScriptProcessor ? this.scriptNode = this.ac.createScriptProcessor(i.scriptBufferSize) : this.scriptNode = this.ac.createJavaScriptNode(i.scriptBufferSize), this.scriptNode.connect(this.ac.destination);
        } }, { key: "addOnAudioProcess", value: function value() {
          var t = this;this.scriptNode.onaudioprocess = function () {
            var e = t.getCurrentTime();e >= t.getDuration() ? (t.setState(d), t.fireEvent("pause")) : e >= t.scheduledPause ? t.pause() : t.state === t.states[h] && t.fireEvent("audioprocess", e);
          };
        } }, { key: "removeOnAudioProcess", value: function value() {
          this.scriptNode.onaudioprocess = null;
        } }, { key: "createAnalyserNode", value: function value() {
          this.analyser = this.ac.createAnalyser(), this.analyser.connect(this.gainNode);
        } }, { key: "createVolumeNode", value: function value() {
          this.ac.createGain ? this.gainNode = this.ac.createGain() : this.gainNode = this.ac.createGainNode(), this.gainNode.connect(this.ac.destination);
        } }, { key: "setSinkId", value: function value(e) {
          if (e) {
            var t = new window.Audio();if (!t.setSinkId) return Promise.reject(new Error("setSinkId is not supported in your browser"));t.autoplay = !0;var r = this.ac.createMediaStreamDestination();return this.gainNode.disconnect(), this.gainNode.connect(r), t.srcObject = r.stream, t.setSinkId(e);
          }return Promise.reject(new Error("Invalid deviceId: " + e));
        } }, { key: "setVolume", value: function value(e) {
          this.gainNode.gain.setValueAtTime(e, this.ac.currentTime);
        } }, { key: "getVolume", value: function value() {
          return this.gainNode.gain.value;
        } }, { key: "decodeArrayBuffer", value: function value(e, t, r) {
          this.offlineAc || (this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100)), this.offlineAc.decodeAudioData(e, function (e) {
            return t(e);
          }, r);
        } }, { key: "setPeaks", value: function value(e, t) {
          this.explicitDuration = t, this.peaks = e;
        } }, { key: "setLength", value: function value(e) {
          if (!this.mergedPeaks || e != 2 * this.mergedPeaks.length - 1 + 2) {
            this.splitPeaks = [], this.mergedPeaks = [];var t,
                r = this.buffer ? this.buffer.numberOfChannels : 1;for (t = 0; t < r; t++) {
              this.splitPeaks[t] = [], this.splitPeaks[t][2 * (e - 1)] = 0, this.splitPeaks[t][2 * (e - 1) + 1] = 0;
            }this.mergedPeaks[2 * (e - 1)] = 0, this.mergedPeaks[2 * (e - 1) + 1] = 0;
          }
        } }, { key: "getPeaks", value: function value(e, t, r) {
          if (this.peaks) return this.peaks;if (t = t || 0, r = r || e - 1, this.setLength(e), !this.buffer.length) {
            var n = this.createBuffer(1, 4096, this.sampleRate);this.buffer = n.buffer;
          }var i,
              a = this.buffer.length / e,
              s = ~~(a / 10) || 1,
              o = this.buffer.numberOfChannels;for (i = 0; i < o; i++) {
            var u = this.splitPeaks[i],
                l = this.buffer.getChannelData(i),
                c = void 0;for (c = t; c <= r; c++) {
              var h = ~~(c * a),
                  f = ~~(h + a),
                  d = 0,
                  p = 0,
                  v = void 0;for (v = h; v < f; v += s) {
                var y = l[v];p < y && (p = y), y < d && (d = y);
              }u[2 * c] = p, u[2 * c + 1] = d, (0 == i || p > this.mergedPeaks[2 * c]) && (this.mergedPeaks[2 * c] = p), (0 == i || d < this.mergedPeaks[2 * c + 1]) && (this.mergedPeaks[2 * c + 1] = d);
            }
          }return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
        } }, { key: "getPlayedPercents", value: function value() {
          return this.state.getPlayedPercents.call(this);
        } }, { key: "disconnectSource", value: function value() {
          this.source && this.source.disconnect();
        } }, { key: "destroy", value: function value() {
          this.isPaused() || this.pause(), this.unAll(), this.buffer = null, this.disconnectFilters(), this.disconnectSource(), this.gainNode.disconnect(), this.scriptNode.disconnect(), this.analyser.disconnect(), this.params.closeAudioContext && ("function" == typeof this.ac.close && "closed" != this.ac.state && this.ac.close(), this.ac = null, this.params.audioContext ? this.params.audioContext = null : window.WaveSurferAudioContext = null, window.WaveSurferOfflineAudioContext = null);
        } }, { key: "load", value: function value(e) {
          this.startPosition = 0, this.lastPlay = this.ac.currentTime, this.buffer = e, this.createSource();
        } }, { key: "createSource", value: function value() {
          this.disconnectSource(), this.source = this.ac.createBufferSource(), this.source.start = this.source.start || this.source.noteGrainOn, this.source.stop = this.source.stop || this.source.noteOff, this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime), this.source.buffer = this.buffer, this.source.connect(this.analyser);
        } }, { key: "isPaused", value: function value() {
          return this.state !== this.states[h];
        } }, { key: "getDuration", value: function value() {
          return this.buffer ? this.buffer.duration : this.explicitDuration ? this.explicitDuration : 0;
        } }, { key: "seekTo", value: function value(e, t) {
          if (this.buffer) return (this.scheduledPause = null) == e && (e = this.getCurrentTime()) >= this.getDuration() && (e = 0), null == t && (t = this.getDuration()), this.startPosition = e, this.lastPlay = this.ac.currentTime, this.state === this.states[d] && this.setState(f), { start: e, end: t };
        } }, { key: "getPlayedTime", value: function value() {
          return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
        } }, { key: "play", value: function value(e, t) {
          if (this.buffer) {
            this.createSource();var r = this.seekTo(e, t);e = r.start, t = r.end, this.scheduledPause = t, this.source.start(0, e, t - e), "suspended" == this.ac.state && this.ac.resume && this.ac.resume(), this.setState(h), this.fireEvent("play");
          }
        } }, { key: "pause", value: function value() {
          this.scheduledPause = null, this.startPosition += this.getPlayedTime(), this.source && this.source.stop(0), this.setState(f), this.fireEvent("pause");
        } }, { key: "getCurrentTime", value: function value() {
          return this.state.getCurrentTime.call(this);
        } }, { key: "getPlaybackRate", value: function value() {
          return this.playbackRate;
        } }, { key: "setPlaybackRate", value: function value(e) {
          e = e || 1, this.isPaused() ? this.playbackRate = e : (this.pause(), this.playbackRate = e, this.play());
        } }]), i;
    }();(t.default = p).scriptBufferSize = 256, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var i = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0)),
        a = n(r(14)),
        s = n(r(3)),
        o = n(r(16)),
        u = n(r(17));function n(e) {
      return e && e.__esModule ? e : { default: e };
    }function l(e) {
      return (l = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function c(e, t) {
      return !t || "object" !== l(t) && "function" != typeof t ? d(e) : t;
    }function h(e) {
      return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function f(e, t) {
      return (f = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }function d(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e;
    }function p(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function v(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function y(e, t, r) {
      return t && v(e.prototype, t), r && v(e, r), e;
    }var m = function (e) {
      function n(e) {
        var t;if (p(this, n), (t = c(this, h(n).call(this))).defaultParams = { audioContext: null, audioRate: 1, autoCenter: !0, backend: "WebAudio", barHeight: 1, barGap: null, container: null, cursorColor: "#333", cursorWidth: 1, dragSelection: !0, fillParent: !0, forceDecode: !1, height: 128, hideScrollbar: !1, interact: !0, loopSelection: !0, maxCanvasWidth: 4e3, mediaContainer: null, mediaControls: !1, mediaType: "audio", minPxPerSec: 20, normalize: !1, partialRender: !1, pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI, plugins: [], progressColor: "#555", removeMediaElementOnDestroy: !0, renderer: a.default, responsive: !1, scrollParent: !1, skipLength: 2, splitChannels: !1, waveColor: "#999", xhr: {} }, t.backends = { MediaElement: o.default, WebAudio: s.default }, t.util = i, t.params = i.extend({}, t.defaultParams, e), t.container = "string" == typeof e.container ? document.querySelector(t.params.container) : t.params.container, !t.container) throw new Error("Container element not found");if (null == t.params.mediaContainer ? t.mediaContainer = t.container : "string" == typeof t.params.mediaContainer ? t.mediaContainer = document.querySelector(t.params.mediaContainer) : t.mediaContainer = t.params.mediaContainer, !t.mediaContainer) throw new Error("Media Container element not found");if (t.params.maxCanvasWidth <= 1) throw new Error("maxCanvasWidth must be greater than 1");if (t.params.maxCanvasWidth % 2 == 1) throw new Error("maxCanvasWidth must be an even number");if (t.savedVolume = 0, t.isMuted = !1, t.tmpEvents = [], t.currentAjax = null, t.arraybuffer = null, t.drawer = null, t.backend = null, t.peakCache = null, "function" != typeof t.params.renderer) throw new Error("Renderer parameter is invalid");t.Drawer = t.params.renderer, t.Backend = t.backends[t.params.backend], t.initialisedPluginList = {}, t.isDestroyed = !1, t.isReady = !1;var r = 0;return t._onResize = i.debounce(function () {
          r == t.drawer.wrapper.clientWidth || t.params.scrollParent || (r = t.drawer.wrapper.clientWidth, t.drawer.fireEvent("redraw"));
        }, "number" == typeof t.params.responsive ? t.params.responsive : 100), c(t, d(d(t)));
      }return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && f(e, t);
      }(n, i.Observer), y(n, null, [{ key: "create", value: function value(e) {
          return new n(e).init();
        } }]), y(n, [{ key: "init", value: function value() {
          return this.registerPlugins(this.params.plugins), this.createDrawer(), this.createBackend(), this.createPeakCache(), this;
        } }, { key: "registerPlugins", value: function value(e) {
          var t = this;return e.forEach(function (e) {
            return t.addPlugin(e);
          }), e.forEach(function (e) {
            e.deferInit || t.initPlugin(e.name);
          }), this.fireEvent("plugins-registered", e), this;
        } }, { key: "addPlugin", value: function value(t) {
          var r = this;if (!t.name) throw new Error("Plugin does not have a name!");if (!t.instance) throw new Error("Plugin ".concat(t.name, " does not have an instance property!"));t.staticProps && Object.keys(t.staticProps).forEach(function (e) {
            r[e] = t.staticProps[e];
          });var n = t.instance;return Object.getOwnPropertyNames(i.Observer.prototype).forEach(function (e) {
            n.prototype[e] = i.Observer.prototype[e];
          }), this[t.name] = new n(t.params || {}, this), this.fireEvent("plugin-added", t.name), this;
        } }, { key: "initPlugin", value: function value(e) {
          if (!this[e]) throw new Error("Plugin ".concat(e, " has not been added yet!"));return this.initialisedPluginList[e] && this.destroyPlugin(e), this[e].init(), this.initialisedPluginList[e] = !0, this.fireEvent("plugin-initialised", e), this;
        } }, { key: "destroyPlugin", value: function value(e) {
          if (!this[e]) throw new Error("Plugin ".concat(e, " has not been added yet and cannot be destroyed!"));if (!this.initialisedPluginList[e]) throw new Error("Plugin ".concat(e, " is not active and cannot be destroyed!"));if ("function" != typeof this[e].destroy) throw new Error("Plugin ".concat(e, " does not have a destroy function!"));return this[e].destroy(), delete this.initialisedPluginList[e], this.fireEvent("plugin-destroyed", e), this;
        } }, { key: "destroyAllPlugins", value: function value() {
          var t = this;Object.keys(this.initialisedPluginList).forEach(function (e) {
            return t.destroyPlugin(e);
          });
        } }, { key: "createDrawer", value: function value() {
          var r = this;this.drawer = new this.Drawer(this.container, this.params), this.drawer.init(), this.fireEvent("drawer-created", this.drawer), !1 !== this.params.responsive && (window.addEventListener("resize", this._onResize, !0), window.addEventListener("orientationchange", this._onResize, !0)), this.drawer.on("redraw", function () {
            r.drawBuffer(), r.drawer.progress(r.backend.getPlayedPercents());
          }), this.drawer.on("click", function (e, t) {
            setTimeout(function () {
              return r.seekTo(t);
            }, 0);
          }), this.drawer.on("scroll", function (e) {
            r.params.partialRender && r.drawBuffer(), r.fireEvent("scroll", e);
          });
        } }, { key: "createBackend", value: function value() {
          var t = this;this.backend && this.backend.destroy(), "AudioElement" == this.params.backend && (this.params.backend = "MediaElement"), "WebAudio" != this.params.backend || this.Backend.prototype.supportsWebAudio.call(null) || (this.params.backend = "MediaElement"), this.backend = new this.Backend(this.params), this.backend.init(), this.fireEvent("backend-created", this.backend), this.backend.on("finish", function () {
            return t.fireEvent("finish");
          }), this.backend.on("play", function () {
            return t.fireEvent("play");
          }), this.backend.on("pause", function () {
            return t.fireEvent("pause");
          }), this.backend.on("audioprocess", function (e) {
            t.drawer.progress(t.backend.getPlayedPercents()), t.fireEvent("audioprocess", e);
          });
        } }, { key: "createPeakCache", value: function value() {
          this.params.partialRender && (this.peakCache = new u.default());
        } }, { key: "getDuration", value: function value() {
          return this.backend.getDuration();
        } }, { key: "getCurrentTime", value: function value() {
          return this.backend.getCurrentTime();
        } }, { key: "setCurrentTime", value: function value(e) {
          e >= this.getDuration() ? this.seekTo(1) : this.seekTo(e / this.getDuration());
        } }, { key: "play", value: function value(e, t) {
          var r = this;return this.fireEvent("interaction", function () {
            return r.play(e, t);
          }), this.backend.play(e, t);
        } }, { key: "pause", value: function value() {
          if (!this.backend.isPaused()) return this.backend.pause();
        } }, { key: "playPause", value: function value() {
          return this.backend.isPaused() ? this.play() : this.pause();
        } }, { key: "isPlaying", value: function value() {
          return !this.backend.isPaused();
        } }, { key: "skipBackward", value: function value(e) {
          this.skip(-e || -this.params.skipLength);
        } }, { key: "skipForward", value: function value(e) {
          this.skip(e || this.params.skipLength);
        } }, { key: "skip", value: function value(e) {
          var t = this.getDuration() || 1,
              r = this.getCurrentTime() || 0;r = Math.max(0, Math.min(t, r + (e || 0))), this.seekAndCenter(r / t);
        } }, { key: "seekAndCenter", value: function value(e) {
          this.seekTo(e), this.drawer.recenter(e);
        } }, { key: "seekTo", value: function value(e) {
          var t = this;if ("number" != typeof e || !isFinite(e) || e < 0 || 1 < e) return console.error("Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!");this.fireEvent("interaction", function () {
            return t.seekTo(e);
          });var r = this.backend.isPaused();r || this.backend.pause();var n = this.params.scrollParent;this.params.scrollParent = !1, this.backend.seekTo(e * this.getDuration()), this.drawer.progress(e), r || this.backend.play(), this.params.scrollParent = n, this.fireEvent("seek", e);
        } }, { key: "stop", value: function value() {
          this.pause(), this.seekTo(0), this.drawer.progress(0);
        } }, { key: "setSinkId", value: function value(e) {
          return this.backend.setSinkId(e);
        } }, { key: "setVolume", value: function value(e) {
          this.backend.setVolume(e), this.fireEvent("volume", e);
        } }, { key: "getVolume", value: function value() {
          return this.backend.getVolume();
        } }, { key: "setPlaybackRate", value: function value(e) {
          this.backend.setPlaybackRate(e);
        } }, { key: "getPlaybackRate", value: function value() {
          return this.backend.getPlaybackRate();
        } }, { key: "toggleMute", value: function value() {
          this.setMute(!this.isMuted);
        } }, { key: "setMute", value: function value(e) {
          e !== this.isMuted && (e ? (this.savedVolume = this.backend.getVolume(), this.backend.setVolume(0), this.isMuted = !0, this.fireEvent("volume", 0)) : (this.backend.setVolume(this.savedVolume), this.isMuted = !1, this.fireEvent("volume", this.savedVolume))), this.fireEvent("mute", this.isMuted);
        } }, { key: "getMute", value: function value() {
          return this.isMuted;
        } }, { key: "isReady", value: function value() {
          return this.isReady;
        } }, { key: "getFilters", value: function value() {
          return this.backend.filters || [];
        } }, { key: "toggleScroll", value: function value() {
          this.params.scrollParent = !this.params.scrollParent, this.drawBuffer();
        } }, { key: "toggleInteraction", value: function value() {
          this.params.interact = !this.params.interact;
        } }, { key: "getWaveColor", value: function value() {
          return this.params.waveColor;
        } }, { key: "setWaveColor", value: function value(e) {
          this.params.waveColor = e, this.drawBuffer();
        } }, { key: "getProgressColor", value: function value() {
          return this.params.progressColor;
        } }, { key: "setProgressColor", value: function value(e) {
          this.params.progressColor = e, this.drawBuffer();
        } }, { key: "getCursorColor", value: function value() {
          return this.params.cursorColor;
        } }, { key: "setCursorColor", value: function value(e) {
          this.params.cursorColor = e, this.drawer.updateCursor();
        } }, { key: "getHeight", value: function value() {
          return this.params.height;
        } }, { key: "setHeight", value: function value(e) {
          this.params.height = e, this.drawer.setHeight(e * this.params.pixelRatio), this.drawBuffer();
        } }, { key: "drawBuffer", value: function value() {
          var e,
              t = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio),
              r = this.drawer.getWidth(),
              n = t,
              i = this.drawer.getScrollX(),
              a = Math.max(i + r, n);if (this.params.fillParent && (!this.params.scrollParent || t < r) && (i = 0, a = n = r), this.params.partialRender) {
            var s,
                o = this.peakCache.addRangeToPeakCache(n, i, a);for (s = 0; s < o.length; s++) {
              e = this.backend.getPeaks(n, o[s][0], o[s][1]), this.drawer.drawPeaks(e, n, o[s][0], o[s][1]);
            }
          } else e = this.backend.getPeaks(n, i, a), this.drawer.drawPeaks(e, n, i, a);this.fireEvent("redraw", e, n);
        } }, { key: "zoom", value: function value(e) {
          this.params.scrollParent = e ? (this.params.minPxPerSec = e, !0) : (this.params.minPxPerSec = this.defaultParams.minPxPerSec, !1), this.drawBuffer(), this.drawer.progress(this.backend.getPlayedPercents()), this.drawer.recenter(this.getCurrentTime() / this.getDuration()), this.fireEvent("zoom", e);
        } }, { key: "loadArrayBuffer", value: function value(e) {
          var t = this;this.decodeArrayBuffer(e, function (e) {
            t.isDestroyed || t.loadDecodedBuffer(e);
          });
        } }, { key: "loadDecodedBuffer", value: function value(e) {
          this.backend.load(e), this.drawBuffer(), this.fireEvent("ready"), this.isReady = !0;
        } }, { key: "loadBlob", value: function value(e) {
          var t = this,
              r = new FileReader();r.addEventListener("progress", function (e) {
            return t.onProgress(e);
          }), r.addEventListener("load", function (e) {
            return t.loadArrayBuffer(e.target.result);
          }), r.addEventListener("error", function () {
            return t.fireEvent("error", "Error reading file");
          }), r.readAsArrayBuffer(e), this.empty();
        } }, { key: "load", value: function value(e, t, r, n) {
          if (this.empty(), r) {
            var i = { "Preload is not 'auto', 'none' or 'metadata'": -1 === ["auto", "metadata", "none"].indexOf(r), "Peaks are not provided": !t, "Backend is not of type MediaElement": "MediaElement" !== this.params.backend, "Url is not of type string": "string" != typeof e },
                a = Object.keys(i).filter(function (e) {
              return i[e];
            });a.length && (console.warn("Preload parameter of wavesurfer.load will be ignored because:\n\t- " + a.join("\n\t- ")), r = null);
          }switch (this.params.backend) {case "WebAudio":
              return this.loadBuffer(e, t, n);case "MediaElement":
              return this.loadMediaElement(e, t, r, n);}
        } }, { key: "loadBuffer", value: function value(t, e, r) {
          var n = this,
              i = function i(e) {
            return e && n.tmpEvents.push(n.once("ready", e)), n.getArrayBuffer(t, function (e) {
              return n.loadArrayBuffer(e);
            });
          };if (!e) return i();this.backend.setPeaks(e, r), this.drawBuffer(), this.tmpEvents.push(this.once("interaction", i));
        } }, { key: "loadMediaElement", value: function value(e, t, r, n) {
          var i = this,
              a = e;if ("string" == typeof e) this.backend.load(a, this.mediaContainer, t, r);else {
            var s = e;this.backend.loadElt(s, t), a = s.src;
          }this.tmpEvents.push(this.backend.once("canplay", function () {
            i.drawBuffer(), i.fireEvent("ready"), i.isReady = !0;
          }), this.backend.once("error", function (e) {
            return i.fireEvent("error", e);
          })), t && this.backend.setPeaks(t, n), t && !this.params.forceDecode || !this.backend.supportsWebAudio() || this.getArrayBuffer(a, function (e) {
            i.decodeArrayBuffer(e, function (e) {
              i.backend.buffer = e, i.backend.setPeaks(null), i.drawBuffer(), i.fireEvent("waveform-ready");
            });
          });
        } }, { key: "decodeArrayBuffer", value: function value(t, r) {
          var n = this;this.arraybuffer = t, this.backend.decodeArrayBuffer(t, function (e) {
            n.isDestroyed || n.arraybuffer != t || (r(e), n.arraybuffer = null);
          }, function () {
            return n.fireEvent("error", "Error decoding audiobuffer");
          });
        } }, { key: "getArrayBuffer", value: function value(e, r) {
          var n = this,
              t = i.ajax({ url: e, responseType: "arraybuffer", xhr: this.params.xhr });return this.currentAjax = t, this.tmpEvents.push(t.on("progress", function (e) {
            n.onProgress(e);
          }), t.on("success", function (e, t) {
            r(e), n.currentAjax = null;
          }), t.on("error", function (e) {
            n.fireEvent("error", "XHR error: " + e.target.statusText), n.currentAjax = null;
          })), t;
        } }, { key: "onProgress", value: function value(e) {
          var t;t = e.lengthComputable ? e.loaded / e.total : e.loaded / (e.loaded + 1e6), this.fireEvent("loading", Math.round(100 * t), e.target);
        } }, { key: "exportPCM", value: function value(e, t, r, n) {
          e = e || 1024, n = n || 0, t = t || 1e4, r = r || !1;var i = this.backend.getPeaks(e, n),
              a = [].map.call(i, function (e) {
            return Math.round(e * t) / t;
          }),
              s = JSON.stringify(a);return r || window.open("data:application/json;charset=utf-8," + encodeURIComponent(s)), s;
        } }, { key: "exportImage", value: function value(e, t) {
          return e || (e = "image/png"), t || (t = 1), this.drawer.getImage(e, t);
        } }, { key: "cancelAjax", value: function value() {
          this.currentAjax && (this.currentAjax.xhr.abort(), this.currentAjax = null);
        } }, { key: "clearTmpEvents", value: function value() {
          this.tmpEvents.forEach(function (e) {
            return e.un();
          });
        } }, { key: "empty", value: function value() {
          this.backend.isPaused() || (this.stop(), this.backend.disconnectSource()), this.isReady = !1, this.cancelAjax(), this.clearTmpEvents(), this.drawer.progress(0), this.drawer.setWidth(0), this.drawer.drawPeaks({ length: this.drawer.getWidth() }, 0);
        } }, { key: "destroy", value: function value() {
          this.destroyAllPlugins(), this.fireEvent("destroy"), this.cancelAjax(), this.clearTmpEvents(), this.unAll(), !1 !== this.params.responsive && (window.removeEventListener("resize", this._onResize, !0), window.removeEventListener("orientationchange", this._onResize, !0)), this.backend.destroy(), this.drawer.destroy(), this.isDestroyed = !0, this.isReady = !1, this.arraybuffer = null;
        } }]), n;
    }();(t.default = m).VERSION = "2.1.0", m.util = i, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
      var t = new i.default(),
          r = new XMLHttpRequest(),
          n = !1;r.open(e.method || "GET", e.url, !0), r.responseType = e.responseType || "json", e.xhr && (e.xhr.requestHeaders && e.xhr.requestHeaders.forEach(function (e) {
        r.setRequestHeader(e.key, e.value);
      }), e.xhr.withCredentials && (r.withCredentials = !0));return r.addEventListener("progress", function (e) {
        t.fireEvent("progress", e), e.lengthComputable && e.loaded == e.total && (n = !0);
      }), r.addEventListener("load", function (e) {
        n || t.fireEvent("progress", e), t.fireEvent("load", e), 200 == r.status || 206 == r.status ? t.fireEvent("success", r.response, e) : t.fireEvent("error", e);
      }), r.addEventListener("error", function (e) {
        return t.fireEvent("error", e);
      }), r.send(), t.xhr = r, t;
    };var n,
        i = (n = r(1)) && n.__esModule ? n : { default: n };e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function () {
      return "wavesurfer_" + Math.random().toString(32).substring(2);
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t) {
      var r = -1 / 0;return Object.keys(t).forEach(function (e) {
        t[e] > r && (r = t[e]);
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t) {
      var r = Number(1 / 0);return Object.keys(t).forEach(function (e) {
        t[e] < r && (r = t[e]);
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (r) {
      for (var e = arguments.length, t = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++) {
        t[n - 1] = arguments[n];
      }return t.forEach(function (t) {
        Object.keys(t).forEach(function (e) {
          r[e] = t[e];
        });
      }), r;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (t, r) {
      return Object.keys(r).forEach(function (e) {
        t.style[e] !== r[e] && (t.style[e] = r[e]);
      }), t;
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (n) {
      return function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
          t[r] = arguments[r];
        }return (0, i.default)(function () {
          return n.apply(void 0, t);
        });
      };
    };var n,
        i = (n = r(2)) && n.__esModule ? n : { default: n };e.exports = t.default;
  }, function (e, t) {
    function r(t, r, n) {
      var i, a, s, o, u;function l() {
        var e = Date.now() - o;e < r && 0 <= e ? i = setTimeout(l, r - e) : (i = null, n || (u = t.apply(s, a), s = a = null));
      }null == r && (r = 100);var e = function e() {
        s = this, a = arguments, o = Date.now();var e = n && !i;return i || (i = setTimeout(l, r)), e && (u = t.apply(s, a), s = a = null), u;
      };return e.clear = function () {
        i && (clearTimeout(i), i = null);
      }, e.flush = function () {
        i && (u = t.apply(s, a), s = a = null, clearTimeout(i), i = null);
      }, e;
    }r.debounce = r, e.exports = r;
  }, function (e, t, r) {
    "use strict";
    function n(e) {
      e.stopPropagation(), document.body.removeEventListener("click", n, !0);
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) {
      document.body.addEventListener("click", n, !0);
    }, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n,
        a = (n = r(15)) && n.__esModule ? n : { default: n },
        f = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e) {
      return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function l(e, t) {
      return (l = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var c = function (e) {
      function n(e, t) {
        var r;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (r = o(this, u(n).call(this, e, t))).maxCanvasWidth = t.maxCanvasWidth, r.maxCanvasElementWidth = Math.round(t.maxCanvasWidth / t.pixelRatio), r.hasProgressCanvas = t.waveColor != t.progressColor, r.halfPixel = .5 / t.pixelRatio, r.canvases = [], r.progressWave = null, r;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && l(e, t);
      }(n, a.default), t = n, (r = [{ key: "init", value: function value() {
          this.createWrapper(), this.createElements();
        } }, { key: "createElements", value: function value() {
          this.progressWave = this.wrapper.appendChild(this.style(document.createElement("wave"), { position: "absolute", zIndex: 3, left: 0, top: 0, bottom: 0, overflow: "hidden", width: "0", display: "none", boxSizing: "border-box", borderRightStyle: "solid", pointerEvents: "none" })), this.addCanvas(), this.updateCursor();
        } }, { key: "updateCursor", value: function value() {
          this.style(this.progressWave, { borderRightWidth: this.params.cursorWidth + "px", borderRightColor: this.params.cursorColor });
        } }, { key: "updateSize", value: function value() {
          for (var n = this, e = Math.round(this.width / this.params.pixelRatio), t = Math.ceil(e / this.maxCanvasElementWidth); this.canvases.length < t;) {
            this.addCanvas();
          }for (; this.canvases.length > t;) {
            this.removeCanvas();
          }this.canvases.forEach(function (e, t) {
            var r = n.maxCanvasWidth + 2 * Math.ceil(n.params.pixelRatio / 2);t == n.canvases.length - 1 && (r = n.width - n.maxCanvasWidth * (n.canvases.length - 1)), n.updateDimensions(e, r, n.height), n.clearWaveForEntry(e);
          });
        } }, { key: "addCanvas", value: function value() {
          var e = {},
              t = this.maxCanvasElementWidth * this.canvases.length;e.wave = this.wrapper.appendChild(this.style(document.createElement("canvas"), { position: "absolute", zIndex: 2, left: t + "px", top: 0, bottom: 0, height: "100%", pointerEvents: "none" })), e.waveCtx = e.wave.getContext("2d"), this.hasProgressCanvas && (e.progress = this.progressWave.appendChild(this.style(document.createElement("canvas"), { position: "absolute", left: t + "px", top: 0, bottom: 0, height: "100%" })), e.progressCtx = e.progress.getContext("2d")), this.canvases.push(e);
        } }, { key: "removeCanvas", value: function value() {
          var e = this.canvases.pop();e.wave.parentElement.removeChild(e.wave), this.hasProgressCanvas && e.progress.parentElement.removeChild(e.progress);
        } }, { key: "updateDimensions", value: function value(e, t, r) {
          var n = Math.round(t / this.params.pixelRatio),
              i = Math.round(this.width / this.params.pixelRatio);e.start = e.waveCtx.canvas.offsetLeft / i || 0, e.end = e.start + n / i, e.waveCtx.canvas.width = t, e.waveCtx.canvas.height = r, this.style(e.waveCtx.canvas, { width: n + "px" }), this.style(this.progressWave, { display: "block" }), this.hasProgressCanvas && (e.progressCtx.canvas.width = t, e.progressCtx.canvas.height = r, this.style(e.progressCtx.canvas, { width: n + "px" }));
        } }, { key: "clearWave", value: function value() {
          var t = this;this.canvases.forEach(function (e) {
            return t.clearWaveForEntry(e);
          });
        } }, { key: "clearWaveForEntry", value: function value(e) {
          e.waveCtx.clearRect(0, 0, e.waveCtx.canvas.width, e.waveCtx.canvas.height), this.hasProgressCanvas && e.progressCtx.clearRect(0, 0, e.progressCtx.canvas.width, e.progressCtx.canvas.height);
        } }, { key: "drawBars", value: function value(e, t, v, y) {
          var m = this;return this.prepareDraw(e, t, v, y, function (e) {
            var t = e.absmax,
                r = e.hasMinVals,
                n = (e.height, e.offsetY),
                i = e.halfH,
                a = e.peaks;if (void 0 !== v) {
              var s,
                  o = r ? 2 : 1,
                  u = a.length / o,
                  l = m.params.barWidth * m.params.pixelRatio,
                  c = l + (null === m.params.barGap ? Math.max(m.params.pixelRatio, ~~(l / 2)) : Math.max(m.params.pixelRatio, m.params.barGap * m.params.pixelRatio)),
                  h = u / m.width,
                  f = y;for (s = v; s < f; s += c) {
                var d = a[Math.floor(s * h * o)] || 0,
                    p = Math.round(d / t * i);m.fillRect(s + m.halfPixel, i - p + n, l + m.halfPixel, 2 * p);
              }
            }
          });
        } }, { key: "drawWave", value: function value(e, t, l, c) {
          var h = this;return this.prepareDraw(e, t, l, c, function (e) {
            var t = e.absmax,
                r = e.hasMinVals,
                n = (e.height, e.offsetY),
                i = e.halfH,
                a = e.peaks;if (!r) {
              var s,
                  o = [],
                  u = a.length;for (s = 0; s < u; s++) {
                o[2 * s] = a[s], o[2 * s + 1] = -a[s];
              }a = o;
            }void 0 !== l && h.drawLine(a, t, i, n, l, c), h.fillRect(0, i + n - h.halfPixel, h.width, h.halfPixel);
          });
        } }, { key: "drawLine", value: function value(t, r, n, i, a, s) {
          var o = this;this.canvases.forEach(function (e) {
            o.setFillStyles(e), o.drawLineToContext(e, e.waveCtx, t, r, n, i, a, s), o.drawLineToContext(e, e.progressCtx, t, r, n, i, a, s);
          });
        } }, { key: "drawLineToContext", value: function value(e, t, r, n, i, a, s, o) {
          if (t) {
            var u = r.length / 2,
                l = this.params.fillParent && this.width != u ? this.width / u : 1,
                c = Math.round(u * e.start),
                h = Math.round(u * e.end) + 1;if (!(o < c || h < s)) {
              var f,
                  d,
                  p = Math.min(c, s),
                  v = Math.max(h, o);for (t.beginPath(), t.moveTo((p - c) * l + this.halfPixel, i + a), f = p; f < v; f++) {
                var y = r[2 * f] || 0,
                    m = Math.round(y / n * i);t.lineTo((f - c) * l + this.halfPixel, i - m + a);
              }for (d = v - 1; p <= d; d--) {
                var b = r[2 * d + 1] || 0,
                    g = Math.round(b / n * i);t.lineTo((d - c) * l + this.halfPixel, i - g + a);
              }t.closePath(), t.fill();
            }
          }
        } }, { key: "fillRect", value: function value(e, t, r, n) {
          var i,
              a = Math.floor(e / this.maxCanvasWidth),
              s = Math.min(Math.ceil((e + r) / this.maxCanvasWidth) + 1, this.canvases.length);for (i = a; i < s; i++) {
            var o = this.canvases[i],
                u = i * this.maxCanvasWidth,
                l = { x1: Math.max(e, i * this.maxCanvasWidth), y1: t, x2: Math.min(e + r, i * this.maxCanvasWidth + o.waveCtx.canvas.width), y2: t + n };l.x1 < l.x2 && (this.setFillStyles(o), this.fillRectToContext(o.waveCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1), this.fillRectToContext(o.progressCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1));
          }
        } }, { key: "prepareDraw", value: function value(s, o, u, l, c) {
          var h = this;return f.frame(function () {
            if (s[0] instanceof Array) {
              var e = s;if (h.params.splitChannels) return h.setHeight(e.length * h.params.height * h.params.pixelRatio), e.forEach(function (e, t) {
                return h.prepareDraw(e, t, u, l, c);
              });s = e[0];
            }var t = 1 / h.params.barHeight;if (h.params.normalize) {
              var r = f.max(s),
                  n = f.min(s);t = r < -n ? -n : r;
            }var i = [].some.call(s, function (e) {
              return e < 0;
            }),
                a = h.params.height * h.params.pixelRatio;return c({ absmax: t, hasMinVals: i, height: a, offsetY: a * o || 0, halfH: a / 2, peaks: s });
          })();
        } }, { key: "fillRectToContext", value: function value(e, t, r, n, i) {
          e && e.fillRect(t, r, n, i);
        } }, { key: "setFillStyles", value: function value(e) {
          e.waveCtx.fillStyle = this.params.waveColor, this.hasProgressCanvas && (e.progressCtx.fillStyle = this.params.progressColor);
        } }, { key: "getImage", value: function value(t, r) {
          var e = this.canvases.map(function (e) {
            return e.wave.toDataURL(t, r);
          });return 1 < e.length ? e : e[0];
        } }, { key: "updateProgress", value: function value(e) {
          this.style(this.progressWave, { width: e + "px" });
        } }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = c, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var a = function (e) {
      {
        if (e && e.__esModule) return e;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }return t.default = e, t;
      }
    }(r(0));function n(e) {
      return (n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== n(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e) {
      return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function l(e, t) {
      return (l = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var i = function (e) {
      function n(e, t) {
        var r;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (r = o(this, u(n).call(this))).container = e, r.params = t, r.width = 0, r.height = t.height * r.params.pixelRatio, r.lastPos = 0, r.wrapper = null, r;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && l(e, t);
      }(n, a.Observer), t = n, (r = [{ key: "style", value: function value(e, t) {
          return a.style(e, t);
        } }, { key: "createWrapper", value: function value() {
          this.wrapper = this.container.appendChild(document.createElement("wave")), this.style(this.wrapper, { display: "block", position: "relative", userSelect: "none", webkitUserSelect: "none", height: this.params.height + "px" }), (this.params.fillParent || this.params.scrollParent) && this.style(this.wrapper, { width: "100%", overflowX: this.params.hideScrollbar ? "hidden" : "auto", overflowY: "hidden" }), this.setupWrapperEvents();
        } }, { key: "handleEvent", value: function value(e, t) {
          !t && e.preventDefault();var r,
              n = e.targetTouches ? e.targetTouches[0].clientX : e.clientX,
              i = this.wrapper.getBoundingClientRect(),
              a = this.width,
              s = this.getWidth();return !this.params.fillParent && a < s ? 1 < (r = (n - i.left) * (this.params.pixelRatio / a) || 0) && (r = 1) : r = (n - i.left + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0, r;
        } }, { key: "setupWrapperEvents", value: function value() {
          var n = this;this.wrapper.addEventListener("click", function (e) {
            var t = n.wrapper.offsetHeight - n.wrapper.clientHeight;if (0 != t) {
              var r = n.wrapper.getBoundingClientRect();if (e.clientY >= r.bottom - t) return;
            }n.params.interact && n.fireEvent("click", e, n.handleEvent(e));
          }), this.wrapper.addEventListener("scroll", function (e) {
            return n.fireEvent("scroll", e);
          });
        } }, { key: "drawPeaks", value: function value(e, t, r, n) {
          this.setWidth(t) || this.clearWave(), this.params.barWidth ? this.drawBars(e, 0, r, n) : this.drawWave(e, 0, r, n);
        } }, { key: "resetScroll", value: function value() {
          null !== this.wrapper && (this.wrapper.scrollLeft = 0);
        } }, { key: "recenter", value: function value(e) {
          var t = this.wrapper.scrollWidth * e;this.recenterOnPosition(t, !0);
        } }, { key: "recenterOnPosition", value: function value(e, t) {
          var r = this.wrapper.scrollLeft,
              n = ~~(this.wrapper.clientWidth / 2),
              i = this.wrapper.scrollWidth - this.wrapper.clientWidth,
              a = e - n,
              s = a - r;if (0 != i) {
            if (!t && -n <= s && s < n) {
              a = r + (s = Math.max(-5, Math.min(5, s)));
            }(a = Math.max(0, Math.min(i, a))) != r && (this.wrapper.scrollLeft = a);
          }
        } }, { key: "getScrollX", value: function value() {
          var e = this.params.pixelRatio,
              t = Math.round(this.wrapper.scrollLeft * e);if (this.params.scrollParent) {
            var r = ~~(this.wrapper.scrollWidth * e - this.getWidth());t = Math.min(r, Math.max(0, t));
          }return t;
        } }, { key: "getWidth", value: function value() {
          return Math.round(this.container.clientWidth * this.params.pixelRatio);
        } }, { key: "setWidth", value: function value(e) {
          return this.width != e && (this.width = e, this.params.fillParent || this.params.scrollParent ? this.style(this.wrapper, { width: "" }) : this.style(this.wrapper, { width: ~~(this.width / this.params.pixelRatio) + "px" }), this.updateSize(), !0);
        } }, { key: "setHeight", value: function value(e) {
          return e != this.height && (this.height = e, this.style(this.wrapper, { height: ~~(this.height / this.params.pixelRatio) + "px" }), this.updateSize(), !0);
        } }, { key: "progress", value: function value(e) {
          var t = 1 / this.params.pixelRatio,
              r = Math.round(e * this.width) * t;if (r < this.lastPos || r - this.lastPos >= t) {
            if (this.lastPos = r, this.params.scrollParent && this.params.autoCenter) {
              var n = ~~(this.wrapper.scrollWidth * e);this.recenterOnPosition(n);
            }this.updateProgress(r);
          }
        } }, { key: "destroy", value: function value() {
          this.unAll(), this.wrapper && (this.wrapper.parentNode == this.container && this.container.removeChild(this.wrapper), this.wrapper = null);
        } }, { key: "updateCursor", value: function value() {} }, { key: "updateSize", value: function value() {} }, { key: "drawBars", value: function value(e, t, r, n) {} }, { key: "drawWave", value: function value(e, t, r, n) {} }, { key: "clearWave", value: function value() {} }, { key: "updateProgress", value: function value(e) {} }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = i, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n,
        a = (n = r(3)) && n.__esModule ? n : { default: n };!function (e) {
      {
        if (e && e.__esModule) return;var t = {};if (null != e) for (var r in e) {
          if (Object.prototype.hasOwnProperty.call(e, r)) {
            var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];
          }
        }t.default = e;
      }
    }(r(0));function i(e) {
      return (i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return typeof e === "undefined" ? "undefined" : _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
      })(e);
    }function s(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }function o(e, t) {
      return !t || "object" !== i(t) && "function" != typeof t ? function (e) {
        if (void 0 !== e) return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }(e) : t;
    }function u(e, t, r) {
      return (u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, r) {
        var n = function (e, t) {
          for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = l(e));) {}return e;
        }(e, t);if (n) {
          var i = Object.getOwnPropertyDescriptor(n, t);return i.get ? i.get.call(r) : i.value;
        }
      })(e, t, r || e);
    }function l(e) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(e);
    }function c(e, t) {
      return (c = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }var h = function (e) {
      function n(e) {
        var t;return function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, n), (t = o(this, l(n).call(this, e))).params = e, t.media = { currentTime: 0, duration: 0, paused: !0, playbackRate: 1, play: function play() {}, pause: function pause() {}, volume: 0 }, t.mediaType = e.mediaType.toLowerCase(), t.elementPosition = e.elementPosition, t.peaks = null, t.playbackRate = 1, t.volume = 1, t.buffer = null, t.onPlayEnd = null, t;
      }var t, r, i;return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && c(e, t);
      }(n, a.default), t = n, (r = [{ key: "init", value: function value() {
          this.setPlaybackRate(this.params.audioRate), this.createTimer();
        } }, { key: "createTimer", value: function value() {
          var t = this;this.on("play", function e() {
            t.isPaused() || (t.fireEvent("audioprocess", t.getCurrentTime()), (window.requestAnimationFrame || window.webkitRequestAnimationFrame)(e));
          }), this.on("pause", function () {
            t.fireEvent("audioprocess", t.getCurrentTime());
          });
        } }, { key: "load", value: function value(e, t, r, n) {
          var i = document.createElement(this.mediaType);i.controls = this.params.mediaControls, i.autoplay = this.params.autoplay || !1, i.preload = null == n ? "auto" : n, i.src = e, i.style.width = "100%";var a = t.querySelector(this.mediaType);a && t.removeChild(a), t.appendChild(i), this._load(i, r);
        } }, { key: "loadElt", value: function value(e, t) {
          e.controls = this.params.mediaControls, e.autoplay = this.params.autoplay || !1, this._load(e, t);
        } }, { key: "_load", value: function value(e, t) {
          var r = this;"function" == typeof e.load && e.load(), e.addEventListener("error", function () {
            r.fireEvent("error", "Error loading media element");
          }), e.addEventListener("canplay", function () {
            r.fireEvent("canplay");
          }), e.addEventListener("ended", function () {
            r.fireEvent("finish");
          }), e.addEventListener("play", function () {
            r.fireEvent("play");
          }), e.addEventListener("pause", function () {
            r.fireEvent("pause");
          }), this.media = e, this.peaks = t, this.onPlayEnd = null, this.buffer = null, this.setPlaybackRate(this.playbackRate), this.setVolume(this.volume);
        } }, { key: "isPaused", value: function value() {
          return !this.media || this.media.paused;
        } }, { key: "getDuration", value: function value() {
          if (this.explicitDuration) return this.explicitDuration;var e = (this.buffer || this.media).duration;return 1 / 0 <= e && (e = this.media.seekable.end(0)), e;
        } }, { key: "getCurrentTime", value: function value() {
          return this.media && this.media.currentTime;
        } }, { key: "getPlayedPercents", value: function value() {
          return this.getCurrentTime() / this.getDuration() || 0;
        } }, { key: "getPlaybackRate", value: function value() {
          return this.playbackRate || this.media.playbackRate;
        } }, { key: "setPlaybackRate", value: function value(e) {
          this.playbackRate = e || 1, this.media.playbackRate = this.playbackRate;
        } }, { key: "seekTo", value: function value(e) {
          null != e && (this.media.currentTime = e), this.clearPlayEnd();
        } }, { key: "play", value: function value(e, t) {
          this.seekTo(e);var r = this.media.play();return t && this.setPlayEnd(t), r;
        } }, { key: "pause", value: function value() {
          var e;return this.media && (e = this.media.pause()), this.clearPlayEnd(), e;
        } }, { key: "setPlayEnd", value: function value(t) {
          var r = this;this._onPlayEnd = function (e) {
            t <= e && (r.pause(), r.seekTo(t));
          }, this.on("audioprocess", this._onPlayEnd);
        } }, { key: "clearPlayEnd", value: function value() {
          this._onPlayEnd && (this.un("audioprocess", this._onPlayEnd), this._onPlayEnd = null);
        } }, { key: "getPeaks", value: function value(e, t, r) {
          return this.buffer ? u(l(n.prototype), "getPeaks", this).call(this, e, t, r) : this.peaks || [];
        } }, { key: "setSinkId", value: function value(e) {
          return e ? this.media.setSinkId ? this.media.setSinkId(e) : Promise.reject(new Error("setSinkId is not supported in your browser")) : Promise.reject(new Error("Invalid deviceId: " + e));
        } }, { key: "getVolume", value: function value() {
          return this.volume || this.media.volume;
        } }, { key: "setVolume", value: function value(e) {
          this.volume = e, this.media.volume = this.volume;
        } }, { key: "destroy", value: function value() {
          this.pause(), this.unAll(), this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode && this.media.parentNode.removeChild(this.media), this.media = null;
        } }]) && s(t.prototype, r), i && s(t, i), n;
    }();t.default = h, e.exports = t.default;
  }, function (e, t, r) {
    "use strict";
    function i(e, t) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
      }
    }Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;var n = function () {
      function e() {
        !function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }(this, e), this.clearPeakCache();
      }var t, r, n;return t = e, (r = [{ key: "clearPeakCache", value: function value() {
          this.peakCacheRanges = [], this.peakCacheLength = -1;
        } }, { key: "addRangeToPeakCache", value: function value(e, t, r) {
          e != this.peakCacheLength && (this.clearPeakCache(), this.peakCacheLength = e);for (var n = [], i = 0; i < this.peakCacheRanges.length && this.peakCacheRanges[i] < t;) {
            i++;
          }for (i % 2 == 0 && n.push(t); i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= r;) {
            n.push(this.peakCacheRanges[i]), i++;
          }i % 2 == 0 && n.push(r), n = n.filter(function (e, t, r) {
            return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];
          }), this.peakCacheRanges = this.peakCacheRanges.concat(n), this.peakCacheRanges = this.peakCacheRanges.sort(function (e, t) {
            return e - t;
          }).filter(function (e, t, r) {
            return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];
          });var a = [];for (i = 0; i < n.length; i += 2) {
            a.push([n[i], n[i + 1]]);
          }return a;
        } }, { key: "getCacheRanges", value: function value() {
          var e,
              t = [];for (e = 0; e < this.peakCacheRanges.length; e += 2) {
            t.push([this.peakCacheRanges[e], this.peakCacheRanges[e + 1]]);
          }return t;
        } }]) && i(t.prototype, r), n && i(t, n), e;
    }();t.default = n, e.exports = t.default;
  }]);
});


},{}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * (Single) Region plugin class
 *
 * Must be turned into an observer before instantiating. This is done in
 * RegionsPlugin (main plugin class)
 *
 * @extends {Observer}
 */
var Region = function () {
    function Region(params, ws) {
        var _this = this;

        _classCallCheck(this, Region);

        this.wavesurfer = ws;
        this.wrapper = ws.drawer.wrapper;
        this.util = ws.util;
        this.style = this.util.style;

        this.id = params.id == null ? ws.util.getId() : params.id;
        this.start = Number(params.start) || 0;
        this.end = params.end == null ? // small marker-like region
        this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);
        this.resize = params.resize === undefined ? true : Boolean(params.resize);
        this.drag = params.drag === undefined ? true : Boolean(params.drag);
        this.loop = Boolean(params.loop);
        this.color = params.color || 'rgba(0, 0, 0, 0.1)';
        this.data = params.data || {};
        this.attributes = params.attributes || {};

        this.maxLength = params.maxLength;
        this.minLength = params.minLength;
        this._onRedraw = function () {
            return _this.updateRender();
        };

        this.scroll = params.scroll !== false && ws.params.scrollParent;
        this.scrollSpeed = params.scrollSpeed || 1;
        this.scrollThreshold = params.scrollThreshold || 10;

        this.bindInOut();
        this.render();
        this.wavesurfer.on('zoom', this._onRedraw);
        this.wavesurfer.on('redraw', this._onRedraw);
        this.wavesurfer.fireEvent('region-created', this);
    }

    /* Update region params. */


    _createClass(Region, [{
        key: 'update',
        value: function update(params) {
            if (null != params.start) {
                this.start = Number(params.start);
            }
            if (null != params.end) {
                this.end = Number(params.end);
            }
            if (null != params.loop) {
                this.loop = Boolean(params.loop);
            }
            if (null != params.color) {
                this.color = params.color;
            }
            if (null != params.data) {
                this.data = params.data;
            }
            if (null != params.resize) {
                this.resize = Boolean(params.resize);
            }
            if (null != params.drag) {
                this.drag = Boolean(params.drag);
            }
            if (null != params.maxLength) {
                this.maxLength = Number(params.maxLength);
            }
            if (null != params.minLength) {
                this.minLength = Number(params.minLength);
            }
            if (null != params.attributes) {
                this.attributes = params.attributes;
            }

            this.updateRender();
            this.fireEvent('update');
            this.wavesurfer.fireEvent('region-updated', this);
        }

        /* Remove a single region. */

    }, {
        key: 'remove',
        value: function remove() {
            if (this.element) {
                this.wrapper.removeChild(this.element);
                this.element = null;
                this.fireEvent('remove');
                this.wavesurfer.un('zoom', this._onRedraw);
                this.wavesurfer.un('redraw', this._onRedraw);
                this.wavesurfer.fireEvent('region-removed', this);
            }
        }

        /* Play the audio region. */

    }, {
        key: 'play',
        value: function play() {
            this.wavesurfer.play(this.start, this.end);
            this.fireEvent('play');
            this.wavesurfer.fireEvent('region-play', this);
        }

        /* Play the region in loop. */

    }, {
        key: 'playLoop',
        value: function playLoop() {
            var _this2 = this;

            this.play();
            this.once('out', function () {
                return _this2.playLoop();
            });
        }

        /* Render a region as a DOM element. */

    }, {
        key: 'render',
        value: function render() {
            var regionEl = document.createElement('region');
            regionEl.className = 'wavesurfer-region';
            regionEl.title = this.formatTime(this.start, this.end);
            regionEl.setAttribute('data-id', this.id);

            for (var attrname in this.attributes) {
                regionEl.setAttribute('data-region-' + attrname, this.attributes[attrname]);
            }

            var width = this.wrapper.scrollWidth;
            this.style(regionEl, {
                position: 'absolute',
                zIndex: 2,
                height: '100%',
                top: '0px'
            });

            /* Resize handles */
            if (this.resize) {
                var handleLeft = regionEl.appendChild(document.createElement('handle'));
                var handleRight = regionEl.appendChild(document.createElement('handle'));
                handleLeft.className = 'wavesurfer-handle wavesurfer-handle-start';
                handleRight.className = 'wavesurfer-handle wavesurfer-handle-end';
                var css = {
                    cursor: 'col-resize',
                    position: 'absolute',
                    left: '0px',
                    top: '0px',
                    width: '1%',
                    maxWidth: '4px',
                    height: '100%'
                };
                this.style(handleLeft, css);
                this.style(handleRight, css);
                this.style(handleRight, {
                    left: '100%'
                });
            }

            this.element = this.wrapper.appendChild(regionEl);
            this.updateRender();
            this.bindEvents(regionEl);
        }
    }, {
        key: 'formatTime',
        value: function formatTime(start, end) {
            return (start == end ? [start] : [start, end]).map(function (time) {
                return [Math.floor(time % 3600 / 60), // minutes
                ('00' + Math.floor(time % 60)).slice(-2) // seconds
                ].join(':');
            }).join('-');
        }
    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
        }

        /* Update element's position, width, color. */

    }, {
        key: 'updateRender',
        value: function updateRender() {
            var dur = this.wavesurfer.getDuration();
            var width = this.getWidth();

            if (this.start < 0) {
                this.start = 0;
                this.end = this.end - this.start;
            }
            if (this.end > dur) {
                this.end = dur;
                this.start = dur - (this.end - this.start);
            }

            if (this.minLength != null) {
                this.end = Math.max(this.start + this.minLength, this.end);
            }

            if (this.maxLength != null) {
                this.end = Math.min(this.start + this.maxLength, this.end);
            }

            if (this.element != null) {
                // Calculate the left and width values of the region such that
                // no gaps appear between regions.
                var left = Math.round(this.start / dur * width);
                var regionWidth = Math.round(this.end / dur * width) - left;

                this.style(this.element, {
                    left: left + 'px',
                    width: regionWidth + 'px',
                    backgroundColor: this.color,
                    cursor: this.drag ? 'move' : 'default'
                });

                for (var attrname in this.attributes) {
                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                }

                this.element.title = this.formatTime(this.start, this.end);
            }
        }

        /* Bind audio events. */

    }, {
        key: 'bindInOut',
        value: function bindInOut() {
            var _this3 = this;

            this.firedIn = false;
            this.firedOut = false;

            var onProcess = function onProcess(time) {
                if (!_this3.firedOut && _this3.firedIn && (_this3.start >= Math.round(time * 100) / 100 || _this3.end <= Math.round(time * 100) / 100)) {
                    _this3.firedOut = true;
                    _this3.firedIn = false;
                    _this3.fireEvent('out');
                    _this3.wavesurfer.fireEvent('region-out', _this3);
                }
                if (!_this3.firedIn && _this3.start <= time && _this3.end > time) {
                    _this3.firedIn = true;
                    _this3.firedOut = false;
                    _this3.fireEvent('in');
                    _this3.wavesurfer.fireEvent('region-in', _this3);
                }
            };

            this.wavesurfer.backend.on('audioprocess', onProcess);

            this.on('remove', function () {
                _this3.wavesurfer.backend.un('audioprocess', onProcess);
            });

            /* Loop playback. */
            this.on('out', function () {
                if (_this3.loop) {
                    _this3.wavesurfer.play(_this3.start);
                }
            });
        }

        /* Bind DOM events. */

    }, {
        key: 'bindEvents',
        value: function bindEvents() {
            var _this4 = this;

            this.element.addEventListener('mouseenter', function (e) {
                _this4.fireEvent('mouseenter', e);
                _this4.wavesurfer.fireEvent('region-mouseenter', _this4, e);
            });

            this.element.addEventListener('mouseleave', function (e) {
                _this4.fireEvent('mouseleave', e);
                _this4.wavesurfer.fireEvent('region-mouseleave', _this4, e);
            });

            this.element.addEventListener('click', function (e) {
                e.preventDefault();
                _this4.fireEvent('click', e);
                _this4.wavesurfer.fireEvent('region-click', _this4, e);
            });

            this.element.addEventListener('dblclick', function (e) {
                e.stopPropagation();
                e.preventDefault();
                _this4.fireEvent('dblclick', e);
                _this4.wavesurfer.fireEvent('region-dblclick', _this4, e);
            });

            /* Drag or resize on mousemove. */
            (this.drag || this.resize) && function () {
                var container = _this4.wavesurfer.drawer.container;
                var duration = _this4.wavesurfer.getDuration();
                var scrollSpeed = _this4.scrollSpeed;
                var scrollThreshold = _this4.scrollThreshold;
                var startTime = void 0;
                var touchId = void 0;
                var drag = void 0;
                var maxScroll = void 0;
                var resize = void 0;
                var updated = false;
                var scrollDirection = void 0;
                var wrapperRect = void 0;

                // Scroll when the user is dragging within the threshold
                var edgeScroll = function edgeScroll(e) {
                    if (!scrollDirection || !drag && !resize) {
                        return;
                    }

                    // Update scroll position
                    var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                    _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft));

                    // Update time
                    var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;
                    var delta = time - startTime;
                    startTime = time;

                    // Continue dragging or resizing
                    drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize);

                    // Repeat
                    window.requestAnimationFrame(function () {
                        edgeScroll(e);
                    });
                };

                var onDown = function onDown(e) {
                    if (e.touches && e.touches.length > 1) {
                        return;
                    }
                    touchId = e.targetTouches ? e.targetTouches[0].identifier : null;

                    e.stopPropagation();
                    startTime = _this4.wavesurfer.drawer.handleEvent(e, true) * duration;

                    // Store for scroll calculations
                    maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                    wrapperRect = _this4.wrapper.getBoundingClientRect();

                    if (e.target.tagName.toLowerCase() == 'handle') {
                        if (e.target.classList.contains('wavesurfer-handle-start')) {
                            resize = 'start';
                        } else {
                            resize = 'end';
                        }
                    } else {
                        drag = true;
                        resize = false;
                    }
                };
                var onUp = function onUp(e) {
                    if (e.touches && e.touches.length > 1) {
                        return;
                    }

                    if (drag || resize) {
                        drag = false;
                        scrollDirection = null;
                        resize = false;
                    }

                    if (updated) {
                        updated = false;
                        _this4.util.preventClick();
                        _this4.fireEvent('update-end', e);
                        _this4.wavesurfer.fireEvent('region-update-end', _this4, e);
                    }
                };
                var onMove = function onMove(e) {
                    if (e.touches && e.touches.length > 1) {
                        return;
                    }
                    if (e.targetTouches && e.targetTouches[0].identifier != touchId) {
                        return;
                    }

                    if (drag || resize) {
                        var oldTime = startTime;
                        var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;
                        var delta = time - startTime;
                        startTime = time;

                        // Drag
                        if (_this4.drag && drag) {
                            updated = updated || !!delta;
                            _this4.onDrag(delta);
                        }

                        // Resize
                        if (_this4.resize && resize) {
                            updated = updated || !!delta;
                            _this4.onResize(delta, resize);
                        }

                        if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                            if (drag) {
                                // The threshold is not between the mouse and the container edge
                                // but is between the region and the container edge
                                var regionRect = _this4.element.getBoundingClientRect();
                                var x = regionRect.left - wrapperRect.left;

                                // Check direction
                                if (time < oldTime && x >= 0) {
                                    scrollDirection = -1;
                                } else if (time > oldTime && x + regionRect.width <= wrapperRect.right) {
                                    scrollDirection = 1;
                                }

                                // Check that we are still beyond the threshold
                                if (scrollDirection === -1 && x > scrollThreshold || scrollDirection === 1 && x + regionRect.width < wrapperRect.right - scrollThreshold) {
                                    scrollDirection = null;
                                }
                            } else {
                                // Mouse based threshold
                                var _x = e.clientX - wrapperRect.left;

                                // Check direction
                                if (_x <= scrollThreshold) {
                                    scrollDirection = -1;
                                } else if (_x >= wrapperRect.right - scrollThreshold) {
                                    scrollDirection = 1;
                                } else {
                                    scrollDirection = null;
                                }
                            }

                            scrollDirection && edgeScroll(e);
                        }
                    }
                };

                _this4.element.addEventListener('mousedown', onDown);
                _this4.element.addEventListener('touchstart', onDown);

                _this4.wrapper.addEventListener('mousemove', onMove);
                _this4.wrapper.addEventListener('touchmove', onMove);

                document.body.addEventListener('mouseup', onUp);
                document.body.addEventListener('touchend', onUp);

                _this4.on('remove', function () {
                    document.body.removeEventListener('mouseup', onUp);
                    document.body.removeEventListener('touchend', onUp);
                    _this4.wrapper.removeEventListener('mousemove', onMove);
                    _this4.wrapper.removeEventListener('touchmove', onMove);
                });

                _this4.wavesurfer.on('destroy', function () {
                    document.body.removeEventListener('mouseup', onUp);
                    document.body.removeEventListener('touchend', onUp);
                });
            }();
        }
    }, {
        key: 'onDrag',
        value: function onDrag(delta) {
            var maxEnd = this.wavesurfer.getDuration();
            if (this.end + delta > maxEnd || this.start + delta < 0) {
                return;
            }

            this.update({
                start: this.start + delta,
                end: this.end + delta
            });
        }
    }, {
        key: 'onResize',
        value: function onResize(delta, direction) {
            if (direction == 'start') {
                this.update({
                    start: Math.min(this.start + delta, this.end),
                    end: Math.max(this.start + delta, this.end)
                });
            } else {
                this.update({
                    start: Math.min(this.end + delta, this.start),
                    end: Math.max(this.end + delta, this.start)
                });
            }
        }
    }]);

    return Region;
}();

/**
 * @typedef {Object} RegionsPluginParams
 * @property {?boolean} dragSelection Enable creating regions by dragging wih
 * the mouse
 * @property {?RegionParams[]} regions Regions that should be added upon
 * initialisation
 * @property {number} slop=2 The sensitivity of the mouse dragging
 * @property {?boolean} deferInit Set to true to manually call
 * `initPlugin('regions')`
 */

/**
 * @typedef {Object} RegionParams
 * @desc The parameters used to describe a region.
 * @example wavesurfer.addRegion(regionParams);
 * @property {string} id=→random The id of the region
 * @property {number} start=0 The start position of the region (in seconds).
 * @property {number} end=0 The end position of the region (in seconds).
 * @property {?boolean} loop Whether to loop the region when played back.
 * @property {boolean} drag=true Allow/dissallow dragging the region.
 * @property {boolean} resize=true Allow/dissallow resizing the region.
 * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.
 */

/**
 * Regions are visual overlays on waveform that can be used to play and loop
 * portions of audio. Regions can be dragged and resized.
 *
 * Visual customization is possible via CSS (using the selectors
 * `.wavesurfer-region` and `.wavesurfer-handle`).
 *
 * @implements {PluginClass}
 * @extends {Observer}
 *
 * @example
 * // es6
 * import RegionsPlugin from 'wavesurfer.regions.js';
 *
 * // commonjs
 * var RegionsPlugin = require('wavesurfer.regions.js');
 *
 * // if you are using <script> tags
 * var RegionsPlugin = window.WaveSurfer.regions;
 *
 * // ... initialising wavesurfer with the plugin
 * var wavesurfer = WaveSurfer.create({
 *   // wavesurfer options ...
 *   plugins: [
 *     RegionsPlugin.create({
 *       // plugin options ...
 *     })
 *   ]
 * });
 */


var RegionsPlugin = function () {
    _createClass(RegionsPlugin, null, [{
        key: 'create',

        /**
         * Regions plugin definition factory
         *
         * This function must be used to create a plugin definition which can be
         * used by wavesurfer to correctly instantiate the plugin.
         *
         * @param {RegionsPluginParams} params parameters use to initialise the plugin
         * @return {PluginDefinition} an object representing the plugin
         */
        value: function create(params) {
            return {
                name: 'regions',
                deferInit: params && params.deferInit ? params.deferInit : false,
                params: params,
                staticProps: {
                    initRegions: function initRegions() {
                        console.warn('Deprecated initRegions! Use wavesurfer.initPlugins("regions") instead!');
                        this.initPlugin('regions');
                    },
                    addRegion: function addRegion(options) {
                        if (!this.initialisedPluginList.regions) {
                            this.initPlugin('regions');
                        }
                        return this.regions.add(options);
                    },
                    clearRegions: function clearRegions() {
                        this.regions && this.regions.clear();
                    },
                    enableDragSelection: function enableDragSelection(options) {
                        if (!this.initialisedPluginList.regions) {
                            this.initPlugin('regions');
                        }
                        this.regions.enableDragSelection(options);
                    },
                    disableDragSelection: function disableDragSelection() {
                        this.regions.disableDragSelection();
                    }
                },
                instance: RegionsPlugin
            };
        }
    }]);

    function RegionsPlugin(params, ws) {
        var _this5 = this;

        _classCallCheck(this, RegionsPlugin);

        this.params = params;
        this.wavesurfer = ws;
        this.util = ws.util;

        // turn the plugin instance into an observer
        var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);
        observerPrototypeKeys.forEach(function (key) {
            Region.prototype[key] = _this5.util.Observer.prototype[key];
        });
        this.wavesurfer.Region = Region;

        // Id-based hash of regions.
        this.list = {};
        this._onReady = function () {
            _this5.wrapper = _this5.wavesurfer.drawer.wrapper;
            if (_this5.params.regions) {
                _this5.params.regions.forEach(function (region) {
                    _this5.add(region);
                });
            }
            if (_this5.params.dragSelection) {
                _this5.enableDragSelection(_this5.params);
            }
        };
    }

    _createClass(RegionsPlugin, [{
        key: 'init',
        value: function init() {
            // Check if ws is ready
            if (this.wavesurfer.isReady) {
                this._onReady();
            }
            this.wavesurfer.on('ready', this._onReady);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.wavesurfer.un('ready', this._onReady);
            this.disableDragSelection();
            this.clear();
        }
        /* Add a region. */

    }, {
        key: 'add',
        value: function add(params) {
            var _this6 = this;

            var region = new this.wavesurfer.Region(params, this.wavesurfer);

            this.list[region.id] = region;

            region.on('remove', function () {
                delete _this6.list[region.id];
            });

            return region;
        }

        /* Remove all regions. */

    }, {
        key: 'clear',
        value: function clear() {
            var _this7 = this;

            Object.keys(this.list).forEach(function (id) {
                _this7.list[id].remove();
            });
        }
    }, {
        key: 'enableDragSelection',
        value: function enableDragSelection(params) {
            var _this8 = this;

            var slop = params.slop || 2;
            var container = this.wavesurfer.drawer.container;
            var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;
            var scrollSpeed = params.scrollSpeed || 1;
            var scrollThreshold = params.scrollThreshold || 10;
            var drag = void 0;
            var duration = this.wavesurfer.getDuration();
            var maxScroll = void 0;
            var start = void 0;
            var region = void 0;
            var touchId = void 0;
            var pxMove = 0;
            var scrollDirection = void 0;
            var wrapperRect = void 0;

            // Scroll when the user is dragging within the threshold
            var edgeScroll = function edgeScroll(e) {
                if (!region || !scrollDirection) {
                    return;
                }

                // Update scroll position
                var scrollLeft = _this8.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                _this8.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft));

                // Update range
                var end = _this8.wavesurfer.drawer.handleEvent(e);
                region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                });

                // Check that there is more to scroll and repeat
                if (scrollLeft < maxScroll && scrollLeft > 0) {
                    window.requestAnimationFrame(function () {
                        edgeScroll(e);
                    });
                }
            };

            var eventDown = function eventDown(e) {
                if (e.touches && e.touches.length > 1) {
                    return;
                }
                duration = _this8.wavesurfer.getDuration();
                touchId = e.targetTouches ? e.targetTouches[0].identifier : null;

                // Store for scroll calculations
                maxScroll = _this8.wrapper.scrollWidth - _this8.wrapper.clientWidth;
                wrapperRect = _this8.wrapper.getBoundingClientRect();

                drag = true;
                start = _this8.wavesurfer.drawer.handleEvent(e, true);
                region = null;
                scrollDirection = null;
            };
            this.wrapper.addEventListener('mousedown', eventDown);
            this.wrapper.addEventListener('touchstart', eventDown);
            this.on('disable-drag-selection', function () {
                _this8.wrapper.removeEventListener('touchstart', eventDown);
                _this8.wrapper.removeEventListener('mousedown', eventDown);
            });

            var eventUp = function eventUp(e) {
                if (e.touches && e.touches.length > 1) {
                    return;
                }

                drag = false;
                pxMove = 0;
                scrollDirection = null;

                if (region) {
                    _this8.util.preventClick();
                    region.fireEvent('update-end', e);
                    _this8.wavesurfer.fireEvent('region-update-end', region, e);
                }

                region = null;
            };
            this.wrapper.addEventListener('mouseup', eventUp);
            this.wrapper.addEventListener('touchend', eventUp);

            document.body.addEventListener('mouseup', eventUp);
            document.body.addEventListener('touchend', eventUp);
            this.on('disable-drag-selection', function () {
                document.body.removeEventListener('mouseup', eventUp);
                document.body.removeEventListener('touchend', eventUp);
                _this8.wrapper.removeEventListener('touchend', eventUp);
                _this8.wrapper.removeEventListener('mouseup', eventUp);
            });

            var eventMove = function eventMove(e) {
                if (!drag) {
                    return;
                }
                if (++pxMove <= slop) {
                    return;
                }

                if (e.touches && e.touches.length > 1) {
                    return;
                }
                if (e.targetTouches && e.targetTouches[0].identifier != touchId) {
                    return;
                }

                if (!region) {
                    region = _this8.add(params || {});
                }

                var end = _this8.wavesurfer.drawer.handleEvent(e);
                region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                });

                // If scrolling is enabled
                if (scroll && container.clientWidth < _this8.wrapper.scrollWidth) {
                    // Check threshold based on mouse
                    var x = e.clientX - wrapperRect.left;
                    if (x <= scrollThreshold) {
                        scrollDirection = -1;
                    } else if (x >= wrapperRect.right - scrollThreshold) {
                        scrollDirection = 1;
                    } else {
                        scrollDirection = null;
                    }
                    scrollDirection && edgeScroll(e);
                }
            };
            this.wrapper.addEventListener('mousemove', eventMove);
            this.wrapper.addEventListener('touchmove', eventMove);
            this.on('disable-drag-selection', function () {
                _this8.wrapper.removeEventListener('touchmove', eventMove);
                _this8.wrapper.removeEventListener('mousemove', eventMove);
            });
        }
    }, {
        key: 'disableDragSelection',
        value: function disableDragSelection() {
            this.fireEvent('disable-drag-selection');
        }

        /* Get current region
         *  The smallest region that contains the current time.
         *  If several such regions exist, we take the first.
         *  Return null if none exist. */

    }, {
        key: 'getCurrentRegion',
        value: function getCurrentRegion() {
            var _this9 = this;

            var time = this.wavesurfer.getCurrentTime();
            var min = null;
            Object.keys(this.list).forEach(function (id) {
                var cur = _this9.list[id];
                if (cur.start <= time && cur.end >= time) {
                    if (!min || cur.end - cur.start < min.end - min.start) {
                        min = cur;
                    }
                }
            });

            return min;
        }
    }]);

    return RegionsPlugin;
}();

exports.default = RegionsPlugin;

},{}],137:[function(require,module,exports){
'use strict';

// lib

var _require = require('iblokz-data'),
    obj = _require.obj;

// initial state


var initial = {
	number: 0
};

// action
var set = function set(number) {
	return function (state) {
		return obj.patch(state, 'counter', { number: number });
	};
};
var incr = function incr() {
	return function (state) {
		return obj.patch(state, 'counter', { number: state.counter.number + 1 });
	};
};
var decr = function decr() {
	return function (state) {
		return obj.patch(state, 'counter', { number: state.counter.number - 1 });
	};
};

module.exports = {
	initial: initial,
	set: set,
	incr: incr,
	decr: decr
};

},{"iblokz-data":10}],138:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

// namespaces=


var counter = require('./counter');
var midiMap = require('./midi-map');

// initial
var initial = {
	mode: 1,
	stt: false,
	sttMic: false,
	query: '',
	session: {
		sample: 'assets/LatinEthnoElektroGroove.mp3',
		playing: false,
		focused: [0, 0],
		pads: {}
	},
	samples: {
		list: [],
		query: {
			page: 1,
			pattern: '',
			source: 'freesound',
			limit: 12
		}
	},
	rack: {
		vcf: {
			on: false,
			expanded: true,
			type: 'lowpass',
			cutoff: 0.64,
			resonance: 0,
			gain: 0
		},
		reverb: {
			on: false,
			seconds: 3,
			decay: 2,
			reverse: false,
			dry: 0.8,
			wet: 0.7
		}
	}
};

// actions
var set = function set(key, value) {
	return function (state) {
		return obj.patch(state, key, value);
	};
};
var toggle = function toggle(key) {
	return function (state) {
		return obj.patch(state, key, !obj.sub(state, key));
	};
};
var arrToggle = function arrToggle(key, value) {
	return function (state) {
		return obj.patch(state, key, arr.toggle(obj.sub(state, key), value));
	};
};

module.exports = {
	initial: initial,
	// namespaces
	midiMap: midiMap,
	// actions
	set: set,
	toggle: toggle,
	arrToggle: arrToggle
};

},{"./counter":137,"./midi-map":139,"iblokz-data":10}],139:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Rx = require('rx');
var $ = Rx.Observable;

// util

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

var arrMod = function arrMod(a, p, v) {
	return [].concat(a.slice(0, p[0]), [p.length === 1 ? v : arrMod(a[p[0]], p.slice(1), v)], a.slice(p[0] + 1));
};

var initial = {
	devices: {
		inputs: [],
		outputs: []
	},
	settings: {
		midiRouteToActive: true
	},
	clock: {
		in: [],
		out: []
	},
	data: {
		in: [],
		out: []
	},
	pitch: 0,
	channels: {},
	map: [['controller', 20, ['instrument', 'vcf', 'cutoff']], ['controller', 21, ['instrument', 'vcf', 'resonance']], ['controller', 22, ['studio', 'bpm'], 60, 200, 0], ['controller', 23, ['studio', 'volume']], ['controller', 24, ['instrument', 'eg', 'attack']], ['controller', 25, ['instrument', 'eg', 'decay']], ['controller', 26, ['instrument', 'eg', 'sustain']], ['controller', 27, ['instrument', 'eg', 'release']]]
};

var connect = function connect(devices) {
	return function (state) {
		return obj.patch(state, 'midiMap', {
			devices: devices,
			data: _extends({}, state.midiMap.data, {
				in: state.midiMap.data.in.indexOf(devices.inputs.findIndex(function (dev) {
					return dev.name.match(/MPKmini2/);
				})) === -1 ? arr.add(state.midiMap.data.in, devices.inputs.findIndex(function (dev) {
					return dev.name.match(/MPKmini2/);
				})) : state.midiMap.data.in
			})
		});
	};
};

var toggleClock = function toggleClock(inOut, index) {
	return function (state) {
		return obj.patch(state, ['midiMap', 'clock', inOut], arr.toggle(obj.sub(state, ['midiMap', 'clock'])[inOut], index));
	};
};

var toggleData = function toggleData(inOut, index) {
	return function (state) {
		return obj.patch(state, ['midiMap', 'data', inOut], arr.toggle(obj.sub(state, ['midiMap', 'data', inOut]), index));
	};
};

var noteOn = function noteOn() {
	var device = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	var channel = arguments[1];
	var note = arguments[2];
	var velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	return function (state) {
		return channel !== undefined ?
		// console.log(state.midiMap.channels, obj.sub(state, ['midiMap', 'channels', channel, note]), channel, note, velocity),
		velocity !== 0 ? obj.patch(state, ['midiMap', 'channels', device, channel, note], velocity) : obj.patch(state, ['midiMap', 'channels', device], _defineProperty({}, channel, obj.filter(obj.sub(state, ['midiMap', 'channels', device, channel]) || {}, function (key, value) {
			return key !== note;
		}))) : state;
	};
};

var panic = function panic() {
	return function (state) {
		return obj.patch(state, ['midiMap', 'channels'], {});
	};
};

var modify = function modify(p, v) {
	return function (state) {
		return obj.patch(state, ['midiMap'], {
			map: arrMod(state.midiMap.map, p, v)
		});
	};
};

module.exports = {
	initial: initial,
	connect: connect,
	toggleClock: toggleClock,
	toggleData: toggleData,
	noteOn: noteOn,
	panic: panic,
	modify: modify
};

},{"iblokz-data":10,"rx":123}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _regions = require('wavesurfer.js/src/plugin/regions.js');

var _regions2 = _interopRequireDefault(_regions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ExtWSRegionsPlugin = function (_RegionsPlugin) {
	_inherits(ExtWSRegionsPlugin, _RegionsPlugin);

	function ExtWSRegionsPlugin() {
		_classCallCheck(this, ExtWSRegionsPlugin);

		return _possibleConstructorReturn(this, (ExtWSRegionsPlugin.__proto__ || Object.getPrototypeOf(ExtWSRegionsPlugin)).apply(this, arguments));
	}

	_createClass(ExtWSRegionsPlugin, [{
		key: 'add',
		value: function add(params) {
			var _this2 = this;

			// console.log(this.params);
			if (this.params.singleRegion === true) {
				this.clear();
			}

			var region = new this.wavesurfer.Region(params, this.wavesurfer);

			this.list[region.id] = region;

			region.on('remove', function () {
				delete _this2.list[region.id];
			});

			return region;
		}
	}], [{
		key: 'create',

		// constructor(params, ws) {
		// 	super(params, ws);
		// }
		value: function create(params) {
			var _RegionsPlugin$create = _regions2.default.create(params),
			    staticProps = _RegionsPlugin$create.staticProps;

			return {
				name: 'regions',
				deferInit: params && params.deferInit ? params.deferInit : false,
				params: params,
				staticProps: staticProps,
				instance: ExtWSRegionsPlugin
			};
		}
	}]);

	return ExtWSRegionsPlugin;
}(_regions2.default);

exports.default = ExtWSRegionsPlugin;

},{"wavesurfer.js/src/plugin/regions.js":136}],141:[function(require,module,exports){
'use strict';

// lib

var Rx = require('rx');
var $ = Rx.Observable;

// iblokz
var vdom = require('iblokz-snabbdom-helpers');

var _require = require('iblokz-data'),
    obj = _require.obj,
    arr = _require.arr;

// app


var app = require('./util/app');
var actions = app.adapt(require('./actions'));
var ui = require('./ui');
var actions$ = void 0;
var state$ = new Rx.BehaviorSubject();
// services
// wavesurfer
var wavesurfer = require('./services/wavesurfer.js');
// samples - audiocommons
var samples = require('./services/samples.js');
actions = app.attach(actions, 'samples', samples.actions);
// pads
var pads = require('./services/pads.js');
actions = app.attach(actions, 'pads', pads.actions);
// midi
var midi = require('./services/midi.js');
actions = app.attach(actions, 'midi', midi.actions);
// stt - speach to text
var stt = require('./services/stt.js');
// control
var control = require('./services/control.js');
actions = app.attach(actions, 'control', control.actions);

// hot reloading
if (module.hot) {
	// actions
	actions$ = $.fromEventPattern(function (h) {
		return module.hot.accept("./actions", h);
	}).flatMap(function () {
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		return actions.stream.startWith(function (state) {
			return state;
		});
	}).merge(actions.stream);
	// ui
	module.hot.accept("./ui", function () {
		ui = require('./ui');
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// services
	// wavesurfer
	module.hot.accept("./services/wavesurfer.js", function () {
		wavesurfer.unhook();
		wavesurfer = require('./services/wavesurfer.js');
		wavesurfer.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// samples
	module.hot.accept("./services/samples.js", function () {
		samples.unhook();
		samples = require('./services/samples.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		samples.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// pads
	module.hot.accept("./services/pads.js", function () {
		pads.unhook();
		pads = require('./services/pads.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		pads.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// midi
	module.hot.accept("./services/midi.js", function () {
		midi.unhook();
		midi = require('./services/midi.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		midi.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// stt
	module.hot.accept("./services/stt.js", function () {
		stt.unhook();
		stt = require('./services/stt.js');
		stt.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
	// control
	module.hot.accept("./services/control.js", function () {
		control.unhook();
		control = require('./services/control.js');
		actions = app.adapt(require('./actions'));
		actions = app.attach(actions, 'pads', pads.actions);
		actions = app.attach(actions, 'samples', samples.actions);
		actions = app.attach(actions, 'midi', midi.actions);
		actions = app.attach(actions, 'control', control.actions);
		control.hook({ state$: state$, actions: actions });
		actions.stream.onNext(function (state) {
			return state;
		});
	});
} else {
	actions$ = actions.stream;
}

// actions -> state
actions$.map(function (action) {
	return action.path && console.log(action.path.join('.'), action.payload), console.log(action), action;
}).startWith(function () {
	return actions.initial;
}).scan(function (state, change) {
	return change(state);
}, {}).map(function (state) {
	return console.log(state), state;
}).subscribe(function (state) {
	return state$.onNext(state);
});

// state -> ui
var ui$ = state$.map(function (state) {
	return ui({ state: state, actions: actions });
});
vdom.patchStream(ui$, '#ui');

wavesurfer.hook({ state$: state$, actions: actions });
samples.hook({ state$: state$, actions: actions });
pads.hook({ state$: state$, actions: actions });
midi.hook({ state$: state$, actions: actions });
stt.hook({ state$: state$, actions: actions });
control.hook({ state$: state$, actions: actions });

// livereload impl.
if (module.hot) {
	document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></script>');
}

},{"./actions":138,"./services/control.js":142,"./services/midi.js":143,"./services/pads.js":144,"./services/samples.js":145,"./services/stt.js":146,"./services/wavesurfer.js":147,"./ui":150,"./util/app":155,"iblokz-data":10,"iblokz-snabbdom-helpers":15,"rx":123}],142:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;

var gamepad = require('../util/gamepad');

var actions = {
	initial: {}
};

var play = function play(url) {
	var an = document.createElement('AUDIO');
	an.setAttribute('autoplay', true);
	an.src = url;
};

var keyMap = [['7', '8', '9', '0'], ['u', 'i', 'o', 'p'], ['j', 'k', 'l', ';'], ['m', ',', '.', '/']];

var getIndex = function getIndex(key) {
	return keyMap.reduce(function (p1, cols, row) {
		return p1.row === -1 ? cols.reduce(function (p2, mapKey, col) {
			return key === mapKey ? { row: row, col: col } : p2;
		}, p1) : p1;
	}, { row: -1, col: -1 });
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	gamepad.changes().map(function (pads) {
		return console.log({ pads: pads }), pads;
	}).withLatestFrom(state$, function (pads, state) {
		return { pads: pads, state: state };
	}).subscribe(function (_ref2) {
		var pads = _ref2.pads,
		    state = _ref2.state;

		console.log(pads[0]);
		if (pads[0]) {
			if (pads[0].axes[1] === -1) actions.samples.prev();
			// if (pads[0].axes[0] > 0) actions.move('right');
			if (pads[0].axes[1] === 1) actions.samples.next();
			// if (pads[0].axes[0] < 0) actions.move('left');
			if (pads[0].buttons[8].pressed === true) {
				if (state.samples.list[state.samples.index]) play(state.samples.list[state.samples.index].sound);
			}
			if (pads[0].buttons[3].pressed === true) {
				var sample = state.samples.list[state.samples.index];
				if (sample) actions.pads.load(sample, sample.sound);
			}
			if (pads[0].buttons[0].pressed === true) {
				actions.set('sttMic', true);
			}
			if (pads[0].buttons[1].pressed === true) {
				actions.set('mode', 0);
			}
			if (pads[0].buttons[2].pressed === true) {
				actions.set('mode', 1);
			}
		}
	});

	$.fromEvent(document, 'keydown').filter(function (ev) {
		return ['input', 'textarea'].indexOf(ev.target.tagName.toLowerCase()) === -1 || ev.target.tagName.toLowerCase() === 'input' && ev.target.type === 'range';
	}).withLatestFrom(state$, function (ev, state) {
		return { ev: ev, state: state };
	}).subscribe(function (_ref3) {
		var ev = _ref3.ev,
		    state = _ref3.state;

		if (ev.key > 0 && ev.key < 4) {
			actions.set('mode', parseInt(ev.key, 10) - 1);
		} else {
			var pos = getIndex(ev.key);
			console.log(ev.key, ev.target, pos);
			if (pos.row !== -1) {
				actions.set(['pads', 'focused'], [pos.row, pos.col]);
				if (state.mode === 2) actions.midi.trigger(pos.row, pos.col);
			}
		}
	});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/gamepad":164,"rx":123}],143:[function(require,module,exports){
'use strict';
// lib

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj;

var midi = require('../util/midi');
var pocket = require('../util/pocket');
var a = require('../util/audio');
var sampler = require('../util/audio/sources/sampler');

var reverb = a.connect(a.create('reverb', {
	on: false,
	wet: 0.1,
	dry: 0.9
}), a.context.destination);

var vcf = a.connect(a.create('vcf', {
	on: false,
	type: 'lowpass',
	cutoff: 0.64,
	resonance: 0,
	gain: 0
}), reverb);

var rack = {};

var getIds = function getIds(inputs, indexes) {
	return inputs.map(function (inp) {
		return inp.id;
	}).filter(function (id, i) {
		return indexes.indexOf(i) > -1;
	});
};

var trigger = function trigger(row, col) {
	return function (state) {
		var sampleId = obj.sub(state, ['pads', 'map', row, col, 'id']);
		if (sampleId) {
			var inst = sampler.clone(pocket.get(['sampleBank', sampleId]));
			inst = a.connect(inst, state.rack.vcf.on ? vcf : state.rack.reverb.on ? reverb : a.context.destination);
			a.start(inst);
		}
		return state;
	};
};

var actions = {
	initial: {},
	trigger: trigger
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	var _midi$init = midi.init(),
	    devices$ = _midi$init.devices$,
	    msg$ = _midi$init.msg$;

	// audio rack


	subs.push(state$.distinctUntilChanged(function (state) {
		return state.rack;
	}).subscribe(function (state) {
		reverb = a.update(reverb, state.rack.reverb);
		vcf = a.update(vcf, state.rack.vcf);
		if (state.rack.reverb.on) {
			vcf = a.disconnect(vcf);
			vcf = a.connect(vcf, reverb);
		} else {
			vcf = a.disconnect(vcf);
			vcf = a.connect(vcf, a.context.destination);
		}
	}));

	// midi device access
	subs.push(devices$.subscribe(function (data) {
		return actions.midiMap.connect(data);
	}));

	var parsedMidiMsg$ = msg$.map(function (raw) {
		return { msg: midi.parseMidiMsg(raw.msg), raw: raw };
	})
	// .map(data => (console.log(data), data))
	.share();

	// midi messages
	subs.push(parsedMidiMsg$.map(function (midiData) {
		return console.log({ midiData: midiData }), midiData;
	})
	// .filter(({msg}) => ['noteOn', 'noteOff'].indexOf(msg.state) > -1)
	.filter(function (_ref2) {
		var msg = _ref2.msg;
		return msg.state === 'controller' || msg.state === 'noteOn';
	}).withLatestFrom(state$, function (midiData, state) {
		return _extends({}, midiData, { state: state });
	})
	// .filter(({raw, state}) => (
	// 	// console.log(raw.input.id, state.midiMap.devices.inputs, state.midiMap.data.in),
	// 	getIds(state.midiMap.devices.inputs, state.midiMap.data.in).indexOf(
	// 		raw.input.id
	// 	) > -1
	// ))
	.subscribe(function (_ref3) {
		var raw = _ref3.raw,
		    msg = _ref3.msg,
		    state = _ref3.state;

		// console.log(state.midiMap.devices.inputs, raw.input);
		// traktor
		if (msg.channel === 13 && msg.state === 'controller' && msg.value === 1) {
			if (msg.controller >= 10 && msg.controller <= 26) {
				var col = (msg.controller - 10) % 4;
				var row = (msg.controller - 10 - col) / 4;
				var sampleId = obj.sub(state, ['pads', 'map', row, col]);
				// let inst;
				actions.set(['pads', 'focused'], [row, col]);
				if (state.mode === 2) trigger(row, col)(state);
			}
			if (msg.controller >= 37 && msg.controller <= 39) {
				actions.set('mode', msg.controller - 37);
			}
		}
		if (msg.channel === 10 && msg.state === 'noteOn') {
			var _col = (msg.note.number - 60) % 4;
			var _row = (msg.note.number - 60 - _col) / 4 + ((msg.note.number - 60 - _col) / 4 % 2 === 1 ? -1 : 1);
			// console.log((msg.note.number - 60 - col) / 4, (msg.note.number - 60 - col) % 2, row, col);
			actions.set(['pads', 'focused'], [_row, _col]);
			if (state.mode === 2) trigger(_row, _col)(state);
		}
		if (msg.channel === 11 && msg.state === 'noteOn') {
			var _col2 = (msg.note.number - 55) % 10;
			var _row2 = (msg.note.number - 55 - _col2) / 10;
			// console.log((msg.note.number - 60 - col) / 4, (msg.note.number - 60 - col) % 2, row, col);
			actions.set(['pads', 'focused'], [_row2, _col2]);
			if (state.mode === 2) trigger(_row2, _col2)(state);
		}
	}));

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/audio":160,"../util/audio/sources/sampler":161,"../util/midi":165,"../util/pocket":166,"iblokz-data":10,"rx":123}],144:[function(require,module,exports){
'use strict';
// lib

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var pocket = require('../util/pocket');
var file = require('../util/file');

var _require2 = require('../util/audio'),
    context = _require2.context;

var sampler = require('../util/audio/sources/sampler');

var load = function load(sample, url) {
	return $.fromPromise(fetch(url.replace('http://', '//')).then(function (res) {
		return res.arrayBuffer();
	})).concatMap(function (buffer) {
		return $.fromCallback(context.decodeAudioData, context)(buffer);
	}).map(function (buffer) {
		return {
			sample: sample,
			node: sampler.create(url, buffer)
		};
	}).map(function (_ref) {
		var sample = _ref.sample,
		    node = _ref.node;
		return pocket.put(['sampleBank', sample.id], node), function (state) {
			return obj.patch(state, ['pads', 'map'].concat(_toConsumableArray(state.pads.focused)), sample);
		};
	});
};

var actions = {
	initial: {
		focused: [0, 0],
		map: {}
	},
	load: load
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/audio":160,"../util/audio/sources/sampler":161,"../util/file":162,"../util/pocket":166,"iblokz-data":10,"rx":123}],145:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;

var request = require('superagent');

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = require('../util/pocket');

var url = 'https://m2.audiocommons.org/api/audioclips';

var search = function search(_ref) {
	var pattern = _ref.pattern,
	    _ref$source = _ref.source,
	    source = _ref$source === undefined ? 'freesound' : _ref$source,
	    _ref$limit = _ref.limit,
	    limit = _ref$limit === undefined ? 12 : _ref$limit,
	    _ref$page = _ref.page,
	    page = _ref$page === undefined ? 1 : _ref$page;
	return request.get(url + '/search').query({ pattern: pattern, source: source, limit: limit, page: page }).then(function (res) {
		return res.body.results;
	}).then(function (results) {
		return console.log(results), results;
	}).then(function (results) {
		return results[0].members.map(function (m) {
			return {
				id: m.content['@id'],
				name: m.content.title,
				author: m.content.author.replace('freesound-users:', ''),
				sound: m.content.availableAs[0].locator,
				image: m.content.images[0].locator,
				license: m.content.license,
				duration: m.content.duration
			};
		});
	}).then(function (list) {
		return function (state) {
			return obj.patch(state, ['samples'], {
				list: page > 1 ? [].concat(state.samples.list, list) : list,
				query: { pattern: pattern, source: source, limit: limit, page: page } });
		};
	});
};

var next = function next() {
	return function (state) {
		return obj.patch(state, ['samples'], {
			index: state.samples.index < state.samples.list.length - 1 ? state.samples.index + 1 : state.samples.index
		});
	};
};

var prev = function prev() {
	return function (state) {
		return obj.patch(state, ['samples'], {
			index: state.samples.index > 0 ? state.samples.index - 1 : state.samples.index
		});
	};
};

var actions = {
	initial: {
		list: [],
		index: 0
	},
	search: search,
	next: next,
	prev: prev
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];
	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	actions: actions,
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../util/pocket":166,"iblokz-data":10,"rx":123,"superagent":128}],146:[function(require,module,exports){
'use strict';
// lib

var Rx = require('rx');
var $ = Rx.Observable;
var request = require('superagent');

var SpeechSDK = window.SpeechSDK;

var subscriptionKey = 'c63057e1219441489c1b43132685c4b8';
var region = 'westus';
var url = 'https://' + region + '.api.cognitive.microsoft.com/sts/v1.0/issueToken';

var init = function init(token) {
	var speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
	speechConfig.speechRecognitionLanguage = "en-GB";
	var audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
	var recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);
	return recognizer;
};

var recognize = function recognize(recognizer) {
	return $.fromCallback(recognizer.recognizeOnceAsync, recognizer)().map(function (res) {
		return console.log(res), res;
	});
};

var _unhook = function unhook() {};
var hook = function hook(_ref) {
	var state$ = _ref.state$,
	    actions = _ref.actions;

	var subs = [];

	request.post(url).set({
		'Content-Type': 'application/json',
		'Ocp-Apim-Subscription-Key': subscriptionKey
	}).then(function (res) {
		return actions.set('stt', res.text);
	});

	state$.distinctUntilChanged(function (state) {
		return state.stt + ' ' + state.sttMic;
	}).filter(function (state) {
		return state.stt && state.sttMic;
	}).map(function (state) {
		return init(state.stt);
	}).flatMap(recognize).subscribe(function (res) {
		var pattern = res.privText.replace(/\.$/, '');
		actions.samples.search({ pattern: pattern });
		actions.set('sttMic', false);
	});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"rx":123,"superagent":128}],147:[function(require,module,exports){
'use strict';
// lib

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Rx = require('rx');
var $ = Rx.Observable;

var WaveSurfer = require('wavesurfer.js');
// window.WaveSurfer = WaveSurfer;
var TimelinePlugin = require('wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js');
var ExtWSRegionsPlugin = require('../ext/ws/regions.js').default;
// console.log(RegionsPlugin);
// require('wavesurfer/plugin/wavesurfer.timeline.js');
// WaveSurfer = window.WaveSurfer;

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = require('../util/pocket');

var init = function init(container) {
	container.innerHTML = '';
	var wavesurfer = WaveSurfer.create({
		container: '#waveform',
		waveColor: '#000',
		progressColor: '#111516',
		plugins: [TimelinePlugin.create({
			container: '#wave-timeline'
			// deferInit: true // stop the plugin from initialising immediately
		}), ExtWSRegionsPlugin.create({
			dragSelection: true,
			singleRegion: true
			// plugin options ...
		})]
	});
	// wavesurfer.load('assets/LatinEthnoElektroGroove.mp3');
	return wavesurfer;
};

var load = function load(_ref) {
	var wavesurfer = _ref.wavesurfer,
	    sample = _ref.sample;

	console.log(wavesurfer, sample, pocket);
	if (sample[0] === 'url') wavesurfer.load(sample[1]);else if (sample[1]) wavesurfer.loadDecodedBuffer(pocket.get(['sampleBank', sample[1]]).output.buffer);
	return wavesurfer;
};

var _unhook = function unhook() {};
var hook = function hook(_ref2) {
	var state$ = _ref2.state$,
	    actions = _ref2.actions;

	var subs = [];

	var wavesurfer$ = $.interval(100).map(function () {
		return document.querySelector('#waveform');
	}).distinctUntilChanged(function (el) {
		return el;
	}).filter(function (el) {
		return el;
	}).map(init);

	var sampleChange$ = state$.distinctUntilChanged(function (state) {
		return state.pads.focused.toString() + ' ' + obj.sub(state.pads, ['map'].concat(_toConsumableArray(state.pads.focused), ['id']));
	}).map(function (state) {
		return ['id', obj.sub(state.pads.map, [].concat(_toConsumableArray(state.pads.focused), ['id']))];
	}).startWith(['url', 'assets/LatinEthnoElektroGroove.mp3']);

	wavesurfer$.flatMap(function (wavesurfer) {
		return $.merge(sampleChange$.map(function (sample) {
			return function (wavesurfer) {
				return load({ wavesurfer: wavesurfer, sample: sample });
			};
		}), state$.distinctUntilChanged(function (state) {
			return state.session.playing;
		}).map(function (state) {
			return function (wavesurfer) {
				return wavesurfer.playPause(), wavesurfer;
			};
		})).scan(function (wavesurfer, reducer) {
			return reducer(wavesurfer);
		}, wavesurfer);
	}).subscribe(function (data) {});

	_unhook = function unhook() {
		return subs.forEach(function (sub) {
			return sub.dispose();
		});
	};
};

module.exports = {
	hook: hook,
	unhook: function unhook() {
		return _unhook();
	}
};

},{"../ext/ws/regions.js":140,"../util/pocket":166,"iblokz-data":10,"rx":123,"wavesurfer.js":135,"wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js":134}],148:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    select = _require.select,
    option = _require.option,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var formUtil = require('../../util/form');

var _require2 = require('iblokz-data'),
    fn = _require2.fn,
    obj = _require2.obj;

var play = function play(url) {
	var an = document.createElement('AUDIO');
	an.setAttribute('autoplay', true);
	an.src = url;
};

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#board', [].concat(form('#board-search', {
		on: {
			submit: function submit(ev) {
				ev.preventDefault();
				var data = formUtil.toData(ev.target);
				console.log(data);
				actions.samples.search(data);
			}
		}
	}, [input('[type="hidden"][name="page"][value=1]'), input('#board-search-pattern[name="pattern"][placeholder="Query"]', {
		attrs: {
			value: state.samples.query.pattern
		}
	}), select('[name="source"]', ['freesound', 'jamendo', 'europeana'].map(function (s) {
		return option('[value="' + s + '"]', s);
	})), button('Search')]), state.samples.list.length > 0 ? ul('#board-samples', [].concat(state.samples.list.map(function (sample, index) {
		return li({
			class: {
				selected: index === state.samples.index
			}
		}, [img('.wave[src="' + sample.image + '"]'), span('.name', {
			on: {
				click: function click() {
					return actions.set(['samples', 'index'], index);
				}
			}
		}, sample.name), a('.author[title="' + sample.author + '"]', i('.fa.fa-user')), span('.duration', (sample.duration / 1000).toFixed(2) + ' s'), a('.license[target="_blank"][href="' + sample.license + '"]', fn.pipe(function () {
			return sample.license.replace('http://creativecommons.org/', '');
		}, function (license) {
			return obj.switch(license, {
				'default': license,
				'licenses/by/3.0/': [i('.cc.cc-cc.cc-2x'), i('.cc.cc-by.cc-2x')],
				'publicdomain/zero/1.0/': [i('.cc.cc-cc.cc-2x'), i('.cc.cc-zero.cc-2x')],
				'licenses/by-nc/3.0/': [i('.cc.cc-cc.cc-2x'), i('.cc.cc-by.cc-2x'), i('.cc.cc-nc.cc-2x')],
				'licenses/sampling+/1.0/': [i('.cc.cc-cc.cc-2x')]
			});
		})()), span('.controls', [button({
			on: {
				click: function click() {
					return play(sample.sound);
				},
				touchstart: function touchstart() {
					return play(sample.sound);
				}
			}
		}, i('.fa.fa-play')), button({
			on: {
				click: function click(ev) {
					return actions.pads.load(sample, sample.sound);
				},
				touchstart: function touchstart(ev) {
					return actions.pads.load(sample, sample.sound);
				}
			}
		}, i('.fa.fa-plus'))])]);
	}), li(button('.full', {
		on: {
			click: function click() {
				return actions.samples.search(_extends({}, state.samples.query, { page: state.samples.query.page + 1 }));
			}
		}
	}, 'Load more samples...')))) : []));
};

},{"../../util/form":163,"iblokz-data":10,"iblokz-snabbdom-helpers":15}],149:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    button = _require.button,
    span = _require.span,
    header = _require.header,
    h1 = _require.h1,
    ul = _require.ul,
    li = _require.li,
    i = _require.i,
    img = _require.img;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return header([ul('.left', [li(button({
		on: {
			click: function click() {
				return actions.set('mode', 0);
			}
		},
		class: {
			selected: state.mode === 0
		}
	}, img('[src="assets/icons/midi.svg"]'))), li(button({
		on: {
			click: function click() {
				return actions.set('mode', 1);
			}
		},
		class: {
			selected: state.mode === 1
		}
	}, i('.fa.fa-edit'))), li(button({
		on: {
			click: function click() {
				return actions.set('mode', 2);
			}
		},
		class: {
			selected: state.mode === 2
		}
	}, i('.fa.fa-music')))]), h1('xAmplR'), ul('.right', [li(button({
		on: {
			click: function click() {
				return actions.set('sttMic', true);
			}
		},
		class: {
			selected: state.sttMic
		}
	}, i('.fa.fa-volume-control-phone')))])]);
};

},{"iblokz-snabbdom-helpers":15}],150:[function(require,module,exports){
'use strict';

// dom

var _require = require('iblokz-snabbdom-helpers'),
    h1 = _require.h1,
    a = _require.a,
    div = _require.div,
    i = _require.i,
    section = _require.section,
    button = _require.button,
    span = _require.span;
// components


var header = require('./header');
var board = require('./board');
var pads = require('./pads');
var rack = require('./rack');
// const counter = require('./counter');

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#ui', [header({ state: state, actions: actions }), section('.waveform', [div('#wave-timeline'), div('#waveform'), button({
		on: {
			click: function click() {
				return actions.toggle(['session', 'playing']);
			}
		}
	}, i('.fa.fa-' + (state.session.playing ? 'pause' : 'play')))]), board({ state: state, actions: actions }), pads({ state: state, actions: actions }), rack({ state: state, actions: actions })]);
};

},{"./board":148,"./header":149,"./pads":151,"./rack":152,"iblokz-snabbdom-helpers":15}],151:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var _require2 = require('iblokz-data'),
    obj = _require2.obj;

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#pads', div('.rows', Array(4).fill({}).map(function (a, row) {
		return div('.cols', Array(4).fill({}).map(function (a, col) {
			return button('.pad', {
				style: _extends({}, obj.sub(state, ['pads', 'map', row, col, 'id']) ? { backgroundImage: 'url(' + obj.sub(state, ['pads', 'map', row, col, 'image']) + ')' } : {}),
				class: {
					focused: state.pads.focused[0] === row && state.pads.focused[1] === col,
					assigned: obj.sub(state, ['pads', 'map', row, col, 'id'])
				},
				on: {
					focus: function focus() {
						return actions.set(['pads', 'focused'], [row, col]);
					},
					mousedown: function mousedown() {
						return state.mode === 2 && actions.midi.trigger(row, col), state.mode === 1 && actions.set(['pads', 'focused'], [row, col]);
					},
					touchstart: function touchstart() {
						return state.mode === 2 && actions.midi.trigger(row, col), state.mode === 1 && actions.set(['pads', 'focused'], [row, col]);
					}
				}
			}, obj.sub(state, ['pads', 'map', row, col, 'name']) || '');
		}));
	})));
};

},{"iblokz-data":10,"iblokz-snabbdom-helpers":15}],152:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    section = _require.section,
    span = _require.span,
    a = _require.a,
    div = _require.div,
    pre = _require.pre,
    img = _require.img,
    i = _require.i,
    form = _require.form,
    input = _require.input,
    button = _require.button,
    label = _require.label,
    ul = _require.ul,
    li = _require.li,
    table = _require.table,
    tbody = _require.tbody,
    thead = _require.thead,
    tr = _require.tr,
    td = _require.td,
    th = _require.th;

var _require2 = require('iblokz-data'),
    obj = _require2.obj;

var vcf = require('./vcf');
var reverb = require('./reverb');

module.exports = function (_ref) {
	var state = _ref.state,
	    actions = _ref.actions;
	return section('#rack', [].concat(vcf({
		name: 'vcf',
		props: state.rack.vcf,
		update: function update(path, value) {
			return actions.set([].concat(['rack', 'vcf'], path), value);
		}
	}), reverb({
		name: 'reverb',
		props: state.rack.reverb,
		update: function update(path, value) {
			return actions.set([].concat(['rack', 'reverb'], path), value);
		}
	})));
};

},{"./reverb":153,"./vcf":154,"iblokz-data":10,"iblokz-snabbdom-helpers":15}],153:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    div = _require.div,
    h2 = _require.h2,
    span = _require.span,
    p = _require.p,
    ul = _require.ul,
    li = _require.li,
    hr = _require.hr,
    button = _require.button,
    br = _require.br,
    form = _require.form,
    label = _require.label,
    input = _require.input,
    fieldset = _require.fieldset,
    legend = _require.legend,
    i = _require.i,
    img = _require.img;

module.exports = function (_ref) {
	var _ref$name = _ref.name,
	    name = _ref$name === undefined ? 'reverb' : _ref$name,
	    props = _ref.props,
	    update = _ref.update;
	return fieldset([legend([span('.on', [name.toUpperCase()])]), div('.on-switch.fa', {
		on: { click: function click(ev) {
				return update('on', !props.on);
			} },
		class: {
			'fa-circle-thin': !props.on,
			'on': props.on,
			'fa-circle': props.on
		}
	}), div([label('Seconds'), ' ',
	// span('.right', `${props.seconds}`),
	input('[type="number"]', {
		attrs: { min: 1, max: 50, step: 0.01 },
		props: { value: props.seconds },
		on: { change: function change(ev) {
				return update('seconds', parseFloat(ev.target.value));
			} }
	}), ' ', label('Decay'),
	// span('.right', `${props.decay}`),
	' ', input('[type="number"]', {
		attrs: { min: 0, max: 100, step: 0.01 },
		props: { value: props.decay },
		on: { change: function change(ev) {
				return update('decay', parseFloat(ev.target.value));
			} }
	}), ' ',
	/*
 label(`Reverse`),
 // span('.right', `${props.reverse}`),
 ' ',
 button('.fa', {
 	class: {
 		'fa-toggle-on': props.reverse,
 		'fa-toggle-off': !props.reverse
 	},
 	on: {
 		click: () => update('reverse', !props.reverse)
 	}
 }),
 */
	br(), label('Dry'), span('.right', '' + props.dry), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.dry },
		on: { change: function change(ev) {
				return update('dry', parseFloat(ev.target.value));
			} }
	}), label('Wet'), span('.right', '' + props.wet), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.wet },
		on: { change: function change(ev) {
				return update('wet', parseFloat(ev.target.value));
			} }
	})
	// label(`Gain`),
	// span('.right', `${props.gain}`),
	// input('[type="range"]', {
	// 	attrs: {min: 0, max: 1, step: 0.005},
	// 	props: {value: props.gain},
	// 	on: {change: ev => update('gain', parseFloat(ev.target.value))}
	// })
	])]);
};

},{"iblokz-snabbdom-helpers":15}],154:[function(require,module,exports){
'use strict';

var _require = require('iblokz-snabbdom-helpers'),
    div = _require.div,
    h2 = _require.h2,
    span = _require.span,
    p = _require.p,
    ul = _require.ul,
    li = _require.li,
    hr = _require.hr,
    button = _require.button,
    br = _require.br,
    a = _require.a,
    form = _require.form,
    label = _require.label,
    input = _require.input,
    fieldset = _require.fieldset,
    legend = _require.legend,
    i = _require.i,
    img = _require.img,
    select = _require.select,
    option = _require.option;

module.exports = function (_ref) {
	var _ref$name = _ref.name,
	    name = _ref$name === undefined ? 'reverb' : _ref$name,
	    props = _ref.props,
	    update = _ref.update;
	return fieldset([legend([span('.on', [name.toUpperCase()])]), div('.on-switch.fa', {
		on: { click: function click(ev) {
				return update('on', !props.on);
			} },
		class: {
			'fa-circle-thin': !props.on,
			'on': props.on,
			'fa-circle': props.on
		}
	}), div([div([label('Type'), select({
		on: { change: function change(ev) {
				return update('type', ev.target.value);
			} }
	}, ['lowpass', 'highpass'
	// 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'
	].map(function (type) {
		return option({
			attrs: {
				value: type
			},
			props: {
				selected: props.type === type
			}
		}, type);
	}))]), div([label('Cutoff'), span('.right', '' + props.cutoff), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.cutoff },
		on: { change: function change(ev) {
				return update('cutoff', parseFloat(ev.target.value));
			} }
	})]), label('Resonance'), span('.right', '' + props.resonance), input('[type="range"]', {
		attrs: { min: 0, max: 1, step: 0.01 },
		props: { value: props.resonance },
		on: { change: function change(ev) {
				return update('resonance', parseFloat(ev.target.value));
			} }
	})
	// label(`Gain`),
	// span('.right', `${props.gain}`),
	// input('[type="range"]', {
	// 	attrs: {min: 0, max: 1, step: 0.005},
	// 	props: {value: props.gain},
	// 	on: {change: ev => update('gain', parseFloat(ev.target.value))}
	// })
	])]);
};

},{"iblokz-snabbdom-helpers":15}],155:[function(require,module,exports){
'use strict';

// lib

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    arr = _require.arr,
    obj = _require.obj;

var observe = function observe(source) {
	return source instanceof Rx.Observable ? source : source.then instanceof Function ? Rx.Observable.fromPromise(source) : Rx.Observable.just(source);
};

var adapt = function adapt(o) {
	var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	return Object.keys(o).filter(function (key) {
		return key !== 'initial';
	}).reduce(function (o2, key) {
		return _extends({}, o2, o[key] instanceof Function && obj.keyValue(key, function () {
			var _arguments = arguments;

			observe(o[key].apply(null, Array.from(arguments))).subscribe(function (resp) {
				return o2.stream.onNext(_extends(resp, {
					path: [].concat(p, key),
					payload: Array.from(_arguments)
				}));
			});
		}) || o[key] instanceof Object && function () {
			var o3 = adapt(o[key], [].concat(p, key));
			o3.stream.subscribe(function (resp) {
				return o2.stream.onNext(resp);
			});
			return _extends({
				initial: _extends({}, o2.initial, obj.keyValue(key, o3.initial))
			}, obj.keyValue(key, o3));
		}() || obj.keyValue(key, o[key]));
	}, { stream: new Rx.Subject(), initial: o.initial || {} });
};

var attach = function attach(tree, path, node) {
	return [adapt(node, path)].map(function (adaptedNode) {
		return adaptedNode.stream.subscribe(function (resp) {
			return tree.stream.onNext(resp);
		}), _extends({}, obj.patch(tree, path, adaptedNode), {
			initial: obj.patch(tree.initial, path, adaptedNode.initial)
		});
	}).pop();
};

module.exports = {
	adapt: adapt,
	attach: attach
};

},{"iblokz-data":10,"rx":123}],156:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData,
    schedule = _require2.schedule;

var create = function create(prefs) {
	return [{
		prefs: _extends({
			volume: 0.41,
			attack: 0.31,
			decay: 0.16,
			sustain: 0.8,
			release: 0.21
		}, prefs),
		through: _create('gain')
	}].map(function (n) {
		return set(n.through.gain, 'value', 0), n;
	}).pop();
};

var update = function update(n, prefs) {
	return set(n, 'prefs', _extends({}, n.prefs, prefs)), n;
};

var noteOn = function noteOn(node, velocity, time) {
	var now = context.currentTime;
	time = (time || now) + 0.0001;

	node.through.gain.cancelScheduledValues(0);

	var changes = [].concat(
	// attack
	node.prefs.attack > 0 ? [[0, time], [velocity * node.prefs.volume, node.prefs.attack]] : [[velocity * node.prefs.volume, time]],
	// decay
	node.prefs.decay > 0 ? [[node.prefs.sustain * velocity * node.prefs.volume, node.prefs.decay]] : []).reduce(function (a, c) {
		return [[].concat(a[0], c[0]), [].concat(a[1], c[1])];
	}, [[], []]);

	schedule(node.through, 'gain', changes[0], changes[1]);
	return node;
};

var noteOff = function noteOff(node, time) {
	var now = context.currentTime;
	time = time || now + 0.0001;

	setTimeout(function () {
		return node.through.gain.cancelScheduledValues(0), node.through.gain.setValueCurveAtTime(new Float32Array([node.through.gain.value, 0]), time, node.prefs.release > 0 && node.prefs.release || 0.00001);
	}, (time - now) * 1000);
	return node;
};

module.exports = {
	create: create,
	update: update,
	noteOn: noteOn,
	noteOff: noteOff
};

},{"../core":157,"iblokz-data":10}],157:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext)();

var set = function set(o, k, v) {
	return o[k] = v;
};
var isSet = function isSet(v) {
	return v !== undefined;
};
var isGet = function isGet(v) {
	return isSet(v) ? v : null;
};

var apply = function apply(o1, o2) {
	return Object.keys(o2).reduce(function (o, k) {
		return set(o, k, o2[k]);
	}, o1);
};

var create = function create(type) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	return (
		// console.log(type),
		obj.switch(type, {
			oscillator: function oscillator() {
				return context.createOscillator.apply(context, args);
			},
			gain: function gain() {
				return context.createGain.apply(context, args);
			},
			biquadFilter: function biquadFilter() {
				return context.createBiquadFilter.apply(context, args);
			},
			convolver: function convolver() {
				return context.createConvolver.apply(context, args);
			},
			buffer: function buffer() {
				return context.createBuffer.apply(context, args);
			},
			bufferSource: function bufferSource() {
				return context.createBufferSource.apply(context, args);
			}
		})()
	);
};

var update = function update(node, prefs) {
	return apply(node, prefs);
};

var connect = function connect(n1, n2) {
	return (
		// console.log(n1, n2),
		n1.connect(n2), n1
	);
};
var disconnect = function disconnect(n1, n2) {
	// since there is no way to determine if they are connected
	try {
		n1.disconnect(n2);
	} catch (err) {
		console.log(err);
	}
	return n1;
};

var chain = function chain() {
	for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		nodes[_key2] = arguments[_key2];
	}

	return nodes.forEach(function (n, i) {
		return isSet(nodes[i + 1]) && connect(n, nodes[i + 1]);
	}), nodes[0];
};

var unchain = function unchain() {
	for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
		nodes[_key3] = arguments[_key3];
	}

	return nodes.slice().reverse().forEach(function (n, i) {
		return isSet(nodes[i - 1]) && disconnect(nodes[i - 1], n);
	}), nodes[0];
};

var duration = function duration(seconds) {
	return context.sampleRate * seconds;
};
var chData = function chData(node) {
	for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		args[_key4 - 1] = arguments[_key4];
	}

	return (
		// console.log(node, args),
		node.getChannelData.apply(node, args)
	);
};

var schedule = function schedule(node, pref, values, times) {
	return values.length === 1 ? node[pref].setValueAtTime(values[0], times[0]) : (node[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [times[0] + times[1]].concat(times.slice(2))));
};

module.exports = {
	context: context,
	set: set,
	isSet: isSet,
	isGet: isGet,
	create: create,
	update: update,
	connect: connect,
	disconnect: disconnect,
	chain: chain,
	unchain: unchain,
	// util
	duration: duration,
	chData: chData,
	schedule: schedule
};

},{"iblokz-data":10}],158:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;

var create = function create(prefs) {
	return [{
		prefs: _extends({
			type: 'sawtooth',
			frequency: 5,
			gain: 15
		}, prefs),
		effect: _create('oscillator'),
		output: _create('gain')
	}].map(function (n) {
		return chain(n.effect, n.output), set(n.effect.frequency, 'value', n.prefs.frequency), set(n.output.gain, 'value', n.prefs.gain), set(n.effect, 'type', n.prefs.type), n;
	}).pop();
};

var update = function update(n, prefs) {
	return set(n, 'prefs', _extends({}, n.prefs, prefs)), set(n.effect.frequency, 'value', n.prefs.frequency), set(n.output.gain, 'value', n.prefs.gain), set(n.effect, 'type', n.prefs.type), n;
};

var start = function start(n) {
	return n.effect.start(), n;
};

// const clone = n => create(null, n.output.buffer);

module.exports = {
	create: create,
	update: update,
	start: start
};

},{"../core":157,"iblokz-data":10}],159:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;
// const {context} = core;

var buildImpulse = function buildImpulse(_ref) {
	var seconds = _ref.seconds,
	    decay = _ref.decay;

	var impulse = _create('buffer', 2, duration(seconds), context.sampleRate);
	var channelData = [chData(impulse, 0), chData(impulse, 1)];
	for (var i = 0; i < duration(seconds); i++) {
		channelData[0][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
		channelData[1][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
	}
	return impulse;
};

var create = function create(prefs) {
	return [{
		prefs: _extends({ seconds: 3, decay: 2, wet: 0, dry: 1 }, prefs),
		input: _create('gain'),
		output: _create('gain'),
		effect: _create('convolver'),
		wet: _create('gain'),
		dry: _create('gain')
	}].map(function (n) {
		return chain(n.input, n.dry, n.output), chain(n.input, n.effect, n.wet, n.output), set(n.dry.gain, 'value', n.prefs.dry), set(n.wet.gain, 'value', n.prefs.wet), set(n.effect, 'buffer', buildImpulse(n.prefs)), n;
	}
	// n

	/*
 n.input.connect(n.effect);
 n.effect.connect(n.wet);
 n.wet.connect(n.output);
 	n.input.connect(n.dry);
 n.dry.connect(n.output);
 */
	/*
 n.dry.gain.value = n.prefs.dry;
 n.wet.gain.value = n.prefs.wet;
 n.effect.buffer = buildImpulse(n.prefs);
 */
	// set(n.wet.gain, 'value', n.prefs.wet),
	// set(n.effect, 'buffer', buildImpulse(n.prefs)),
	// return n;
	).pop();
};

var update = function update(n, prefs) {
	return (
		//	console.log(prefs, n.prefs),
		(n.prefs.seconds !== prefs.seconds || n.prefs.decay !== prefs.decay) && set(n.effect, 'buffer', buildImpulse(n.prefs)), n.prefs.dry !== prefs.dry && set(n.dry.gain, 'value', prefs.dry), n.prefs.wet !== prefs.wet && set(n.wet.gain, 'value', prefs.wet), set(n, 'prefs', _extends({}, n.prefs, prefs)), n
	);
};

module.exports = {
	create: create,
	update: update
};

},{"../core":157,"iblokz-data":10}],160:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('./core'),
    context = _require2.context,
    set = _require2.set,
    isSet = _require2.isSet,
    isGet = _require2.isGet,
    _schedule = _require2.schedule,
    _create = _require2.create,
    _connect = _require2.connect,
    _disconnect = _require2.disconnect;

var _reverb = require('./effects/reverb');
var _lfo = require('./effects/lfo');
var _adsr = require('./controls/adsr');

var create = function create(type) {
	var prefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context;
	return _extends({}, obj.switch(type, {
		vco: function vco() {
			return { output: _create('oscillator') };
		},
		vca: function vca() {
			return { through: _create('gain') };
		},
		vcf: function vcf() {
			return { through: _create('biquadFilter') };
		},
		lfo: function lfo() {
			return _lfo.create(prefs);
		},
		reverb: function reverb() {
			return _reverb.create(prefs);
		},
		adsr: function adsr() {
			return _adsr.create(prefs);
		}
	})(), { type: type, out: [] });
};

var cutoffToFreq = function cutoffToFreq(cutoff) {
	var minValue = 40;
	var maxValue = context.sampleRate / 2;
	// Logarithm (base 2) to compute how many octaves fall in the range.
	var numberOfOctaves = Math.log(maxValue / minValue) / Math.LN2;
	// Compute a multiplier from 0 to 1 based on an exponential scale.
	var multiplier = Math.pow(2, numberOfOctaves * (cutoff - 1.0));
	// Get back to the frequency value between min and max.
	return maxValue * multiplier;
};

var update = function update(node, prefs) {
	return obj.switch(node.type, {
		vco: function vco() {
			return isSet(prefs.type) && set(node.output, 'type', prefs.type), isSet(prefs.freq) && set(node.output.frequency, 'value', prefs.freq), isSet(prefs.detune) && set(node.output.detune, 'value', prefs.detune), _extends(node, { prefs: prefs });
		},
		vca: function vca() {
			return isSet(prefs.gain) && set(node.through.gain, 'value', prefs.gain), _extends(node, { prefs: prefs });
		},
		vcf: function vcf() {
			return isSet(prefs.type) && set(node.through, 'type', prefs.type), isSet(prefs.cutoff) && _schedule(node.through, 'frequency', [cutoffToFreq(prefs.cutoff)], [context.currentTime + 0.0001]),
			// set(node.through.frequency, 'value', cutoffToFreq(prefs.cutoff)),
			isSet(prefs.resonance) && _schedule(node.through, 'Q', [prefs.resonance * 30], [context.currentTime + 0.0001]), _extends(node, { prefs: prefs });
		},
		reverb: function reverb() {
			return _reverb.update(node, prefs);
		},
		adsr: function adsr() {
			return _adsr.update(node, prefs);
		},
		lfo: function lfo() {
			return _lfo.update(node, prefs);
		}
	})();
};

var connect = function connect(node1, node2) {
	return !(node1.out && node1.out.indexOf(node2) > -1) ? (_connect(
	// input
	isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1,
	// output
	node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), _extends({}, node1, {
		out: [].concat(node1.out || [], [node2])
	})) : node1;
};

var disconnect = function disconnect(node1, node2) {
	return (
		// (console.log('dissconnecting', node1, node2)),
		node1.out.indexOf(node2) > -1 ? (_disconnect(
		// input
		isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1,
		// output
		node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), _extends({}, node1, {
			out: [].concat(node1.out.slice(0, node1.out.indexOf(node2)), node1.out.slice(node1.out.indexOf(node2) + 1))
		})) : typeof node2 === 'undefined' ? node1.out.reduce(function (node1, prevNode) {
			return disconnect(node1, prevNode);
		}, node1) : node1
	);
};

var reroute = function reroute(node1, node2) {
	return node1.out && node1.out.indexOf(node2) === -1 ? connect(disconnect(node1), node2) : node1;
};

var chain = function chain() {
	for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
		nodes[_key] = arguments[_key];
	}

	return nodes.forEach(function (n, i) {
		return isSet(n[i + 1]) && connect(n, nodes[i + 1]);
	}), nodes[0];
};

var unchain = function unchain() {
	for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		nodes[_key2] = arguments[_key2];
	}

	return nodes.slice().reverse().forEach(function (n, i) {
		return isSet(n[i - 1]) && disconnect(nodes[i - 1], n);
	}), nodes[0];
};

var start = function start(node) {
	var _node$output;

	for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		args[_key3 - 1] = arguments[_key3];
	}

	return node.type === 'lfo' && _lfo.start.apply(_lfo, [node].concat(args)) || (_node$output = node.output).start.apply(_node$output, args), node;
};

var stop = function stop(node) {
	var _node$output2;

	for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		args[_key4 - 1] = arguments[_key4];
	}

	return (_node$output2 = node.output).stop.apply(_node$output2, args), node;
};

var schedule = function schedule(node, pref, values, times) {
	return values.length === 1 ? node.through[pref].setValueAtTime(values[0], times[0]) : (node.through[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [times[0] + times[1]].concat(times.slice(2))));
};

var noteToFrequency = function noteToFrequency(note) {
	var notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
	var keyNumber;
	var octave;

	if (note.length === 3) {
		octave = note.charAt(2);
	} else {
		octave = note.charAt(1);
	}

	keyNumber = notes.indexOf(note.slice(0, -1));

	if (keyNumber < 3) {
		keyNumber = keyNumber + 12 + (octave - 1) * 12 + 1;
	} else {
		keyNumber = keyNumber + (octave - 1) * 12 + 1;
	}

	return 440 * Math.pow(2, (keyNumber - 49) / 12);
};

module.exports = {
	context: context,
	create: create,
	update: update,
	schedule: schedule,
	connect: connect,
	disconnect: disconnect,
	reroute: reroute,
	chain: chain,
	unchain: unchain,
	noteToFrequency: noteToFrequency,
	start: start,
	stop: stop,
	vco: function vco(prefs) {
		return update(create('vco', {}, context), prefs);
	},
	vcf: function vcf(prefs) {
		return update(create('vcf', {}, context), prefs);
	},
	lfo: function lfo(prefs) {
		return update(create('lfo', {}, context), prefs);
	},
	vca: function vca(prefs) {
		return update(create('vca', {}, context), prefs);
	},
	adsr: function adsr(prefs) {
		return create('adsr', prefs, context);
	},
	noteOn: _adsr.noteOn,
	noteOff: _adsr.noteOff
};

},{"./controls/adsr":156,"./core":157,"./effects/lfo":158,"./effects/reverb":159,"iblokz-data":10}],161:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj,
    fn = _require.fn;

var _require2 = require('../core'),
    context = _require2.context,
    _create = _require2.create,
    set = _require2.set,
    chain = _require2.chain,
    duration = _require2.duration,
    chData = _require2.chData;

var create = function create(file, buffer) {
	return [{
		output: _create('bufferSource')
	}].map(function (n) {
		return !buffer ? fetch(file).then(function (res) {
			return res.arrayBuffer();
		}).then(function (buffer) {
			return context.decodeAudioData(buffer, function (buffer) {
				return set(n.output, 'buffer', buffer);
			});
		}) : set(n.output, 'buffer', buffer), n;
	}).pop();
};

var update = function update() {};

var clone = function clone(n) {
	return create(null, n.output.buffer);
};

module.exports = {
	create: create,
	update: update,
	clone: clone
};

},{"../core":157,"iblokz-data":10}],162:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;
var fileSaver = require('file-saver');
var jsZip = require("jszip");

var _require = require("iblokz-data"),
    fn = _require.fn,
    obj = _require.obj;

var load = function load(file) {
	var readAs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
	return $.create(function (stream) {
		var fr = new FileReader();
		fr.onload = function (ev) {
			// console.log(readAs, ev.target.result);
			stream.onNext(readAs === 'json' ? JSON.parse(ev.target.result) : ev.target.result);
			stream.onCompleted();
		};
		// console.log(file, readAs);
		(typeof file === 'string' ? $.fromPromise(fetch(file)).flatMap(function (res) {
			return res.blob();
		}) : $.just(file)).subscribe(function (f) {
			return fn.switch(readAs, {
				arrayBuffer: function arrayBuffer(f) {
					return fr.readAsArrayBuffer(f);
				},
				default: function _default(f) {
					return fr.readAsText(f);
				}
			})(f);
		});
	});
};

var loadZip = function loadZip(file) {
	return load(file, 'arrayBuffer').flatMap(function (data) {
		return $.fromPromise(jsZip.loadAsync(data));
	}).flatMap(function (zf) {
		return $.concat(Object.keys(zf.files).filter(function (k) {
			return !zf.files[k].dir;
		})
		// .map(k => (console.log(k), k))
		.map(function (k) {
			return $.fromPromise(zf.files[k].async('arraybuffer')).map(function (v) {
				return { k: k, v: v };
			});
		})).reduce(function (o, _ref) {
			var k = _ref.k,
			    v = _ref.v;
			return obj.patch(o, k, v);
		}, {});
	});
};

var save = function save(fileName, content) {
	return fileSaver.saveAs(new Blob([JSON.stringify(content)], { type: "text/plain;charset=utf-8" }), fileName);
};

module.exports = {
	load: load,
	loadZip: loadZip,
	save: save
};

},{"file-saver":7,"iblokz-data":10,"jszip":42,"rx":123}],163:[function(require,module,exports){
'use strict';

var _require = require('iblokz-data'),
    obj = _require.obj;

var keys = Object.keys;

var arrify = function arrify(o) {
  return o instanceof Object ? !(o instanceof Array) && keys(o).filter(function (k) {
    return k.match(/^-?[0-9.]+$/);
  }).length === keys(o).length ? keys(o).map(function (k) {
    return arrify(o[k]);
  }) : keys(o).reduce(function (o2, k) {
    return obj.patch(o2, k, arrify(o[k]));
  }, {}) : o;
};

var toData = function toData(form) {
  return arrify(Array.from(form.elements)
  // .map(el => (console.log(el.name), el))
  .filter(function (el) {
    return el.name !== undefined && el.name !== '';
  }).reduce(function (o, el) {
    return obj.patch(o, el.name.split('.'), el.type && el.type === 'number' ? Number(el.value) : el.value);
  }, {}));
};

var clear = function clear(form) {
  return Array.from(form.elements).forEach(function (el) {
    return el.value = null;
  });
};

module.exports = {
  toData: toData,
  clear: clear
};

},{"iblokz-data":10}],164:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var time = require('./time');

var parsePad = function parsePad(pad) {
	return pad && {
		axes: pad.axes,
		buttons: pad.buttons.map(function (button) {
			return {
				pressed: button.pressed,
				value: button.value
			};
		}),
		connected: pad.connected,
		id: pad.id,
		index: pad.index,
		mapping: pad.mapping,
		timestamp: pad.timestamp
	} || pad;
};

var list = function list() {
	return Array.from(navigator.getGamepads() || navigator.webkitGetGamepads() || []).map(parsePad);
};

var changes = function changes() {
	return time.frame().map(list).distinctUntilChanged(function (pads) {
		return pads;
	})
	//	pads.reduce((r, pad) => !pad && r || (r + (pad.axes || '') + (pad.buttons || '')), ''))
	.share();
};

module.exports = {
	list: list,
	changes: changes
};

},{"./time":167,"rx":123}],165:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var Rx = require('rx');
var $ = Rx.Observable;

var keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

var numberToNote = function numberToNote(number) {
	return {
		key: keys[number % 12],
		octave: parseInt((number - number % 12) / 12, 10) - 1,
		number: number
	};
};

var noteToNumber = function noteToNumber(note) {
	return keys.indexOf(note.replace(/[0-9]+/, '')) + (parseInt(note.replace(/[A-Z#b]+/, ''), 10) + 1) * 12;
};

var parseMidiMsg = function parseMidiMsg(event) {
	// Mask off the lower nibble (MIDI channel, which we don't care about)

	var status = event.data[0] & 0xf0;
	var binary = event.data[0].toString(2);
	var channel = event.data[0] - status + 1;
	var msg = {};

	switch (binary.slice(0, 4)) {
		// noteoff
		case "1000":
			msg = {
				state: 'noteOff',
				note: numberToNote(event.data[1])
			};
			break;
		// noteon
		case "1001":
			msg = event.data[2] !== 0 ? // if velocity != 0, this is a note-on message
			{
				state: 'noteOn',
				note: numberToNote(event.data[1]),
				velocity: parseFloat((event.data[2] / 127).toFixed(2))
			} : { // if velocity == 0, fall thru: it's a note-off.	MIDI's weird, ya'll.
				state: 'noteOff',
				note: numberToNote(event.data[1])
			};
			break;
		// pitch wheel
		case "1110":
			msg = {
				state: 'pitchBend',
				pitchValue: event.data[2] === 64 ? 0 : parseFloat((event.data[2] / 63.5 - 1).toFixed(2))
			};
			break;
		// controller
		case "1011":
			msg = {
				state: "controller",
				controller: event.data[1],
				value: parseFloat((event.data[2] / 127).toFixed(2))
			};
			break;
		case "1100":
			msg = {
				state: "bankSelect",
				bank: event.data[1]
			};
			break;
		default:
			msg = {
				state: false
			};
			break;
	}

	return _extends({}, msg, {
		binary: binary,
		status: status,
		channel: channel,
		data: event.data
	});
};
//
// const hookUpMIDIInput = midiAccess => {
// 	var haveAtLeastOneDevice = false;
// 	var inputs = midiAccess.inputs.values();
// 	for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
// 		input.value.onmidimessage = MIDIMessageEventHandler;
// 		haveAtLeastOneDevice = true;
// 	}
// };
//
// const onMIDIInit = midi => {
// 	hookUpMIDIInput(midi);
// 	midi.onstatechange = hookUpMIDIInput;
// };
//
// const onMIDIReject = err =>
// 	console.log(err, 'The MIDI system failed to start.');
//
// (navigator.requestMIDIAccess)
// 		&& navigator.requestMIDIAccess().then(onMIDIInit, onMIDIReject);

var parseAccess = function parseAccess(access) {
	var inputs = [];
	var outputs = [];

	// console.log(access);

	access.inputs.forEach(function (input) {
		return inputs.push(input);
	});
	access.outputs.forEach(function (output) {
		return outputs.push(output);
	});
	return { access: access, inputs: inputs, outputs: outputs };
};

var init = function init() {
	var devices$ = new Rx.Subject();
	$.fromPromise(navigator.requestMIDIAccess()).flatMap(function (access) {
		return $.create(function (stream) {
			access.onstatechange = function (connection) {
				return stream.onNext(connection.currentTarget);
			};
		}).startWith(access);
	}).map(parseAccess)
	// .map(data => (console.log('midi access', data), data))
	.subscribe(function (device) {
		return devices$.onNext(device);
	});
	// .share();

	var msg$ = new Rx.Subject();
	devices$.flatMap(function (_ref) {
		var access = _ref.access,
		    inputs = _ref.inputs;
		return inputs.reduce(function (msgStream, input) {
			return msgStream.merge($.fromEventPattern(function (h) {
				input.onmidimessage = h;
			}).map(function (msg) {
				return { access: access, input: input, msg: msg };
			}));
		}, $.empty());
	}).subscribe(function (msg) {
		return msg$.onNext(msg);
	});

	return {
		devices$: devices$,
		msg$: msg$
	};
};

module.exports = {
	init: init,
	numberToNote: numberToNote,
	noteToNumber: noteToNumber,
	parseMidiMsg: parseMidiMsg
};

},{"rx":123}],166:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var _require = require('iblokz-data'),
    obj = _require.obj;

var pocket = void 0;

var reducers$ = new Rx.Subject();
var pocket$ = new Rx.BehaviorSubject({});

reducers$.scan(function (pocket, reduce) {
	return reduce(pocket);
}, {}).subscribe(function (pocket) {
	return pocket$.onNext(pocket);
});

pocket$.subscribe(function (_pocket) {
	// console.log({pocket});
	pocket = _pocket;
});

var put = function put(path, val) {
	return reducers$.onNext(function (pocket) {
		return obj.patch(pocket, path, val);
	});
};
var get = function get(path) {
	return obj.sub(pocket, path);
};

module.exports = {
	put: put,
	get: get,
	reducers$: reducers$,
	stream: pocket$
};

},{"iblokz-data":10,"rx":123}],167:[function(require,module,exports){
'use strict';

var Rx = require('rx');
var $ = Rx.Observable;

var raf = require('raf');

var tick = function tick(cb) {
	return raf(function (dt) {
		cb(dt);
		tick(cb);
	});
};

var frame = function frame() {
	return $.create(function (obs) {
		return tick(function (dt) {
			return obs.onNext(dt);
		});
	}).filter(function (dt) {
		return dt !== 0;
	}).share();
};

var loop = function loop(state$, node) {
	return frame(node).withLatestFrom(state$, function (dt, state) {
		return { dt: dt, state: state };
	});
};

module.exports = {
	frame: frame,
	loop: loop
};

},{"raf":109,"rx":123}]},{},[141])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmlsZS1zYXZlci9kaXN0L0ZpbGVTYXZlci5taW4uanMiLCJub2RlX21vZHVsZXMvaHRtbC10YWdzL2h0bWwtdGFncy5qc29uIiwibm9kZV9tb2R1bGVzL2h0bWwtdGFncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9saWIvYXJyLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1kYXRhL2xpYi9mbi5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otZGF0YS9saWIvb2JqLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1kYXRhL2xpYi9zdHIuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2guanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2h0bWxkb21hcGkuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2lzLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1zbmFiYmRvbS1oZWxwZXJzL25vZGVfbW9kdWxlcy9zbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvY2xhc3MuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvcHJvcHMuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwibm9kZV9tb2R1bGVzL2libG9rei1zbmFiYmRvbS1oZWxwZXJzL25vZGVfbW9kdWxlcy9zbmFiYmRvbS90aHVuay5qcyIsIm5vZGVfbW9kdWxlcy9pYmxva3otc25hYmJkb20taGVscGVycy9ub2RlX21vZHVsZXMvc25hYmJkb20vdm5vZGUuanMiLCJub2RlX21vZHVsZXMvaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMvdXRpbC9hdHRycy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRhYmxlLXN0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvQXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1N0cmluZ1JlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0dlbmVyaWNXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2xpZS9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguYWxsLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9hZ2VudC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcGx1Z2luL3dhdmVzdXJmZXIudGltZWxpbmUubWluLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC93YXZlc3VyZmVyLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL3NyYy9wbHVnaW4vcmVnaW9ucy5qcyIsInNyYy9qcy9hY3Rpb25zL2NvdW50ZXIvaW5kZXguanMiLCJzcmMvanMvYWN0aW9ucy9pbmRleC5qcyIsInNyYy9qcy9hY3Rpb25zL21pZGktbWFwL2luZGV4LmpzIiwic3JjL2pzL2V4dC93cy9yZWdpb25zLmpzIiwic3JjL2pzL2luZGV4LmpzIiwic3JjL2pzL3NlcnZpY2VzL2NvbnRyb2wuanMiLCJzcmMvanMvc2VydmljZXMvbWlkaS5qcyIsInNyYy9qcy9zZXJ2aWNlcy9wYWRzLmpzIiwic3JjL2pzL3NlcnZpY2VzL3NhbXBsZXMuanMiLCJzcmMvanMvc2VydmljZXMvc3R0LmpzIiwic3JjL2pzL3NlcnZpY2VzL3dhdmVzdXJmZXIuanMiLCJzcmMvanMvdWkvYm9hcmQvaW5kZXguanMiLCJzcmMvanMvdWkvaGVhZGVyL2luZGV4LmpzIiwic3JjL2pzL3VpL2luZGV4LmpzIiwic3JjL2pzL3VpL3BhZHMvaW5kZXguanMiLCJzcmMvanMvdWkvcmFjay9pbmRleC5qcyIsInNyYy9qcy91aS9yYWNrL3JldmVyYi9pbmRleC5qcyIsInNyYy9qcy91aS9yYWNrL3ZjZi9pbmRleC5qcyIsInNyYy9qcy91dGlsL2FwcC5qcyIsInNyYy9qcy91dGlsL2F1ZGlvL2NvbnRyb2xzL2Fkc3IuanMiLCJzcmMvanMvdXRpbC9hdWRpby9jb3JlLmpzIiwic3JjL2pzL3V0aWwvYXVkaW8vZWZmZWN0cy9sZm8uanMiLCJzcmMvanMvdXRpbC9hdWRpby9lZmZlY3RzL3JldmVyYi5qcyIsInNyYy9qcy91dGlsL2F1ZGlvL2luZGV4LmpzIiwic3JjL2pzL3V0aWwvYXVkaW8vc291cmNlcy9zYW1wbGVyLmpzIiwic3JjL2pzL3V0aWwvZmlsZS5qcyIsInNyYy9qcy91dGlsL2Zvcm0uanMiLCJzcmMvanMvdXRpbC9nYW1lcGFkLmpzIiwic3JjL2pzL3V0aWwvbWlkaS5qcyIsInNyYy9qcy91dGlsL3BvY2tldC5qcyIsInNyYy9qcy91dGlsL3RpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUFFQSxRQUFRLFVBQVIsR0FBcUIsVUFBckI7QUFDQSxRQUFRLFdBQVIs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QSxDQUFiOztBQUtBLElBQU0sUUFBUSxTQUFSLEtBQVE7QUFBQSxRQUFNLEVBQUUsTUFBRixDQUNuQjtBQUFBLFNBQU8sS0FBSztBQUFBLFVBQU0sSUFBSSxNQUFKLENBQVcsRUFBWCxDQUFOO0FBQUEsR0FBTCxDQUFQO0FBQUEsRUFEbUIsRUFHbEIsTUFIa0IsQ0FHWDtBQUFBLFNBQU0sT0FBTyxDQUFiO0FBQUEsRUFIVyxFQUlsQixLQUprQixFQUFOO0FBQUEsQ0FBZDs7QUFNQSxJQUFNLE9BQU8sU0FBUCxJQUFPLENBQUMsTUFBRCxFQUFTLElBQVQ7QUFBQSxRQUFrQixNQUFNLElBQU4sRUFBWSxjQUFaLENBQTJCLE1BQTNCLEVBQW1DLFVBQUMsRUFBRCxFQUFLLEtBQUw7QUFBQSxTQUFnQixFQUFDLE1BQUQsRUFBSyxZQUFMLEVBQWhCO0FBQUEsRUFBbkMsQ0FBbEI7QUFBQSxDQUFiOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNoQixhQURnQjtBQUVoQjtBQUZnQixDQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklpSXNJbVpwYkdVaU9pSmxiWEIwZVM1cWN5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJYWDA9IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiKGZ1bmN0aW9uKGEsYil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxiKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKWIoKTtlbHNle2IoKSxhLkZpbGVTYXZlcj17ZXhwb3J0czp7fX0uZXhwb3J0c319KSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhLGIpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBiP2I9e2F1dG9Cb206ITF9Olwib2JqZWN0XCIhPXR5cGVvZiBiJiYoY29uc29sZS53YXJuKFwiRGVwcmljYXRlZDogRXhwZWN0ZWQgdGhpcmQgYXJndW1lbnQgdG8gYmUgYSBvYmplY3RcIiksYj17YXV0b0JvbTohYn0pLGIuYXV0b0JvbSYmL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYS50eXBlKT9uZXcgQmxvYihbXCJcXHVGRUZGXCIsYV0se3R5cGU6YS50eXBlfSk6YX1mdW5jdGlvbiBjKGIsYyxkKXt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZS5vcGVuKFwiR0VUXCIsYiksZS5yZXNwb25zZVR5cGU9XCJibG9iXCIsZS5vbmxvYWQ9ZnVuY3Rpb24oKXthKGUucmVzcG9uc2UsYyxkKX0sZS5vbmVycm9yPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcImNvdWxkIG5vdCBkb3dubG9hZCBmaWxlXCIpfSxlLnNlbmQoKX1mdW5jdGlvbiBkKGEpe3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYi5vcGVuKFwiSEVBRFwiLGEsITEpLGIuc2VuZCgpLDIwMDw9Yi5zdGF0dXMmJjI5OT49Yi5zdGF0dXN9ZnVuY3Rpb24gZShhKXt0cnl7YS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfWNhdGNoKGMpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7Yi5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsd2luZG93LDAsMCwwLDgwLDIwLCExLCExLCExLCExLDAsbnVsbCksYS5kaXNwYXRjaEV2ZW50KGIpfX12YXIgZj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfHwoNDIsZXZhbCkoXCJ0aGlzXCIpfWNhdGNoKGEpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy53aW5kb3c9PT13aW5kb3c/d2luZG93Olwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLnNlbGY9PT1zZWxmP3NlbGY6XCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsLmdsb2JhbD09PWdsb2JhbD9nbG9iYWw6dGhpc319KCksYT1mLnNhdmVBc3x8XCJvYmplY3RcIiE9dHlwZW9mIHdpbmRvd3x8d2luZG93IT09Zj9mdW5jdGlvbigpe306XCJkb3dubG9hZFwiaW4gSFRNTEFuY2hvckVsZW1lbnQucHJvdG90eXBlP2Z1bmN0aW9uKGIsZyxoKXt2YXIgaT1mLlVSTHx8Zi53ZWJraXRVUkwsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtnPWd8fGIubmFtZXx8XCJkb3dubG9hZFwiLGouZG93bmxvYWQ9ZyxqLnJlbD1cIm5vb3BlbmVyXCIsXCJzdHJpbmdcIj09dHlwZW9mIGI/KGouaHJlZj1iLGoub3JpZ2luPT09bG9jYXRpb24ub3JpZ2luP2Uoaik6ZChqLmhyZWYpP2MoYixnLGgpOmUoaixqLnRhcmdldD1cIl9ibGFua1wiKSk6KGouaHJlZj1pLmNyZWF0ZU9iamVjdFVSTChiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS5yZXZva2VPYmplY3RVUkwoai5ocmVmKX0sNEU0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShqKX0sMCkpfTpcIm1zU2F2ZU9yT3BlbkJsb2JcImluIG5hdmlnYXRvcj9mdW5jdGlvbihmLGcsaCl7aWYoZz1nfHxmLm5hbWV8fFwiZG93bmxvYWRcIixcInN0cmluZ1wiIT10eXBlb2YgZiluYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihiKGYsaCksZyk7ZWxzZSBpZihkKGYpKWMoZixnLGgpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7aS5ocmVmPWYsaS50YXJnZXQ9XCJfYmxhbmtcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShpKX0pfX06ZnVuY3Rpb24oYSxiLGQsZSl7aWYoZT1lfHxvcGVuKFwiXCIsXCJfYmxhbmtcIiksZSYmKGUuZG9jdW1lbnQudGl0bGU9ZS5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD1cImRvd25sb2FkaW5nLi4uXCIpLFwic3RyaW5nXCI9PXR5cGVvZiBhKXJldHVybiBjKGEsYixkKTt2YXIgZz1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiPT09YS50eXBlLGg9L2NvbnN0cnVjdG9yL2kudGVzdChmLkhUTUxFbGVtZW50KXx8Zi5zYWZhcmksaT0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoKGl8fGcmJmgpJiZcIm9iamVjdFwiPT10eXBlb2YgRmlsZVJlYWRlcil7dmFyIGo9bmV3IEZpbGVSZWFkZXI7ai5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXt2YXIgYT1qLnJlc3VsdDthPWk/YTphLnJlcGxhY2UoL15kYXRhOlteO10qOy8sXCJkYXRhOmF0dGFjaG1lbnQvZmlsZTtcIiksZT9lLmxvY2F0aW9uLmhyZWY9YTpsb2NhdGlvbj1hLGU9bnVsbH0sai5yZWFkQXNEYXRhVVJMKGEpfWVsc2V7dmFyIGs9Zi5VUkx8fGYud2Via2l0VVJMLGw9ay5jcmVhdGVPYmplY3RVUkwoYSk7ZT9lLmxvY2F0aW9uPWw6bG9jYXRpb24uaHJlZj1sLGU9bnVsbCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ay5yZXZva2VPYmplY3RVUkwobCl9LDRFNCl9fTtmLnNhdmVBcz1hLnNhdmVBcz1hLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJihtb2R1bGUuZXhwb3J0cz1hKX0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlU2F2ZXIubWluLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPVtcblx0XCJhXCIsXG5cdFwiYWJiclwiLFxuXHRcImFkZHJlc3NcIixcblx0XCJhcmVhXCIsXG5cdFwiYXJ0aWNsZVwiLFxuXHRcImFzaWRlXCIsXG5cdFwiYXVkaW9cIixcblx0XCJiXCIsXG5cdFwiYmFzZVwiLFxuXHRcImJkaVwiLFxuXHRcImJkb1wiLFxuXHRcImJsb2NrcXVvdGVcIixcblx0XCJib2R5XCIsXG5cdFwiYnJcIixcblx0XCJidXR0b25cIixcblx0XCJjYW52YXNcIixcblx0XCJjYXB0aW9uXCIsXG5cdFwiY2l0ZVwiLFxuXHRcImNvZGVcIixcblx0XCJjb2xcIixcblx0XCJjb2xncm91cFwiLFxuXHRcImRhdGFcIixcblx0XCJkYXRhbGlzdFwiLFxuXHRcImRkXCIsXG5cdFwiZGVsXCIsXG5cdFwiZGV0YWlsc1wiLFxuXHRcImRmblwiLFxuXHRcImRpYWxvZ1wiLFxuXHRcImRpdlwiLFxuXHRcImRsXCIsXG5cdFwiZHRcIixcblx0XCJlbVwiLFxuXHRcImVtYmVkXCIsXG5cdFwiZmllbGRzZXRcIixcblx0XCJmaWdjYXB0aW9uXCIsXG5cdFwiZmlndXJlXCIsXG5cdFwiZm9vdGVyXCIsXG5cdFwiZm9ybVwiLFxuXHRcImgxXCIsXG5cdFwiaDJcIixcblx0XCJoM1wiLFxuXHRcImg0XCIsXG5cdFwiaDVcIixcblx0XCJoNlwiLFxuXHRcImhlYWRcIixcblx0XCJoZWFkZXJcIixcblx0XCJoZ3JvdXBcIixcblx0XCJoclwiLFxuXHRcImh0bWxcIixcblx0XCJpXCIsXG5cdFwiaWZyYW1lXCIsXG5cdFwiaW1nXCIsXG5cdFwiaW5wdXRcIixcblx0XCJpbnNcIixcblx0XCJrYmRcIixcblx0XCJrZXlnZW5cIixcblx0XCJsYWJlbFwiLFxuXHRcImxlZ2VuZFwiLFxuXHRcImxpXCIsXG5cdFwibGlua1wiLFxuXHRcIm1haW5cIixcblx0XCJtYXBcIixcblx0XCJtYXJrXCIsXG5cdFwibWF0aFwiLFxuXHRcIm1lbnVcIixcblx0XCJtZW51aXRlbVwiLFxuXHRcIm1ldGFcIixcblx0XCJtZXRlclwiLFxuXHRcIm5hdlwiLFxuXHRcIm5vc2NyaXB0XCIsXG5cdFwib2JqZWN0XCIsXG5cdFwib2xcIixcblx0XCJvcHRncm91cFwiLFxuXHRcIm9wdGlvblwiLFxuXHRcIm91dHB1dFwiLFxuXHRcInBcIixcblx0XCJwYXJhbVwiLFxuXHRcInBpY3R1cmVcIixcblx0XCJwcmVcIixcblx0XCJwcm9ncmVzc1wiLFxuXHRcInFcIixcblx0XCJyYlwiLFxuXHRcInJwXCIsXG5cdFwicnRcIixcblx0XCJydGNcIixcblx0XCJydWJ5XCIsXG5cdFwic1wiLFxuXHRcInNhbXBcIixcblx0XCJzY3JpcHRcIixcblx0XCJzZWN0aW9uXCIsXG5cdFwic2VsZWN0XCIsXG5cdFwic2xvdFwiLFxuXHRcInNtYWxsXCIsXG5cdFwic291cmNlXCIsXG5cdFwic3BhblwiLFxuXHRcInN0cm9uZ1wiLFxuXHRcInN0eWxlXCIsXG5cdFwic3ViXCIsXG5cdFwic3VtbWFyeVwiLFxuXHRcInN1cFwiLFxuXHRcInN2Z1wiLFxuXHRcInRhYmxlXCIsXG5cdFwidGJvZHlcIixcblx0XCJ0ZFwiLFxuXHRcInRlbXBsYXRlXCIsXG5cdFwidGV4dGFyZWFcIixcblx0XCJ0Zm9vdFwiLFxuXHRcInRoXCIsXG5cdFwidGhlYWRcIixcblx0XCJ0aW1lXCIsXG5cdFwidGl0bGVcIixcblx0XCJ0clwiLFxuXHRcInRyYWNrXCIsXG5cdFwidVwiLFxuXHRcInVsXCIsXG5cdFwidmFyXCIsXG5cdFwidmlkZW9cIixcblx0XCJ3YnJcIlxuXVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2h0bWwtdGFncy5qc29uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0b2JqOiByZXF1aXJlKCcuL2xpYi9vYmonKSxcblx0YXJyOiByZXF1aXJlKCcuL2xpYi9hcnInKSxcblx0c3RyOiByZXF1aXJlKCcuL2xpYi9zdHInKSxcblx0Zm46IHJlcXVpcmUoJy4vbGliL2ZuJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFkZCA9IChhcnIsIGl0ZW0pID0+IFtdLmNvbmNhdChhcnIsIFtpdGVtXSk7XG5cbmNvbnN0IHJlbW92ZSA9IChhcnIsIGl0ZW0pID0+IGFyci5pbmRleE9mKGl0ZW0pID4gLTEgPyBbXS5jb25jYXQoXG5cdGFyci5zbGljZSgwLCBhcnIuaW5kZXhPZihpdGVtKSksXG5cdGFyci5zbGljZShhcnIuaW5kZXhPZihpdGVtKSArIDEpXG4pIDogYXJyO1xuXG5jb25zdCB0b2dnbGUgPSAoYXJyLCBpdGVtKSA9PiBhcnIuaW5kZXhPZihpdGVtKSA+IC0xXG5cdD8gcmVtb3ZlKGFyciwgaXRlbSlcblx0OiBhZGQoYXJyLCBpdGVtKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFkZCxcblx0cmVtb3ZlLFxuXHR0b2dnbGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9iaiA9IHJlcXVpcmUoJy4vb2JqJyk7XG5cbi8vICgoKGEsIGIsIOKApiwgbikg4oaSIG8pLCAobyDihpIgcCksIOKApiwgKHgg4oaSIHkpLCAoeSDihpIgeikpIOKGkiAoKGEsIGIsIOKApiwgbikg4oaSIHopXG5jb25zdCBwaXBlID0gKGEsIC4uLmZucykgPT4gKC4uLmFyZ3MpID0+IGZucy5yZWR1Y2UoKHJlcywgZm4pID0+IGZuKHJlcyksIGEoLi4uYXJncykpO1xuXG4vLyAoKHkg4oaSIHopLCAoeCDihpIgeSksIOKApiwgKG8g4oaSIHApLCAoKGEsIGIsIOKApiwgbikg4oaSIG8pKSDihpIgKChhLCBiLCDigKYsIG4pIOKGkiB6KVxuY29uc3QgY29tcG9zZSA9ICguLi5mbnMpID0+IHBpcGUoZm5zLnNsaWNlKC0xKS5wb3AoKSwgLi4uZm5zLnJldmVyc2UoKS5zbGljZSgxKSk7XG5cbi8vIHN3aXRjaCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjb21wb3NlLFxuXHRwaXBlLFxuXHRzd2l0Y2g6IG9iai5zd2l0Y2hcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtleVZhbHVlID0gKGssIHYpID0+IHtcblx0bGV0IG8gPSB7fTtcblx0b1trXSA9IHY7XG5cdHJldHVybiBvO1xufTtcblxuY29uc3QgY2xvbmUgPSBvID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobykgfHwge30pLCBvKTtcblxuY29uc3Qgc3ViID0gKG8sIHApID0+IChwIGluc3RhbmNlb2YgQXJyYXkpXG5cdD8gKHR5cGVvZiBvW3BbMF1dICE9PSAndW5kZWZpbmVkJyAmJiBwLmxlbmd0aCA+IDEpID8gc3ViKG9bcFswXV0sIHAuc2xpY2UoMSkpIDogb1twWzBdXVxuXHQ6IG9bcF07XG5cbmNvbnN0IHBhdGNoID0gKG8sIGssIHYpID0+IE9iamVjdC5hc3NpZ24oY2xvbmUobyksXG5cdChrIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0PyBrZXlWYWx1ZShrWzBdLCAoay5sZW5ndGggPiAxKVxuXHRcdFx0PyBwYXRjaChvW2tbMF1dIHx8IHt9LCBrLnNsaWNlKDEpLCB2KVxuXHRcdFx0OiB0eXBlb2Ygb1trWzBdXSA9PT0gJ29iamVjdCcgJiYgb1trWzBdXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5hc3NpZ24oY2xvbmUob1trWzBdXSksIHYpIHx8IHYpXG5cdFx0OiBrZXlWYWx1ZShrLCB0eXBlb2Ygb1trXSA9PT0gJ29iamVjdCcgJiYgb1trXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5hc3NpZ24oY2xvbmUob1trXSksIHYpIHx8IHYpXG4pO1xuXG5jb25zdCByZWR1Y2UgPSAobywgcmVkdWNlRm4sIGluaXRpYWwpID0+IE9iamVjdC5rZXlzKG8pXG5cdC5yZWR1Y2UoXG5cdFx0KGFjY3VtdWxhdG9yLCBrZXksIGluZGV4KSA9PiByZWR1Y2VGbihhY2N1bXVsYXRvciwga2V5LCBvW2tleV0sIGluZGV4LCBvKSxcblx0XHR0eXBlb2YgaW5pdGlhbCA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdD8gb1tPYmplY3Qua2V5cyhvKVswXV0gLy8gdG8gY29uZmlybSB3aXRoIHRoZSBhcnJheSByZWR1Y2Ugc3BlYyBpbiB0aGlzIGNhc2UgdGhlIGZpcnRzIHByb3BlcnR5IGlzIHVzZWRcblx0XHRcdDogaW5pdGlhbFxuXHQpO1xuXG5jb25zdCBtYXAgPSAobywgbWFwRm4pID0+IHJlZHVjZShvLFxuXHQobzIsIGtleSwgdmFsdWUsIGluZGV4KSA9PiBwYXRjaChvMiwga2V5LCBtYXBGbihrZXksIHZhbHVlLCBpbmRleCwgbykpLFxuXHR7fVxuKTtcblxuY29uc3QgZmlsdGVyID0gKG8sIGZpbHRlckZuKSA9PiByZWR1Y2Uobyxcblx0KG8yLCBrZXksIHZhbHVlLCBpbmRleCkgPT4gZmlsdGVyRm4oa2V5LCB2YWx1ZSwgaW5kZXgsIG8pXG5cdFx0PyBwYXRjaChvMiwga2V5LCB2YWx1ZSlcblx0XHQ6IG8yLFxuXHR7fVxuKTtcblxuY29uc3QgdHJhdmVyc2UgPSAodHJlZSwgZm4pID0+IE9iamVjdC5rZXlzKHRyZWUpLnJlZHVjZSgobywgaykgPT5cblx0cGF0Y2gobywgayxcblx0XHQodHlwZW9mIHRyZWVba10gPT09ICdvYmplY3QnICYmIHRyZWVba10uY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHRcdD8gdHJhdmVyc2UodHJlZVtrXSwgZm4pXG5cdFx0XHQ6IGZuKHRyZWVba10sIGspXG5cdCksIHt9XG4pO1xuXG5jb25zdCBjaGFpbkNhbGwgPSAobywgY2hhaW4pID0+IGNoYWluLnJlZHVjZShcblx0KG8sIGxpbmspID0+ICh0eXBlb2YgbGlua1sxXSA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0PyBvW2xpbmtbMF1dKClcblx0XHQ6IG9bbGlua1swXV0obGlua1sxXSksXG5cdG9cbik7XG5cbmNvbnN0IF9zd2l0Y2ggPSAodmFsdWUsIGNhc2VzKSA9PlxuXHRzdWIoY2FzZXMsIHZhbHVlKSAmJiBzdWIoY2FzZXMsIHZhbHVlKVsnZGVmYXVsdCddIHx8IHN1YihjYXNlcywgdmFsdWUpXG5cdHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdCYmIHZhbHVlLmxlbmd0aCA+IDEgJiYgX3N3aXRjaCh2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSAxKSwgY2FzZXMpXG5cdHx8IGNhc2VzWydkZWZhdWx0J10gfHwgZmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRrZXlWYWx1ZSxcblx0Y2xvbmUsXG5cdHN1Yixcblx0cGF0Y2gsXG5cdHJlZHVjZSxcblx0bWFwLFxuXHRmaWx0ZXIsXG5cdHRyYXZlcnNlLFxuXHRjaGFpbkNhbGwsXG5cdHN3aXRjaDogX3N3aXRjaFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2FwaXRhbGl6ZSA9IGNodW5rID0+IGNodW5rLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2h1bmsuc2xpY2UoMSk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gKHN0ciwgZ2x1ZSA9ICdfJykgPT5cblx0c3RyLnNwbGl0KGdsdWUpXG5cdFx0Lm1hcCgoY2h1bmssIGkpID0+IChpID09PSAwKVxuXHRcdFx0PyBjaHVua1xuXHRcdFx0OiBjYXBpdGFsaXplKGNodW5rKSlcblx0XHQuam9pbignJyk7XG5cbmNvbnN0IGZyb21DYW1lbENhc2UgPSAoc3RyLCBnbHVlID0gJ18nKSA9PlxuXHRzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCAnICQxJylcblx0XHQuc3BsaXQoJyAnKVxuXHRcdC5tYXAoY2h1bmsgPT4gY2h1bmsudG9Mb3dlckNhc2UoKSlcblx0XHQuam9pbihnbHVlKTtcblxuY29uc3Qgc2luZ3VsYXJUb1BsdXJhbCA9IHN0ciA9PlxuXHRzdHIucmVwbGFjZSgveSQvLCAnaWUnKS5jb25jYXQoJ3MnKTtcblxuY29uc3QgcGx1cmFsVG9TaW5ndWxhciA9IHN0ciA9PlxuXHRzdHIucmVwbGFjZSgvaWVzJC8sICd5JykucmVwbGFjZSgvcyQvLCAnJyk7XG5cbmNvbnN0IHRvRG9jdW1lbnRJZCA9IChzdHIsIGdsdWUgPSAnXycsIHN1ZmZpeCA9ICdJZCcsIHByZWZpeCA9ICcnKSA9PlxuXHRwcmVmaXguY29uY2F0KHBsdXJhbFRvU2luZ3VsYXIodG9DYW1lbENhc2Uoc3RyLCBnbHVlKSksIHN1ZmZpeCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjYXBpdGFsaXplLFxuXHR0b0NhbWVsQ2FzZSxcblx0ZnJvbUNhbWVsQ2FzZSxcblx0c2luZ3VsYXJUb1BsdXJhbCxcblx0cGx1cmFsVG9TaW5ndWxhcixcblx0dG9Eb2N1bWVudElkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzbmFiYmRvbSA9IHJlcXVpcmUoJ3NuYWJiZG9tJyk7XG5jb25zdCBoID0gcmVxdWlyZSgnc25hYmJkb20vaCcpLmRlZmF1bHQ7XG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCBodG1sVGFncyA9IHJlcXVpcmUoJ2h0bWwtdGFncycpO1xuXG5jb25zdCBhdHRycyA9IHJlcXVpcmUoJy4vdXRpbC9hdHRycycpO1xuXG5jb25zdCBwYXRjaCA9IHNuYWJiZG9tLmluaXQoWyAvLyBJbml0IHBhdGNoIGZ1bmN0aW9uIHdpdGggY2hvb3NlbiBtb2R1bGVzXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvY2xhc3MnKS5kZWZhdWx0LCAvLyBtYWtlcyBpdCBlYXN5IHRvIHRvZ2dsZSBjbGFzc2VzXG5cdHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvcHJvcHMnKS5kZWZhdWx0LCAvLyBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIERPTSBlbGVtZW50c1xuXHRyZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMnKS5kZWZhdWx0LCAvLyBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIERPTSBlbGVtZW50c1xuXHRyZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL3N0eWxlJykuZGVmYXVsdCwgLy8gaGFuZGxlcyBzdHlsaW5nIG9uIGVsZW1lbnRzIHdpdGggc3VwcG9ydCBmb3IgYW5pbWF0aW9uc1xuXHRyZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2V2ZW50bGlzdGVuZXJzJykuZGVmYXVsdCAvLyBhdHRhY2hlcyBldmVudCBsaXN0ZW5lcnNcbl0pO1xuXG5jb25zdCBwYXRjaFN0cmVhbSA9IChzdHJlYW0sIGRvbSkgPT4ge1xuXHRkb20gPSAodHlwZW9mIGRvbSA9PT0gJ3N0cmluZycpID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihkb20pIDogZG9tO1xuXHRzdHJlYW0uc2Nhbihcblx0XHQodm5vZGUsIG5ld1Zub2RlKSA9PiBwYXRjaCh2bm9kZSwgbmV3Vm5vZGUpLFxuXHRcdGRvbVxuXHQpLnN1YnNjcmliZSgpO1xufTtcblxuY29uc3QgaHlwZXJIZWxwZXJzID0gaHRtbFRhZ3MucmVkdWNlKFxuXHQobywgdGFnKSA9PiB7XG5cdFx0b1t0YWddID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW0FycmF5LmZyb20oYXJndW1lbnRzKV1cblx0XHRcdFx0Lm1hcChhdHRycy5wcm9jZXNzKVxuXHRcdFx0XHQubWFwKGFyZ3MgPT4gKFxuXHRcdFx0XHRcdC8vIGlzIHRoZSBmaXJzdCBhcmd1bWVudCBhIHNlbGVjdG9yXG5cdFx0XHRcdFx0YXJnc1swXSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgJiYgYXJnc1swXS5tYXRjaCgvXihcXC58IylbYS16QS1aXFwtXzAtOV0rL2lnKSlcblx0XHRcdFx0XHRcdD8gW10uY29uY2F0KHRhZyArIGFyZ3NbMF0sIGFyZ3Muc2xpY2UoMSkpXG5cdFx0XHRcdFx0XHQ6IFt0YWddLmNvbmNhdChhcmdzKSlcblx0XHRcdFx0Lm1hcChhcmdzID0+IGguYXBwbHkodGhpcywgYXJncykpXG5cdFx0XHRcdC5wb3AoKTtcblx0XHR9O1xuXHRcdHJldHVybiBvO1xuXHR9LCB7fVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKFxuXHR7XG5cdFx0aCxcblx0XHRwYXRjaCxcblx0XHRwYXRjaFN0cmVhbVxuXHR9LFxuXHRoeXBlckhlbHBlcnNcbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2bm9kZV8xID0gcmVxdWlyZShcIi4vdm5vZGVcIik7XG52YXIgaXMgPSByZXF1aXJlKFwiLi9pc1wiKTtcbmZ1bmN0aW9uIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWwpIHtcbiAgICBkYXRhLm5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICBpZiAoc2VsICE9PSAnZm9yZWlnbk9iamVjdCcgJiYgY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGREYXRhID0gY2hpbGRyZW5baV0uZGF0YTtcbiAgICAgICAgICAgIGlmIChjaGlsZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFkZE5TKGNoaWxkRGF0YSwgY2hpbGRyZW5baV0uY2hpbGRyZW4sIGNoaWxkcmVuW2ldLnNlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoKHNlbCwgYiwgYykge1xuICAgIHZhciBkYXRhID0ge30sIGNoaWxkcmVuLCB0ZXh0LCBpO1xuICAgIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YSA9IGI7XG4gICAgICAgIGlmIChpcy5hcnJheShjKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShjKSkge1xuICAgICAgICAgICAgdGV4dCA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAmJiBjLnNlbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpcy5hcnJheShiKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShiKSkge1xuICAgICAgICAgICAgdGV4dCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiAmJiBiLnNlbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbYl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzLnByaW1pdGl2ZShjaGlsZHJlbltpXSkpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB2bm9kZV8xLnZub2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsWzBdID09PSAncycgJiYgc2VsWzFdID09PSAndicgJiYgc2VsWzJdID09PSAnZycgJiZcbiAgICAgICAgKHNlbC5sZW5ndGggPT09IDMgfHwgc2VsWzNdID09PSAnLicgfHwgc2VsWzNdID09PSAnIycpKSB7XG4gICAgICAgIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWwpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVfMS52bm9kZShzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCB1bmRlZmluZWQpO1xufVxuZXhwb3J0cy5oID0gaDtcbjtcbmV4cG9ydHMuZGVmYXVsdCA9IGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbn1cbmZ1bmN0aW9uIHRhZ05hbWUoZWxtKSB7XG4gICAgcmV0dXJuIGVsbS50YWdOYW1lO1xufVxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzVGV4dChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDM7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSA4O1xufVxuZXhwb3J0cy5odG1sRG9tQXBpID0ge1xuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gICAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBnZXRUZXh0Q29udGVudDogZ2V0VGV4dENvbnRlbnQsXG4gICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgaXNUZXh0OiBpc1RleHQsXG4gICAgaXNDb21tZW50OiBpc0NvbW1lbnQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5odG1sRG9tQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHRtbGRvbWFwaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gcHJpbWl0aXZlKHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMucHJpbWl0aXZlID0gcHJpbWl0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYm9vbGVhbkF0dHJzID0gW1wiYWxsb3dmdWxsc2NyZWVuXCIsIFwiYXN5bmNcIiwgXCJhdXRvZm9jdXNcIiwgXCJhdXRvcGxheVwiLCBcImNoZWNrZWRcIiwgXCJjb21wYWN0XCIsIFwiY29udHJvbHNcIiwgXCJkZWNsYXJlXCIsXG4gICAgXCJkZWZhdWx0XCIsIFwiZGVmYXVsdGNoZWNrZWRcIiwgXCJkZWZhdWx0bXV0ZWRcIiwgXCJkZWZhdWx0c2VsZWN0ZWRcIiwgXCJkZWZlclwiLCBcImRpc2FibGVkXCIsIFwiZHJhZ2dhYmxlXCIsXG4gICAgXCJlbmFibGVkXCIsIFwiZm9ybW5vdmFsaWRhdGVcIiwgXCJoaWRkZW5cIiwgXCJpbmRldGVybWluYXRlXCIsIFwiaW5lcnRcIiwgXCJpc21hcFwiLCBcIml0ZW1zY29wZVwiLCBcImxvb3BcIiwgXCJtdWx0aXBsZVwiLFxuICAgIFwibXV0ZWRcIiwgXCJub2hyZWZcIiwgXCJub3Jlc2l6ZVwiLCBcIm5vc2hhZGVcIiwgXCJub3ZhbGlkYXRlXCIsIFwibm93cmFwXCIsIFwib3BlblwiLCBcInBhdXNlb25leGl0XCIsIFwicmVhZG9ubHlcIixcbiAgICBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJzY29wZWRcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCIsIFwic29ydGFibGVcIiwgXCJzcGVsbGNoZWNrXCIsIFwidHJhbnNsYXRlXCIsXG4gICAgXCJ0cnVlc3BlZWRcIiwgXCJ0eXBlbXVzdG1hdGNoXCIsIFwidmlzaWJsZVwiXTtcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhtbE5TID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XG52YXIgY29sb25DaGFyID0gNTg7XG52YXIgeENoYXIgPSAxMjA7XG52YXIgYm9vbGVhbkF0dHJzRGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKHZhciBpID0gMCwgbGVuID0gYm9vbGVhbkF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYm9vbGVhbkF0dHJzRGljdFtib29sZWFuQXR0cnNbaV1dID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBrZXksIGVsbSA9IHZub2RlLmVsbSwgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzLCBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnM7XG4gICAgaWYgKCFvbGRBdHRycyAmJiAhYXR0cnMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkQXR0cnMgPT09IGF0dHJzKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkQXR0cnMgPSBvbGRBdHRycyB8fCB7fTtcbiAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgIC8vIHVwZGF0ZSBtb2RpZmllZCBhdHRyaWJ1dGVzLCBhZGQgbmV3IGF0dHJpYnV0ZXNcbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICB2YXIgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgICAgdmFyIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgICAgICAgaWYgKGJvb2xlYW5BdHRyc0RpY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuY2hhckNvZGVBdCgwKSAhPT0geENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5jaGFyQ29kZUF0KDMpID09PSBjb2xvbkNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHhtbCBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZU5TKHhtbE5TLCBrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5jaGFyQ29kZUF0KDUpID09PSBjb2xvbkNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHhsaW5rIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZW1vdmVkIGF0dHJpYnV0ZXNcbiAgICAvLyB1c2UgYGluYCBvcGVyYXRvciBzaW5jZSB0aGUgcHJldmlvdXMgYGZvcmAgaXRlcmF0aW9uIHVzZXMgaXQgKC5pLmUuIGFkZCBldmVuIGF0dHJpYnV0ZXMgd2l0aCB1bmRlZmluZWQgdmFsdWUpXG4gICAgLy8gdGhlIG90aGVyIG9wdGlvbiBpcyB0byByZW1vdmUgYWxsIGF0dHJpYnV0ZXMgd2l0aCB2YWx1ZSA9PSB1bmRlZmluZWRcbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmF0dHJpYnV0ZXNNb2R1bGUgPSB7IGNyZWF0ZTogdXBkYXRlQXR0cnMsIHVwZGF0ZTogdXBkYXRlQXR0cnMgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuYXR0cmlidXRlc01vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIG9sZENsYXNzID0gb2xkVm5vZGUuZGF0YS5jbGFzcywga2xhc3MgPSB2bm9kZS5kYXRhLmNsYXNzO1xuICAgIGlmICghb2xkQ2xhc3MgJiYgIWtsYXNzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZENsYXNzID09PSBrbGFzcylcbiAgICAgICAgcmV0dXJuO1xuICAgIG9sZENsYXNzID0gb2xkQ2xhc3MgfHwge307XG4gICAga2xhc3MgPSBrbGFzcyB8fCB7fTtcbiAgICBmb3IgKG5hbWUgaW4gb2xkQ2xhc3MpIHtcbiAgICAgICAgaWYgKCFrbGFzc1tuYW1lXSkge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIGtsYXNzKSB7XG4gICAgICAgIGN1ciA9IGtsYXNzW25hbWVdO1xuICAgICAgICBpZiAoY3VyICE9PSBvbGRDbGFzc1tuYW1lXSkge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdFtjdXIgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2xhc3NNb2R1bGUgPSB7IGNyZWF0ZTogdXBkYXRlQ2xhc3MsIHVwZGF0ZTogdXBkYXRlQ2xhc3MgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuY2xhc3NNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGludm9rZUhhbmRsZXIoaGFuZGxlciwgdm5vZGUsIGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiBoYW5kbGVyXG4gICAgICAgIGhhbmRsZXIuY2FsbCh2bm9kZSwgZXZlbnQsIHZub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gY2FsbCBoYW5kbGVyIHdpdGggYXJndW1lbnRzXG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlclswXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHNpbmdsZSBhcmd1bWVudCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJbMF0uY2FsbCh2bm9kZSwgaGFuZGxlclsxXSwgZXZlbnQsIHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaGFuZGxlci5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlclswXS5hcHBseSh2bm9kZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjYWxsIG11bHRpcGxlIGhhbmRsZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnZva2VIYW5kbGVyKGhhbmRsZXJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQsIHZub2RlKSB7XG4gICAgdmFyIG5hbWUgPSBldmVudC50eXBlLCBvbiA9IHZub2RlLmRhdGEub247XG4gICAgLy8gY2FsbCBldmVudCBoYW5kbGVyKHMpIGlmIGV4aXN0c1xuICAgIGlmIChvbiAmJiBvbltuYW1lXSkge1xuICAgICAgICBpbnZva2VIYW5kbGVyKG9uW25hbWVdLCB2bm9kZSwgZXZlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGhhbmRsZUV2ZW50KGV2ZW50LCBoYW5kbGVyLnZub2RlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlRXZlbnRMaXN0ZW5lcnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiwgb2xkTGlzdGVuZXIgPSBvbGRWbm9kZS5saXN0ZW5lciwgb2xkRWxtID0gb2xkVm5vZGUuZWxtLCBvbiA9IHZub2RlICYmIHZub2RlLmRhdGEub24sIGVsbSA9ICh2bm9kZSAmJiB2bm9kZS5lbG0pLCBuYW1lO1xuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgcmV1c2VkIGltbXV0YWJsZSBoYW5kbGVyc1xuICAgIGlmIChvbGRPbiA9PT0gb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgbGlzdGVuZXJzIHdoaWNoIG5vIGxvbmdlciB1c2VkXG4gICAgaWYgKG9sZE9uICYmIG9sZExpc3RlbmVyKSB7XG4gICAgICAgIC8vIGlmIGVsZW1lbnQgY2hhbmdlZCBvciBkZWxldGVkIHdlIHJlbW92ZSBhbGwgZXhpc3RpbmcgbGlzdGVuZXJzIHVuY29uZGl0aW9uYWxseVxuICAgICAgICBpZiAoIW9uKSB7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXIgaWYgZWxlbWVudCB3YXMgY2hhbmdlZCBvciBleGlzdGluZyBsaXN0ZW5lcnMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIG9sZEVsbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIG9sZExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXIgaWYgZXhpc3RpbmcgbGlzdGVuZXIgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgb2xkTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG5ldyBsaXN0ZW5lcnMgd2hpY2ggaGFzIG5vdCBhbHJlYWR5IGF0dGFjaGVkXG4gICAgaWYgKG9uKSB7XG4gICAgICAgIC8vIHJldXNlIGV4aXN0aW5nIGxpc3RlbmVyIG9yIGNyZWF0ZSBuZXdcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdm5vZGUubGlzdGVuZXIgPSBvbGRWbm9kZS5saXN0ZW5lciB8fCBjcmVhdGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyB1cGRhdGUgdm5vZGUgZm9yIGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyLnZub2RlID0gdm5vZGU7XG4gICAgICAgIC8vIGlmIGVsZW1lbnQgY2hhbmdlZCBvciBhZGRlZCB3ZSBhZGQgYWxsIG5lZWRlZCBsaXN0ZW5lcnMgdW5jb25kaXRpb25hbGx5XG4gICAgICAgIGlmICghb2xkT24pIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBsaXN0ZW5lciBpZiBlbGVtZW50IHdhcyBjaGFuZ2VkIG9yIG5ldyBsaXN0ZW5lcnMgYWRkZWRcbiAgICAgICAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGxpc3RlbmVyIGlmIG5ldyBsaXN0ZW5lciBhZGRlZFxuICAgICAgICAgICAgICAgIGlmICghb2xkT25bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV2ZW50TGlzdGVuZXJzTW9kdWxlID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnMsXG4gICAgdXBkYXRlOiB1cGRhdGVFdmVudExpc3RlbmVycyxcbiAgICBkZXN0cm95OiB1cGRhdGVFdmVudExpc3RlbmVyc1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZXZlbnRMaXN0ZW5lcnNNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudGxpc3RlbmVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5wcm9wcywgcHJvcHMgPSB2bm9kZS5kYXRhLnByb3BzO1xuICAgIGlmICghb2xkUHJvcHMgJiYgIXByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZFByb3BzID09PSBwcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIG9sZFByb3BzID0gb2xkUHJvcHMgfHwge307XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICBpZiAoIXByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbG1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgICAgICBvbGQgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICBpZiAob2xkICE9PSBjdXIgJiYgKGtleSAhPT0gJ3ZhbHVlJyB8fCBlbG1ba2V5XSAhPT0gY3VyKSkge1xuICAgICAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnByb3BzTW9kdWxlID0geyBjcmVhdGU6IHVwZGF0ZVByb3BzLCB1cGRhdGU6IHVwZGF0ZVByb3BzIH07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnByb3BzTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmFmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24gKGZuKSB7IHJhZihmdW5jdGlvbiAoKSB7IHJhZihmbik7IH0pOyB9O1xuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgb2xkU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0eWxlLCBzdHlsZSA9IHZub2RlLmRhdGEuc3R5bGU7XG4gICAgaWYgKCFvbGRTdHlsZSAmJiAhc3R5bGUpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkU3R5bGUgPT09IHN0eWxlKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkU3R5bGUgPSBvbGRTdHlsZSB8fCB7fTtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHZhciBvbGRIYXNEZWwgPSAnZGVsYXllZCcgaW4gb2xkU3R5bGU7XG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICAgIGlmICghc3R5bGVbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChuYW1lWzBdID09PSAnLScgJiYgbmFtZVsxXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGN1ciA9IHN0eWxlW25hbWVdO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2RlbGF5ZWQnICYmIHN0eWxlLmRlbGF5ZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUyIGluIHN0eWxlLmRlbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBzdHlsZS5kZWxheWVkW25hbWUyXTtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZEhhc0RlbCB8fCBjdXIgIT09IG9sZFN0eWxlLmRlbGF5ZWRbbmFtZTJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE5leHRGcmFtZShlbG0uc3R5bGUsIG5hbWUyLCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lICE9PSAncmVtb3ZlJyAmJiBjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAobmFtZVswXSA9PT0gJy0nICYmIG5hbWVbMV0gPT09ICctJykge1xuICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlEZXN0cm95U3R5bGUodm5vZGUpIHtcbiAgICB2YXIgc3R5bGUsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gICAgaWYgKCFzIHx8ICEoc3R5bGUgPSBzLmRlc3Ryb3kpKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGVsbS5zdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5UmVtb3ZlU3R5bGUodm5vZGUsIHJtKSB7XG4gICAgdmFyIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICAgIGlmICghcyB8fCAhcy5yZW1vdmUpIHtcbiAgICAgICAgcm0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBpID0gMCwgY29tcFN0eWxlLCBzdHlsZSA9IHMucmVtb3ZlLCBhbW91bnQgPSAwLCBhcHBsaWVkID0gW107XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGFwcGxpZWQucHVzaChuYW1lKTtcbiAgICAgICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgfVxuICAgIGNvbXBTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxtKTtcbiAgICB2YXIgcHJvcHMgPSBjb21wU3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS5zcGxpdCgnLCAnKTtcbiAgICBmb3IgKDsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhcHBsaWVkLmluZGV4T2YocHJvcHNbaV0pICE9PSAtMSlcbiAgICAgICAgICAgIGFtb3VudCsrO1xuICAgIH1cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXYudGFyZ2V0ID09PSBlbG0pXG4gICAgICAgICAgICAtLWFtb3VudDtcbiAgICAgICAgaWYgKGFtb3VudCA9PT0gMClcbiAgICAgICAgICAgIHJtKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnN0eWxlTW9kdWxlID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZSxcbiAgICBkZXN0cm95OiBhcHBseURlc3Ryb3lTdHlsZSxcbiAgICByZW1vdmU6IGFwcGx5UmVtb3ZlU3R5bGVcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnN0eWxlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdm5vZGVfMSA9IHJlcXVpcmUoXCIuL3Zub2RlXCIpO1xudmFyIGlzID0gcmVxdWlyZShcIi4vaXNcIik7XG52YXIgaHRtbGRvbWFwaV8xID0gcmVxdWlyZShcIi4vaHRtbGRvbWFwaVwiKTtcbmZ1bmN0aW9uIGlzVW5kZWYocykgeyByZXR1cm4gcyA9PT0gdW5kZWZpbmVkOyB9XG5mdW5jdGlvbiBpc0RlZihzKSB7IHJldHVybiBzICE9PSB1bmRlZmluZWQ7IH1cbnZhciBlbXB0eU5vZGUgPSB2bm9kZV8xLmRlZmF1bHQoJycsIHt9LCBbXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuZnVuY3Rpb24gc2FtZVZub2RlKHZub2RlMSwgdm5vZGUyKSB7XG4gICAgcmV0dXJuIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiYgdm5vZGUxLnNlbCA9PT0gdm5vZGUyLnNlbDtcbn1cbmZ1bmN0aW9uIGlzVm5vZGUodm5vZGUpIHtcbiAgICByZXR1cm4gdm5vZGUuc2VsICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICAgIHZhciBpLCBtYXAgPSB7fSwga2V5LCBjaDtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAgICBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAga2V5ID0gY2gua2V5O1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95JywgJ3ByZScsICdwb3N0J107XG52YXIgaF8xID0gcmVxdWlyZShcIi4vaFwiKTtcbmV4cG9ydHMuaCA9IGhfMS5oO1xudmFyIHRodW5rXzEgPSByZXF1aXJlKFwiLi90aHVua1wiKTtcbmV4cG9ydHMudGh1bmsgPSB0aHVua18xLnRodW5rO1xuZnVuY3Rpb24gaW5pdChtb2R1bGVzLCBkb21BcGkpIHtcbiAgICB2YXIgaSwgaiwgY2JzID0ge307XG4gICAgdmFyIGFwaSA9IGRvbUFwaSAhPT0gdW5kZWZpbmVkID8gZG9tQXBpIDogaHRtbGRvbWFwaV8xLmRlZmF1bHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBob29rID0gbW9kdWxlc1tqXVtob29rc1tpXV07XG4gICAgICAgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKGhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICB2YXIgaWQgPSBlbG0uaWQgPyAnIycgKyBlbG0uaWQgOiAnJztcbiAgICAgICAgdmFyIGMgPSBlbG0uY2xhc3NOYW1lID8gJy4nICsgZWxtLmNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICByZXR1cm4gdm5vZGVfMS5kZWZhdWx0KGFwaS50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSArIGlkICsgYywge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm1DYigpIHtcbiAgICAgICAgICAgIGlmICgtLWxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGFwaS5wYXJlbnROb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50XzEsIGNoaWxkRWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgdmFyIGksIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbiwgc2VsID0gdm5vZGUuc2VsO1xuICAgICAgICBpZiAoc2VsID09PSAnIScpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUudGV4dCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUuZWxtID0gYXBpLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHNlbGVjdG9yXG4gICAgICAgICAgICB2YXIgaGFzaElkeCA9IHNlbC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICB2YXIgZG90SWR4ID0gc2VsLmluZGV4T2YoJy4nLCBoYXNoSWR4KTtcbiAgICAgICAgICAgIHZhciBoYXNoID0gaGFzaElkeCA+IDAgPyBoYXNoSWR4IDogc2VsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkb3QgPSBkb3RJZHggPiAwID8gZG90SWR4IDogc2VsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0YWcgPSBoYXNoSWR4ICE9PSAtMSB8fCBkb3RJZHggIT09IC0xID8gc2VsLnNsaWNlKDAsIE1hdGgubWluKGhhc2gsIGRvdCkpIDogc2VsO1xuICAgICAgICAgICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLm5zKSA/IGFwaS5jcmVhdGVFbGVtZW50TlMoaSwgdGFnKVxuICAgICAgICAgICAgICAgIDogYXBpLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgICAgIGlmIChoYXNoIDwgZG90KVxuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsLnNsaWNlKGhhc2ggKyAxLCBkb3QpKTtcbiAgICAgICAgICAgIGlmIChkb3RJZHggPiAwKVxuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgc2VsLnNsaWNlKGRvdCArIDEpLnJlcGxhY2UoL1xcLi9nLCAnICcpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgICAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmFwcGVuZENoaWxkKGVsbSwgY3JlYXRlRWxtKGNoLCBpbnNlcnRlZFZub2RlUXVldWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaS5pbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGUuZWxtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0oY2gsIGluc2VydGVkVm5vZGVRdWV1ZSksIGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sodm5vZGUpIHtcbiAgICAgICAgdmFyIGksIGosIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgaSh2bm9kZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHZub2RlLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSBudWxsICYmIHR5cGVvZiBpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXMocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgdmFyIGlfMSA9IHZvaWQgMCwgbGlzdGVuZXJzID0gdm9pZCAwLCBybSA9IHZvaWQgMCwgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICAgICAgaWYgKGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2guc2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKGNoLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpXzEgPSAwOyBpXzEgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYnMucmVtb3ZlW2lfMV0oY2gsIHJtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKGlfMSA9IGNoLmRhdGEpICYmIGlzRGVmKGlfMSA9IGlfMS5ob29rKSAmJiBpc0RlZihpXzEgPSBpXzEucmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaV8xKGNoLCBybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50RWxtLCBjaC5lbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIHZhciBvbGRTdGFydElkeCA9IDAsIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgICAgICB2YXIgb2xkS2V5VG9JZHg7XG4gICAgICAgIHZhciBpZHhJbk9sZDtcbiAgICAgICAgdmFyIGVsbVRvTW92ZTtcbiAgICAgICAgdmFyIGJlZm9yZTtcbiAgICAgICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEtleVRvSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeEluT2xkID0gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLnNlbCAhPT0gbmV3U3RhcnRWbm9kZS5zZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIHZhciBpLCBob29rO1xuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEpICYmIGlzRGVmKGhvb2sgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBob29rLnByZXBhdGNoKSkge1xuICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHZub2RlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vaztcbiAgICAgICAgICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKVxuICAgICAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ2ggIT09IGNoKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGhvb2spICYmIGlzRGVmKGkgPSBob29rLnBvc3RwYXRjaCkpIHtcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2gob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIHZhciBpLCBlbG0sIHBhcmVudDtcbiAgICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnByZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGNicy5wcmVbaV0oKTtcbiAgICAgICAgaWYgKCFpc1Zub2RlKG9sZFZub2RlKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgICAgIHBhcmVudCA9IGFwaS5wYXJlbnROb2RlKGVsbSk7XG4gICAgICAgICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnQsIHZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKGVsbSkpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnQsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnNlcnRlZFZub2RlUXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KGluc2VydGVkVm5vZGVRdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5wb3N0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY2JzLnBvc3RbaV0oKTtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH07XG59XG5leHBvcnRzLmluaXQgPSBpbml0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25hYmJkb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaF8xID0gcmVxdWlyZShcIi4vaFwiKTtcbmZ1bmN0aW9uIGNvcHlUb1RodW5rKHZub2RlLCB0aHVuaykge1xuICAgIHRodW5rLmVsbSA9IHZub2RlLmVsbTtcbiAgICB2bm9kZS5kYXRhLmZuID0gdGh1bmsuZGF0YS5mbjtcbiAgICB2bm9kZS5kYXRhLmFyZ3MgPSB0aHVuay5kYXRhLmFyZ3M7XG4gICAgdGh1bmsuZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdGh1bmsuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB0aHVuay50ZXh0ID0gdm5vZGUudGV4dDtcbiAgICB0aHVuay5lbG0gPSB2bm9kZS5lbG07XG59XG5mdW5jdGlvbiBpbml0KHRodW5rKSB7XG4gICAgdmFyIGN1ciA9IHRodW5rLmRhdGE7XG4gICAgdmFyIHZub2RlID0gY3VyLmZuLmFwcGx5KHVuZGVmaW5lZCwgY3VyLmFyZ3MpO1xuICAgIGNvcHlUb1RodW5rKHZub2RlLCB0aHVuayk7XG59XG5mdW5jdGlvbiBwcmVwYXRjaChvbGRWbm9kZSwgdGh1bmspIHtcbiAgICB2YXIgaSwgb2xkID0gb2xkVm5vZGUuZGF0YSwgY3VyID0gdGh1bmsuZGF0YTtcbiAgICB2YXIgb2xkQXJncyA9IG9sZC5hcmdzLCBhcmdzID0gY3VyLmFyZ3M7XG4gICAgaWYgKG9sZC5mbiAhPT0gY3VyLmZuIHx8IG9sZEFyZ3MubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICBjb3B5VG9UaHVuayhjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSwgdGh1bmspO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChvbGRBcmdzW2ldICE9PSBhcmdzW2ldKSB7XG4gICAgICAgICAgICBjb3B5VG9UaHVuayhjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSwgdGh1bmspO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHlUb1RodW5rKG9sZFZub2RlLCB0aHVuayk7XG59XG5leHBvcnRzLnRodW5rID0gZnVuY3Rpb24gdGh1bmsoc2VsLCBrZXksIGZuLCBhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmdzID0gZm47XG4gICAgICAgIGZuID0ga2V5O1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBoXzEuaChzZWwsIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGhvb2s6IHsgaW5pdDogaW5pdCwgcHJlcGF0Y2g6IHByZXBhdGNoIH0sXG4gICAgICAgIGZuOiBmbixcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMudGh1bms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHVuay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHZub2RlKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIGVsbSkge1xuICAgIHZhciBrZXkgPSBkYXRhID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBkYXRhLmtleTtcbiAgICByZXR1cm4geyBzZWw6IHNlbCwgZGF0YTogZGF0YSwgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICB0ZXh0OiB0ZXh0LCBlbG06IGVsbSwga2V5OiBrZXkgfTtcbn1cbmV4cG9ydHMudm5vZGUgPSB2bm9kZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZub2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dm5vZGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IHN0clBhcnNlID0gcyA9PlxuXHRzLm1hdGNoKC9eWzAtOV0rJC8pID8gcGFyc2VJbnQocywgMTApXG5cdDogcy5tYXRjaCgvXlswLTkuXSskLykgPyBwYXJzZUZsb2F0KHMpXG5cdDogcyA9PT0gJ3RydWUnID8gdHJ1ZVxuXHQ6IHMgPT09ICdmYWxzZScgPyBmYWxzZVxuXHQ6IHM7XG5cbmNvbnN0IHByb2Nlc3MgPSBhcmdzID0+IHtcblx0bGV0IG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG5cblx0bGV0IHNlbGVjdG9yID0gbmV3QXJnc1swXSAmJiB0eXBlb2YgbmV3QXJnc1swXSA9PT0gJ3N0cmluZycgJiYgbmV3QXJnc1swXSB8fCAnJztcblx0aWYgKHNlbGVjdG9yICE9PSAnJykgbmV3QXJncyA9IG5ld0FyZ3Muc2xpY2UoMSk7XG5cblx0Y29uc3QgYXR0clJlZ0V4cCA9IC9cXFtbYS16XFwtMC05XSs9KFwiW15cIl0rXCJ8J1teJ10rJ3xbMC05Ll0rfHRydWV8ZmFsc2V8W15cXF1ePV5cIl4nXSspXFxdL2lnO1xuXG5cdGxldCBhdHRycyA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLm1hdGNoKGF0dHJSZWdFeHApO1xuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoYXR0clJlZ0V4cCwgJycpO1xuXG5cdGF0dHJzID0gYXR0cnMgJiYgYXR0cnMubWFwICYmIGF0dHJzXG5cdFx0Lm1hcChjID0+IGMucmVwbGFjZSgvW1tcXF0oXCJ8JyldL2csICcnKS5zcGxpdCgnPScpKVxuXHRcdC5yZWR1Y2UoKG8sIGF0dHIpID0+IG9iai5wYXRjaChvLCBhdHRyWzBdLCBzdHJQYXJzZShhdHRyWzFdKSksIHt9KSB8fCB7fTtcblxuXHRpZiAoYXR0cnMgJiYgT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCA+IDApIHtcblx0XHRpZiAoIW5ld0FyZ3NbMF0gfHwgbmV3QXJnc1swXVxuXHRcdFx0JiYgdHlwZW9mIG5ld0FyZ3NbMF0gPT09ICdvYmplY3QnICYmICEobmV3QXJnc1swXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0YXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdBcmdzWzBdICYmIG5ld0FyZ3NbMF0uYXR0cnMgfHwge30sIGF0dHJzKTtcblx0XHRcdG5ld0FyZ3NbMF0gPSBPYmplY3QuYXNzaWduKHt9LCBuZXdBcmdzWzBdIHx8IHt9LCB7YXR0cnN9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3QXJncyA9IFt7YXR0cnN9XS5jb25jYXQobmV3QXJncyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNlbGVjdG9yICE9PSAnJykgbmV3QXJncyA9IFtzZWxlY3Rvcl0uY29uY2F0KG5ld0FyZ3MpO1xuXG5cdC8vIGNvbnNvbGUubG9nKGFyZ3MsIG5ld0FyZ3MpO1xuXHRyZXR1cm4gbmV3QXJncztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdHJQYXJzZSxcblx0cHJvY2Vzc1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBNdXRhdGlvbiA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG52YXIgc2NoZWR1bGVEcmFpbjtcblxue1xuICBpZiAoTXV0YXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb24obmV4dFRpY2spO1xuICAgIHZhciBlbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5kYXRhID0gKGNhbGxlZCA9ICsrY2FsbGVkICUgMik7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2xvYmFsLnNldEltbWVkaWF0ZSAmJiB0eXBlb2YgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbmV4dFRpY2s7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgnZG9jdW1lbnQnIGluIGdsb2JhbCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0RWwgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKCk7XG5cbiAgICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgIHNjcmlwdEVsID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBkcmFpbmluZztcbnZhciBxdWV1ZSA9IFtdO1xuLy9uYW1lZCBuZXh0VGljayBmb3IgbGVzcyBjb25mdXNpbmcgc3RhY2sgdHJhY2VzXG5mdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgZHJhaW5pbmcgPSB0cnVlO1xuICB2YXIgaSwgb2xkUXVldWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChsZW4pIHtcbiAgICBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG4gICAgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIG9sZFF1ZXVlW2ldKCk7XG4gICAgfVxuICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgfVxuICBkcmFpbmluZyA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGltbWVkaWF0ZTtcbmZ1bmN0aW9uIGltbWVkaWF0ZSh0YXNrKSB7XG4gIGlmIChxdWV1ZS5wdXNoKHRhc2spID09PSAxICYmICFkcmFpbmluZykge1xuICAgIHNjaGVkdWxlRHJhaW4oKTtcbiAgfVxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vIHByaXZhdGUgcHJvcGVydHlcbnZhciBfa2V5U3RyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuXG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGVuY29kaW5nXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoLCByZW1haW5pbmdCeXRlcyA9IGxlbjtcblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmdCeXRlcyA9IGxlbiAtIGk7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgY2hyMiA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dFtpKytdIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICBlbmMzID0gcmVtYWluaW5nQnl0ZXMgPiAxID8gKCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKSA6IDY0O1xuICAgICAgICBlbmM0ID0gcmVtYWluaW5nQnl0ZXMgPiAyID8gKGNocjMgJiA2MykgOiA2NDtcblxuICAgICAgICBvdXRwdXQucHVzaChfa2V5U3RyLmNoYXJBdChlbmMxKSArIF9rZXlTdHIuY2hhckF0KGVuYzIpICsgX2tleVN0ci5jaGFyQXQoZW5jMykgKyBfa2V5U3RyLmNoYXJBdChlbmM0KSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG4vLyBwdWJsaWMgbWV0aG9kIGZvciBkZWNvZGluZ1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgdmFyIGRhdGFVcmxQcmVmaXggPSBcImRhdGE6XCI7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIGRhdGFVcmxQcmVmaXgubGVuZ3RoKSA9PT0gZGF0YVVybFByZWZpeCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgY29tbW9uIGVycm9yOiBwZW9wbGUgZ2l2ZSBhIGRhdGEgdXJsXG4gICAgICAgIC8vIChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1IuLi4pIHdpdGggYSB7YmFzZTY0OiB0cnVlfSBhbmRcbiAgICAgICAgLy8gd29uZGVycyB3aHkgdGhpbmdzIGRvbid0IHdvcmsuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgc3RyaW5nIGlucHV0IGxvb2tzIGxpa2UgYSBkYXRhIHVybCBidXQgd2VcbiAgICAgICAgLy8gKmNhbid0KiBiZSBzdXJlIGl0IGlzIG9uZTogcmVtb3ZpbmcgZXZlcnl0aGluZyB1cCB0byB0aGUgY29tbWEgd291bGRcbiAgICAgICAgLy8gYmUgdG9vIGRhbmdlcm91cy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGl0IGxvb2tzIGxpa2UgYSBkYXRhIHVybC5cIik7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG5cbiAgICB2YXIgdG90YWxMZW5ndGggPSBpbnB1dC5sZW5ndGggKiAzIC8gNDtcbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMikgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZiAodG90YWxMZW5ndGggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIHRvdGFsTGVuZ3RoIGlzIG5vdCBhbiBpbnRlZ2VyLCB0aGUgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGEgdmFsaWRcbiAgICAgICAgLy8gYmFzZTY0IGNvbnRlbnQuIFRoYXQgY2FuIGhhcHBlbiBpZjpcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgbm90IGEgYmFzZTY0IGNvbnRlbnRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgKmFsbW9zdCogYSBiYXNlNjQgY29udGVudCwgd2l0aCBhIGV4dHJhIGNoYXJzIGF0IHRoZVxuICAgICAgICAvLyAgIGJlZ2lubmluZyBvciBhdCB0aGUgZW5kXG4gICAgICAgIC8vIC0gdGhlIGlucHV0IHVzZXMgYSBiYXNlNjQgdmFyaWFudCAoYmFzZTY0dXJsIGZvciBleGFtcGxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgYmFkIGNvbnRlbnQgbGVuZ3RoLlwiKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheSh0b3RhbExlbmd0aHwwKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGVuYzEgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciBEYXRhTGVuZ3RoUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbXByZXNzZWQgb2JqZWN0LCB3aXRoIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGRlY29tcHJlc3MgaXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjcmMzMiB0aGUgY3JjMzIgb2YgdGhlIGRlY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXByZXNzaW9uIHRoZSB0eXBlIG9mIGNvbXByZXNzaW9uLCBzZWUgbGliL2NvbXByZXNzaW9ucy5qcy5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIENvbXByZXNzZWRPYmplY3QoY29tcHJlc3NlZFNpemUsIHVuY29tcHJlc3NlZFNpemUsIGNyYzMyLCBjb21wcmVzc2lvbiwgZGF0YSkge1xuICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBjb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSB1bmNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMuY3JjMzIgPSBjcmMzMjtcbiAgICB0aGlzLmNvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGRhdGE7XG59XG5cbkNvbXByZXNzZWRPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIHVuY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29udGVudFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLnBpcGUodGhpcy5jb21wcmVzc2lvbi51bmNvbXByZXNzV29ya2VyKCkpXG4gICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJkYXRhX2xlbmd0aFwiKSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB3b3JrZXIub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5zdHJlYW1JbmZvWydkYXRhX2xlbmd0aCddICE9PSB0aGF0LnVuY29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIGNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbXByZXNzZWRXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzZWRTaXplXCIsIHRoaXMuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcInVuY29tcHJlc3NlZFNpemVcIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCB0aGlzLmNyYzMyKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCB0aGlzLmNvbXByZXNzaW9uKVxuICAgICAgICA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGFpbiB0aGUgZ2l2ZW4gd29ya2VyIHdpdGggb3RoZXIgd29ya2VycyB0byBjb21wcmVzcyB0aGUgY29udGVudCB3aXRoIHRoZVxuICogZ2l2ZW4gY29tcHJlc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKCcuL2ZsYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4uL3V0ZjgnKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbnMgYWJvdXQgdGhlIGNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtZWRDb250ZW50IGlzIHRoZSBjb250ZW50IHN0cmVhbWVkID9cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtaW5nRW5kZWQgaXMgdGhlIHN0cmVhbSBmaW5pc2hlZCA/XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gbGV0J3MgcHJldGVuZCB3ZSBhcmUgdGhpcyBwbGF0Zm9ybSAoY2hhbmdlIHBsYXRmb3JtIGRlcGVuZGVudHMgZmllbGRzKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgZmlsZSBuYW1lIC8gY29tbWVudC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHppcCBwYXJ0cy5cbiAqL1xudmFyIGdlbmVyYXRlWmlwUGFydHMgPSBmdW5jdGlvbihzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHN0cmVhbWluZ0VuZGVkLCBvZmZzZXQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBmaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLFxuICAgIGNvbXByZXNzaW9uID0gc3RyZWFtSW5mb1snY29tcHJlc3Npb24nXSxcbiAgICB1c2VDdXN0b21FbmNvZGluZyA9IGVuY29kZUZpbGVOYW1lICE9PSB1dGY4LnV0ZjhlbmNvZGUsXG4gICAgZW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoZmlsZS5uYW1lKSksXG4gICAgdXRmRW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGZpbGUubmFtZSkpLFxuICAgIGNvbW1lbnQgPSBmaWxlLmNvbW1lbnQsXG4gICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgdXRmRW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoY29tbWVudCkpLFxuICAgIHVzZVVURjhGb3JGaWxlTmFtZSA9IHV0ZkVuY29kZWRGaWxlTmFtZS5sZW5ndGggIT09IGZpbGUubmFtZS5sZW5ndGgsXG4gICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgIGRvc1RpbWUsXG4gICAgZG9zRGF0ZSxcbiAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID0gXCJcIixcbiAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIGRpciA9IGZpbGUuZGlyLFxuICAgIGRhdGUgPSBmaWxlLmRhdGU7XG5cblxuICAgIHZhciBkYXRhSW5mbyA9IHtcbiAgICAgICAgY3JjMzIgOiAwLFxuICAgICAgICBjb21wcmVzc2VkU2l6ZSA6IDAsXG4gICAgICAgIHVuY29tcHJlc3NlZFNpemUgOiAwXG4gICAgfTtcblxuICAgIC8vIGlmIHRoZSBjb250ZW50IGlzIHN0cmVhbWVkLCB0aGUgc2l6ZXMvY3JjMzIgYXJlIG9ubHkgYXZhaWxhYmxlIEFGVEVSXG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgIGlmICghc3RyZWFtZWRDb250ZW50IHx8IHN0cmVhbWluZ0VuZGVkKSB7XG4gICAgICAgIGRhdGFJbmZvLmNyYzMyID0gc3RyZWFtSW5mb1snY3JjMzInXTtcbiAgICAgICAgZGF0YUluZm8uY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddO1xuICAgICAgICBkYXRhSW5mby51bmNvbXByZXNzZWRTaXplID0gc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddO1xuICAgIH1cblxuICAgIHZhciBiaXRmbGFnID0gMDtcbiAgICBpZiAoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIEJpdCAzOiB0aGUgc2l6ZXMvY3JjMzIgYXJlIHNldCB0byB6ZXJvIGluIHRoZSBsb2NhbCBoZWFkZXIuXG4gICAgICAgIC8vIFRoZSBjb3JyZWN0IHZhbHVlcyBhcmUgcHV0IGluIHRoZSBkYXRhIGRlc2NyaXB0b3IgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gZm9sbG93aW5nIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwMDA4O1xuICAgIH1cbiAgICBpZiAoIXVzZUN1c3RvbUVuY29kaW5nICYmICh1c2VVVEY4Rm9yRmlsZU5hbWUgfHwgdXNlVVRGOEZvckNvbW1lbnQpKSB7XG4gICAgICAgIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDA4MDA7XG4gICAgfVxuXG5cbiAgICB2YXIgZXh0RmlsZUF0dHIgPSAwO1xuICAgIHZhciB2ZXJzaW9uTWFkZUJ5ID0gMDtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIC8vIGRvcyBvciB1bml4LCB3ZSBzZXQgdGhlIGRvcyBkaXIgZmxhZ1xuICAgICAgICBleHRGaWxlQXR0ciB8PSAweDAwMDEwO1xuICAgIH1cbiAgICBpZihwbGF0Zm9ybSA9PT0gXCJVTklYXCIpIHtcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDMxRTsgLy8gVU5JWCwgdmVyc2lvbiAzLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0cihmaWxlLnVuaXhQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9IGVsc2UgeyAvLyBET1Mgb3Igb3RoZXIsIGZhbGxiYWNrIHRvIERPU1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMDE0OyAvLyBET1MsIHZlcnNpb24gMi4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0cihmaWxlLmRvc1Blcm1pc3Npb25zLCBkaXIpO1xuICAgIH1cblxuICAgIC8vIGRhdGVcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNTIvMTMuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82NS8xNi5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY2LzE2Lmh0bWxcblxuICAgIGRvc1RpbWUgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNjtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDU7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ1NlY29uZHMoKSAvIDI7XG5cbiAgICBkb3NEYXRlID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA0O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDU7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCBkYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgIGlmICh1c2VVVEY4Rm9yRmlsZU5hbWUpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuIHVuemlwIG5lZWRzIGF0IGxlYXN0IG9uZSBleHRyYVxuICAgICAgICAvLyBmaWVsZCB0byBjb3JyZWN0bHkgaGFuZGxlIHVuaWNvZGUgcGF0aCwgc28gdXNpbmcgdGhlIHBhdGggaXMgYXMgZ29vZFxuICAgICAgICAvLyBhcyBhbnkgb3RoZXIgaW5mb3JtYXRpb24uIFRoaXMgY291bGQgaW1wcm92ZSB0aGUgc2l0dWF0aW9uIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgYXJjaGl2ZSBtYW5hZ2VycyB0b28uXG4gICAgICAgIC8vIFRoaXMgZmllbGQgaXMgdXN1YWxseSB1c2VkIHdpdGhvdXQgdGhlIHV0ZjggZmxhZywgd2l0aCBhIG5vblxuICAgICAgICAvLyB1bmljb2RlIHBhdGggaW4gdGhlIGhlYWRlciAod2lucmFyLCB3aW56aXApLiBUaGlzIGhlbHBzIChhIGJpdClcbiAgICAgICAgLy8gd2l0aCB0aGUgbWVzc3kgV2luZG93cycgZGVmYXVsdCBjb21wcmVzc2VkIGZvbGRlcnMgZmVhdHVyZSBidXRcbiAgICAgICAgLy8gYnJlYWtzIG9uIHA3emlwIHdoaWNoIGRvZXNuJ3Qgc2VlayB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLlxuICAgICAgICAvLyBTbyBmb3Igbm93LCBVVEYtOCBldmVyeXdoZXJlICFcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZEZpbGVOYW1lKSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZTtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NzBcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlUGF0aEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgaWYodXNlVVRGOEZvckNvbW1lbnQpIHtcblxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gQ29tbWVudENSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkQ29tbWVudCksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkQ29tbWVudDtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NjNcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlQ29tbWVudEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IFwiXCI7XG5cbiAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgaGVhZGVyICs9IFwiXFx4MEFcXHgwMFwiO1xuICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIGhlYWRlciArPSBkZWNUb0hleChiaXRmbGFnLCAyKTtcbiAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBoZWFkZXIgKz0gY29tcHJlc3Npb24ubWFnaWM7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSB0aW1lXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc1RpbWUsIDIpO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NEYXRlLCAyKTtcbiAgICAvLyBjcmMtMzJcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY3JjMzIsIDQpO1xuICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8udW5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChlbmNvZGVkRmlsZU5hbWUubGVuZ3RoLCAyKTtcbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZXh0cmFGaWVsZHMubGVuZ3RoLCAyKTtcblxuXG4gICAgdmFyIGZpbGVSZWNvcmQgPSBzaWduYXR1cmUuTE9DQUxfRklMRV9IRUFERVIgKyBoZWFkZXIgKyBlbmNvZGVkRmlsZU5hbWUgKyBleHRyYUZpZWxkcztcblxuICAgIHZhciBkaXJSZWNvcmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9GSUxFX0hFQURFUiArXG4gICAgICAgIC8vIHZlcnNpb24gbWFkZSBieSAoMDA6IERPUylcbiAgICAgICAgZGVjVG9IZXgodmVyc2lvbk1hZGVCeSwgMikgK1xuICAgICAgICAvLyBmaWxlIGhlYWRlciAoY29tbW9uIHRvIGZpbGUgYW5kIGNlbnRyYWwgZGlyZWN0b3J5KVxuICAgICAgICBoZWFkZXIgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyBkaXNrIG51bWJlciBzdGFydFxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyBUT0RPXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgIGRlY1RvSGV4KGV4dEZpbGVBdHRyLCA0KSArXG4gICAgICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXJcbiAgICAgICAgZGVjVG9IZXgob2Zmc2V0LCA0KSArXG4gICAgICAgIC8vIGZpbGUgbmFtZVxuICAgICAgICBlbmNvZGVkRmlsZU5hbWUgK1xuICAgICAgICAvLyBleHRyYSBmaWVsZFxuICAgICAgICBleHRyYUZpZWxkcyArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVSZWNvcmQ6IGZpbGVSZWNvcmQsXG4gICAgICAgIGRpclJlY29yZDogZGlyUmVjb3JkXG4gICAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIEVPQ0QgcmVjb3JkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVudHJpZXNDb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRyYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBjZW50cmFsIGRpci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGxvY2FsIGRpci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSB6aXAgZmlsZSBjb21tZW50IGFzIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgdGhlIGNvbW1lbnQuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBFT0NEIHJlY29yZC5cbiAqL1xudmFyIGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCA9IGZ1bmN0aW9uIChlbnRyaWVzQ291bnQsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCBjb21tZW50LCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBkaXJFbmQgPSBcIlwiO1xuICAgIHZhciBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKTtcblxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmVcbiAgICBkaXJFbmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoaXMgZGlza1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrXG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChjZW50cmFsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyXG4gICAgICAgIGRlY1RvSGV4KGxvY2FsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4gZGlyRW5kO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkYXRhIGRlc2NyaXB0b3JzIGZvciBhIGZpbGUgZW50cnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCBnZW5lcmF0ZWQgYnkgYSB3b3JrZXIsIGNvbnRhaW5pbmcgaW5mb3JtYXRpb25zXG4gKiBvbiB0aGUgZmlsZSBlbnRyeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRhdGEgZGVzY3JpcHRvcnMuXG4gKi9cbnZhciBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgIGRlc2NyaXB0b3IgPSBzaWduYXR1cmUuREFUQV9ERVNDUklQVE9SICtcbiAgICAgICAgLy8gY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ2NyYzMyJ10sIDQpICtcbiAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ10sIDQpICtcbiAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ3VuY29tcHJlc3NlZFNpemUnXSwgNCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuLyoqXG4gKiBBIHdvcmtlciB0byBjb25jYXRlbmF0ZSBvdGhlciB3b3JrZXJzIHRvIGNyZWF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1GaWxlcyBgdHJ1ZWAgdG8gc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyxcbiAqIGBmYWxzZWAgdG8gYWNjdW11bGF0ZSBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSB0aGUgcGxhdGZvcm0gdG8gdXNlLCBcIlVOSVhcIiBvciBcIkRPU1wiLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAqL1xuZnVuY3Rpb24gWmlwRmlsZVdvcmtlcihzdHJlYW1GaWxlcywgY29tbWVudCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiWmlwRmlsZVdvcmtlclwiKTtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gc28gZmFyLiBUaGlzIGRvZXNuJ3QgY291bnQgYWNjdW11bGF0ZWQgY2h1bmtzLlxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICAvLyBUaGUgY29tbWVudCBvZiB0aGUgemlwIGZpbGVcbiAgICB0aGlzLnppcENvbW1lbnQgPSBjb21tZW50O1xuICAgIC8vIFRoZSBwbGF0Zm9ybSBcImdlbmVyYXRpbmdcIiB0aGUgemlwIGZpbGUuXG4gICAgdGhpcy56aXBQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gICAgdGhpcy5lbmNvZGVGaWxlTmFtZSA9IGVuY29kZUZpbGVOYW1lO1xuICAgIC8vIFNob3VsZCB3ZSBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzID9cbiAgICB0aGlzLnN0cmVhbUZpbGVzID0gc3RyZWFtRmlsZXM7XG4gICAgLy8gSWYgYHN0cmVhbUZpbGVzYCBpcyBmYWxzZSwgd2Ugd2lsbCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgLy8gZmlsZXMgdG8gY2FsY3VsYXRlIHNpemVzIC8gY3JjMzIgKGFuZCB3cml0ZSB0aGVtICpiZWZvcmUqIHRoZSBjb250ZW50KS5cbiAgICAvLyBUaGlzIGJvb2xlYW4gaW5kaWNhdGVzIGlmIHdlIGFyZSBhY2N1bXVsYXRpbmcgY2h1bmtzIChpdCB3aWxsIGNoYW5nZSBhIGxvdFxuICAgIC8vIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyB3b3JrZXIpLlxuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlO1xuICAgIC8vIFRoZSBidWZmZXIgcmVjZWl2aW5nIGNodW5rcyB3aGVuIGFjY3VtdWxhdGluZyBjb250ZW50LlxuICAgIHRoaXMuY29udGVudEJ1ZmZlciA9IFtdO1xuICAgIC8vIFRoZSBsaXN0IG9mIGdlbmVyYXRlZCBkaXJlY3RvcnkgcmVjb3Jkcy5cbiAgICB0aGlzLmRpclJlY29yZHMgPSBbXTtcbiAgICAvLyBUaGUgb2Zmc2V0IChpbiBieXRlcykgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB6aXAgZmlsZSBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IDA7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgemlwIGZpbGUuXG4gICAgdGhpcy5lbnRyaWVzQ291bnQgPSAwO1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGN1cnJlbnRseSBiZWluZyBhZGRlZCwgbnVsbCB3aGVuIGhhbmRsaW5nIHRoZSBlbmQgb2YgdGhlIHppcCBmaWxlLlxuICAgIC8vIFVzZWQgZm9yIHRoZSBlbWl0ZWQgbWV0YWRhdGEuXG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG5cblxuXG4gICAgdGhpcy5fc291cmNlcyA9IFtdO1xufVxudXRpbHMuaW5oZXJpdHMoWmlwRmlsZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnB1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGN1cnJlbnRGaWxlUGVyY2VudCA9IGNodW5rLm1ldGEucGVyY2VudCB8fCAwO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSB0aGlzLmVudHJpZXNDb3VudDtcbiAgICB2YXIgcmVtYWluaW5nRmlsZXMgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcblxuICAgIGlmKHRoaXMuYWNjdW11bGF0ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRCdWZmZXIucHVzaChjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gY2h1bmsuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGRhdGEgOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZSA6IHRoaXMuY3VycmVudEZpbGUsXG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IGVudHJpZXNDb3VudCA/IChjdXJyZW50RmlsZVBlcmNlbnQgKyAxMDAgKiAoZW50cmllc0NvdW50IC0gcmVtYWluaW5nRmlsZXMgLSAxKSkgLyBlbnRyaWVzQ291bnQgOiAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIHN0YXJ0ZWQgYSBuZXcgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIG5ldyBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IHN0cmVhbUluZm9bJ2ZpbGUnXS5uYW1lO1xuXG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG5cbiAgICAvLyBkb24ndCBzdHJlYW0gZm9sZGVycyAoYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgYW55IGNvbnRlbnQpXG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgZmFsc2UsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgd2hvbGUgZmlsZSBiZWZvcmUgcHVzaGluZyBhbnl0aGluZ1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBmaW5pc2hlZCBhIHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBmaW5pc2hlZCBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmNsb3NlZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG4gICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCB0cnVlLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsIHRoaXMuemlwUGxhdGZvcm0sIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5kaXJSZWNvcmRzLnB1c2gocmVjb3JkLmRpclJlY29yZCk7XG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIGFmdGVyIHRoZSBzdHJlYW1lZCBmaWxlLCB3ZSBwdXQgZGF0YSBkZXNjcmlwdG9yc1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzKHN0cmVhbUluZm8pLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgd2Fzbid0IHN0cmVhbWVkLCB3ZSBuZWVkIHRvIHB1c2ggZXZlcnl0aGluZyBub3dcbiAgICAgICAgLy8gZmlyc3QgdGhlIGZpbGUgcmVjb3JkLCB0aGVuIHRoZSBjb250ZW50XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmNvbnRlbnRCdWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsb2NhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRpclJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiB0aGlzLmRpclJlY29yZHNbaV0sXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNlbnRyYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbiAtIGxvY2FsRGlyTGVuZ3RoO1xuXG4gICAgdmFyIGRpckVuZCA9IGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCh0aGlzLmRpclJlY29yZHMubGVuZ3RoLCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgdGhpcy56aXBDb21tZW50LCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBkaXJFbmQsXG4gICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIG5leHQgc291cmNlIHRvIGJlIHJlYWQuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLl9zb3VyY2VzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuZWRTb3VyY2UodGhpcy5wcmV2aW91cy5zdHJlYW1JbmZvKTtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5yZXN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZWdpc3RlclByZXZpb3VzXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXMgPSBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICB0aGlzLl9zb3VyY2VzLnB1c2gocHJldmlvdXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNsb3NlZFNvdXJjZShzZWxmLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgICAgICBpZihzZWxmLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmIHRoaXMuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiAhdGhpcy5fc291cmNlcy5sZW5ndGggJiYgIXRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZXJyb3JcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb3VyY2VzW2ldLmVycm9yKGUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBgZXJyb3JgIGV4cGxvZGVkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5sb2NrXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUubG9jay5jYWxsKHRoaXMpO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VzW2ldLmxvY2soKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcEZpbGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKCcuLi9jb21wcmVzc2lvbnMnKTtcbnZhciBaaXBGaWxlV29ya2VyID0gcmVxdWlyZSgnLi9aaXBGaWxlV29ya2VyJyk7XG5cbi8qKlxuICogRmluZCB0aGUgY29tcHJlc3Npb24gdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgZmlsZSBsZXZlbCwgaWYgYW55LlxuICogQHBhcmFtIHtTdHJpbmd9IHppcENvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBsb2FkKCkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICovXG52YXIgZ2V0Q29tcHJlc3Npb24gPSBmdW5jdGlvbiAoZmlsZUNvbXByZXNzaW9uLCB6aXBDb21wcmVzc2lvbikge1xuXG4gICAgdmFyIGNvbXByZXNzaW9uTmFtZSA9IGZpbGVDb21wcmVzc2lvbiB8fCB6aXBDb21wcmVzc2lvbjtcbiAgICB2YXIgY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbnNbY29tcHJlc3Npb25OYW1lXTtcbiAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wcmVzc2lvbk5hbWUgKyBcIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2VuZXJhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7SlNaaXB9IHppcCB0aGUgSlNaaXAgaW5zdGFuY2UgYXQgdGhlIHJpZ2h0IHJvb3QgbGV2ZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXb3JrZXIgPSBmdW5jdGlvbiAoemlwLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICB2YXIgemlwRmlsZVdvcmtlciA9IG5ldyBaaXBGaWxlV29ya2VyKG9wdGlvbnMuc3RyZWFtRmlsZXMsIGNvbW1lbnQsIG9wdGlvbnMucGxhdGZvcm0sIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUpO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSAwO1xuICAgIHRyeSB7XG5cbiAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgZW50cmllc0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbihmaWxlLm9wdGlvbnMuY29tcHJlc3Npb24sIG9wdGlvbnMuY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uT3B0aW9ucyA9IGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwgb3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZGlyID0gZmlsZS5kaXIsIGRhdGUgPSBmaWxlLmRhdGU7XG5cbiAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJmaWxlXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lIDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgIGRpciA6IGRpcixcbiAgICAgICAgICAgICAgICBkYXRlIDogZGF0ZSxcbiAgICAgICAgICAgICAgICBjb21tZW50IDogZmlsZS5jb21tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogZmlsZS51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBmaWxlLmRvc1Blcm1pc3Npb25zXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoemlwRmlsZVdvcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVudHJpZXNDb3VudCA9IGVudHJpZXNDb3VudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHppcEZpbGVXb3JrZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzwqB1c2VkIHdpdGhvdXTCoGBuZXdgLCBpdMKgYWRkcyBgbmV3YCBiZWZvcmXCoGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU1ppcCgpO1xuICAgIH1cblxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9O1xufVxuSlNaaXAucHJvdG90eXBlID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbkpTWmlwLnByb3RvdHlwZS5sb2FkQXN5bmMgPSByZXF1aXJlKCcuL2xvYWQnKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzIHZlcnNpb24sXG4vLyBhIHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpLnZlcnNpb24gZG9lc24ndCB3b3JrIHdpdGggd2VicGFjaywgc2VlICMzMjdcbkpTWmlwLnZlcnNpb24gPSBcIjMuMS41XCI7XG5cbkpTWmlwLmxvYWRBc3luYyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKU1ppcCgpLmxvYWRBc3luYyhjb250ZW50LCBvcHRpb25zKTtcbn07XG5cbkpTWmlwLmV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEpTWmlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKCcuL3ppcEVudHJpZXMnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod29ya2VyLnN0cmVhbUluZm8uY3JjMzIgIT09IHppcEVudHJ5LmRlY29tcHJlc3NlZC5jcmMzMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICB6aXBFbnRyaWVzLmxvYWQoZGF0YSk7XG4gICAgICAgIHJldHVybiB6aXBFbnRyaWVzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwRW50cmllcyldO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGVja0VudHJ5Q1JDMzIoZmlsZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZXNbaV07XG4gICAgICAgICAgICB6aXAuZmlsZShpbnB1dC5maWxlTmFtZVN0ciwgaW5wdXQuZGVjb21wcmVzc2VkLCB7XG4gICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBpbnB1dC5kYXRlLFxuICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW0ucGF1c2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX3Vwc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLCBSZWFkYWJsZSk7XG5cbi8qKlxuKiBBIG5vZGVqcyBzdHJlYW0gdXNpbmcgYSB3b3JrZXIgYXMgc291cmNlLlxuKiBAc2VlIHRoZSBTb3VyY2VXcmFwcGVyIGluIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbFxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHdyYXBwaW5nIHRoZSB3b3JrZXJcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG5vZGVqcyBzdHJlYW0gb3B0aW9uc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIoaGVscGVyLCBvcHRpb25zLCB1cGRhdGVDYikge1xuICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5faGVscGVyID0gaGVscGVyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGhlbHBlci5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnB1c2goZGF0YSkpIHtcbiAgICAgICAgICAgIHNlbGYuX2hlbHBlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHVwZGF0ZUNiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYihtZXRhKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSlcbiAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgfSk7XG59XG5cblxuTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBydW5uaW5nIGluIE5vZGVqcywgd2lsbCBiZSB1bmRlZmluZWQgaW4gYSBicm93c2VyLlxuICAgICAqIEluIGEgYnJvd3NlciwgYnJvd3NlcmlmeSB3b24ndCBpbmNsdWRlIHRoaXMgZmlsZSBhbmQgdGhlIHdob2xlIG1vZHVsZVxuICAgICAqIHdpbGwgYmUgcmVzb2x2ZWQgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAqL1xuICAgIGlzTm9kZSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgZnJvbSBhbiBleGlzdGluZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIG5ld0J1ZmZlckZyb206IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIC8vIFhYWCBXZSBjYW4ndCB1c2UgYEJ1ZmZlci5mcm9tYCB3aGljaCBjb21lcyBmcm9tIGBVaW50OEFycmF5LmZyb21gXG4gICAgICAgIC8vIGluIG5vZGVqcyB2NCAoPCB2LjQuNSkuIEl0J3Mgbm90IHRoZSBleHBlY3RlZCBpbXBsZW1lbnRhdGlvbiAoYW5kXG4gICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBzaWduYXR1cmUpLlxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84MDUzXG4gICAgICAgIC8vIEEgY29uZGl0aW9uIG9uIG5vZGVqcycgdmVyc2lvbiB3b24ndCBzb2x2ZSB0aGUgaXNzdWUgYXMgd2UgZG9uJ3RcbiAgICAgICAgLy8gY29udHJvbCB0aGUgQnVmZmVyIHBvbHlmaWxscyB0aGF0IG1heSBvciBtYXkgbm90IGJlIHVzZWQuXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jQnVmZmVyOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmFsbG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgQnVmZmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNCdWZmZXIgOiBmdW5jdGlvbihiKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgICB9LFxuXG4gICAgaXNTdHJlYW0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5wYXVzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIFppcE9iamVjdCA9IHJlcXVpcmUoJy4vemlwT2JqZWN0Jyk7XG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIik7XG5cblxuLyoqXG4gKiBBZGQgYSBmaWxlIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbE9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmaWxlLlxuICovXG52YXIgZmlsZUFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuXG4gICAgLypcbiAgICAgKiBDb3JyZWN0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgICB2YXIgbyA9IHV0aWxzLmV4dGVuZChvcmlnaW5hbE9wdGlvbnMgfHwge30sIGRlZmF1bHRzKTtcbiAgICBvLmRhdGUgPSBvLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAoby5jb21wcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gby5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygby51bml4UGVybWlzc2lvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgby51bml4UGVybWlzc2lvbnMgPSBwYXJzZUludChvLnVuaXhQZXJtaXNzaW9ucywgOCk7XG4gICAgfVxuXG4gICAgLy8gVU5YX0lGRElSICAwMDQwMDAwIHNlZSB6aXBpbmZvLmNcbiAgICBpZiAoby51bml4UGVybWlzc2lvbnMgJiYgKG8udW5peFBlcm1pc3Npb25zICYgMHg0MDAwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuICAgIC8vIEJpdCA0ICAgIERpcmVjdG9yeVxuICAgIGlmIChvLmRvc1Blcm1pc3Npb25zICYmIChvLmRvc1Blcm1pc3Npb25zICYgMHgwMDEwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyKSB7XG4gICAgICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG4gICAgfVxuICAgIGlmIChvLmNyZWF0ZUZvbGRlcnMgJiYgKHBhcmVudCA9IHBhcmVudEZvbGRlcihuYW1lKSkpIHtcbiAgICAgICAgZm9sZGVyQWRkLmNhbGwodGhpcywgcGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gZGF0YVR5cGUgPT09IFwic3RyaW5nXCIgJiYgby5iaW5hcnkgPT09IGZhbHNlICYmIG8uYmFzZTY0ID09PSBmYWxzZTtcbiAgICBpZiAoIW9yaWdpbmFsT3B0aW9ucyB8fCB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmJpbmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvLmJpbmFyeSA9ICFpc1VuaWNvZGVTdHJpbmc7XG4gICAgfVxuXG5cbiAgICB2YXIgaXNDb21wcmVzc2VkRW1wdHkgPSAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpICYmIGRhdGEudW5jb21wcmVzc2VkU2l6ZSA9PT0gMDtcblxuICAgIGlmIChpc0NvbXByZXNzZWRFbXB0eSB8fCBvLmRpciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICBvLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gXCJTVE9SRVwiO1xuICAgICAgICBkYXRhVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbnRlbnQgdG8gZml0LlxuICAgICAqL1xuXG4gICAgdmFyIHppcE9iamVjdENvbnRlbnQgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gbmV3IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihuYW1lLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gdXRpbHMucHJlcGFyZUNvbnRlbnQobmFtZSwgZGF0YSwgby5iaW5hcnksIG8ub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvLmJhc2U2NCk7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgemlwT2JqZWN0Q29udGVudCwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICAvKlxuICAgIFRPRE86IHdlIGNhbid0IHRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIHdlIGhhdmUgYXN5bmMgcHJvbWlzZXNcbiAgICAod2UgY2FuIGhhdmUgYSBwcm9taXNlIG9mIGEgRGF0ZSgpIGZvciBleGFtcGxlKSBidXQgcmV0dXJuaW5nIGFcbiAgICBwcm9taXNlIGlzIHVzZWxlc3MgYmVjYXVzZSBmaWxlKG5hbWUsIGRhdGEpIHJldHVybnMgdGhlIEpTWmlwXG4gICAgb2JqZWN0IGZvciBjaGFpbmluZy4gU2hvdWxkIHdlIGJyZWFrIHRoYXQgdG8gYWxsb3cgdGhlIHVzZXJcbiAgICB0byBjYXRjaCB0aGUgZXJyb3IgP1xuXG4gICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBPYmplY3RDb250ZW50KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgICAqL1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gKGxhc3RTbGFzaCA+IDApID8gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggd2l0aCBhIHNsYXNoIGF0IHRoZSBlbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAqL1xudmFyIGZvcmNlVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBDaGVjayB0aGUgbmFtZSBlbmRzIHdpdGggYSAvXG4gICAgaWYgKHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgKHN1YikgZm9sZGVyIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZm9sZGVyJ3MgbmFtZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2NyZWF0ZUZvbGRlcnNdIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHN1YlxuICogIGZvbGRlcnMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZvbGRlci5cbiAqL1xudmFyIGZvbGRlckFkZCA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUZvbGRlcnMpIHtcbiAgICBjcmVhdGVGb2xkZXJzID0gKHR5cGVvZiBjcmVhdGVGb2xkZXJzICE9PSAndW5kZWZpbmVkJykgPyBjcmVhdGVGb2xkZXJzIDogZGVmYXVsdHMuY3JlYXRlRm9sZGVycztcblxuICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG5cbiAgICAvLyBEb2VzIHRoaXMgZm9sZGVyIGFscmVhZHkgZXhpc3Q/XG4gICAgaWYgKCF0aGlzLmZpbGVzW25hbWVdKSB7XG4gICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCB7XG4gICAgICAgICAgICBkaXI6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBjcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlc1tuYW1lXTtcbn07XG5cbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGxvYWRBc3luY1xuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZW50cnkgYXQgdGhpcyBmb2xkZXIgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lLCByZWxhdGl2ZVBhdGgsIGZpbGU7XG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgemlwIGZpbGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzIGFuIGludGVybmFsIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIHN0cmVhbWVkIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0cyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb246IFwiU1RPUkVcIixcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IFwiRE9TXCIsXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICAgZW5jb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGVuY29kZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3B0cy50eXBlID0gb3B0cy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgb3B0cy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJlbmNlIG9mIGEgemlwIHNpZ25hdHVyZSAoNCBieXRlcykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgc2lnbmF0dXJlIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJlbmNlLCAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbGFzdEluZGV4T2ZTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBzaWduYXR1cmUgKDQgYnl0ZXMpIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjb21wYXJlIGl0IHdpdGggc2lnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVhZEFuZENoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGRhdGUuXG4gICAgICogQHJldHVybiB7RGF0ZX0gdGhlIGRhdGUuXG4gICAgICovXG4gICAgcmVhZERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9zdGltZSA9IHRoaXMucmVhZEludCg0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKFxuICAgICAgICAoKGRvc3RpbWUgPj4gMjUpICYgMHg3ZikgKyAxOTgwLCAvLyB5ZWFyXG4gICAgICAgICgoZG9zdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIC8vIG1vbnRoXG4gICAgICAgIChkb3N0aW1lID4+IDE2KSAmIDB4MWYsIC8vIGRheVxuICAgICAgICAoZG9zdGltZSA+PiAxMSkgJiAweDFmLCAvLyBob3VyXG4gICAgICAgIChkb3N0aW1lID4+IDUpICYgMHgzZiwgLy8gbWludXRlXG4gICAgICAgIChkb3N0aW1lICYgMHgxZikgPDwgMSkpOyAvLyBzZWNvbmRcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIE5vZGVCdWZmZXJSZWFkZXIoZGF0YSkge1xuICAgIFVpbnQ4QXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKE5vZGVCdWZmZXJSZWFkZXIsIFVpbnQ4QXJyYXlSZWFkZXIpO1xuXG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5Ob2RlQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZUJ1ZmZlclJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZSgnLi9EYXRhUmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFN0cmluZ1JlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuemVybyArIGkpO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKHNpZykgLSB0aGlzLnplcm87XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnID09PSBkYXRhO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAvLyB0aGlzIHdpbGwgd29yayBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRoZSBcIiYgMHhmZlwiIG1hc2suXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBVaW50OEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoVWludDhBcnJheVJlYWRlciwgQXJyYXlSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuVWludDhBcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIC8vIGluIElFMTAsIHdoZW4gdXNpbmcgc3ViYXJyYXkoaWR4LCBpZHgpLCB3ZSBnZXQgdGhlIGFycmF5IFsweDAwXSBpbnN0ZWFkIG9mIFtdLlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9BcnJheVJlYWRlcicpO1xudmFyIFN0cmluZ1JlYWRlciA9IHJlcXVpcmUoJy4vU3RyaW5nUmVhZGVyJyk7XG52YXIgTm9kZUJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4vTm9kZUJ1ZmZlclJlYWRlcicpO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWFkZXIgYWRhcHRlZCB0byB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIHRvIHJlYWQuXG4gKiBAcmV0dXJuIHtEYXRhUmVhZGVyfSB0aGUgZGF0YSByZWFkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1JlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5XCIsIGRhdGEpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLkxPQ0FMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAzXFx4MDRcIjtcbmV4cG9ydHMuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwMVxceDAyXCI7XG5leHBvcnRzLkNFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNVxceDA2XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSBcIlBLXFx4MDZcXHgwN1wiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDZcXHgwNlwiO1xuZXhwb3J0cy5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXHgwOFwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgY3JjMzIgb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENyYzMyUHJvYmUoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ3JjMzJQcm9iZVwiKTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgMCk7XG59XG51dGlscy5pbmhlcml0cyhDcmMzMlByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNyYzMyUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMuc3RyZWFtSW5mby5jcmMzMiA9IGNyYzMyKGNodW5rLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ3JjMzJQcm9iZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIG5hbWUgdXNlZCB0byBleHBvc2UgdGhlIGxlbmd0aFxuICovXG5mdW5jdGlvbiBEYXRhTGVuZ3RoUHJvYmUocHJvcE5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgcHJvcE5hbWUpO1xuICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKHByb3BOYW1lLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKERhdGFMZW5ndGhQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5EYXRhTGVuZ3RoUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKGNodW5rKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdID0gbGVuZ3RoICsgY2h1bmsuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFMZW5ndGhQcm9iZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLy8gdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjaHVua3Ncbi8vIFRPRE8gZXhwb3NlIHRoaXMgYXMgYSBwdWJsaWMgdmFyaWFibGVcbnZhciBERUZBVUxUX0JMT0NLX1NJWkUgPSAxNiAqIDEwMjQ7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCByZWFkcyBhIGNvbnRlbnQgYW5kIGVtaXRzIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlfSBkYXRhUCB0aGUgcHJvbWlzZSBvZiB0aGUgZGF0YSB0byBzcGxpdFxuICovXG5mdW5jdGlvbiBEYXRhV29ya2VyKGRhdGFQKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YVdvcmtlclwiKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG5cbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBkYXRhUC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YUlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLm1heCA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgc2VsZi50eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICBpZighc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdGlja0FuZFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRGF0YVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSkge1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIHRpY2sgYSBzY2hlZHVsZSBhbiBvdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrQW5kUmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGljaygpO1xuICAgIGlmKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHB1c2ggYSBjaHVuay5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IERFRkFVTFRfQkxPQ0tfU0laRTtcbiAgICB2YXIgZGF0YSA9IG51bGwsIG5leHRJbmRleCA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YnN0cmluZyh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCBwYXNzaW5nIGNodW5rcyB0byB0aGUgbmV4dCBvbmUuIFRoaXMgaXMgbGlrZVxuICogYSBub2RlanMgc3RyZWFtIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXMuIE9uIHRoZSBnb29kIHNpZGUgOlxuICogLSBpdCB3b3JrcyBvbiBJRSA2LTkgd2l0aG91dCBhbnkgaXNzdWUgLyBwb2x5ZmlsbFxuICogLSBpdCB3ZWlnaHRzIGxlc3MgdGhhbiB0aGUgZnVsbCBkZXBlbmRlbmNpZXMgYnVuZGxlZCB3aXRoIGJyb3dzZXJpZnlcbiAqIC0gaXQgZm9yd2FyZHMgZXJyb3JzIChubyBuZWVkIHRvIGRlY2xhcmUgYW4gZXJyb3IgaGFuZGxlciBFVkVSWVdIRVJFKVxuICpcbiAqIEEgY2h1bmsgaXMgYW4gb2JqZWN0IHdpdGggMiBhdHRyaWJ1dGVzIDogYG1ldGFgIGFuZCBgZGF0YWAuIFRoZSBmb3JtZXIgaXMgYW5cbiAqIG9iamVjdCBjb250YWluaW5nIGFueXRoaW5nIChgcGVyY2VudGAgZm9yIGV4YW1wbGUpLCBzZWUgZWFjaCB3b3JrZXIgZm9yIG1vcmVcbiAqIGRldGFpbHMuIFRoZSBsYXR0ZXIgaXMgdGhlIHJlYWwgZGF0YSAoU3RyaW5nLCBVaW50OEFycmF5LCBldGMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSAobWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gR2VuZXJpY1dvcmtlcihuYW1lKSB7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIHdvcmtlclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgdGhlIHdvcmtlcnMgY2hhaW5cbiAgICB0aGlzLnN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyBhbiBlcnJvciB3aGljaCBoYXBwZW5lZCB3aGVuIHRoZSB3b3JrZXIgd2FzIHBhdXNlZFxuICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHRvIGJlIG1lcmdlZCBieSB0aGlzIHdvcmtlciBpbnRvIHRoZSBnZW5lcmFsIG1ldGFkYXRhXG4gICAgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBzdHJ1Y3R1cmUgdXBkYXRlcyAocGlwZSksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAnZGF0YSc6W10sXG4gICAgICAgICdlbmQnOltdLFxuICAgICAgICAnZXJyb3InOltdXG4gICAgfTtcbiAgICAvLyB0aGUgcHJldmlvdXMgd29ya2VyLCBpZiBhbnlcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuR2VuZXJpY1dvcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHVzaCBhIGNodW5rIHRvIHRoZSBuZXh0IHdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwdXNoXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlbmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbSB3aXRoIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGUgdGhlIGVycm9yIHdoaWNoIGNhdXNlZCB0aGUgcHJlbWF0dXJlIGVuZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyIHdpdGggYW4gZXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcnJvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSB3b3JrZXJzIGNoYWluIGV4cGxvZGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYWluLFxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IHdpbGwgZ28gZG93bndhcmQgYnV0IHdlIGFsc28gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgIC8vIHdvcmtlcnMgdXB3YXJkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayBvbiBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW55IHJlZmVyZW5jZXMgd2hlbiBhIHdvcmtlciBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYW5VcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBUaGlzIHdpbGwgY2FsbCByZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggdGhlIHByb3ZpZGVkIGFyZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyB0aGUgYXJndW1lbnQgdG8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICAgKi9cbiAgICBlbWl0IDogZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzW25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdW2ldLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhaW4gYSB3b3JrZXIgd2l0aCBhbiBvdGhlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gbmV4dCB0aGUgd29ya2VyIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybiB7d29ya2VyfSB0aGUgbmV4dCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHBpcGUgOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5yZWdpc3RlclByZXZpb3VzKHRoaXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgcGlwZWAgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBVc2luZyBhbiBBUEkgd2l0aCBgcGlwZShuZXh0KWAgaXMgdmVyeSBlYXN5LlxuICAgICAqIEltcGxlbWVudGluZyB0aGUgQVBJIHdpdGggdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG5leHQgb25lIHJlZ2lzdGVyaW5nXG4gICAgICogYSBzb3VyY2UgaXMgZWFzaWVyLCBzZWUgdGhlIFppcEZpbGVXb3JrZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IHByZXZpb3VzIHRoZSBwcmV2aW91cyB3b3JrZXIsIHNlbmRpbmcgZXZlbnRzIHRvIHRoaXMgb25lXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmlvdXMgOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhcmluZyB0aGUgc3RyZWFtSW5mby4uLlxuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSBwcmV2aW91cy5zdHJlYW1JbmZvO1xuICAgICAgICAvLyAuLi4gYW5kIGFkZGluZyBvdXIgb3duIGJpdHNcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9ICBwcmV2aW91cztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcmV2aW91cy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbSBzbyBpdCBkb2Vzbid0IHNlbmQgZXZlbnRzIGFueW1vcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcGF1c2VkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgYSBwYXVzZWQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHJlc3VtZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIXRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHRydWUsIHRoZSB3b3JrZXIgdHJpZWQgdG8gcmVzdW1lIGJ1dCBmYWlsZWRcbiAgICAgICAgdmFyIHdpdGhFcnJvciA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuZ2VuZXJhdGVkRXJyb3IpO1xuICAgICAgICAgICAgd2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICF3aXRoRXJyb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGbHVzaCBhbnkgcmVtYWluaW5nIGJ5dGVzIGFzIHRoZSBzdHJlYW0gaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGZsdXNoIDogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGNodW5rLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQ2h1bmsgOiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEga2V5L3ZhbHVlIHRvIGJlIGFkZGVkIGluIHRoZSB3b3JrZXJzIGNoYWluIHN0cmVhbUluZm8gb25jZSBhY3RpdmF0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICB3aXRoU3RyZWFtSW5mbyA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGlzIHdvcmtlcidzIHN0cmVhbUluZm8gaW50byB0aGUgY2hhaW4ncyBzdHJlYW1JbmZvLlxuICAgICAqL1xuICAgIG1lcmdlU3RyZWFtSW5mbyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHRyYVN0cmVhbUluZm8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmZvW2tleV0gPSB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIHN0cmVhbSB0byBwcmV2ZW50IGZ1cnRoZXIgdXBkYXRlcyBvbiB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgY2FsbHMgdG8gcGlwZSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByZXR0eSBwcmludCB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lID0gXCJXb3JrZXIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQ29udmVydFdvcmtlciA9IHJlcXVpcmUoJy4vQ29udmVydFdvcmtlcicpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuLi9iYXNlNjQnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWxcIik7XG5cbnZhciBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gbnVsbDtcbmlmIChzdXBwb3J0Lm5vZGVzdHJlYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gcmVxdWlyZSgnLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXInKTtcbiAgICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIGZpbmFsIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBkYXRhLiBJZiB0aGUgdXNlciB3YW50cyBhIEJsb2IgZm9yXG4gKiBleGFtcGxlLCBpdCdzIGVhc2llciB0byB3b3JrIHdpdGggYW4gVThpbnRBcnJheSBhbmQgZmluYWxseSBkbyB0aGVcbiAqIEFycmF5QnVmZmVyL0Jsb2IgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lIG9mIHRoZSBmaW5hbCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gY29udGVudCB0aGUgY29udGVudCB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSBjb250ZW50IGluIHRoZSByaWdodCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVppcE91dHB1dCh0eXBlLCBjb250ZW50LCBtaW1lVHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCIgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm5ld0Jsb2IodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCBjb250ZW50KSwgbWltZVR5cGUpO1xuICAgICAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoY29udGVudCk7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKHR5cGUsIGNvbnRlbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBhcnJheSBvZiBkYXRhIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gZGF0YUFycmF5IHRoZSBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIGNodW5rcyB0byBjb25jYXRlbmF0ZVxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgY29uY2F0ZW5hdGVkIGRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFza2VkIHR5cGUgaXMgdW5zdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0ICh0eXBlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgaSwgaW5kZXggPSAwLCByZXMgPSBudWxsLCB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBkYXRhQXJyYXkuam9pbihcIlwiKTtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkYXRhQXJyYXkpO1xuICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChkYXRhQXJyYXlbaV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGRhdGFBcnJheSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIiAgKyB0eXBlICsgXCInXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICogY29tcGxldGUgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2FsbGJhY2sgYSBjYWxsYmFjayBjYWxsZWQgb24gZWFjaCB1cGRhdGUuIENhbGxlZFxuICogd2l0aCBvbmUgYXJnIDpcbiAqIC0gdGhlIG1ldGFkYXRhIGxpbmtlZCB0byB0aGUgdXBkYXRlIHJlY2VpdmVkLlxuICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlKGhlbHBlciwgdXBkYXRlQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IGhlbHBlci5faW50ZXJuYWxUeXBlLFxuICAgICAgICAgICAgcmVzdWx0VHlwZSA9IGhlbHBlci5fb3V0cHV0VHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gaGVscGVyLl9taW1lVHlwZTtcbiAgICAgICAgaGVscGVyXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FsbGJhY2sobWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1aaXBPdXRwdXQocmVzdWx0VHlwZSwgY29uY2F0KGNodW5rVHlwZSwgZGF0YUFycmF5KSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciB0byBlYXNpbHkgdXNlIHdvcmtlcnMgb3V0c2lkZSBvZiBKU1ppcC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXb3JrZXJ9IHdvcmtlciB0aGUgd29ya2VyIHRvIHdyYXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSB0eXBlIG9mIGRhdGEgZXhwZWN0ZWQgYnkgdGhlIHVzZVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbUhlbHBlcih3b3JrZXIsIG91dHB1dFR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGludGVybmFsVHlwZSA9IG91dHB1dFR5cGU7XG4gICAgc3dpdGNoKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInVpbnQ4YXJyYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gYnVpbGRlci5nZXRCbG9iKCdhcHBsaWNhdGlvbi96aXAnKS5zaXplID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudHJ5IHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSAhIXJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi91dGlscy9zdHJpbmdzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaT0wOyBpPDI1NjsgaSsrKSB7XG4gIF91dGY4bGVuW2ldID0gKGkgPj0gMjUyID8gNiA6IGkgPj0gMjQ4ID8gNSA6IGkgPj0gMjQwID8gNCA6IGkgPj0gMjI0ID8gMyA6IGkgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XT1fdXRmOGxlblsyNTRdPTE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICAgIH1cblxuICAgIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IEFycmF5KGJ1Zl9sZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnRcbiAgICBmb3IgKGk9MCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gICAgdmFyIHBvcztcblxuICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAgIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICAgIHBvcyA9IG1heC0xO1xuICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gICAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAgIC8vIHJldHVybiBtYXggdG9vLlxuICAgIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBzdHIsIGksIG91dCwgYywgY19sZW47XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gICAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gICAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuKjIpO1xuXG4gICAgZm9yIChvdXQ9MCwgaT0wOyBpPGxlbjspIHtcbiAgICAgICAgYyA9IGJ1ZltpKytdO1xuICAgICAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgICAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbi0xOyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgICAgICAgIGNfbGVuLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNocmlua0J1Zih1dGYxNmJ1Ziwgb3V0KVxuICAgIGlmICh1dGYxNmJ1Zi5sZW5ndGggIT09IG91dCkge1xuICAgICAgICBpZih1dGYxNmJ1Zi5zdWJhcnJheSkge1xuICAgICAgICAgICAgdXRmMTZidWYgPSB1dGYxNmJ1Zi5zdWJhcnJheSgwLCBvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmMTZidWYubGVuZ3RoID0gb3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRmMTZidWYpO1xuICAgIHJldHVybiB1dGlscy5hcHBseUZyb21DaGFyQ29kZSh1dGYxNmJ1Zik7XG59O1xuXG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGphdmFzY3JpcHQgc3RyaW5nIGludG8gYW4gYXJyYXkgKHR5cGVkIGlmIHBvc3NpYmxlKSBvZiBieXRlcyxcbiAqIFVURi04IGVuY29kZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhlbmNvZGUgPSBmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oc3RyLCBcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcyYnVmKHN0cik7XG59O1xuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgYnl0ZXMgYXJyYXkgKG9yIGEgcmVwcmVzZW50YXRpb24pIHJlcHJlc2VudGluZyBhbiBVVEYtOCBlbmNvZGVkXG4gKiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gYnVmIHRoZSBkYXRhIGRlIGRlY29kZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGRlY29kZSA9IGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnVmKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsIGJ1ZikudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICBidWYgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgYnVmKTtcblxuICAgIHJldHVybiBidWYyc3RyaW5nKGJ1Zik7XG59O1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGRlY29kZSB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcyBpbnRvIHN0cmluZyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOERlY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBkZWNvZGVcIik7XG4gICAgLy8gdGhlIGxhc3QgYnl0ZXMgaWYgYSBjaHVuayBkaWRuJ3QgZW5kIHdpdGggYSBjb21wbGV0ZSBjb2RlcG9pbnQuXG4gICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RGVjb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGRhdGEgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgY2h1bmsuZGF0YSk7XG5cbiAgICAvLyAxc3Qgc3RlcCwgcmUtdXNlIHdoYXQncyBsZWZ0IG9mIHRoZSBwcmV2aW91cyBjaHVua1xuICAgIGlmICh0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocHJldmlvdXNEYXRhLmxlbmd0aCArIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHRoaXMubGVmdE92ZXIsIDApO1xuICAgICAgICAgICAgZGF0YS5zZXQocHJldmlvdXNEYXRhLCB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWZ0T3Zlci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5leHRCb3VuZGFyeSA9IHV0Zjhib3JkZXIoZGF0YSk7XG4gICAgdmFyIHVzYWJsZURhdGEgPSBkYXRhO1xuICAgIGlmIChuZXh0Qm91bmRhcnkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnN1YmFycmF5KDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zdWJhcnJheShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnNsaWNlKDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zbGljZShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodXNhYmxlRGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZih0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLFxuICAgICAgICAgICAgbWV0YSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5VdGY4RGVjb2RlV29ya2VyID0gVXRmOERlY29kZVdvcmtlcjtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBlbmRjb2RlIHN0cmluZyBjaHVua3MgaW50byB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RW5jb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGVuY29kZVwiKTtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhFbmNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOEVuY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGVuY29kZShjaHVuay5kYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5leHBvcnRzLlV0ZjhFbmNvZGVXb3JrZXIgPSBVdGY4RW5jb2RlV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnY29yZS1qcy9saWJyYXJ5L2ZuL3NldC1pbW1lZGlhdGUnKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9ucyBhbmQgZnVuY3Rpb25zIHRoYXRcbiAqIGNhbiBiZSBvcHRpbWl6ZWQgYnkgdGhlIGJyb3dzZXIgSklUIGNvbXBpbGVyLlxuICovXG52YXIgYXJyYXlUb1N0cmluZ0hlbHBlciA9IHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgaW50IGludG8gYSBzdHJpbmcsIGNodW5rIGJ5IGNodW5rLlxuICAgICAqIFNlZSB0aGUgcGVyZm9ybWFuY2VzIG5vdGVzIG9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY2h1bmsgdGhlIGNodW5rIHNpemUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjaHVuayBpcyB0b28gYmlnIGZvciB0aGUgc3RhY2suXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaHVuazogZnVuY3Rpb24oYXJyYXksIHR5cGUsIGNodW5rKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgayA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgLy8gc2hvcnRjdXRcbiAgICAgICAgaWYgKGxlbiA8PSBjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zbGljZShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnN1YmFycmF5KGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbCBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgaXMgdGhlIG5haXZlIGltcGxlbWVudGF0aW9uLCB3aGljaCBnZW5lcmF0ZSBBIExPVCBvZiBpbnRlcm1lZGlhdGUgc3RyaW5nLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBldmVyeXRoaW5nIGVsc2UgZmFpbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNoYXI6IGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgdmFyIHJlc3VsdFN0ciA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfSxcbiAgICBhcHBseUNhbkJlVXNlZCA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBVaW50OEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB1aW50OGFycmF5IDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQudWludDhhcnJheSAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIG5vZGVqcyBCdWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBub2RlYnVmZmVyIDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZyhhcnJheSkge1xuICAgIC8vIFBlcmZvcm1hbmNlcyBub3RlcyA6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBpcyB0aGUgZmFzdGVzdCwgc2VlXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnZlcnRpbmctYS11aW50OGFycmF5LXRvLWEtc3RyaW5nLzJcbiAgICAvLyBidXQgdGhlIHN0YWNrIGlzIGxpbWl0ZWQgKGFuZCB3ZSBjYW4gZ2V0IGh1Z2UgYXJyYXlzICEpLlxuICAgIC8vXG4gICAgLy8gcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pOyBnZW5lcmF0ZSB0b28gbWFueSBzdHJpbmdzICFcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBpcyBpbnNwaXJlZCBieSBodHRwOi8vanNwZXJmLmNvbS9hcnJheWJ1ZmZlci10by1zdHJpbmctYXBwbHktcGVyZm9ybWFuY2UvMlxuICAgIC8vIFRPRE8gOiB3ZSBub3cgaGF2ZSB3b3JrZXJzIHRoYXQgc3BsaXQgdGhlIHdvcmsuIERvIHdlIHN0aWxsIG5lZWQgdGhhdCA/XG4gICAgdmFyIGNodW5rID0gNjU1MzYsXG4gICAgICAgIHR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihhcnJheSksXG4gICAgICAgIGNhblVzZUFwcGx5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50OGFycmF5XCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQubm9kZWJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoY2FuVXNlQXBwbHkpIHtcbiAgICAgICAgd2hpbGUgKGNodW5rID4gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNodW5rKGFycmF5LCB0eXBlLCBjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBNYXRoLmZsb29yKGNodW5rIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBhcHBseSBvciBjaHVuayBlcnJvciA6IHNsb3cgYW5kIHBhaW5mdWwgYWxnb3JpdGhtXG4gICAgLy8gZGVmYXVsdCBicm93c2VyIG9uIGFuZHJvaWQgNC4qXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaGFyKGFycmF5KTtcbn1cblxuZXhwb3J0cy5hcHBseUZyb21DaGFyQ29kZSA9IGFycmF5TGlrZVRvU3RyaW5nO1xuXG5cbi8qKlxuICogQ29weSB0aGUgZGF0YSBmcm9tIGFuIGFycmF5LWxpa2UgdG8gYW4gb3RoZXIgYXJyYXktbGlrZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5RnJvbSB0aGUgb3JpZ2luIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlUbyB0aGUgZGVzdGluYXRpb24gYXJyYXkgd2hpY2ggd2lsbCBiZSBtdXRhdGVkLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGRlc3RpbmF0aW9uIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5TGlrZShhcnJheUZyb20sIGFycmF5VG8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5RnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVRvW2ldID0gYXJyYXlGcm9tW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUbztcbn1cblxuLy8gYSBtYXRyaXggY29udGFpbmluZyBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtIGV2ZXJ5dGhpbmcgaW50byBldmVyeXRoaW5nLlxudmFyIHRyYW5zZm9ybSA9IHt9O1xuXG4vLyBzdHJpbmcgdG8gP1xudHJhbnNmb3JtW1wic3RyaW5nXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJzdHJpbmdcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5YnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcImFycmF5YnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH0sXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UobmV3IFVpbnQ4QXJyYXkoaW5wdXQpLCBuZXcgQXJyYXkoaW5wdXQuYnl0ZUxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBpZGVudGl0eSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH1cbn07XG5cbi8vIHVpbnQ4YXJyYXkgdG8gP1xudHJhbnNmb3JtW1widWludDhhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gbm9kZWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGlucHV0IGludG8gYW55IHR5cGUuXG4gKiBUaGUgc3VwcG9ydGVkIG91dHB1dCB0eXBlIGFyZSA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBub2RlYnVmZmVyLlxuICogSWYgbm8gb3V0cHV0IHR5cGUgaXMgc3BlY2lmaWVkLCB0aGUgdW5tb2RpZmllZCBpbnB1dCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIG91dHB1dCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGlucHV0IHRoZSBpbnB1dCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIG91dHB1dCB0eXBlLlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgZXRjXG4gICAgICAgIC8vIGFuIGVtcHR5IHN0cmluZyB3b24ndCBoYXJtLlxuICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KG91dHB1dFR5cGUpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihpbnB1dCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVtpbnB1dFR5cGVdW291dHB1dFR5cGVdKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogVGhlIHR5cGUgd2lsbCBiZSBpbiBhIGZvcm1hdCB2YWxpZCBmb3IgSlNaaXAudXRpbHMudHJhbnNmb3JtVG8gOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQgdG8gaWRlbnRpZnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSAobG93ZXJjYXNlKSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0cy5nZXRUeXBlT2YgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBub2RlanNVdGlscy5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFwibm9kZWJ1ZmZlclwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5ICYmIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJ1aW50OGFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LmFycmF5YnVmZmVyICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgdHlwZS5cbiAqL1xuZXhwb3J0cy5jaGVja1N1cHBvcnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLk1BWF9WQUxVRV8xNkJJVFMgPSA2NTUzNTtcbmV4cG9ydHMuTUFYX1ZBTFVFXzMyQklUUyA9IC0xOyAvLyB3ZWxsLCBcIlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcIiBpcyBwYXJzZWQgYXMgLTFcblxuLyoqXG4gKiBQcmV0dGlmeSBhIHN0cmluZyByZWFkIGFzIGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBwcmV0dGlmeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gYSBwcmV0dHkgc3RyaW5nLlxuICovXG5leHBvcnRzLnByZXR0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciByZXMgPSAnJyxcbiAgICAgICAgY29kZSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgKHN0ciB8fCBcIlwiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJlcyArPSAnXFxcXHgnICsgKGNvZGUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYXN5bmNocm9ub3VzbHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gZ2l2ZSB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydHMuZGVsYXkgPSBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgc2VsZikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYgfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgYSBwcm90b3R5cGUgd2l0aCBhbiBvdGhlciwgd2l0aG91dCBjYWxsaW5nIGEgY29uc3RydWN0b3Igd2l0aFxuICogc2lkZSBlZmZlY3RzLiBJbnNwaXJlZCBieSBub2RlanMnIGB1dGlscy5pbmhlcml0c2BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgdGhlIGNvbnN0cnVjdG9yIHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ3RvciB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHRvIHVzZVxuICovXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIHZhciBPYmogPSBmdW5jdGlvbigpIHt9O1xuICAgIE9iai5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IE9iaigpO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0aGUgb2JqZWN0cyBwYXNzZWQgYXMgcGFyYW1ldGVycyBpbnRvIGEgbmV3IG9uZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgQWxsIG9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRoIHRoZSBkYXRhIG9mIHRoZSBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpLCBhdHRyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgLy8gYXJndW1lbnRzIGlzIG5vdCBlbnVtZXJhYmxlIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgZm9yIChhdHRyIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiB0eXBlb2YgcmVzdWx0W2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2F0dHJdID0gYXJndW1lbnRzW2ldW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhcmJpdHJhcnkgY29udGVudCBpbnRvIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSBmb3IgdGhlIGNvbnRlbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YSB0aGUgY29udGVudCB0byBwcm9jZXNzLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSB0cnVlIGlmIHRoZSBjb250ZW50IGlzIG5vdCBhbiB1bmljb2RlIHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpc09wdGltaXplZEJpbmFyeVN0cmluZyB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBvbmx5IGhhcyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0Jhc2U2NCB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBpcyBlbmNvZGVkIHdpdGggYmFzZTY0LlxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIGluIGEgZm9ybWF0IHVzYWJsZSBieSBKU1ppcC5cbiAqL1xuZXhwb3J0cy5wcmVwYXJlQ29udGVudCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0RGF0YSwgaXNCaW5hcnksIGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nLCBpc0Jhc2U2NCkge1xuXG4gICAgLy8gaWYgaW5wdXREYXRhIGlzIGFscmVhZHkgYSBwcm9taXNlLCB0aGlzIGZsYXR0ZW4gaXQuXG4gICAgdmFyIHByb21pc2UgPSBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoaW5wdXREYXRhKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaXNCbG9iID0gc3VwcG9ydC5ibG9iICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBbJ1tvYmplY3QgRmlsZV0nLCAnW29iamVjdCBCbG9iXSddLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSAhPT0gLTEpO1xuXG4gICAgICAgIGlmIChpc0Jsb2IgJiYgdHlwZW9mIEZpbGVSZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGFUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiQ2FuJ3QgcmVhZCB0aGUgZGF0YSBvZiAnXCIgKyBuYW1lICsgXCInLiBJcyBpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gYSBzdXBwb3J0ZWQgSmF2YVNjcmlwdCB0eXBlIChTdHJpbmcsIEJsb2IsIEFycmF5QnVmZmVyLCBldGMpID9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIDogaXQncyB3YXkgZWFzaWVyIHRvIHdvcmsgd2l0aCBVaW50OEFycmF5IHRoYW4gd2l0aCBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgICAgZGF0YSA9IGV4cG9ydHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCB3aXRoIGEgMHhGRiBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdGhhdCB0aGlzIGlzIGEgY29ycmVjdCBcImJpbmFyeSBzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyaW5nMmJpbmFyeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoJy4vcmVhZGVyL3JlYWRlckZvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHNpZyA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKCcuL3ppcEVudHJ5Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSBcIiArIFwiKFwiICsgdXRpbHMucHJldHR5KHNpZ25hdHVyZSkgKyBcIiwgZXhwZWN0ZWQgXCIgKyB1dGlscy5wcmV0dHkoZXhwZWN0ZWRTaWduYXR1cmUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGlzIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNrZWRJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBoZXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTaWduYXR1cmU6IGZ1bmN0aW9uKGFza2VkSW5kZXgsIGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoYXNrZWRJbmRleCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2lnbmF0dXJlID09PSBleHBlY3RlZFNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEJsb2NrRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIHRoaXMuemlwQ29tbWVudExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIC8vIHdhcm5pbmcgOiB0aGUgZW5jb2RpbmcgZGVwZW5kcyBvZiB0aGUgc3lzdGVtIGxvY2FsZVxuICAgICAgICAvLyBPbiBhIGxpbnV4IG1hY2hpbmUgd2l0aCBMQU5HPWVuX1VTLnV0ZjgsIHRoaXMgZmllbGQgaXMgdXRmOCBlbmNvZGVkLlxuICAgICAgICAvLyBPbiBhIHdpbmRvd3MgbWFjaGluZSwgdGhpcyBmaWVsZCBpcyBlbmNvZGVkIHdpdGggdGhlIGxvY2FsaXplZCB3aW5kb3dzIGNvZGUgcGFnZS5cbiAgICAgICAgdmFyIHppcENvbW1lbnQgPSB0aGlzLnJlYWRlci5yZWFkRGF0YSh0aGlzLnppcENvbW1lbnRMZW5ndGgpO1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIC8vIFRvIGdldCBjb25zaXN0ZW50IGJlaGF2aW9yIHdpdGggdGhlIGdlbmVyYXRpb24gcGFydCwgd2Ugd2lsbCBhc3N1bWUgdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIHV0ZjggZW5jb2RlZCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGRlY29kZUNvbnRlbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHppcENvbW1lbnQpO1xuICAgICAgICB0aGlzLnppcENvbW1lbnQgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGRlY29kZUNvbnRlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICogTm90IG1lcmdlZCB3aXRoIHRoZSBtZXRob2QgcmVhZEVuZE9mQ2VudHJhbCA6XG4gICAgICogVGhlIGVuZCBvZiBjZW50cmFsIGNhbiBjb2V4aXN0IHdpdGggaXRzIFppcDY0IGJyb3RoZXIsXG4gICAgICogSSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIHdyb25nIG51bWJlciBvZiBieXRlcyAhXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMucmVhZGVyLnNraXAoNCk7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk1hZGVCeSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcblxuICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGV4dHJhRGF0YVNpemUgPSB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSAtIDQ0LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZXh0cmFEYXRhU2l6ZSkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gdGhpcy5yZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yLlxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2tzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aS12b2x1bWVzIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgZmlsZXMsIGJhc2VkIG9uIHRoZSBvZmZzZXQgcmVhZCBpbiB0aGUgY2VudHJhbCBwYXJ0LlxuICAgICAqL1xuICAgIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGZpbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGZpbGUubG9jYWxIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuICAgICAgICAgICAgZmlsZS5yZWFkTG9jYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlVVRGOCgpO1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzQXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWxlO1xuXG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICBmaWxlID0gbmV3IFppcEVudHJ5KHtcbiAgICAgICAgICAgICAgICB6aXA2NDogdGhpcy56aXA2NFxuICAgICAgICAgICAgfSwgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICBmaWxlLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSAwICYmIHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0ZWQgc29tZSByZWNvcmRzIGJ1dCBjb3VsZG4ndCBmaW5kIEFOWS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlYWxseSBzdXNwaWNpb3VzLCBhcyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBzb21lIHJlY29yZHMgYnV0IG5vdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGlzIHdyb25nIGJ1dCB3ZSBnb3Qgc29tZXRoaW5nIGZvciB0aGUgdXNlcjogbm8gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJleHBlY3RlZFwiLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzLCBcInJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdFwiLCB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgYSB0cnVuY2F0ZWQgemlwIG9yIGNvbXBsZXRlIGdhcmJhZ2UuXG4gICAgICAgICAgICAvLyBBIFwiTE9DQUxfRklMRV9IRUFERVJcIiBpcyBub3QgcmVxdWlyZWQgYXQgdGhlIGJlZ2lubmluZyAoYXV0b1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlibGUgemlwIGZvciBleGFtcGxlKSBidXQgaXQgY2FuIGdpdmUgYSBnb29kIGhpbnQuXG4gICAgICAgICAgICAvLyBJZiBhbiBhamF4IHJlcXVlc3Qgd2FzIHVzZWQgd2l0aG91dCByZXNwb25zZVR5cGUsIHdlIHdpbGwgYWxzb1xuICAgICAgICAgICAgLy8gZ2V0IHVucmVhZGFibGUgZGF0YS5cbiAgICAgICAgICAgIHZhciBpc0dhcmJhZ2UgPSAhdGhpcy5pc1NpZ25hdHVyZSgwLCBzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNHYXJiYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgOiBpcyB0aGlzIGEgemlwIGZpbGUgPyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFTY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB0aGUgemlwNjQgRU9DRCByZWNvcmRcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NpZ25hdHVyZSh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIsIHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IG5vdCB3aGVyZSBleHBlY3RlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIGNyYzMyZm4gPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb25zJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xudmFyIGZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGNvbXByZXNzaW9ucykge1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9ucy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb25zIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IFwiICsgXCIoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXByZXNzaW9uID0gZmluZENvbXByZXNzaW9uKHRoaXMuY29tcHJlc3Npb25NZXRob2QpO1xuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IG51bGwpIHsgLy8gbm8gY29tcHJlc3Npb24gZm91bmRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIiArIHV0aWxzLnByZXR0eSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKSArIFwiIHVua25vd24gKGlubmVyIGZpbGUgOiBcIiArIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMuZmlsZU5hbWUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gbmV3IENvbXByZXNzZWRPYmplY3QodGhpcy5jb21wcmVzc2VkU2l6ZSwgdGhpcy51bmNvbXByZXNzZWRTaXplLCB0aGlzLmNyYzMyLCBjb21wcmVzc2lvbiwgcmVhZGVyLnJlYWREYXRhKHRoaXMuY29tcHJlc3NlZFNpemUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB0aGlzLnZlcnNpb25NYWRlQnkgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgcmVhZGVyLnNraXAoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmJpdEZsYWcgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICB0aGlzLmRhdGUgPSByZWFkZXIucmVhZERhdGUoKTtcbiAgICAgICAgdGhpcy5jcmMzMiA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB2YXIgZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50TGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IHJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aWxsIGJlIHJlYWQgaW4gdGhlIGxvY2FsIHBhcnQsIHNlZSB0aGUgY29tbWVudHMgdGhlcmVcbiAgICAgICAgcmVhZGVyLnNraXAoZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICB0aGlzLnJlYWRFeHRyYUZpZWxkcyhyZWFkZXIpO1xuICAgICAgICB0aGlzLnBhcnNlWklQNjRFeHRyYUZpZWxkKHJlYWRlcik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnQgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlQ29tbWVudExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgYW5kIGdldCB0aGUgdW5peC9kb3MgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdmFyIG1hZGVCeSA9IHRoaXMudmVyc2lvbk1hZGVCeSA+PiA4O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIERPUyBkaXJlY3RvcnkgZmxhZyBzZXQuXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGl0IGluIHRoZSBET1MgYW5kIFVOSVggcGVybWlzc2lvbnNcbiAgICAgICAgLy8gYnV0IHNvbWUgdW5rbm93biBwbGF0Zm9ybSBjb3VsZCBzZXQgaXQgYXMgYSBjb21wYXRpYmlsaXR5IGZsYWcuXG4gICAgICAgIHRoaXMuZGlyID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgwMDEwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9ET1MpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IDYgYml0cyAoMCB0byA1KVxuICAgICAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4M0Y7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfVU5JWCkge1xuICAgICAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSAodGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAgICAgICAgIC8vIHRoZSBvY3RhbCBwZXJtaXNzaW9ucyBhcmUgaW4gKHRoaXMudW5peFBlcm1pc3Npb25zICYgMHgwMUZGKS50b1N0cmluZyg4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWwgc2FmZSA6IGlmIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC8gaXQgcHJvYmFibHkgbWVhbnMgYSBmb2xkZXJcbiAgICAgICAgaWYgKCF0aGlzLmRpciAmJiB0aGlzLmZpbGVOYW1lU3RyLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLmRpciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIFpJUDY0IGV4dHJhIGZpZWxkIGFuZCBtZXJnZSB0aGUgaW5mbyBpbiB0aGUgY3VycmVudCBaaXBFbnRyeS5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwYXJzZVpJUDY0RXh0cmFGaWVsZDogZnVuY3Rpb24ocmVhZGVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBiZSBzb21ldGhpbmcsIHByZXBhcmluZyB0aGUgZXh0cmEgcmVhZGVyXG4gICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0udmFsdWUpO1xuXG4gICAgICAgIC8vIEkgcmVhbGx5IGhvcGUgdGhhdCB0aGVzZSA2NGJpdHMgaW50ZWdlciBjYW4gZml0IGluIDMyIGJpdHMgaW50ZWdlciwgYmVjYXVzZSBqc1xuICAgICAgICAvLyB3b24ndCBsZXQgdXMgaGF2ZSBtb3JlLlxuICAgICAgICBpZiAodGhpcy51bmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5pbmRleCArIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlYWRlci5pbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLnNldEltbWVkaWF0ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuMy4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG4gIHZhciBkaWN0O1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0ID0gZGljdGlvbmFyeTtcbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbmZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcbiIsIi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbnZhciBTVFJfQVBQTFlfT0sgPSB0cnVlO1xudmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFsgMCBdKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX09LID0gZmFsc2U7IH1cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gdXNlIGZhbGxiYWNrIGZvciBiaWcgYXJyYXlzIHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93XG4gIGlmIChsZW4gPCA2NTUzNykge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSByZXF1aXJlKCdpbW1lZGlhdGUnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSU5URVJOQUwpO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcbiAgICB1bndyYXAocHJvbWlzZSwgcmVzb2x2ZXIsIHRoaXMub3V0Y29tZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcbmZ1bmN0aW9uIFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkO1xuICAgIHRoaXMuY2FsbEZ1bGZpbGxlZCA9IHRoaXMub3RoZXJDYWxsRnVsZmlsbGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQ7XG4gICAgdGhpcy5jYWxsUmVqZWN0ZWQgPSB0aGlzLm90aGVyQ2FsbFJlamVjdGVkO1xuICB9XG59XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVzb2x2ZSh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uRnVsZmlsbGVkLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vblJlamVjdGVkLCB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB1bndyYXAocHJvbWlzZSwgZnVuYywgdmFsdWUpIHtcbiAgaW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlKTtcbiAgICB9XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBwcm9taXNlKSB7XG4gICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignQ2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuaGFuZGxlcnMucmVzb2x2ZSA9IGZ1bmN0aW9uIChzZWxmLCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZ2V0VGhlbiwgdmFsdWUpO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBoYW5kbGVycy5yZWplY3Qoc2VsZiwgcmVzdWx0LnZhbHVlKTtcbiAgfVxuICB2YXIgdGhlbmFibGUgPSByZXN1bHQudmFsdWU7XG5cbiAgaWYgKHRoZW5hYmxlKSB7XG4gICAgc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnN0YXRlID0gRlVMRklMTEVEO1xuICAgIHNlbGYub3V0Y29tZSA9IHZhbHVlO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIHNlbGYucXVldWVbaV0uY2FsbEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbmhhbmRsZXJzLnJlamVjdCA9IGZ1bmN0aW9uIChzZWxmLCBlcnJvcikge1xuICBzZWxmLnN0YXRlID0gUkVKRUNURUQ7XG4gIHNlbGYub3V0Y29tZSA9IGVycm9yO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBzZWxmLnF1ZXVlW2ldLmNhbGxSZWplY3RlZChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhY2Nlc3MgdGhlIGFjY2Vzc29yIG9uY2UgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWNcbiAgdmFyIHRoZW4gPSBvYmogJiYgb2JqLnRoZW47XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcHlUaGVuKCkge1xuICAgICAgdGhlbi5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpIHtcbiAgLy8gRWl0aGVyIGZ1bGZpbGwsIHJlamVjdCBvciByZWplY3Qgd2l0aCBlcnJvclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uRXJyb3IodmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVqZWN0KHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VjY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvVW53cmFwKCkge1xuICAgIHRoZW5hYmxlKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godHJ5VG9VbndyYXApO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIG9uRXJyb3IocmVzdWx0LnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYXRjaChmdW5jLCB2YWx1ZSkge1xuICB2YXIgb3V0ID0ge307XG4gIHRyeSB7XG4gICAgb3V0LnZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgb3V0LnN0YXR1cyA9ICdzdWNjZXNzJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dC5zdGF0dXMgPSAnZXJyb3InO1xuICAgIG91dC52YWx1ZSA9IGU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgdGhpcyhJTlRFUk5BTCksIHZhbHVlKTtcbn1cblxuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIHJlc29sdmVkID0gMDtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFsbFJlc29sdmVyKGl0ZXJhYmxlW2ldLCBpKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gYWxsUmVzb2x2ZXIodmFsdWUsIGkpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZUZyb21BbGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbUFsbChvdXRWYWx1ZSkge1xuICAgICAgdmFsdWVzW2ldID0gb3V0VmFsdWU7XG4gICAgICBpZiAoKytyZXNvbHZlZCA9PT0gbGVuICYmICFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzb2x2ZXIoaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiByZXNvbHZlcih2YWx1ZSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHJvb3Q7XG4gIH1cbiAgb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICBvYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTtcblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LCBBbGwgcmlnaHRzIHJlc2VydmVkLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuOyhmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0dsb2JhbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgdmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKSA/IGV4cG9ydHMgOiBudWxsO1xuICB2YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSkgPyBtb2R1bGUgOiBudWxsO1xuICB2YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcbiAgdmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuICB2YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG4gIHZhciBtb2R1bGVFeHBvcnRzID0gKGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykgPyBmcmVlRXhwb3J0cyA6IG51bGw7XG4gIHZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICB2YXIgUnggPSB7XG4gICAgaW50ZXJuYWxzOiB7fSxcbiAgICBjb25maWc6IHtcbiAgICAgIFByb21pc2U6IHJvb3QuUHJvbWlzZVxuICAgIH0sXG4gICAgaGVscGVyczogeyB9XG4gIH07XG5cbiAgLy8gRGVmYXVsdHNcbiAgdmFyIG5vb3AgPSBSeC5oZWxwZXJzLm5vb3AgPSBmdW5jdGlvbiAoKSB7IH0sXG4gICAgaWRlbnRpdHkgPSBSeC5oZWxwZXJzLmlkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAgZGVmYXVsdE5vdyA9IFJ4LmhlbHBlcnMuZGVmYXVsdE5vdyA9IERhdGUubm93LFxuICAgIGRlZmF1bHRDb21wYXJlciA9IFJ4LmhlbHBlcnMuZGVmYXVsdENvbXBhcmVyID0gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGlzRXF1YWwoeCwgeSk7IH0sXG4gICAgZGVmYXVsdFN1YkNvbXBhcmVyID0gUnguaGVscGVycy5kZWZhdWx0U3ViQ29tcGFyZXIgPSBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA+IHkgPyAxIDogKHggPCB5ID8gLTEgOiAwKTsgfSxcbiAgICBkZWZhdWx0S2V5U2VyaWFsaXplciA9IFJ4LmhlbHBlcnMuZGVmYXVsdEtleVNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9LFxuICAgIGRlZmF1bHRFcnJvciA9IFJ4LmhlbHBlcnMuZGVmYXVsdEVycm9yID0gZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgaXNQcm9taXNlID0gUnguaGVscGVycy5pc1Byb21pc2UgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gISFwICYmIHR5cGVvZiBwLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nOyB9LFxuICAgIGlzRnVuY3Rpb24gPSBSeC5oZWxwZXJzLmlzRnVuY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICB2YXIgaXNGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAvLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgIGlmIChpc0ZuKC94LykpIHtcbiAgICAgICAgaXNGbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0ZuO1xuICAgIH0oKSk7XG5cbiAgZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHsgZm9yKHZhciBhID0gW10sIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgYS5wdXNoKGFycltpXSk7IH0gcmV0dXJuIGE7fVxuXG4gIHZhciBlcnJvck9iaiA9IHtlOiB7fX07XG4gIFxuICBmdW5jdGlvbiB0cnlDYXRjaGVyR2VuKHRyeUNhdGNoVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyeUNhdGNoID0gUnguaW50ZXJuYWxzLnRyeUNhdGNoID0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZuIG11c3QgYmUgYSBmdW5jdGlvbicpOyB9XG4gICAgcmV0dXJuIHRyeUNhdGNoZXJHZW4oZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgIHRocm93IGU7XG4gIH1cblxuICBSeC5jb25maWcubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuICB2YXIgaGFzU3RhY2tzID0gZmFsc2UsIHN0YWNrcyA9IHRyeUNhdGNoKGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCk7IH0pKCk7XG4gIGhhc1N0YWNrcyA9ICEhc3RhY2tzLmUgJiYgISFzdGFja3MuZS5zdGFjaztcblxuICAvLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWQgYnkgUnhKU1xuICB2YXIgclN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCksIHJGaWxlTmFtZTtcblxuICB2YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSAnRnJvbSBwcmV2aW91cyBldmVudDonO1xuXG4gIGZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgb2JzZXJ2YWJsZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFJ4SlNcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBvYnNlcnZhYmxlYC5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIG9ic2VydmFibGUuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFjayAmJlxuICAgICAgICBlcnJvci5zdGFjay5pbmRleE9mKFNUQUNLX0pVTVBfU0VQQVJBVE9SKSA9PT0gLTFcbiAgICApIHtcbiAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgIGZvciAodmFyIG8gPSBvYnNlcnZhYmxlOyAhIW87IG8gPSBvLnNvdXJjZSkge1xuICAgICAgICBpZiAoby5zdGFjaykge1xuICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KG8uc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKCdcXG4nICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyAnXFxuJyk7XG4gICAgICBlcnJvci5zdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KCdcXG4nKSwgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdLCBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSByRmlsZU5hbWUgJiZcbiAgICAgIGxpbmVOdW1iZXIgPj0gclN0YXJ0aW5nTGluZSAmJlxuICAgICAgbGluZU51bWJlciA8PSByRW5kaW5nTGluZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZignKG1vZHVsZS5qczonKSAhPT0gLTEgfHxcbiAgICAgIHN0YWNrTGluZS5pbmRleE9mKCcobm9kZS5qczonKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykgeyByZXR1cm47IH1cblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKCdAJykgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7IHJldHVybjsgfVxuXG4gICAgICByRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6ICdhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKSdcbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7IHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldOyB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiAnYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXInXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MikgeyByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTsgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogJ2Z1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXInXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MykgeyByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTsgfVxuICB9XG5cbiAgdmFyIEVtcHR5RXJyb3IgPSBSeC5FbXB0eUVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1NlcXVlbmNlIGNvbnRhaW5zIG5vIGVsZW1lbnRzLic7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgRW1wdHlFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIEVtcHR5RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRW1wdHlFcnJvcic7XG5cbiAgdmFyIE9iamVjdERpc3Bvc2VkRXJyb3IgPSBSeC5PYmplY3REaXNwb3NlZEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ09iamVjdCBoYXMgYmVlbiBkaXNwb3NlZCc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgT2JqZWN0RGlzcG9zZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIE9iamVjdERpc3Bvc2VkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnT2JqZWN0RGlzcG9zZWRFcnJvcic7XG5cbiAgdmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gUnguQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ0FyZ3VtZW50IG91dCBvZiByYW5nZSc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvci5wcm90b3R5cGUubmFtZSA9ICdBcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG5cbiAgdmFyIE5vdFN1cHBvcnRlZEVycm9yID0gUnguTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIE5vdFN1cHBvcnRlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgTm90U3VwcG9ydGVkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnTm90U3VwcG9ydGVkRXJyb3InO1xuXG4gIHZhciBOb3RJbXBsZW1lbnRlZEVycm9yID0gUnguTm90SW1wbGVtZW50ZWRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhpcyBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBOb3RJbXBsZW1lbnRlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgTm90SW1wbGVtZW50ZWRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdOb3RJbXBsZW1lbnRlZEVycm9yJztcblxuICB2YXIgbm90SW1wbGVtZW50ZWQgPSBSeC5oZWxwZXJzLm5vdEltcGxlbWVudGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH07XG5cbiAgdmFyIG5vdFN1cHBvcnRlZCA9IFJ4LmhlbHBlcnMubm90U3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICB9O1xuXG4gIC8vIFNoaW0gaW4gaXRlcmF0b3Igc3VwcG9ydFxuICB2YXIgJGl0ZXJhdG9yJCA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcikgfHxcbiAgICAnX2VzNnNoaW1faXRlcmF0b3JfJztcbiAgLy8gQnVnIGZvciBtb3ppbGxhIHZlcnNpb25cbiAgaWYgKHJvb3QuU2V0ICYmIHR5cGVvZiBuZXcgcm9vdC5TZXQoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgJGl0ZXJhdG9yJCA9ICdAQGl0ZXJhdG9yJztcbiAgfVxuXG4gIHZhciBkb25lRW51bWVyYXRvciA9IFJ4LmRvbmVFbnVtZXJhdG9yID0geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cbiAgdmFyIGlzSXRlcmFibGUgPSBSeC5oZWxwZXJzLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIG9bJGl0ZXJhdG9yJF0gIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgaXNBcnJheUxpa2UgPSBSeC5oZWxwZXJzLmlzQXJyYXlMaWtlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBvLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFJ4LmhlbHBlcnMuaXRlcmF0b3IgPSAkaXRlcmF0b3IkO1xuXG4gIHZhciBiaW5kQ2FsbGJhY2sgPSBSeC5pbnRlcm5hbHMuYmluZENhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzQXJnID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZnVuYzsgfVxuICAgIHN3aXRjaChhcmdDb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKVxuICAgICAgICB9O1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmcpO1xuICAgICAgICB9O1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIGRvbnRFbnVtcyA9IFsndG9TdHJpbmcnLFxuICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgJ3ZhbHVlT2YnLFxuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ2NvbnN0cnVjdG9yJ10sXG4gIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXMgfHwgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGhhc0RvbnRFbnVtQnVnID0gISh7IHRvU3RyaW5nOiBudWxsIH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuICAgICAgICBkb250RW51bXMgPSBbXG4gICAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICAgICAgXSxcbiAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgcHJvcCwgaTtcblxuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSgpKTtcblxuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9PSBvdGhMZW5ndGggJiYgIWlzTG9vc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoLCBrZXk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB2YXIgc2tpcEN0b3IgPSBpc0xvb3NlO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSA6IHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAoIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChvYmpDdG9yICE9PSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gK29iamVjdCA9PT0gK290aGVyO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgcmV0dXJuIChvYmplY3QgIT09ICtvYmplY3QpID9cbiAgICAgICAgb3RoZXIgIT09ICtvdGhlciA6XG4gICAgICAgIG9iamVjdCA9PT0gK290aGVyO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSAob3RoZXIgKyAnJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaXNPYmplY3QgPSBSeC5pbnRlcm5hbHMuaXNPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcblxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbnZhciBpc0hvc3RPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0KHsgJ3RvU3RyaW5nJzogMCB9ICsgJycpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiAodmFsdWUgKyAnJykgPT09ICdzdHJpbmcnO1xuICB9O1xufSgpKTtcblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBhcnJheVRhZztcbn07XG5cbmZ1bmN0aW9uIGFycmF5U29tZSAoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKGlzTG9vc2UpIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICBpZiAob2JqVGFnID09PSBhcmdzVGFnKSB7XG4gICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgfSBlbHNlIGlmIChvYmpUYWcgIT09IG9iamVjdFRhZykge1xuICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgIGlmIChvdGhUYWcgPT09IGFyZ3NUYWcpIHtcbiAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICB9XG4gIH1cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgIShvYmpJc0FyciB8fCBvYmpJc09iaikpIHtcbiAgICByZXR1cm4gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcpO1xuICB9XG4gIGlmICghaXNMb29zZSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsIG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PT0gb2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT09IG90aGVyO1xuICAgIH1cbiAgfVxuICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBzdGFja0EucHVzaChvYmplY3QpO1xuICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcblxuICBzdGFja0EucG9wKCk7XG4gIHN0YWNrQi5wb3AoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xufVxuXG52YXIgaXNFcXVhbCA9IFJ4LmludGVybmFscy5pc0VxdWFsID0gZnVuY3Rpb24gKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn07XG5cbiAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIHZhciBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG4gIH07XG5cbiAgdmFyIGFkZFByb3BlcnRpZXMgPSBSeC5pbnRlcm5hbHMuYWRkUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IodmFyIHNvdXJjZXMgPSBbXSwgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxuID0gc291cmNlcy5sZW5ndGg7IGlkeCA8IGxuOyBpZHgrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaWR4XTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUnggVXRpbHNcbiAgdmFyIGFkZFJlZiA9IFJ4LmludGVybmFscy5hZGRSZWYgPSBmdW5jdGlvbiAoeHMsIHIpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoci5nZXREaXNwb3NhYmxlKCksIHhzLnN1YnNjcmliZShvYnNlcnZlcikpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFycmF5SW5pdGlhbGl6ZShjb3VudCwgZmFjdG9yeSkge1xuICAgIHZhciBhID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGFbaV0gPSBmYWN0b3J5KCk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgZnVuY3Rpb24gSW5kZXhlZEl0ZW0oaWQsIHZhbHVlKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIEluZGV4ZWRJdGVtLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgYyA9IHRoaXMudmFsdWUuY29tcGFyZVRvKG90aGVyLnZhbHVlKTtcbiAgICBjID09PSAwICYmIChjID0gdGhpcy5pZCAtIG90aGVyLmlkKTtcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICB2YXIgUHJpb3JpdHlRdWV1ZSA9IFJ4LmludGVybmFscy5Qcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheShjYXBhY2l0eSk7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIHZhciBwcmlvcml0eVByb3RvID0gUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGU7XG4gIHByaW9yaXR5UHJvdG8uaXNIaWdoZXJQcmlvcml0eSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2xlZnRdLmNvbXBhcmVUbyh0aGlzLml0ZW1zW3JpZ2h0XSkgPCAwO1xuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8ucGVyY29sYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoIHx8IGluZGV4IDwgMCkgeyByZXR1cm47IH1cbiAgICB2YXIgcGFyZW50ID0gaW5kZXggLSAxID4+IDE7XG4gICAgaWYgKHBhcmVudCA8IDAgfHwgcGFyZW50ID09PSBpbmRleCkgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5pc0hpZ2hlclByaW9yaXR5KGluZGV4LCBwYXJlbnQpKSB7XG4gICAgICB2YXIgdGVtcCA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB0aGlzLml0ZW1zW3BhcmVudF07XG4gICAgICB0aGlzLml0ZW1zW3BhcmVudF0gPSB0ZW1wO1xuICAgICAgdGhpcy5wZXJjb2xhdGUocGFyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5oZWFwaWZ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgK2luZGV4IHx8IChpbmRleCA9IDApO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHsgcmV0dXJuOyB9XG4gICAgdmFyIGxlZnQgPSAyICogaW5kZXggKyAxLFxuICAgICAgICByaWdodCA9IDIgKiBpbmRleCArIDIsXG4gICAgICAgIGZpcnN0ID0gaW5kZXg7XG4gICAgaWYgKGxlZnQgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLmlzSGlnaGVyUHJpb3JpdHkobGVmdCwgZmlyc3QpKSB7XG4gICAgICBmaXJzdCA9IGxlZnQ7XG4gICAgfVxuICAgIGlmIChyaWdodCA8IHRoaXMubGVuZ3RoICYmIHRoaXMuaXNIaWdoZXJQcmlvcml0eShyaWdodCwgZmlyc3QpKSB7XG4gICAgICBmaXJzdCA9IHJpZ2h0O1xuICAgIH1cbiAgICBpZiAoZmlyc3QgIT09IGluZGV4KSB7XG4gICAgICB2YXIgdGVtcCA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB0aGlzLml0ZW1zW2ZpcnN0XTtcbiAgICAgIHRoaXMuaXRlbXNbZmlyc3RdID0gdGVtcDtcbiAgICAgIHRoaXMuaGVhcGlmeShmaXJzdCk7XG4gICAgfVxuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8ucGVlayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlbXNbMF0udmFsdWU7IH07XG5cbiAgcHJpb3JpdHlQcm90by5yZW1vdmVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdGhpcy5pdGVtc1stLXRoaXMubGVuZ3RoXTtcbiAgICB0aGlzLml0ZW1zW3RoaXMubGVuZ3RoXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlYXBpZnkoKTtcbiAgfTtcblxuICBwcmlvcml0eVByb3RvLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgIHRoaXMucmVtb3ZlQXQoMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBwcmlvcml0eVByb3RvLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5pdGVtc1tpbmRleF0gPSBuZXcgSW5kZXhlZEl0ZW0oUHJpb3JpdHlRdWV1ZS5jb3VudCsrLCBpdGVtKTtcbiAgICB0aGlzLnBlcmNvbGF0ZShpbmRleCk7XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaXRlbXNbaV0udmFsdWUgPT09IGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgUHJpb3JpdHlRdWV1ZS5jb3VudCA9IDA7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBncm91cCBvZiBkaXNwb3NhYmxlIHJlc291cmNlcyB0aGF0IGFyZSBkaXNwb3NlZCB0b2dldGhlci5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgQ29tcG9zaXRlRGlzcG9zYWJsZSA9IFJ4LkNvbXBvc2l0ZURpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSwgbGVuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBhcmdzO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUgPSBDb21wb3NpdGVEaXNwb3NhYmxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQWRkcyBhIGRpc3Bvc2FibGUgdG8gdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUgb3IgZGlzcG9zZXMgdGhlIGRpc3Bvc2FibGUgaWYgdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUgaXMgZGlzcG9zZWQuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gRGlzcG9zYWJsZSB0byBhZGQuXG4gICAqL1xuICBDb21wb3NpdGVEaXNwb3NhYmxlUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgaXRlbS5kaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZXMucHVzaChpdGVtKTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuZCBkaXNwb3NlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIGRpc3Bvc2FibGUgZnJvbSB0aGUgQ29tcG9zaXRlRGlzcG9zYWJsZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gaXRlbSBEaXNwb3NhYmxlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgZm91bmQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgc2hvdWxkRGlzcG9zZSA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5kaXNwb3NhYmxlcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgc2hvdWxkRGlzcG9zZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkRGlzcG9zZTtcbiAgfTtcblxuICAvKipcbiAgICogIERpc3Bvc2VzIGFsbCBkaXNwb3NhYmxlcyBpbiB0aGUgZ3JvdXAgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBncm91cC5cbiAgICovXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRpc3Bvc2FibGVzLmxlbmd0aCwgY3VycmVudERpc3Bvc2FibGVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgY3VycmVudERpc3Bvc2FibGVzW2ldID0gdGhpcy5kaXNwb3NhYmxlc1tpXTsgfVxuICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY3VycmVudERpc3Bvc2FibGVzW2ldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgc2V0IG9mIHN0YXRpYyBtZXRob2RzIGZvciBjcmVhdGluZyBEaXNwb3NhYmxlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcG9zZSBBY3Rpb24gdG8gcnVuIGR1cmluZyB0aGUgZmlyc3QgY2FsbCB0byBkaXNwb3NlLiBUaGUgYWN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgcnVuIGF0IG1vc3Qgb25jZS5cbiAgICovXG4gIHZhciBEaXNwb3NhYmxlID0gUnguRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbiB8fCBub29wO1xuICB9O1xuXG4gIC8qKiBQZXJmb3JtcyB0aGUgdGFzayBvZiBjbGVhbmluZyB1cCByZXNvdXJjZXMuICovXG4gIERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuYWN0aW9uKCk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRpc3Bvc2FibGUgb2JqZWN0IHRoYXQgaW52b2tlcyB0aGUgc3BlY2lmaWVkIGFjdGlvbiB3aGVuIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwb3NlIEFjdGlvbiB0byBydW4gZHVyaW5nIHRoZSBmaXJzdCBjYWxsIHRvIGRpc3Bvc2UuIFRoZSBhY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBiZSBydW4gYXQgbW9zdCBvbmNlLlxuICAgKiBAcmV0dXJuIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdGhhdCBydW5zIHRoZSBnaXZlbiBhY3Rpb24gdXBvbiBkaXNwb3NhbC5cbiAgICovXG4gIHZhciBkaXNwb3NhYmxlQ3JlYXRlID0gRGlzcG9zYWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXcgRGlzcG9zYWJsZShhY3Rpb24pOyB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkaXNwb3NhYmxlIHRoYXQgZG9lcyBub3RoaW5nIHdoZW4gZGlzcG9zZWQuXG4gICAqL1xuICB2YXIgZGlzcG9zYWJsZUVtcHR5ID0gRGlzcG9zYWJsZS5lbXB0eSA9IHsgZGlzcG9zZTogbm9vcCB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgZGlzcG9zYWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIHRlc3Qgd2hldGhlciBpdCBoYXMgYSBkaXNwb3NlIG1ldGhvZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGRpc3Bvc2FibGUgb2JqZWN0LCBlbHNlIGZhbHNlLlxuICAgKi9cbiAgdmFyIGlzRGlzcG9zYWJsZSA9IERpc3Bvc2FibGUuaXNEaXNwb3NhYmxlID0gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZCAmJiBpc0Z1bmN0aW9uKGQuZGlzcG9zZSk7XG4gIH07XG5cbiAgdmFyIGNoZWNrRGlzcG9zZWQgPSBEaXNwb3NhYmxlLmNoZWNrRGlzcG9zZWQgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgIGlmIChkaXNwb3NhYmxlLmlzRGlzcG9zZWQpIHsgdGhyb3cgbmV3IE9iamVjdERpc3Bvc2VkRXJyb3IoKTsgfVxuICB9O1xuXG4gIHZhciBkaXNwb3NhYmxlRml4dXAgPSBEaXNwb3NhYmxlLl9maXh1cCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gaXNEaXNwb3NhYmxlKHJlc3VsdCkgPyByZXN1bHQgOiBkaXNwb3NhYmxlRW1wdHk7XG4gIH07XG5cbiAgLy8gU2luZ2xlIGFzc2lnbm1lbnRcbiAgdmFyIFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlID0gUnguU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgfTtcbiAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUucHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcbiAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUucHJvdG90eXBlLnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7IHRocm93IG5ldyBFcnJvcignRGlzcG9zYWJsZSBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkJyk7IH1cbiAgICB2YXIgc2hvdWxkRGlzcG9zZSA9IHRoaXMuaXNEaXNwb3NlZDtcbiAgICAhc2hvdWxkRGlzcG9zZSAmJiAodGhpcy5jdXJyZW50ID0gdmFsdWUpO1xuICAgIHNob3VsZERpc3Bvc2UgJiYgdmFsdWUgJiYgdmFsdWUuZGlzcG9zZSgpO1xuICB9O1xuICBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgb2xkICYmIG9sZC5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE11bHRpcGxlIGFzc2lnbm1lbnQgZGlzcG9zYWJsZVxuICB2YXIgU2VyaWFsRGlzcG9zYWJsZSA9IFJ4LlNlcmlhbERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgfTtcbiAgU2VyaWFsRGlzcG9zYWJsZS5wcm90b3R5cGUuZ2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuICBTZXJpYWxEaXNwb3NhYmxlLnByb3RvdHlwZS5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHNob3VsZERpc3Bvc2UgPSB0aGlzLmlzRGlzcG9zZWQ7XG4gICAgaWYgKCFzaG91bGREaXNwb3NlKSB7XG4gICAgICB2YXIgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgICAgdGhpcy5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIG9sZCAmJiBvbGQuZGlzcG9zZSgpO1xuICAgIHNob3VsZERpc3Bvc2UgJiYgdmFsdWUgJiYgdmFsdWUuZGlzcG9zZSgpO1xuICB9O1xuICBTZXJpYWxEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgdmFyIG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIG9sZCAmJiBvbGQuZGlzcG9zZSgpO1xuICB9O1xuXG4gIHZhciBCaW5hcnlEaXNwb3NhYmxlID0gUnguQmluYXJ5RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgdGhpcy5fZmlyc3QgPSBmaXJzdDtcbiAgICB0aGlzLl9zZWNvbmQgPSBzZWNvbmQ7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH07XG5cbiAgQmluYXJ5RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBvbGQxID0gdGhpcy5fZmlyc3Q7XG4gICAgICB0aGlzLl9maXJzdCA9IG51bGw7XG4gICAgICBvbGQxICYmIG9sZDEuZGlzcG9zZSgpO1xuICAgICAgdmFyIG9sZDIgPSB0aGlzLl9zZWNvbmQ7XG4gICAgICB0aGlzLl9zZWNvbmQgPSBudWxsO1xuICAgICAgb2xkMiAmJiBvbGQyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIE5BcnlEaXNwb3NhYmxlID0gUnguTkFyeURpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZXMpIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IGRpc3Bvc2FibGVzO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9O1xuXG4gIE5BcnlEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2Rpc3Bvc2FibGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzW2ldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSB0aGF0IG9ubHkgZGlzcG9zZXMgaXRzIHVuZGVybHlpbmcgZGlzcG9zYWJsZSByZXNvdXJjZSB3aGVuIGFsbCBkZXBlbmRlbnQgZGlzcG9zYWJsZSBvYmplY3RzIGhhdmUgYmVlbiBkaXNwb3NlZC5cbiAgICovXG4gIHZhciBSZWZDb3VudERpc3Bvc2FibGUgPSBSeC5SZWZDb3VudERpc3Bvc2FibGUgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24gSW5uZXJEaXNwb3NhYmxlKGRpc3Bvc2FibGUpIHtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGU7XG4gICAgICB0aGlzLmRpc3Bvc2FibGUuY291bnQrKztcbiAgICAgIHRoaXMuaXNJbm5lckRpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgSW5uZXJEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCAmJiAhdGhpcy5pc0lubmVyRGlzcG9zZWQpIHtcbiAgICAgICAgdGhpcy5pc0lubmVyRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUuY291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zYWJsZS5jb3VudCA9PT0gMCAmJiB0aGlzLmRpc3Bvc2FibGUuaXNQcmltYXJ5RGlzcG9zZWQpIHtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXNwb3NhYmxlLnVuZGVybHlpbmdEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUmVmQ291bnREaXNwb3NhYmxlIHdpdGggdGhlIHNwZWNpZmllZCBkaXNwb3NhYmxlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gZGlzcG9zYWJsZSBVbmRlcmx5aW5nIGRpc3Bvc2FibGUuXG4gICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50RGlzcG9zYWJsZShkaXNwb3NhYmxlKSB7XG4gICAgICB0aGlzLnVuZGVybHlpbmdEaXNwb3NhYmxlID0gZGlzcG9zYWJsZTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZSBvbmx5IHdoZW4gYWxsIGRlcGVuZGVudCBkaXNwb3NhYmxlcyBoYXZlIGJlZW4gZGlzcG9zZWRcbiAgICAgKi9cbiAgICBSZWZDb3VudERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCAmJiAhdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzUHJpbWFyeURpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudW5kZXJseWluZ0Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkZXBlbmRlbnQgZGlzcG9zYWJsZSB0aGF0IHdoZW4gZGlzcG9zZWQgZGVjcmVhc2VzIHRoZSByZWZjb3VudCBvbiB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRlcGVuZGVudCBkaXNwb3NhYmxlIGNvbnRyaWJ1dGluZyB0byB0aGUgcmVmZXJlbmNlIGNvdW50IHRoYXQgbWFuYWdlcyB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlJ3MgbGlmZXRpbWUuXG4gICAgICovXG4gICAgUmVmQ291bnREaXNwb3NhYmxlLnByb3RvdHlwZS5nZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNEaXNwb3NlZCA/IGRpc3Bvc2FibGVFbXB0eSA6IG5ldyBJbm5lckRpc3Bvc2FibGUodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZWZDb3VudERpc3Bvc2FibGU7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gU2NoZWR1bGVkRGlzcG9zYWJsZShzY2hlZHVsZXIsIGRpc3Bvc2FibGUpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLmRpc3Bvc2FibGUgPSBkaXNwb3NhYmxlO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVJdGVtKHMsIHNlbGYpIHtcbiAgICBpZiAoIXNlbGYuaXNEaXNwb3NlZCkge1xuICAgICAgc2VsZi5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHNlbGYuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgU2NoZWR1bGVkRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBzY2hlZHVsZUl0ZW0pO1xuICB9O1xuXG4gIHZhciBTY2hlZHVsZWRJdGVtID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlZEl0ZW0gPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBzdGF0ZSwgYWN0aW9uLCBkdWVUaW1lLCBjb21wYXJlcikge1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlciB8fCBkZWZhdWx0U3ViQ29tcGFyZXI7XG4gICAgdGhpcy5kaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gIH07XG5cbiAgU2NoZWR1bGVkSXRlbS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKHRoaXMuaW52b2tlQ29yZSgpKTtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlcih0aGlzLmR1ZVRpbWUsIG90aGVyLmR1ZVRpbWUpO1xuICB9O1xuXG4gIFNjaGVkdWxlZEl0ZW0ucHJvdG90eXBlLmlzQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZDtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5pbnZva2VDb3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwb3NhYmxlRml4dXAodGhpcy5hY3Rpb24odGhpcy5zY2hlZHVsZXIsIHRoaXMuc3RhdGUpKTtcbiAgfTtcblxuICAvKiogUHJvdmlkZXMgYSBzZXQgb2Ygc3RhdGljIHByb3BlcnRpZXMgdG8gYWNjZXNzIGNvbW1vbmx5IHVzZWQgc2NoZWR1bGVycy4gKi9cbiAgdmFyIFNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7IH1cblxuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHNjaGVkdWxlciAqL1xuICAgIFNjaGVkdWxlci5pc1NjaGVkdWxlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcyBpbnN0YW5jZW9mIFNjaGVkdWxlcjtcbiAgICB9O1xuXG4gICAgdmFyIHNjaGVkdWxlclByb3RvID0gU2NoZWR1bGVyLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGR1ZVRpbWUuXG4gICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgUmVsYXRpdmUgdGltZSBhZnRlciB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdmFyIGR0ID0gZHVlVGltZTtcbiAgICAgIGR0IGluc3RhbmNlb2YgRGF0ZSAmJiAoZHQgPSBkdCAtIHRoaXMubm93KCkpO1xuICAgICAgZHQgPSBTY2hlZHVsZXIubm9ybWFsaXplKGR0KTtcblxuICAgICAgaWYgKGR0ID09PSAwKSB7IHJldHVybiB0aGlzLnNjaGVkdWxlKHN0YXRlLCBhY3Rpb24pOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZUZ1dHVyZShzdGF0ZSwgZHQsIGFjdGlvbik7XG4gICAgfTtcblxuICAgIHNjaGVkdWxlclByb3RvLl9zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG5cbiAgICAvKiogR2V0cyB0aGUgY3VycmVudCB0aW1lIGFjY29yZGluZyB0byB0aGUgbG9jYWwgbWFjaGluZSdzIHN5c3RlbSBjbG9jay4gKi9cbiAgICBTY2hlZHVsZXIubm93ID0gZGVmYXVsdE5vdztcblxuICAgIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbCBtYWNoaW5lJ3Mgc3lzdGVtIGNsb2NrLiAqL1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUubm93ID0gZGVmYXVsdE5vdztcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBUaW1lU3BhbiB2YWx1ZSB0byBhIHBvc2l0aXZlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBUaGUgdGltZSBzcGFuIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3BlY2lmaWVkIFRpbWVTcGFuIHZhbHVlIGlmIGl0IGlzIHplcm8gb3IgcG9zaXRpdmU7IG90aGVyd2lzZSwgMFxuICAgICAqL1xuICAgIFNjaGVkdWxlci5ub3JtYWxpemUgPSBmdW5jdGlvbiAodGltZVNwYW4pIHtcbiAgICAgIHRpbWVTcGFuIDwgMCAmJiAodGltZVNwYW4gPSAwKTtcbiAgICAgIHJldHVybiB0aW1lU3BhbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjaGVkdWxlcjtcbiAgfSgpKTtcblxuICB2YXIgbm9ybWFsaXplVGltZSA9IFNjaGVkdWxlci5ub3JtYWxpemUsIGlzU2NoZWR1bGVyID0gU2NoZWR1bGVyLmlzU2NoZWR1bGVyO1xuXG4gIChmdW5jdGlvbiAoc2NoZWR1bGVyUHJvdG8pIHtcblxuICAgIGZ1bmN0aW9uIGludm9rZVJlY0ltbWVkaWF0ZShzY2hlZHVsZXIsIHBhaXIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHBhaXJbMF0sIGFjdGlvbiA9IHBhaXJbMV0sIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGFjdGlvbihzdGF0ZSwgaW5uZXJBY3Rpb24pO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuXG4gICAgICBmdW5jdGlvbiBpbm5lckFjdGlvbihzdGF0ZTIpIHtcbiAgICAgICAgdmFyIGlzQWRkZWQgPSBmYWxzZSwgaXNEb25lID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGQgPSBzY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUyLCBzY2hlZHVsZVdvcmspO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIGdyb3VwLmFkZChkKTtcbiAgICAgICAgICBpc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhfLCBzdGF0ZTMpIHtcbiAgICAgICAgICBpZiAoaXNBZGRlZCkge1xuICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb24oc3RhdGUzLCBpbm5lckFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZVJlY0RhdGUoc2NoZWR1bGVyLCBwYWlyKSB7XG4gICAgICB2YXIgc3RhdGUgPSBwYWlyWzBdLCBhY3Rpb24gPSBwYWlyWzFdLCBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBhY3Rpb24oc3RhdGUsIGlubmVyQWN0aW9uKTtcbiAgICAgIHJldHVybiBncm91cDtcblxuICAgICAgZnVuY3Rpb24gaW5uZXJBY3Rpb24oc3RhdGUyLCBkdWVUaW1lMSkge1xuICAgICAgICB2YXIgaXNBZGRlZCA9IGZhbHNlLCBpc0RvbmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZCA9IHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShzdGF0ZTIsIGR1ZVRpbWUxLCBzY2hlZHVsZVdvcmspO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIGdyb3VwLmFkZChkKTtcbiAgICAgICAgICBpc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhfLCBzdGF0ZTMpIHtcbiAgICAgICAgICBpZiAoaXNBZGRlZCkge1xuICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb24oc3RhdGUzLCBpbm5lckFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgcmVjdXJzaXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBleGVjdXRlIHJlY3Vyc2l2ZWx5LiBUaGUgbGFzdCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBhY3Rpb24gaXMgdXNlZCB0byB0cmlnZ2VyIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nIG9mIHRoZSBhY3Rpb24sIHBhc3NpbmcgaW4gcmVjdXJzaXZlIGludm9jYXRpb24gc3RhdGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUmVjdXJzaXZlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKFtzdGF0ZSwgYWN0aW9uXSwgaW52b2tlUmVjSW1tZWRpYXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCByZWN1cnNpdmVseSBhZnRlciBhIHNwZWNpZmllZCByZWxhdGl2ZSBvciBhYnNvbHV0ZSBkdWUgdGltZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGV4ZWN1dGUgcmVjdXJzaXZlbHkuIFRoZSBsYXN0IHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGFjdGlvbiBpcyB1c2VkIHRvIHRyaWdnZXIgcmVjdXJzaXZlIHNjaGVkdWxpbmcgb2YgdGhlIGFjdGlvbiwgcGFzc2luZyBpbiB0aGUgcmVjdXJzaXZlIGR1ZSB0aW1lIGFuZCBpbnZvY2F0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyIHwgRGF0ZX0gZHVlVGltZSBSZWxhdGl2ZSBvciBhYnNvbHV0ZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlRnV0dXJlKFtzdGF0ZSwgYWN0aW9uXSwgZHVlVGltZSwgaW52b2tlUmVjRGF0ZSk7XG4gICAgfTtcblxuICB9KFNjaGVkdWxlci5wcm90b3R5cGUpKTtcblxuICAoZnVuY3Rpb24gKHNjaGVkdWxlclByb3RvKSB7XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBwZXJpb2RpYyBwaWVjZSBvZiB3b3JrIGJ5IGR5bmFtaWNhbGx5IGRpc2NvdmVyaW5nIHRoZSBzY2hlZHVsZXIncyBjYXBhYmlsaXRpZXMuIFRoZSBwZXJpb2RpYyB0YXNrIHdpbGwgYmUgc2NoZWR1bGVkIHVzaW5nIHdpbmRvdy5zZXRJbnRlcnZhbCBmb3IgdGhlIGJhc2UgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB1cG9uIHRoZSBmaXJzdCBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZCBQZXJpb2QgZm9yIHJ1bm5pbmcgdGhlIHdvcmsgcGVyaW9kaWNhbGx5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQsIHBvdGVudGlhbGx5IHVwZGF0aW5nIHRoZSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVjdXJyaW5nIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUGVyaW9kaWMgPSBmdW5jdGlvbihzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2Ygcm9vdC5zZXRJbnRlcnZhbCA9PT0gJ3VuZGVmaW5lZCcpIHsgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCk7IH1cbiAgICAgIHBlcmlvZCA9IG5vcm1hbGl6ZVRpbWUocGVyaW9kKTtcbiAgICAgIHZhciBzID0gc3RhdGUsIGlkID0gcm9vdC5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHMgPSBhY3Rpb24ocyk7IH0sIHBlcmlvZCk7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7IHJvb3QuY2xlYXJJbnRlcnZhbChpZCk7IH0pO1xuICAgIH07XG5cbiAgfShTY2hlZHVsZXIucHJvdG90eXBlKSk7XG5cbiAgKGZ1bmN0aW9uIChzY2hlZHVsZXJQcm90bykge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzY2hlZHVsZXIgdGhhdCB3cmFwcyB0aGUgb3JpZ2luYWwgc2NoZWR1bGVyLCBhZGRpbmcgZXhjZXB0aW9uIGhhbmRsaW5nIGZvciBzY2hlZHVsZWQgYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEhhbmRsZXIgdGhhdCdzIHJ1biBpZiBhbiBleGNlcHRpb24gaXMgY2F1Z2h0LiBUaGUgZXhjZXB0aW9uIHdpbGwgYmUgcmV0aHJvd24gaWYgdGhlIGhhbmRsZXIgcmV0dXJucyBmYWxzZS5cbiAgICAgKiBAcmV0dXJucyB7U2NoZWR1bGVyfSBXcmFwcGVyIGFyb3VuZCB0aGUgb3JpZ2luYWwgc2NoZWR1bGVyLCBlbmZvcmNpbmcgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLmNhdGNoRXJyb3IgPSBzY2hlZHVsZXJQcm90b1snY2F0Y2gnXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gbmV3IENhdGNoU2NoZWR1bGVyKHRoaXMsIGhhbmRsZXIpO1xuICAgIH07XG4gIH0oU2NoZWR1bGVyLnByb3RvdHlwZSkpO1xuXG4gIHZhciBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRpY2soc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRpY2soY29tbWFuZCwgcmVjdXJzZSkge1xuICAgICAgICByZWN1cnNlKDAsIHNlbGYuX3BlcmlvZCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRyeUNhdGNoKHNlbGYuX2FjdGlvbikoc2VsZi5fc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgc2VsZi5fY2FuY2VsLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aHJvd2VyKHN0YXRlLmUpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX3N0YXRlID0gc3RhdGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUoc2NoZWR1bGVyLCBzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuXG4gICAgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgdGhpcy5fY2FuY2VsID0gZDtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUoMCwgdGhpcy5fcGVyaW9kLCBjcmVhdGVUaWNrKHRoaXMpKSk7XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZTtcbiAgfSgpKTtcblxuICAvKiogR2V0cyBhIHNjaGVkdWxlciB0aGF0IHNjaGVkdWxlcyB3b3JrIGltbWVkaWF0ZWx5IG9uIHRoZSBjdXJyZW50IHRocmVhZC4gKi9cbiAgIHZhciBJbW1lZGlhdGVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEltbWVkaWF0ZVNjaGVkdWxlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbW1lZGlhdGVTY2hlZHVsZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbW1lZGlhdGVTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRml4dXAoYWN0aW9uKHRoaXMsIHN0YXRlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbW1lZGlhdGVTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgdmFyIGltbWVkaWF0ZVNjaGVkdWxlciA9IFNjaGVkdWxlci5pbW1lZGlhdGUgPSBuZXcgSW1tZWRpYXRlU2NoZWR1bGVyKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzY2hlZHVsZXIgdGhhdCBzY2hlZHVsZXMgd29yayBhcyBzb29uIGFzIHBvc3NpYmxlIG9uIHRoZSBjdXJyZW50IHRocmVhZC5cbiAgICovXG4gIHZhciBDdXJyZW50VGhyZWFkU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICB2YXIgcXVldWU7XG5cbiAgICBmdW5jdGlvbiBydW5UcmFtcG9saW5lICgpIHtcbiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAhaXRlbS5pc0NhbmNlbGxlZCgpICYmIGl0ZW0uaW52b2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoQ3VycmVudFRocmVhZFNjaGVkdWxlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDdXJyZW50VGhyZWFkU2NoZWR1bGVyKCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ3VycmVudFRocmVhZFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgdmFyIHNpID0gbmV3IFNjaGVkdWxlZEl0ZW0odGhpcywgc3RhdGUsIGFjdGlvbiwgdGhpcy5ub3coKSk7XG5cbiAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSg0KTtcbiAgICAgICAgcXVldWUuZW5xdWV1ZShzaSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJ1blRyYW1wb2xpbmUpKCk7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgdGhyb3dlcihyZXN1bHQuZSk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlLmVucXVldWUoc2kpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpLmRpc3Bvc2FibGU7XG4gICAgfTtcblxuICAgIEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlUmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhcXVldWU7IH07XG5cbiAgICByZXR1cm4gQ3VycmVudFRocmVhZFNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICB2YXIgY3VycmVudFRocmVhZFNjaGVkdWxlciA9IFNjaGVkdWxlci5jdXJyZW50VGhyZWFkID0gbmV3IEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIoKTtcblxuICB2YXIgc2NoZWR1bGVNZXRob2QsIGNsZWFyTWV0aG9kO1xuXG4gIHZhciBsb2NhbFRpbWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG9jYWxTZXRUaW1lb3V0LCBsb2NhbENsZWFyVGltZW91dCA9IG5vb3A7XG4gICAgaWYgKCEhcm9vdC5zZXRUaW1lb3V0KSB7XG4gICAgICBsb2NhbFNldFRpbWVvdXQgPSByb290LnNldFRpbWVvdXQ7XG4gICAgICBsb2NhbENsZWFyVGltZW91dCA9IHJvb3QuY2xlYXJUaW1lb3V0O1xuICAgIH0gZWxzZSBpZiAoISFyb290LldTY3JpcHQpIHtcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xuICAgICAgICByb290LldTY3JpcHQuU2xlZXAodGltZSk7XG4gICAgICAgIGZuKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2V0VGltZW91dDogbG9jYWxTZXRUaW1lb3V0LFxuICAgICAgY2xlYXJUaW1lb3V0OiBsb2NhbENsZWFyVGltZW91dFxuICAgIH07XG4gIH0oKSk7XG4gIHZhciBsb2NhbFNldFRpbWVvdXQgPSBsb2NhbFRpbWVyLnNldFRpbWVvdXQsXG4gICAgbG9jYWxDbGVhclRpbWVvdXQgPSBsb2NhbFRpbWVyLmNsZWFyVGltZW91dDtcblxuICAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxLCB0YXNrc0J5SGFuZGxlID0ge30sIGN1cnJlbnRseVJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIGNsZWFyTWV0aG9kID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhoYW5kbGUpIHtcbiAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nKSB7XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJ1blRhc2soaGFuZGxlKTsgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGFzaykoKTtcbiAgICAgICAgICBjbGVhck1ldGhvZChoYW5kbGUpO1xuICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyB0aHJvd2VyKHJlc3VsdC5lKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlTmF0aXZlID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICB2YXIgc2V0SW1tZWRpYXRlID0gdHlwZW9mIChzZXRJbW1lZGlhdGUgPSBmcmVlR2xvYmFsICYmIG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5zZXRJbW1lZGlhdGUpID09ICdmdW5jdGlvbicgJiZcbiAgICAgICFyZU5hdGl2ZS50ZXN0KHNldEltbWVkaWF0ZSkgJiYgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgKCkge1xuICAgICAgLy8gRW5zdXJlIG5vdCBpbiBhIHdvcmtlclxuICAgICAgaWYgKCFyb290LnBvc3RNZXNzYWdlIHx8IHJvb3QuaW1wb3J0U2NyaXB0cykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHZhciBpc0FzeW5jID0gZmFsc2UsIG9sZEhhbmRsZXIgPSByb290Lm9ubWVzc2FnZTtcbiAgICAgIC8vIFRlc3QgZm9yIGFzeW5jXG4gICAgICByb290Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHsgaXNBc3luYyA9IHRydWU7IH07XG4gICAgICByb290LnBvc3RNZXNzYWdlKCcnLCAnKicpO1xuICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBvbGRIYW5kbGVyO1xuXG4gICAgICByZXR1cm4gaXNBc3luYztcbiAgICB9XG5cbiAgICAvLyBVc2UgaW4gb3JkZXIsIHNldEltbWVkaWF0ZSwgbmV4dFRpY2ssIHBvc3RNZXNzYWdlLCBNZXNzYWdlQ2hhbm5lbCwgc2NyaXB0IHJlYWR5c3RhdGVjaGFuZ2VkLCBzZXRUaW1lb3V0XG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0SW1tZWRpYXRlKSkge1xuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7IHJ1blRhc2soaWQpOyB9KTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5UYXNrKGlkKTsgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBvc3RNZXNzYWdlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHZhciBNU0dfUFJFRklYID0gJ21zLnJ4LnNjaGVkdWxlJyArIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgIHZhciBvbkdsb2JhbFBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE9ubHkgaWYgd2UncmUgYSBtYXRjaCB0byBhdm9pZCBhbnkgb3RoZXIgZ2xvYmFsIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnICYmIGV2ZW50LmRhdGEuc3Vic3RyaW5nKDAsIE1TR19QUkVGSVgubGVuZ3RoKSA9PT0gTVNHX1BSRUZJWCkge1xuICAgICAgICAgIHJ1blRhc2soZXZlbnQuZGF0YS5zdWJzdHJpbmcoTVNHX1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25HbG9iYWxQb3N0TWVzc2FnZSwgZmFsc2UpO1xuXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcbiAgICAgICAgcm9vdC5wb3N0TWVzc2FnZShNU0dfUFJFRklYICsgaWQsICcqJyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghIXJvb3QuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IHJvb3QuTWVzc2FnZUNoYW5uZWwoKTtcblxuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkgeyBydW5UYXNrKGUuZGF0YSk7IH07XG5cbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGlkKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gcm9vdCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiByb290LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgc2NyaXB0RWxlbWVudCA9IHJvb3QuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG5cbiAgICAgICAgc2NyaXB0RWxlbWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcnVuVGFzayhpZCk7XG4gICAgICAgICAgc2NyaXB0RWxlbWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgIHNjcmlwdEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICAgICAgICBzY3JpcHRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcm9vdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcnVuVGFzayhpZCk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfVxuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgc2NoZWR1bGVyIHRoYXQgc2NoZWR1bGVzIHdvcmsgdmlhIGEgdGltZWQgY2FsbGJhY2sgYmFzZWQgdXBvbiBwbGF0Zm9ybS5cbiAgICovXG4gICB2YXIgRGVmYXVsdFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgIGluaGVyaXRzKERlZmF1bHRTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG4gICAgIGZ1bmN0aW9uIERlZmF1bHRTY2hlZHVsZXIoKSB7XG4gICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgIH1cblxuICAgICBmdW5jdGlvbiBzY2hlZHVsZUFjdGlvbihkaXNwb3NhYmxlLCBhY3Rpb24sIHNjaGVkdWxlciwgc3RhdGUpIHtcbiAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgICAgICBkaXNwb3NhYmxlLnNldERpc3Bvc2FibGUoRGlzcG9zYWJsZS5fZml4dXAoYWN0aW9uKHNjaGVkdWxlciwgc3RhdGUpKSk7XG4gICAgICAgfTtcbiAgICAgfVxuXG4gICAgIGZ1bmN0aW9uIENsZWFyRGlzcG9zYWJsZShpZCkge1xuICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgIH1cblxuICAgICBDbGVhckRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICBjbGVhck1ldGhvZCh0aGlzLl9pZCk7XG4gICAgICAgfVxuICAgICB9O1xuXG4gICAgIGZ1bmN0aW9uIExvY2FsQ2xlYXJEaXNwb3NhYmxlKGlkKSB7XG4gICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgfVxuXG4gICAgIExvY2FsQ2xlYXJEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGhpcy5faWQpO1xuICAgICAgIH1cbiAgICAgfTtcblxuICAgIERlZmF1bHRTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgICAgaWQgPSBzY2hlZHVsZU1ldGhvZChzY2hlZHVsZUFjdGlvbihkaXNwb3NhYmxlLCBhY3Rpb24sIHRoaXMsIHN0YXRlKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoZGlzcG9zYWJsZSwgbmV3IENsZWFyRGlzcG9zYWJsZShpZCkpO1xuICAgIH07XG5cbiAgICBEZWZhdWx0U2NoZWR1bGVyLnByb3RvdHlwZS5fc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgaWYgKGR1ZVRpbWUgPT09IDApIHsgcmV0dXJuIHRoaXMuc2NoZWR1bGUoc3RhdGUsIGFjdGlvbik7IH1cbiAgICAgIHZhciBkaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgICAgaWQgPSBsb2NhbFNldFRpbWVvdXQoc2NoZWR1bGVBY3Rpb24oZGlzcG9zYWJsZSwgYWN0aW9uLCB0aGlzLCBzdGF0ZSksIGR1ZVRpbWUpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGRpc3Bvc2FibGUsIG5ldyBMb2NhbENsZWFyRGlzcG9zYWJsZShpZCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUxvbmdSdW5uaW5nKHN0YXRlLCBhY3Rpb24sIGRpc3Bvc2FibGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGFjdGlvbihzdGF0ZSwgZGlzcG9zYWJsZSk7IH07XG4gICAgfVxuXG4gICAgRGVmYXVsdFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVMb25nUnVubmluZyA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVDcmVhdGUobm9vcCk7XG4gICAgICBzY2hlZHVsZU1ldGhvZChzY2hlZHVsZUxvbmdSdW5uaW5nKHN0YXRlLCBhY3Rpb24sIGRpc3Bvc2FibGUpKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVmYXVsdFNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICB2YXIgZGVmYXVsdFNjaGVkdWxlciA9IFNjaGVkdWxlclsnZGVmYXVsdCddID0gU2NoZWR1bGVyLmFzeW5jID0gbmV3IERlZmF1bHRTY2hlZHVsZXIoKTtcblxuICB2YXIgQ2F0Y2hTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENhdGNoU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQ2F0Y2hTY2hlZHVsZXIoc2NoZWR1bGVyLCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZU9yaWdpbmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZVdyYXBwZXIgPSBudWxsO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHRoaXMuX3dyYXAoYWN0aW9uKSk7XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgZHVlVGltZSwgdGhpcy5fd3JhcChhY3Rpb24pKTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5ub3coKTsgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2F0Y2hTY2hlZHVsZXIoc2NoZWR1bGVyLCB0aGlzLl9oYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYsIHN0YXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaChhY3Rpb24pKHBhcmVudC5fZ2V0UmVjdXJzaXZlV3JhcHBlcihzZWxmKSwgc3RhdGUpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikge1xuICAgICAgICAgIGlmICghcGFyZW50Ll9oYW5kbGVyKHJlcy5lKSkgeyB0aHJvd2VyKHJlcy5lKTsgfVxuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVGaXh1cChyZXMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl9nZXRSZWN1cnNpdmVXcmFwcGVyID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgaWYgKHRoaXMuX3JlY3Vyc2l2ZU9yaWdpbmFsICE9PSBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlT3JpZ2luYWwgPSBzY2hlZHVsZXI7XG4gICAgICAgIHZhciB3cmFwcGVyID0gdGhpcy5fY2xvbmUoc2NoZWR1bGVyKTtcbiAgICAgICAgd3JhcHBlci5fcmVjdXJzaXZlT3JpZ2luYWwgPSBzY2hlZHVsZXI7XG4gICAgICAgIHdyYXBwZXIuX3JlY3Vyc2l2ZVdyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVXcmFwcGVyID0gd3JhcHBlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZWN1cnNpdmVXcmFwcGVyO1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVQZXJpb2RpYyA9IGZ1bmN0aW9uIChzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgZmFpbGVkID0gZmFsc2UsIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgZC5zZXREaXNwb3NhYmxlKHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVBlcmlvZGljKHN0YXRlLCBwZXJpb2QsIGZ1bmN0aW9uIChzdGF0ZTEpIHtcbiAgICAgICAgaWYgKGZhaWxlZCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2goYWN0aW9uKShzdGF0ZTEpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVyKHJlcy5lKSkgeyB0aHJvd2VyKHJlcy5lKTsgfVxuICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2F0Y2hTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXByZXNlbnRzIGEgbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxuICAgKi9cbiAgdmFyIE5vdGlmaWNhdGlvbiA9IFJ4Lk5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKCkge1xuXG4gICAgfVxuXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcblxuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdE9ic2VydmVyID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGRlbGVnYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5vdGlmaWNhdGlvbiBvciB0aGUgb2JzZXJ2ZXIncyBtZXRob2QgY29ycmVzcG9uZGluZyB0byB0aGUgbm90aWZpY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBwcm9kdWNlZCByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbiB8IE9ic2VydmVyfSBvYnNlcnZlck9yT25OZXh0IEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgYW4gT25OZXh0IG5vdGlmaWNhdGlvbiBvciBPYnNlcnZlciB0byBpbnZva2UgdGhlIG5vdGlmaWNhdGlvbiBvbi4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBGdW5jdGlvbiB0byBpbnZva2UgZm9yIGFuIE9uRXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgYW4gT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBbnl9IFJlc3VsdCBwcm9kdWNlZCBieSB0aGUgb2JzZXJ2YXRpb24uXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlck9yT25OZXh0ICYmIHR5cGVvZiBvYnNlcnZlck9yT25OZXh0ID09PSAnb2JqZWN0JyA/XG4gICAgICAgIHRoaXMuX2FjY2VwdE9ic2VydmVyKG9ic2VydmVyT3JPbk5leHQpIDpcbiAgICAgICAgdGhpcy5fYWNjZXB0KG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIE5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHNlbmQgb3V0IHRoZSBub3RpZmljYXRpb24gY2FsbHMgb24uXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc3VyZmFjZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBub3RpZmljYXRpb24gdXBvbiBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoc2VsZiwgZnVuY3Rpb24gKF8sIG5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbi5fYWNjZXB0T2JzZXJ2ZXIobyk7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLmtpbmQgPT09ICdOJyAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBOb3RpZmljYXRpb247XG4gIH0pKCk7XG5cbiAgdmFyIE9uTmV4dE5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25OZXh0Tm90aWZpY2F0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uTmV4dE5vdGlmaWNhdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5raW5kID0gJ04nO1xuICAgIH1cblxuICAgIE9uTmV4dE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIChvbk5leHQpIHtcbiAgICAgIHJldHVybiBvbk5leHQodGhpcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIE9uTmV4dE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdE9ic2VydmVyID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLm9uTmV4dCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgT25OZXh0Tm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnT25OZXh0KCcgKyB0aGlzLnZhbHVlICsgJyknO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25OZXh0Tm90aWZpY2F0aW9uO1xuICB9KE5vdGlmaWNhdGlvbikpO1xuXG4gIHZhciBPbkVycm9yTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPbkVycm9yTm90aWZpY2F0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JOb3RpZmljYXRpb24oZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIHRoaXMua2luZCA9ICdFJztcbiAgICB9XG5cbiAgICBPbkVycm9yTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvcikge1xuICAgICAgcmV0dXJuIG9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgfTtcblxuICAgIE9uRXJyb3JOb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHRPYnNlcnZlciA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5vbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgIH07XG5cbiAgICBPbkVycm9yTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnT25FcnJvcignICsgdGhpcy5lcnJvciArICcpJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9uRXJyb3JOb3RpZmljYXRpb247XG4gIH0oTm90aWZpY2F0aW9uKSk7XG5cbiAgdmFyIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbiwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbigpIHtcbiAgICAgIHRoaXMua2luZCA9ICdDJztcbiAgICB9XG5cbiAgICBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm4gb25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgT25Db21wbGV0ZWROb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHRPYnNlcnZlciA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ09uQ29tcGxldGVkKCknO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25Db21wbGV0ZWROb3RpZmljYXRpb247XG4gIH0oTm90aWZpY2F0aW9uKSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBPbk5leHQgbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxuICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIGNvbnRhaW5lZCBpbiB0aGUgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25OZXh0IG5vdGlmaWNhdGlvbiBjb250YWluaW5nIHRoZSB2YWx1ZS5cbiAgICovXG4gIHZhciBub3RpZmljYXRpb25DcmVhdGVPbk5leHQgPSBOb3RpZmljYXRpb24uY3JlYXRlT25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPbk5leHROb3RpZmljYXRpb24odmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gT25FcnJvciBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7QW55fSBlcnJvciBUaGUgZXhjZXB0aW9uIGNvbnRhaW5lZCBpbiB0aGUgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25FcnJvciBub3RpZmljYXRpb24gY29udGFpbmluZyB0aGUgZXhjZXB0aW9uLlxuICAgKi9cbiAgdmFyIG5vdGlmaWNhdGlvbkNyZWF0ZU9uRXJyb3IgPSBOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBuZXcgT25FcnJvck5vdGlmaWNhdGlvbihlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIHtOb3RpZmljYXRpb259IFRoZSBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24uXG4gICAqL1xuICB2YXIgbm90aWZpY2F0aW9uQ3JlYXRlT25Db21wbGV0ZWQgPSBOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdXBwb3J0cyBwdXNoLXN0eWxlIGl0ZXJhdGlvbiBvdmVyIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqL1xuICB2YXIgT2JzZXJ2ZXIgPSBSeC5PYnNlcnZlciA9IGZ1bmN0aW9uICgpIHsgfTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBub3RpZmljYXRpb24gY2FsbGJhY2sgZnJvbSBhbiBvYnNlcnZlci5cbiAgICogQHJldHVybnMgVGhlIGFjdGlvbiB0aGF0IGZvcndhcmRzIGl0cyBpbnB1dCBub3RpZmljYXRpb24gdG8gdGhlIHVuZGVybHlpbmcgb2JzZXJ2ZXIuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUudG9Ob3RpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAobikgeyByZXR1cm4gbi5hY2NlcHQob2JzZXJ2ZXIpOyB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiAgSGlkZXMgdGhlIGlkZW50aXR5IG9mIGFuIG9ic2VydmVyLlxuICAgKiBAcmV0dXJucyBBbiBvYnNlcnZlciB0aGF0IGhpZGVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3BlY2lmaWVkIG9ic2VydmVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmFzT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2ZXIoXG4gICAgICBmdW5jdGlvbiAoeCkgeyBzZWxmLm9uTmV4dCh4KTsgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5vbkVycm9yKGVycik7IH0sXG4gICAgICBmdW5jdGlvbiAoKSB7IHNlbGYub25Db21wbGV0ZWQoKTsgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDaGVja3MgYWNjZXNzIHRvIHRoZSBvYnNlcnZlciBmb3IgZ3JhbW1hciB2aW9sYXRpb25zLiBUaGlzIGluY2x1ZGVzIGNoZWNraW5nIGZvciBtdWx0aXBsZSBPbkVycm9yIG9yIE9uQ29tcGxldGVkIGNhbGxzLCBhcyB3ZWxsIGFzIHJlZW50cmFuY3kgaW4gYW55IG9mIHRoZSBvYnNlcnZlciBtZXRob2RzLlxuICAgKiAgSWYgYSB2aW9sYXRpb24gaXMgZGV0ZWN0ZWQsIGFuIEVycm9yIGlzIHRocm93biBmcm9tIHRoZSBvZmZlbmRpbmcgb2JzZXJ2ZXIgbWV0aG9kIGNhbGwuXG4gICAqIEByZXR1cm5zIEFuIG9ic2VydmVyIHRoYXQgY2hlY2tzIGNhbGxiYWNrcyBpbnZvY2F0aW9ucyBhZ2FpbnN0IHRoZSBvYnNlcnZlciBncmFtbWFyIGFuZCwgaWYgdGhlIGNoZWNrcyBwYXNzLCBmb3J3YXJkcyB0aG9zZSB0byB0aGUgc3BlY2lmaWVkIG9ic2VydmVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmNoZWNrZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ2hlY2tlZE9ic2VydmVyKHRoaXMpOyB9O1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhbiBvYnNlcnZlciBmcm9tIHRoZSBzcGVjaWZpZWQgT25OZXh0LCBhbG9uZyB3aXRoIG9wdGlvbmFsIE9uRXJyb3IsIGFuZCBPbkNvbXBsZXRlZCBhY3Rpb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25OZXh0XSBPYnNlcnZlcidzIE9uTmV4dCBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBPYnNlcnZlcidzIE9uRXJyb3IgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Db21wbGV0ZWRdIE9ic2VydmVyJ3MgT25Db21wbGV0ZWQgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2ZXJ9IFRoZSBvYnNlcnZlciBvYmplY3QgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIGdpdmVuIGFjdGlvbnMuXG4gICAqL1xuICB2YXIgb2JzZXJ2ZXJDcmVhdGUgPSBPYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgIG9uTmV4dCB8fCAob25OZXh0ID0gbm9vcCk7XG4gICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvcik7XG4gICAgb25Db21wbGV0ZWQgfHwgKG9uQ29tcGxldGVkID0gbm9vcCk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZlcihvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgZnJvbSBhIG5vdGlmaWNhdGlvbiBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBBY3Rpb24gdGhhdCBoYW5kbGVzIGEgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHRoYXQgaW52b2tlcyB0aGUgc3BlY2lmaWVkIGhhbmRsZXIgdXNpbmcgYSBub3RpZmljYXRpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG1lc3NhZ2UgaXQgcmVjZWl2ZXMuXG4gICAqL1xuICBPYnNlcnZlci5mcm9tTm90aWZpZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgdGhpc0FyZykge1xuICAgIHZhciBjYiA9IGJpbmRDYWxsYmFjayhoYW5kbGVyLCB0aGlzQXJnLCAxKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gY2Iobm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0KHgpKTtcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGNiKG5vdGlmaWNhdGlvbkNyZWF0ZU9uRXJyb3IoZSkpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYihub3RpZmljYXRpb25DcmVhdGVPbkNvbXBsZXRlZCgpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVzIHRoZSBpbnZvY2F0aW9uIG9mIG9ic2VydmVyIG1ldGhvZHMgb24gdGhlIGdpdmVuIHNjaGVkdWxlci5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gc2NoZWR1bGUgb2JzZXJ2ZXIgbWVzc2FnZXMgb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZlcn0gT2JzZXJ2ZXIgd2hvc2UgbWVzc2FnZXMgYXJlIHNjaGVkdWxlZCBvbiB0aGUgZ2l2ZW4gc2NoZWR1bGVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLm5vdGlmeU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2ZU9uT2JzZXJ2ZXIoc2NoZWR1bGVyLCB0aGlzKTtcbiAgfTtcblxuICBPYnNlcnZlci5wcm90b3R5cGUubWFrZVNhZmUgPSBmdW5jdGlvbihkaXNwb3NhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTYWZlT2JzZXJ2ZXIodGhpcy5fb25OZXh0LCB0aGlzLl9vbkVycm9yLCB0aGlzLl9vbkNvbXBsZXRlZCwgZGlzcG9zYWJsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgT2JzZXJ2ZXIgY2xhc3MuXG4gICAqIFRoaXMgYmFzZSBjbGFzcyBlbmZvcmNlcyB0aGUgZ3JhbW1hciBvZiBvYnNlcnZlcnMgd2hlcmUgT25FcnJvciBhbmQgT25Db21wbGV0ZWQgYXJlIHRlcm1pbmFsIG1lc3NhZ2VzLlxuICAgKi9cbiAgdmFyIEFic3RyYWN0T2JzZXJ2ZXIgPSBSeC5pbnRlcm5hbHMuQWJzdHJhY3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQWJzdHJhY3RPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JzZXJ2ZXIgaW4gYSBub24tc3RvcHBlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdE9ic2VydmVyKCkge1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IG90aGVyIG9ic2VydmVyc1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBub3RJbXBsZW1lbnRlZDtcbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IG5vdEltcGxlbWVudGVkO1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIG9ic2VydmVyIG9mIGEgbmV3IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBOZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm9uTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMubmV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBvYnNlcnZlciB0aGF0IGFuIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQuXG4gICAgICogQHBhcmFtIHtBbnl9IGVycm9yIFRoZSBlcnJvciB0aGF0IGhhcyBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBvYnNlcnZlciBvZiB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgb2JzZXJ2ZXIsIGNhdXNpbmcgaXQgdG8gdHJhbnNpdGlvbiB0byB0aGUgc3RvcHBlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmlzU3RvcHBlZCA9IHRydWU7IH07XG5cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3RPYnNlcnZlcjtcbiAgfShPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDbGFzcyB0byBjcmVhdGUgYW4gT2JzZXJ2ZXIgaW5zdGFuY2UgZnJvbSBkZWxlZ2F0ZS1iYXNlZCBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIG9uKiBtZXRob2RzLlxuICAgKi9cbiAgdmFyIEFub255bW91c09ic2VydmVyID0gUnguQW5vbnltb3VzT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEFub255bW91c09ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZlciBmcm9tIHRoZSBzcGVjaWZpZWQgT25OZXh0LCBPbkVycm9yLCBhbmQgT25Db21wbGV0ZWQgYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0FueX0gb25OZXh0IE9ic2VydmVyJ3MgT25OZXh0IGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gb25FcnJvciBPYnNlcnZlcidzIE9uRXJyb3IgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSBvbkNvbXBsZXRlZCBPYnNlcnZlcidzIE9uQ29tcGxldGVkIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNPYnNlcnZlcihvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTmV4dCA9IG9uTmV4dDtcbiAgICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgdGhpcy5fb25Db21wbGV0ZWQgPSBvbkNvbXBsZXRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgb25OZXh0IGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgTmV4dCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBBbm9ueW1vdXNPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5fb25OZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG9uRXJyb3IgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSBlcnJvciBUaGUgZXJyb3IgdGhhdCBoYXMgb2NjdXJyZWQuXG4gICAgICovXG4gICAgQW5vbnltb3VzT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB0aGlzLl9vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIENhbGxzIHRoZSBvbkNvbXBsZXRlZCBhY3Rpb24uXG4gICAgICovXG4gICAgQW5vbnltb3VzT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBbm9ueW1vdXNPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIENoZWNrZWRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ2hlY2tlZE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tlZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLl9zdGF0ZSA9IDA7IC8vIDAgLSBpZGxlLCAxIC0gYnVzeSwgMiAtIGRvbmVcbiAgICB9XG5cbiAgICB2YXIgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlID0gQ2hlY2tlZE9ic2VydmVyLnByb3RvdHlwZTtcblxuICAgIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZS5vbk5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuY2hlY2tBY2Nlc3MoKTtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYnNlcnZlci5vbk5leHQpLmNhbGwodGhpcy5fb2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICAgIHJlcyA9PT0gZXJyb3JPYmogJiYgdGhyb3dlcihyZXMuZSk7XG4gICAgfTtcblxuICAgIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdGhpcy5jaGVja0FjY2VzcygpO1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29ic2VydmVyLm9uRXJyb3IpLmNhbGwodGhpcy5fb2JzZXJ2ZXIsIGVycik7XG4gICAgICB0aGlzLl9zdGF0ZSA9IDI7XG4gICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgIH07XG5cbiAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNoZWNrQWNjZXNzKCk7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fb2JzZXJ2ZXIub25Db21wbGV0ZWQpLmNhbGwodGhpcy5fb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fc3RhdGUgPSAyO1xuICAgICAgcmVzID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlcy5lKTtcbiAgICB9O1xuXG4gICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLmNoZWNrQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAxKSB7IHRocm93IG5ldyBFcnJvcignUmUtZW50cmFuY3kgZGV0ZWN0ZWQnKTsgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAyKSB7IHRocm93IG5ldyBFcnJvcignT2JzZXJ2ZXIgY29tcGxldGVkJyk7IH1cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMCkgeyB0aGlzLl9zdGF0ZSA9IDE7IH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENoZWNrZWRPYnNlcnZlcjtcbiAgfShPYnNlcnZlcikpO1xuXG4gIHZhciBTY2hlZHVsZWRPYnNlcnZlciA9IFJ4LmludGVybmFscy5TY2hlZHVsZWRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2NoZWR1bGVkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTY2hlZHVsZWRPYnNlcnZlcihzY2hlZHVsZXIsIG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5pc0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0ZhdWx0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZU5leHQob2JzZXJ2ZXIsIHgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgb2JzZXJ2ZXIub25OZXh0KHgpOyB9OyB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUVycm9yKG9ic2VydmVyLCBlKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IG9ic2VydmVyLm9uRXJyb3IoZSk7IH07IH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29tcGxldGVkKG9ic2VydmVyKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IG9ic2VydmVyLm9uQ29tcGxldGVkKCk7IH07IH1cblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaChlbnF1ZXVlTmV4dCh0aGlzLm9ic2VydmVyLCB4KSk7XG4gICAgfTtcblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZW5xdWV1ZUVycm9yKHRoaXMub2JzZXJ2ZXIsIGUpKTtcbiAgICB9O1xuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaChlbnF1ZXVlQ29tcGxldGVkKHRoaXMub2JzZXJ2ZXIpKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgdmFyIHdvcms7XG4gICAgICBpZiAoc3RhdGUucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB3b3JrID0gc3RhdGUucXVldWUuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmlzQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHdvcmspKCk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IFtdO1xuICAgICAgICBzdGF0ZS5oYXNGYXVsdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRocm93ZXIocmVzLmUpO1xuICAgICAgfVxuICAgICAgcmVjdXJzZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmVuc3VyZUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc093bmVyID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuaGFzRmF1bHRlZCAmJiB0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXNPd25lciA9ICF0aGlzLmlzQWNxdWlyZWQ7XG4gICAgICAgIHRoaXMuaXNBY3F1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpc093bmVyICYmXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHRoaXMsIHNjaGVkdWxlTWV0aG9kKSk7XG4gICAgfTtcblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZWR1bGVkT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBPYnNlcnZlT25PYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT2JzZXJ2ZU9uT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZlT25PYnNlcnZlcihzY2hlZHVsZXIsIG9ic2VydmVyLCBjYW5jZWwpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIHNjaGVkdWxlciwgb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fY2FuY2VsID0gY2FuY2VsO1xuICAgIH1cblxuICAgIE9ic2VydmVPbk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xuICAgIH07XG5cbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpO1xuICAgICAgdGhpcy5lbnN1cmVBY3RpdmUoKTtcbiAgICB9O1xuXG4gICAgT2JzZXJ2ZU9uT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuY29tcGxldGVkLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xuICAgIH07XG5cbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fY2FuY2VsICYmIHRoaXMuX2NhbmNlbC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYW5jZWwgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JzZXJ2ZU9uT2JzZXJ2ZXI7XG4gIH0pKFNjaGVkdWxlZE9ic2VydmVyKTtcblxuICB2YXIgb2JzZXJ2YWJsZVByb3RvO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcHVzaC1zdHlsZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgdmFyIE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIG1ha2VTdWJzY3JpYmUoc2VsZiwgc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIG9sZE9uRXJyb3IgPSBvLm9uRXJyb3I7XG4gICAgICAgIG8ub25FcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGUsIHNlbGYpO1xuICAgICAgICAgIG9sZE9uRXJyb3IuY2FsbChvLCBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlLmNhbGwoc2VsZiwgbyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG4gICAgICBpZiAoUnguY29uZmlnLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHZhciBvbGRTdWJzY3JpYmUgPSB0aGlzLl9zdWJzY3JpYmU7XG4gICAgICAgIHZhciBlID0gdHJ5Q2F0Y2godGhyb3dlcikobmV3IEVycm9yKCkpLmU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoJ1xcbicpICsgMSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IG1ha2VTdWJzY3JpYmUodGhpcywgb2xkU3Vic2NyaWJlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYnNlcnZhYmxlUHJvdG8gPSBPYnNlcnZhYmxlLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gT2JzZXJ2YWJsZVxuICAgICogQHBhcmFtIHtBbnl9IEFuIG9iamVjdCB0byBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBhbiBPYnNlcnZhYmxlXG4gICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBhbiBPYnNlcnZhYmxlLCBlbHNlIGZhbHNlLlxuICAgICovXG4gICAgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8gJiYgaXNGdW5jdGlvbihvLnN1YnNjcmliZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBTdWJzY3JpYmVzIGFuIG8gdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogIEBwYXJhbSB7TWl4ZWR9IFtvT3JPbk5leHRdIFRoZSBvYmplY3QgdGhhdCBpcyB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb3IgYW4gYWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQWN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Db21wbGV0ZWRdIEFjdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiAgQHJldHVybnMge0RpcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZSA9IG9ic2VydmFibGVQcm90by5mb3JFYWNoID0gZnVuY3Rpb24gKG9Pck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUodHlwZW9mIG9Pck9uTmV4dCA9PT0gJ29iamVjdCcgP1xuICAgICAgICBvT3JPbk5leHQgOlxuICAgICAgICBvYnNlcnZlckNyZWF0ZShvT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIG5leHQgdmFsdWUgaW4gdGhlIHNlcXVlbmNlIHdpdGggYW4gb3B0aW9uYWwgXCJ0aGlzXCIgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb24gZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRpc3Bvc2FibGUgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT25OZXh0ID0gZnVuY3Rpb24gKG9uTmV4dCwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlckNyZWF0ZSh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcgPyBmdW5jdGlvbih4KSB7IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgpOyB9IDogb25OZXh0KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gYW4gZXhjZXB0aW9uYWwgY29uZGl0aW9uIGluIHRoZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIFwidGhpc1wiIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBBIGRpc3Bvc2FibGUgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT25FcnJvciA9IGZ1bmN0aW9uIChvbkVycm9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKG9ic2VydmVyQ3JlYXRlKG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKGUpIHsgb25FcnJvci5jYWxsKHRoaXNBcmcsIGUpOyB9IDogb25FcnJvcikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIFwidGhpc1wiIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uQ29tcGxldGVkID0gZnVuY3Rpb24gKG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKG9ic2VydmVyQ3JlYXRlKG51bGwsIG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKCkgeyBvbkNvbXBsZXRlZC5jYWxsKHRoaXNBcmcpOyB9IDogb25Db21wbGV0ZWQpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG4gIH0pKCk7XG5cbiAgdmFyIE9ic2VydmFibGVCYXNlID0gUnguT2JzZXJ2YWJsZUJhc2UgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9ic2VydmFibGVCYXNlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gZml4U3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlciAmJiBpc0Z1bmN0aW9uKHN1YnNjcmliZXIuZGlzcG9zZSkgPyBzdWJzY3JpYmVyIDpcbiAgICAgICAgaXNGdW5jdGlvbihzdWJzY3JpYmVyKSA/IGRpc3Bvc2FibGVDcmVhdGUoc3Vic2NyaWJlcikgOiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGlzcG9zYWJsZShzLCBzdGF0ZSkge1xuICAgICAgdmFyIGFkbyA9IHN0YXRlWzBdLCBzZWxmID0gc3RhdGVbMV07XG4gICAgICB2YXIgc3ViID0gdHJ5Q2F0Y2goc2VsZi5zdWJzY3JpYmVDb3JlKS5jYWxsKHNlbGYsIGFkbyk7XG4gICAgICBpZiAoc3ViID09PSBlcnJvck9iaiAmJiAhYWRvLmZhaWwoZXJyb3JPYmouZSkpIHsgdGhyb3dlcihlcnJvck9iai5lKTsgfVxuICAgICAgYWRvLnNldERpc3Bvc2FibGUoZml4U3Vic2NyaWJlcihzdWIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlQmFzZSgpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE9ic2VydmFibGVCYXNlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhZG8gPSBuZXcgQXV0b0RldGFjaE9ic2VydmVyKG8pLCBzdGF0ZSA9IFthZG8sIHRoaXNdO1xuXG4gICAgICBpZiAoY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlcXVpcmVkKCkpIHtcbiAgICAgICAgY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZShzdGF0ZSwgc2V0RGlzcG9zYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREaXNwb3NhYmxlKG51bGwsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZG87XG4gICAgfTtcblxuICAgIE9ic2VydmFibGVCYXNlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZUJhc2U7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG52YXIgRmxhdE1hcE9ic2VydmFibGUgPSBSeC5GbGF0TWFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcblxuICAgIGluaGVyaXRzKEZsYXRNYXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRmxhdE1hcE9ic2VydmFibGUoc291cmNlLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSA/IHJlc3VsdFNlbGVjdG9yIDogbnVsbDtcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBiaW5kQ2FsbGJhY2soaXNGdW5jdGlvbihzZWxlY3RvcikgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZWN0b3I7IH0sIHRoaXNBcmcsIDMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGbGF0TWFwT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIobywgdGhpcy5zZWxlY3RvciwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcykpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKG9ic2VydmVyLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHNvdXJjZSkge1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5vID0gb2JzZXJ2ZXI7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuX3dyYXBSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHQsIHgsIGkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdFNlbGVjdG9yID9cbiAgICAgICAgcmVzdWx0Lm1hcChmdW5jdGlvbih5LCBpMikgeyByZXR1cm4gdGhpcy5yZXN1bHRTZWxlY3Rvcih4LCB5LCBpLCBpMik7IH0sIHRoaXMpIDpcbiAgICAgICAgcmVzdWx0O1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGkgPSB0aGlzLmkrKztcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLnNlbGVjdG9yKSh4LCBpLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG5cbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAoaXNBcnJheUxpa2UocmVzdWx0KSB8fCBpc0l0ZXJhYmxlKHJlc3VsdCkpICYmIChyZXN1bHQgPSBPYnNlcnZhYmxlLmZyb20ocmVzdWx0KSk7XG4gICAgICB0aGlzLm8ub25OZXh0KHRoaXMuX3dyYXBSZXN1bHQocmVzdWx0LCB4LCBpKSk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkgeyB0aGlzLm8ub25FcnJvcihlKTsgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkgeyB0aGlzLm8ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBGbGF0TWFwT2JzZXJ2YWJsZTtcblxufShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFbnVtZXJhYmxlID0gUnguaW50ZXJuYWxzLkVudW1lcmFibGUgPSBmdW5jdGlvbiAoKSB7IH07XG5cbiAgZnVuY3Rpb24gSXNEaXNwb3NlZERpc3Bvc2FibGUoc3RhdGUpIHtcbiAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICBJc0Rpc3Bvc2VkRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3MuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIGlmIChzdGF0ZS5pc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxuICAgICAgdmFyIGN1cnJlbnRJdGVtID0gdHJ5Q2F0Y2goc3RhdGUuZS5uZXh0KS5jYWxsKHN0YXRlLmUpO1xuICAgICAgaWYgKGN1cnJlbnRJdGVtID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKGN1cnJlbnRJdGVtLmUpOyB9XG4gICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkgeyByZXR1cm4gc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgIGlzUHJvbWlzZShjdXJyZW50VmFsdWUpICYmIChjdXJyZW50VmFsdWUgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoY3VycmVudFZhbHVlKSk7XG5cbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBzdGF0ZS5zdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShjdXJyZW50VmFsdWUuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgIH1cblxuICAgIENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBpc0Rpc3Bvc2VkOiBmYWxzZSxcbiAgICAgICAgbzogbyxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgICAgIGU6IHRoaXMuc291cmNlc1skaXRlcmF0b3IkXSgpXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2FuY2VsYWJsZSA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSwgbmV3IElzRGlzcG9zZWREaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zdGF0ZS5vLm9uRXJyb3IoZSk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZWN1cnNlKHRoaXMuX3N0YXRlKTsgfTtcblxuICAgIHJldHVybiBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIEVudW1lcmFibGUucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbmNhdEVudW1lcmFibGVPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBDYXRjaEVycm9yT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBmdW5jdGlvbiBDYXRjaEVycm9yT2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoQ2F0Y2hFcnJvck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmlzRGlzcG9zZWQpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgY3VycmVudEl0ZW0gPSB0cnlDYXRjaChzdGF0ZS5lLm5leHQpLmNhbGwoc3RhdGUuZSk7XG4gICAgICBpZiAoY3VycmVudEl0ZW0gPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IoY3VycmVudEl0ZW0uZSk7IH1cbiAgICAgIGlmIChjdXJyZW50SXRlbS5kb25lKSB7IHJldHVybiBzdGF0ZS5sYXN0RXJyb3IgIT09IG51bGwgPyBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUubGFzdEVycm9yKSA6IHN0YXRlLm8ub25Db21wbGV0ZWQoKTsgfVxuXG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudEl0ZW0udmFsdWU7XG4gICAgICBpc1Byb21pc2UoY3VycmVudFZhbHVlKSAmJiAoY3VycmVudFZhbHVlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkpKTtcbiAgICB9XG5cbiAgICBDYXRjaEVycm9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIGU6IHRoaXMuc291cmNlc1skaXRlcmF0b3IkXSgpLFxuICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbixcbiAgICAgICAgbGFzdEVycm9yOiBudWxsLFxuICAgICAgICBvOiBvXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2FuY2VsYWJsZSA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSwgbmV3IElzRGlzcG9zZWREaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zdGF0ZS5sYXN0RXJyb3IgPSBlOyB0aGlzLl9yZWN1cnNlKHRoaXMuX3N0YXRlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3N0YXRlLm8ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBDYXRjaEVycm9yT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIEVudW1lcmFibGUucHJvdG90eXBlLmNhdGNoRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDYXRjaEVycm9yT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgUmVwZWF0RW51bWVyYWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVwZWF0RW51bWVyYWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZXBlYXRFbnVtZXJhYmxlKHYsIGMpIHtcbiAgICAgIHRoaXMudiA9IHY7XG4gICAgICB0aGlzLmMgPSBjID09IG51bGwgPyAtMSA6IGM7XG4gICAgfVxuXG4gICAgUmVwZWF0RW51bWVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcGVhdEVudW1lcmF0b3IodGhpcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlcGVhdEVudW1lcmF0b3IocCkge1xuICAgICAgdGhpcy52ID0gcC52O1xuICAgICAgdGhpcy5sID0gcC5jO1xuICAgIH1cblxuICAgIFJlcGVhdEVudW1lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5sID09PSAwKSB7IHJldHVybiBkb25lRW51bWVyYXRvcjsgfVxuICAgICAgaWYgKHRoaXMubCA+IDApIHsgdGhpcy5sLS07IH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy52IH07XG4gICAgfTtcblxuICAgIHJldHVybiBSZXBlYXRFbnVtZXJhYmxlO1xuICB9KEVudW1lcmFibGUpKTtcblxuICB2YXIgZW51bWVyYWJsZVJlcGVhdCA9IEVudW1lcmFibGUucmVwZWF0ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBlYXRDb3VudCkge1xuICAgIHJldHVybiBuZXcgUmVwZWF0RW51bWVyYWJsZSh2YWx1ZSwgcmVwZWF0Q291bnQpO1xuICB9O1xuXG4gIHZhciBPZkVudW1lcmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT2ZFbnVtZXJhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE9mRW51bWVyYWJsZShzLCBmbiwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zID0gcztcbiAgICAgIHRoaXMuZm4gPSBmbiA/IGJpbmRDYWxsYmFjayhmbiwgdGhpc0FyZywgMykgOiBudWxsO1xuICAgIH1cbiAgICBPZkVudW1lcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBPZkVudW1lcmF0b3IodGhpcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIE9mRW51bWVyYXRvcihwKSB7XG4gICAgICB0aGlzLmkgPSAtMTtcbiAgICAgIHRoaXMucyA9IHAucztcbiAgICAgIHRoaXMubCA9IHRoaXMucy5sZW5ndGg7XG4gICAgICB0aGlzLmZuID0gcC5mbjtcbiAgICB9XG5cbiAgICBPZkVudW1lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgIHJldHVybiArK3RoaXMuaSA8IHRoaXMubCA/XG4gICAgICAgeyBkb25lOiBmYWxzZSwgdmFsdWU6ICF0aGlzLmZuID8gdGhpcy5zW3RoaXMuaV0gOiB0aGlzLmZuKHRoaXMuc1t0aGlzLmldLCB0aGlzLmksIHRoaXMucykgfSA6XG4gICAgICAgZG9uZUVudW1lcmF0b3I7XG4gICAgfTtcblxuICAgIHJldHVybiBPZkVudW1lcmFibGU7XG4gIH0oRW51bWVyYWJsZSkpO1xuXG4gIHZhciBlbnVtZXJhYmxlT2YgPSBFbnVtZXJhYmxlLm9mID0gZnVuY3Rpb24gKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IE9mRW51bWVyYWJsZShzb3VyY2UsIHNlbGVjdG9yLCB0aGlzQXJnKTtcbiAgfTtcblxudmFyIE9ic2VydmVPbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICBpbmhlcml0cyhPYnNlcnZlT25PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICBmdW5jdGlvbiBPYnNlcnZlT25PYnNlcnZhYmxlKHNvdXJjZSwgcykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX3MgPSBzO1xuICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgT2JzZXJ2ZU9uT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uT2JzZXJ2ZXIodGhpcy5fcywgbykpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZlT25PYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gICAvKipcbiAgICogIFdyYXBzIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaW4gb3JkZXIgdG8gcnVuIGl0cyBvYnNlcnZlciBjYWxsYmFja3Mgb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqXG4gICAqICBUaGlzIG9ubHkgaW52b2tlcyBvYnNlcnZlciBjYWxsYmFja3Mgb24gYSBzY2hlZHVsZXIuIEluIGNhc2UgdGhlIHN1YnNjcmlwdGlvbiBhbmQvb3IgdW5zdWJzY3JpcHRpb24gYWN0aW9ucyBoYXZlIHNpZGUtZWZmZWN0c1xuICAgKiAgdGhhdCByZXF1aXJlIHRvIGJlIHJ1biBvbiBhIHNjaGVkdWxlciwgdXNlIHN1YnNjcmliZU9uLlxuICAgKlxuICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gbm90aWZ5IG9ic2VydmVycyBvbi5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdob3NlIG9ic2VydmF0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ub2JzZXJ2ZU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2ZU9uT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTdWJzY3JpYmVPbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN1YnNjcmliZU9uT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVPbk9ic2VydmFibGUoc291cmNlLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc2NoZWR1bGVyLCBzdGF0ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlWzBdLCBkID0gc3RhdGVbMV0sIG8gPSBzdGF0ZVsyXTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShuZXcgU2NoZWR1bGVkRGlzcG9zYWJsZShzY2hlZHVsZXIsIHNvdXJjZS5zdWJzY3JpYmUobykpKTtcbiAgICB9XG5cbiAgICBTdWJzY3JpYmVPbk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSwgZCA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUobSk7XG4gICAgICBtLnNldERpc3Bvc2FibGUodGhpcy5fcy5zY2hlZHVsZShbdGhpcy5zb3VyY2UsIGQsIG9dLCBzY2hlZHVsZU1ldGhvZCkpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJzY3JpYmVPbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAgLyoqXG4gICAqICBXcmFwcyB0aGUgc291cmNlIHNlcXVlbmNlIGluIG9yZGVyIHRvIHJ1biBpdHMgc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiBsb2dpYyBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci4gVGhpcyBvcGVyYXRpb24gaXMgbm90IGNvbW1vbmx5IHVzZWQ7XG4gICAqICBzZWUgdGhlIHJlbWFya3Mgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBzdWJzY3JpYmVPbiBhbmQgb2JzZXJ2ZU9uLlxuXG4gICAqICBUaGlzIG9ubHkgcGVyZm9ybXMgdGhlIHNpZGUtZWZmZWN0cyBvZiBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLiBJbiBvcmRlciB0byBpbnZva2Ugb2JzZXJ2ZXJcbiAgICogIGNhbGxiYWNrcyBvbiBhIHNjaGVkdWxlciwgdXNlIG9ic2VydmVPbi5cblxuICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcGVyZm9ybSBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIGFjdGlvbnMgb24uXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSB3aG9zZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMgaGFwcGVuIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlT25PYnNlcnZhYmxlKHRoaXMsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIEZyb21Qcm9taXNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGcm9tUHJvbWlzZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRnJvbVByb21pc2VPYnNlcnZhYmxlKHAsIHMpIHtcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU5leHQocywgc3RhdGUpIHtcbiAgICAgIHZhciBvID0gc3RhdGVbMF0sIGRhdGEgPSBzdGF0ZVsxXTtcbiAgICAgIG8ub25OZXh0KGRhdGEpO1xuICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRXJyb3Iocywgc3RhdGUpIHtcbiAgICAgIHZhciBvID0gc3RhdGVbMF0sIGVyciA9IHN0YXRlWzFdO1xuICAgICAgby5vbkVycm9yKGVycik7XG4gICAgfVxuXG4gICAgRnJvbVByb21pc2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBzZWxmID0gdGhpcywgcCA9IHRoaXMuX3A7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHApKSB7XG4gICAgICAgIHAgPSB0cnlDYXRjaChwKSgpO1xuICAgICAgICBpZiAocCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICBvLm9uRXJyb3IocC5lKTtcbiAgICAgICAgICByZXR1cm4gc2FkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzZWxmLl9zLnNjaGVkdWxlKFtvLCBkYXRhXSwgc2NoZWR1bGVOZXh0KSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzZWxmLl9zLnNjaGVkdWxlKFtvLCBlcnJdLCBzY2hlZHVsZUVycm9yKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2FkO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbVByb21pc2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogQ29udmVydHMgYSBQcm9taXNlIHRvIGFuIE9ic2VydmFibGUgc2VxdWVuY2VcbiAgKiBAcGFyYW0ge1Byb21pc2V9IEFuIEVTNiBDb21wbGlhbnQgcHJvbWlzZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCB3cmFwcyB0aGUgZXhpc3RpbmcgcHJvbWlzZSBzdWNjZXNzIGFuZCBmYWlsdXJlLlxuICAqL1xuICB2YXIgb2JzZXJ2YWJsZUZyb21Qcm9taXNlID0gT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzY2hlZHVsZXIpIHtcbiAgICBzY2hlZHVsZXIgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbVByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgLypcbiAgICogQ29udmVydHMgYW4gZXhpc3Rpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBFUzYgQ29tcGF0aWJsZSBQcm9taXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwcm9taXNlID0gUnguT2JzZXJ2YWJsZS5yZXR1cm4oNDIpLnRvUHJvbWlzZShSU1ZQLlByb21pc2UpO1xuICAgKlxuICAgKiAvLyBXaXRoIGNvbmZpZ1xuICAgKiBSeC5jb25maWcuUHJvbWlzZSA9IFJTVlAuUHJvbWlzZTtcbiAgICogdmFyIHByb21pc2UgPSBSeC5PYnNlcnZhYmxlLnJldHVybig0MikudG9Qcm9taXNlKCk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9taXNlQ3Rvcl0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwcm9taXNlLiBJZiBub3QgcHJvdmlkZWQsIGl0IGxvb2tzIGZvciBpdCBpbiBSeC5jb25maWcuUHJvbWlzZS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEFuIEVTNiBjb21wYXRpYmxlIHByb21pc2Ugd2l0aCB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlQ3Rvcikge1xuICAgIHByb21pc2VDdG9yIHx8IChwcm9taXNlQ3RvciA9IFJ4LmNvbmZpZy5Qcm9taXNlKTtcbiAgICBpZiAoIXByb21pc2VDdG9yKSB7IHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignUHJvbWlzZSB0eXBlIG5vdCBwcm92aWRlZCBub3IgaW4gUnguY29uZmlnLlByb21pc2UnKTsgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gTm8gY2FuY2VsbGF0aW9uIGNhbiBiZSBkb25lXG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhbHVlID0gdjtcbiAgICAgIH0sIHJlamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBUb0FycmF5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb0FycmF5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUb0FycmF5T2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9BcnJheU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5hID0gW107XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIFxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLmEucHVzaCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuby5vbkVycm9yKGUpOyAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuby5vbk5leHQodGhpcy5hKTsgdGhpcy5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gVG9BcnJheU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBhIGxpc3QgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICovXG4gIG9ic2VydmFibGVQcm90by50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVG9BcnJheU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBhIHNwZWNpZmllZCBzdWJzY3JpYmUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB9ICk7XG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBSeC5EaXNwb3NhYmxlLmVtcHR5OyB9ICk7XG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IH0gKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIEltcGxlbWVudGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSdzIHN1YnNjcmliZSBtZXRob2QsIHJldHVybmluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB3cmFwcGVkIGluIGEgRGlzcG9zYWJsZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFN1YnNjcmliZSBtZXRob2QuXG4gICAqL1xuICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUsIHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShzdWJzY3JpYmUsIHBhcmVudCk7XG4gIH07XG5cbiAgdmFyIERlZmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlZmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlZmVyKGZhY3RvcnkpIHtcbiAgICAgIHRoaXMuX2YgPSBmYWN0b3J5O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVmZXIucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2YpKCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gb2JzZXJ2YWJsZVRocm93KHJlc3VsdC5lKS5zdWJzY3JpYmUobyk7fVxuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgIHJldHVybiByZXN1bHQuc3Vic2NyaWJlKG8pO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVmZXI7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGludm9rZXMgdGhlIHNwZWNpZmllZCBmYWN0b3J5IGZ1bmN0aW9uIHdoZW5ldmVyIGEgbmV3IG9ic2VydmVyIHN1YnNjcmliZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLmZyb21BcnJheShbMSwyLDNdKTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ic2VydmFibGVGYWN0b3J5IE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggb2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2Ugb3IgUHJvbWlzZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2Ugb2JzZXJ2ZXJzIHRyaWdnZXIgYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gb2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVEZWZlciA9IE9ic2VydmFibGUuZGVmZXIgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IERlZmVyKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgfTtcblxuICB2YXIgRW1wdHlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEVtcHR5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEVtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHNpbmsgPSBuZXcgRW1wdHlTaW5rKG9ic2VydmVyLCB0aGlzLnNjaGVkdWxlcik7XG4gICAgICByZXR1cm4gc2luay5ydW4oKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRW1wdHlTaW5rKG9ic2VydmVyLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzdGF0ZSkge1xuICAgICAgc3RhdGUub25Db21wbGV0ZWQoKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgRW1wdHlTaW5rLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgP1xuICAgICAgICBzY2hlZHVsZUl0ZW0obnVsbCwgc3RhdGUpIDpcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNjaGVkdWxlSXRlbSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRU1QVFlfT0JTRVJWQUJMRSA9IG5ldyBFbXB0eU9ic2VydmFibGUoaW1tZWRpYXRlU2NoZWR1bGVyKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gZW1wdHkgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIHNpbmdsZSBPbkNvbXBsZXRlZCBtZXNzYWdlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKTtcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmVtcHR5KFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBzZW5kIHRoZSB0ZXJtaW5hdGlvbiBjYWxsIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIG5vIGVsZW1lbnRzLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVFbXB0eSA9IE9ic2VydmFibGUuZW1wdHkgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgPyBFTVBUWV9PQlNFUlZBQkxFIDogbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGcm9tT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGcm9tT2JzZXJ2YWJsZShpdGVyYWJsZSwgZm4sIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTY2hlZHVsZU1ldGhvZChvLCBpdCwgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wUmVjdXJzaXZlKGksIHJlY3Vyc2UpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0cnlDYXRjaChpdC5uZXh0KS5jYWxsKGl0KTtcbiAgICAgICAgaWYgKG5leHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IobmV4dC5lKTsgfVxuICAgICAgICBpZiAobmV4dC5kb25lKSB7IHJldHVybiBvLm9uQ29tcGxldGVkKCk7IH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dC52YWx1ZTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaChmbikocmVzdWx0LCBpKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgcmVjdXJzZShpICsgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMuX2l0ZXJhYmxlKSxcbiAgICAgICAgICBpdCA9IGdldEl0ZXJhYmxlKGxpc3QpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKDAsIGNyZWF0ZVNjaGVkdWxlTWV0aG9kKG8sIGl0LCB0aGlzLl9mbikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhYmxlKHMpIHtcbiAgICB0aGlzLl9zID0gcztcbiAgfVxuXG4gIFN0cmluZ0l0ZXJhYmxlLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKHRoaXMuX3MpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKHMpIHtcbiAgICB0aGlzLl9zID0gcztcbiAgICB0aGlzLl9sID0gcy5sZW5ndGg7XG4gICAgdGhpcy5faSA9IDA7XG4gIH1cblxuICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2kgPCB0aGlzLl9sID8geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3MuY2hhckF0KHRoaXMuX2krKykgfSA6IGRvbmVFbnVtZXJhdG9yO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFycmF5SXRlcmFibGUoYSkge1xuICAgIHRoaXMuX2EgPSBhO1xuICB9XG5cbiAgQXJyYXlJdGVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKHRoaXMuX2EpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoYSkge1xuICAgIHRoaXMuX2EgPSBhO1xuICAgIHRoaXMuX2wgPSB0b0xlbmd0aChhKTtcbiAgICB0aGlzLl9pID0gMDtcbiAgfVxuXG4gIEFycmF5SXRlcmF0b3IucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2kgPCB0aGlzLl9sID8geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX2FbdGhpcy5faSsrXSB9IDogZG9uZUVudW1lcmF0b3I7XG4gIH07XG5cbiAgZnVuY3Rpb24gbnVtYmVySXNGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByb290LmlzRmluaXRlKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmFuKG4pIHtcbiAgICByZXR1cm4gbiAhPT0gbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhYmxlKG8pIHtcbiAgICB2YXIgaSA9IG9bJGl0ZXJhdG9yJF0sIGl0O1xuICAgIGlmICghaSAmJiB0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGl0ID0gbmV3IFN0cmluZ0l0ZXJhYmxlKG8pO1xuICAgICAgcmV0dXJuIGl0WyRpdGVyYXRvciRdKCk7XG4gICAgfVxuICAgIGlmICghaSAmJiBvLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdCA9IG5ldyBBcnJheUl0ZXJhYmxlKG8pO1xuICAgICAgcmV0dXJuIGl0WyRpdGVyYXRvciRdKCk7XG4gICAgfVxuICAgIGlmICghaSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGl0ZXJhYmxlJyk7IH1cbiAgICByZXR1cm4gb1skaXRlcmF0b3IkXSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbih2YWx1ZSkge1xuICAgIHZhciBudW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKG51bWJlciA9PT0gMCkgeyByZXR1cm4gbnVtYmVyOyB9XG4gICAgaWYgKGlzTmFOKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgIHJldHVybiBudW1iZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9MZW5ndGgobykge1xuICAgIHZhciBsZW4gPSArby5sZW5ndGg7XG4gICAgaWYgKGlzTmFOKGxlbikpIHsgcmV0dXJuIDA7IH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7IHJldHVybiBsZW47IH1cbiAgICBsZW4gPSBzaWduKGxlbikgKiBNYXRoLmZsb29yKE1hdGguYWJzKGxlbikpO1xuICAgIGlmIChsZW4gPD0gMCkgeyByZXR1cm4gMDsgfVxuICAgIGlmIChsZW4gPiBtYXhTYWZlSW50ZWdlcikgeyByZXR1cm4gbWF4U2FmZUludGVnZXI7IH1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLyoqXG4gICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYW4gYXJyYXktbGlrZSBvciBpdGVyYWJsZSBvYmplY3QuXG4gICogQHBhcmFtIHtBbnl9IGFycmF5TGlrZSBBbiBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdCB0byBjb252ZXJ0IHRvIGFuIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW21hcEZuXSBNYXAgZnVuY3Rpb24gdG8gY2FsbCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIFRoZSBjb250ZXh0IHRvIHVzZSBjYWxsaW5nIHRoZSBtYXBGbiBpZiBwcm92aWRlZC5cbiAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gT3B0aW9uYWwgc2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZy4gIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQuXG4gICovXG4gIHZhciBvYnNlcnZhYmxlRnJvbSA9IE9ic2VydmFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgbWFwRm4sIHRoaXNBcmcsIHNjaGVkdWxlcikge1xuICAgIGlmIChpdGVyYWJsZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhYmxlIGNhbm5vdCBiZSBudWxsLicpXG4gICAgfVxuICAgIGlmIChtYXBGbiAmJiAhaXNGdW5jdGlvbihtYXBGbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFwRm4gd2hlbiBwcm92aWRlZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgaWYgKG1hcEZuKSB7XG4gICAgICB2YXIgbWFwcGVyID0gYmluZENhbGxiYWNrKG1hcEZuLCB0aGlzQXJnLCAyKTtcbiAgICB9XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShpdGVyYWJsZSwgbWFwcGVyLCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgdmFyIEZyb21BcnJheU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRnJvbUFycmF5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGcm9tQXJyYXlPYnNlcnZhYmxlKGFyZ3MsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChvLCBhcmdzKSB7XG4gICAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZSAoaSwgcmVjdXJzZSkge1xuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIG8ub25OZXh0KGFyZ3NbaV0pO1xuICAgICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBGcm9tQXJyYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoMCwgc2NoZWR1bGVNZXRob2QobywgdGhpcy5fYXJncykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbUFycmF5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqICBDb252ZXJ0cyBhbiBhcnJheSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyBhbiBvcHRpb25hbCBzY2hlZHVsZXIgdG8gZW51bWVyYXRlIHRoZSBhcnJheS5cbiAgKiBAZGVwcmVjYXRlZCB1c2UgT2JzZXJ2YWJsZS5mcm9tIG9yIE9ic2VydmFibGUub2ZcbiAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgcHVsbGVkIGZyb20gdGhlIGdpdmVuIGVudW1lcmFibGUgc2VxdWVuY2UuXG4gICovXG4gIHZhciBvYnNlcnZhYmxlRnJvbUFycmF5ID0gT2JzZXJ2YWJsZS5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKVxuICB9O1xuXG4gIHZhciBHZW5lcmF0ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEdlbmVyYXRlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZU9ic2VydmFibGUoc3RhdGUsIGNuZEZuLCBpdHJGbiwgcmVzRm4sIHMpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxTdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fY25kRm4gPSBjbmRGbjtcbiAgICAgIHRoaXMuX2l0ckZuID0gaXRyRm47XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmZpcnN0KSB7XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5uZXdTdGF0ZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2l0ckZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5uZXdTdGF0ZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5uZXdTdGF0ZS5lKTsgfVxuICAgICAgfVxuICAgICAgdmFyIGhhc1Jlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2NuZEZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICBpZiAoaGFzUmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKGhhc1Jlc3VsdC5lKTsgfVxuICAgICAgaWYgKGhhc1Jlc3VsdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fcmVzRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgICAgc3RhdGUuby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgcmVjdXJzZShzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VuZXJhdGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgIG5ld1N0YXRlOiB0aGlzLl9pbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fcy5zY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgc2NoZWR1bGVSZWN1cnNpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gR2VuZXJhdGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBydW5uaW5nIGEgc3RhdGUtZHJpdmVuIGxvb3AgcHJvZHVjaW5nIHRoZSBzZXF1ZW5jZSdzIGVsZW1lbnRzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmdlbmVyYXRlKDAsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IDwgMTA7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZ2VuZXJhdGUoMCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPCAxMDsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsU3RhdGUgSW5pdGlhbCBzdGF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIENvbmRpdGlvbiB0byB0ZXJtaW5hdGUgZ2VuZXJhdGlvbiAodXBvbiByZXR1cm5pbmcgZmFsc2UpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiBmb3IgcmVzdWx0cyBwcm9kdWNlZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuY3VycmVudFRocmVhZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBPYnNlcnZhYmxlLmdlbmVyYXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmF0ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVPZiAoc2NoZWR1bGVyLCBhcnJheSkge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIC8qKlxuICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IE9ic2VydmFibGUgaW5zdGFuY2Ugd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIHJlZ2FyZGxlc3Mgb2YgbnVtYmVyIG9yIHR5cGUgb2YgdGhlIGFyZ3VtZW50cy5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHB1bGxlZCBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICovXG4gIE9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcmdzLCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKipcbiAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIGluc3RhbmNlIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mIG51bWJlciBvciB0eXBlIG9mIHRoZSBhcmd1bWVudHMuXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBBIHNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmcgdGhlIGFyZ3VtZW50cy5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHB1bGxlZCBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICovXG4gIE9ic2VydmFibGUub2ZXaXRoU2NoZWR1bGVyID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgeyBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBuZXcgRnJvbUFycmF5T2JzZXJ2YWJsZShhcmdzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBjaGFuZ2VzIHRvIGFuIGFycmF5IHVzaW5nIEFycmF5Lm9ic2VydmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFuIGFycmF5IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBjaGFuZ2VzIHRvIGFuIGFycmF5IGZyb20gQXJyYXkub2JzZXJ2ZS5cbiAgICovXG4gIE9ic2VydmFibGUub2ZBcnJheUNoYW5nZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkub2JzZXJ2ZSBvbmx5IGFjY2VwdHMgYXJyYXlzLicpOyB9XG4gICAgaWYgKHR5cGVvZiBBcnJheS5vYnNlcnZlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBBcnJheS51bm9ic2VydmUgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkub2JzZXJ2ZSBpcyBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgcGxhdGZvcm0nKSB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICBmdW5jdGlvbiBvYnNlcnZlckZuKGNoYW5nZXMpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChjaGFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBBcnJheS5vYnNlcnZlKGFycmF5LCBvYnNlcnZlckZuKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQXJyYXkudW5vYnNlcnZlKGFycmF5LCBvYnNlcnZlckZuKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGNoYW5nZXMgdG8gYW4gb2JqZWN0IHVzaW5nIE9iamVjdC5vYnNlcnZlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIEFuIG9iamVjdCB0byBvYnNlcnZlIGNoYW5nZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgY2hhbmdlcyB0byBhbiBvYmplY3QgZnJvbSBPYmplY3Qub2JzZXJ2ZS5cbiAgICovXG4gIE9ic2VydmFibGUub2ZPYmplY3RDaGFuZ2VzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKTsgfVxuICAgIGlmICh0eXBlb2YgT2JqZWN0Lm9ic2VydmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC51bm9ic2VydmUgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0Lm9ic2VydmUgaXMgbm90IHN1cHBvcnRlZCBvbiB5b3VyIHBsYXRmb3JtJykgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgZnVuY3Rpb24gb2JzZXJ2ZXJGbihjaGFuZ2VzKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGNoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoY2hhbmdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0Lm9ic2VydmUob2JqLCBvYnNlcnZlckZuKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LnVub2JzZXJ2ZShvYmosIG9ic2VydmVyRm4pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgTmV2ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE5ldmVyT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBOZXZlck9ic2VydmFibGUoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBOZXZlck9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfTtcblxuICAgIHJldHVybiBOZXZlck9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTkVWRVJfT0JTRVJWQUJMRSA9IG5ldyBOZXZlck9ic2VydmFibGUoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5vbi10ZXJtaW5hdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZW5vdGUgYW4gaW5maW5pdGUgZHVyYXRpb24gKGUuZy4gd2hlbiB1c2luZyByZWFjdGl2ZSBqb2lucykuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIG9ic2VydmVycyB3aWxsIG5ldmVyIGdldCBjYWxsZWQuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZU5ldmVyID0gT2JzZXJ2YWJsZS5uZXZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTkVWRVJfT0JTRVJWQUJMRTtcbiAgfTtcblxuICB2YXIgUGFpcnNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYWlyc09ic2VydmFibGUobywgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2tleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKG8sIG9iaiwga2V5cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgICBpZiAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgby5vbk5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICAgICAgICByZWN1cnNlKGkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgUGFpcnNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoMCwgc2NoZWR1bGVNZXRob2QobywgdGhpcy5fbywgdGhpcy5fa2V5cykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGFpcnNPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMgZnJvbSB0aGUgb2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5wYWlycyA9IGZ1bmN0aW9uIChvYmosIHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlciB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBQYWlyc09ic2VydmFibGUob2JqLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gICAgdmFyIFJhbmdlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSYW5nZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLnJhbmdlQ291bnQgPSBjb3VudDtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZShzdGFydCwgY291bnQsIG8pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wIChpLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChpIDwgY291bnQpIHtcbiAgICAgICAgICBvLm9uTmV4dChzdGFydCArIGkpO1xuICAgICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKFxuICAgICAgICAwLFxuICAgICAgICBsb29wUmVjdXJzaXZlKHRoaXMuc3RhcnQsIHRoaXMucmFuZ2VDb3VudCwgbylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBSYW5nZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgaW50ZWdyYWwgbnVtYmVycyB3aXRoaW4gYSBzcGVjaWZpZWQgcmFuZ2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludGVnZXIgaW4gdGhlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHNlcXVlbnRpYWwgaW50ZWdlcnMgdG8gZ2VuZXJhdGUuXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuY3VycmVudFRocmVhZC5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIGEgcmFuZ2Ugb2Ygc2VxdWVudGlhbCBpbnRlZ3JhbCBudW1iZXJzLlxuICAqL1xuICBPYnNlcnZhYmxlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBSYW5nZU9ic2VydmFibGUoc3RhcnQsIGNvdW50LCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBSZXBlYXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlcGVhdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVwZWF0T2JzZXJ2YWJsZSh2YWx1ZSwgcmVwZWF0Q291bnQsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5yZXBlYXRDb3VudCA9IHJlcGVhdENvdW50ID09IG51bGwgPyAtMSA6IHJlcGVhdENvdW50O1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZXBlYXRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgc2luayA9IG5ldyBSZXBlYXRTaW5rKG9ic2VydmVyLCB0aGlzKTtcbiAgICAgIHJldHVybiBzaW5rLnJ1bigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIGZ1bmN0aW9uIFJlcGVhdFNpbmsob2JzZXJ2ZXIsIHBhcmVudCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuXG4gIFJlcGVhdFNpbmsucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLCB2YWx1ZSA9IHRoaXMucGFyZW50LnZhbHVlO1xuICAgIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgaWYgKGkgPT09IC0xIHx8IGkgPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIGkgPiAwICYmIGktLTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSAwKSB7IHJldHVybiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICByZWN1cnNlKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcmVudC5zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUodGhpcy5wYXJlbnQucmVwZWF0Q291bnQsIGxvb3BSZWN1cnNpdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgRWxlbWVudCB0byByZXBlYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRDb3VudCBbT3B0aW9uYV0gTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCwgcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgcHJvZHVjZXIgbG9vcCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5yZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFJlcGVhdE9ic2VydmFibGUodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBKdXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhKdXN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBKdXN0T2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSnVzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0gW3RoaXMuX3ZhbHVlLCBvXTtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIgPT09IGltbWVkaWF0ZVNjaGVkdWxlciA/XG4gICAgICAgIHNjaGVkdWxlSXRlbShudWxsLCBzdGF0ZSkgOlxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNjaGVkdWxlSXRlbSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzdGF0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGVbMF0sIG9ic2VydmVyID0gc3RhdGVbMV07XG4gICAgICBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEp1c3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBhIHNpbmdsZSBlbGVtZW50LCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogIFRoZXJlIGlzIGFuIGFsaWFzIGNhbGxlZCAnanVzdCcgb3IgYnJvd3NlcnMgPElFOS5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgU2luZ2xlIGVsZW1lbnQgaW4gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBzZW5kIHRoZSBzaW5nbGUgZWxlbWVudCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgc2luZ2xlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVSZXR1cm4gPSBPYnNlcnZhYmxlWydyZXR1cm4nXSA9IE9ic2VydmFibGUuanVzdCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEp1c3RPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBUaHJvd09ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGhyb3dPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRocm93T2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGhyb3dPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IFt0aGlzLl9lcnJvciwgb107XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgP1xuICAgICAgICBzY2hlZHVsZUl0ZW0obnVsbCwgc3RhdGUpIDpcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzY2hlZHVsZUl0ZW0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUl0ZW0ocywgc3RhdGUpIHtcbiAgICAgIHZhciBlID0gc3RhdGVbMF0sIG8gPSBzdGF0ZVsxXTtcbiAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRocm93T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgdGVybWluYXRlcyB3aXRoIGFuIGV4Y2VwdGlvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIHNpbmdsZSBvbkVycm9yIG1lc3NhZ2UuXG4gICAqICBUaGVyZSBpcyBhbiBhbGlhcyB0byB0aGlzIG1ldGhvZCBjYWxsZWQgJ3Rocm93RXJyb3InIGZvciBicm93c2VycyA8SUU5LlxuICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBBbiBvYmplY3QgdXNlZCBmb3IgdGhlIHNlcXVlbmNlJ3MgdGVybWluYXRpb24uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHNlbmQgdGhlIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIGNhbGwgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5pbW1lZGlhdGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseSB3aXRoIHRoZSBzcGVjaWZpZWQgZXhjZXB0aW9uIG9iamVjdC5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlVGhyb3cgPSBPYnNlcnZhYmxlWyd0aHJvdyddID0gZnVuY3Rpb24gKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGhyb3dPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBVc2luZ09ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFVzaW5nT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBVc2luZ09ic2VydmFibGUocmVzRm4sIG9ic0ZuKSB7XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fb2JzRm4gPSBvYnNGbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFVzaW5nT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIHZhciByZXNvdXJjZSA9IHRyeUNhdGNoKHRoaXMuX3Jlc0ZuKSgpO1xuICAgICAgaWYgKHJlc291cmNlID09PSBlcnJvck9iaikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUob2JzZXJ2YWJsZVRocm93KHJlc291cmNlLmUpLnN1YnNjcmliZShvKSwgZGlzcG9zYWJsZSk7XG4gICAgICB9XG4gICAgICByZXNvdXJjZSAmJiAoZGlzcG9zYWJsZSA9IHJlc291cmNlKTtcbiAgICAgIHZhciBzb3VyY2UgPSB0cnlDYXRjaCh0aGlzLl9vYnNGbikocmVzb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKG9ic2VydmFibGVUaHJvdyhzb3VyY2UuZSkuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFVzaW5nT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBkZXBlbmRzIG9uIGEgcmVzb3VyY2Ugb2JqZWN0LCB3aG9zZSBsaWZldGltZSBpcyB0aWVkIHRvIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSdzIGxpZmV0aW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvdXJjZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiB0byBvYnRhaW4gYSByZXNvdXJjZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ic2VydmFibGVGYWN0b3J5IEZhY3RvcnkgZnVuY3Rpb24gdG8gb2J0YWluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBkZXBlbmRzIG9uIHRoZSBvYnRhaW5lZCByZXNvdXJjZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgbGlmZXRpbWUgY29udHJvbHMgdGhlIGxpZmV0aW1lIG9mIHRoZSBkZXBlbmRlbnQgcmVzb3VyY2Ugb2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS51c2luZyA9IGZ1bmN0aW9uIChyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBVc2luZ09ic2VydmFibGUocmVzb3VyY2VGYWN0b3J5LCBvYnNlcnZhYmxlRmFjdG9yeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHJlYWN0cyBmaXJzdC5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodFNvdXJjZSBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzdXJmYWNlcyBlaXRoZXIgb2YgdGhlIGdpdmVuIHNlcXVlbmNlcywgd2hpY2hldmVyIHJlYWN0ZWQgZmlyc3QuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYW1iID0gZnVuY3Rpb24gKHJpZ2h0U291cmNlKSB7XG4gICAgdmFyIGxlZnRTb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBjaG9pY2UsXG4gICAgICAgIGxlZnRDaG9pY2UgPSAnTCcsIHJpZ2h0Q2hvaWNlID0gJ1InLFxuICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIGlzUHJvbWlzZShyaWdodFNvdXJjZSkgJiYgKHJpZ2h0U291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJpZ2h0U291cmNlKSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNob2ljZUwoKSB7XG4gICAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgICAgY2hvaWNlID0gbGVmdENob2ljZTtcbiAgICAgICAgICByaWdodFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hvaWNlUigpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgICAgICBjaG9pY2UgPSByaWdodENob2ljZTtcbiAgICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdFN1YnNjcmliZSA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25OZXh0KGxlZnQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHZhciByaWdodFN1YnNjcmliZSA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICBjaG9pY2VSKCk7XG4gICAgICAgICAgY2hvaWNlID09PSByaWdodENob2ljZSAmJiBvYnNlcnZlci5vbk5leHQocmlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNob2ljZVIoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IHJpZ2h0Q2hvaWNlICYmIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjaG9pY2VSKCk7XG4gICAgICAgICAgY2hvaWNlID09PSByaWdodENob2ljZSAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBsZWZ0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUobGVmdFNvdXJjZS5zdWJzY3JpYmUobGVmdFN1YnNjcmliZSkpO1xuICAgICAgcmlnaHRTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShyaWdodFNvdXJjZS5zdWJzY3JpYmUocmlnaHRTdWJzY3JpYmUpKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGxlZnRTdWJzY3JpcHRpb24sIHJpZ2h0U3Vic2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBhbWIocCwgYykgeyByZXR1cm4gcC5hbWIoYyk7IH1cblxuICAvKipcbiAgICogUHJvcGFnYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgcmVhY3RzIGZpcnN0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHN1cmZhY2VzIGFueSBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2VzLCB3aGljaGV2ZXIgcmVhY3RlZCBmaXJzdC5cbiAgICovXG4gIE9ic2VydmFibGUuYW1iID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBvYnNlcnZhYmxlTmV2ZXIoKSwgaXRlbXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgaXRlbXMgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaXRlbXMgPSBuZXcgQXJyYXkoaXRlbXMpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGl0ZW1zW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYWNjID0gYW1iKGFjYywgaXRlbXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIHZhciBDYXRjaE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENhdGNoT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDYXRjaE9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkMSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZDEpO1xuICAgICAgZDEuc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IENhdGNoT2JzZXJ2ZXIobywgc3Vic2NyaXB0aW9uLCB0aGlzLl9mbikpKTtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQ2F0Y2hPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDYXRjaE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENhdGNoT2JzZXJ2ZXIobywgcywgZm4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX28ub25OZXh0KHgpOyB9O1xuICAgIENhdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcbiAgICBDYXRjaE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG5cbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9zLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUocmVzdWx0LnN1YnNjcmliZSh0aGlzLl9vKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGhhbmRsZXJPclNlY29uZCBFeGNlcHRpb24gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBnaXZlbiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UsIG9yIGEgc2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IHNlcXVlbmNlJ3MgZWxlbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50cyBvZiB0aGUgaGFuZGxlciBzZXF1ZW5jZSBpbiBjYXNlIGFuIGV4Y2VwdGlvbiBvY2N1cnJlZC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90b1snY2F0Y2gnXSA9IGZ1bmN0aW9uIChoYW5kbGVyT3JTZWNvbmQpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihoYW5kbGVyT3JTZWNvbmQpID8gbmV3IENhdGNoT2JzZXJ2YWJsZSh0aGlzLCBoYW5kbGVyT3JTZWNvbmQpIDogb2JzZXJ2YWJsZUNhdGNoKFt0aGlzLCBoYW5kbGVyT3JTZWNvbmRdKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIHVzZSBhcyB0aGUgbmV4dCBzZXF1ZW5jZSBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgZWxlbWVudHMgZnJvbSBjb25zZWN1dGl2ZSBzb3VyY2Ugc2VxdWVuY2VzIHVudGlsIGEgc291cmNlIHNlcXVlbmNlIHRlcm1pbmF0ZXMgc3VjY2Vzc2Z1bGx5LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVDYXRjaCA9IE9ic2VydmFibGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGl0ZW1zID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGl0ZW1zID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgaXRlbXNbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgcmV0dXJuIGVudW1lcmFibGVPZihpdGVtcykuY2F0Y2hFcnJvcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbnkgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIFByb21pc2VzIHByb2R1Y2VzIGFuIGVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGluIHRoZSBmb3JtIG9mIGFuIGFyZ3VtZW50IGxpc3Qgb2Ygb2JzZXJ2YWJsZXMgb3IgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDEgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qob2JzMSwgb2JzMiwgb2JzMywgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XG4gICAqIDIgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb21iaW5lTGF0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgYXJnc1swXS51bnNoaWZ0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlKHBhcmFtcywgY2IpIHtcbiAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5fcGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaGFzVmFsdWU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgIGhhc1ZhbHVlQWxsOiBmYWxzZSxcbiAgICAgICAgaXNEb25lOiBhcnJheUluaXRpYWxpemUobGVuLCBmYWxzZUZhY3RvcnkpLFxuICAgICAgICB2YWx1ZXM6IG5ldyBBcnJheShsZW4pXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9wYXJhbXNbaV0sIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zW2ldID0gc2FkO1xuICAgICAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIob2JzZXJ2ZXIsIGksIHRoaXMuX2NiLCBzdGF0ZSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvbWJpbmVMYXRlc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29tYmluZUxhdGVzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RPYnNlcnZlcihvLCBpLCBjYiwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9PSBpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fc3RhdGUudmFsdWVzW3RoaXMuX2ldID0geDtcbiAgICAgIHRoaXMuX3N0YXRlLmhhc1ZhbHVlW3RoaXMuX2ldID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZS5oYXNWYWx1ZUFsbCB8fCAodGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwgPSB0aGlzLl9zdGF0ZS5oYXNWYWx1ZS5ldmVyeShpZGVudGl0eSkpKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9jYikuYXBwbHkobnVsbCwgdGhpcy5fc3RhdGUudmFsdWVzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUuaXNEb25lLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgQ29tYmluZUxhdGVzdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0RvbmVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhdGUuaXNEb25lLmV2ZXJ5KGlkZW50aXR5KSAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFueSBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgUHJvbWlzZXMgcHJvZHVjZXMgYW4gZWxlbWVudC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogMSAtIG9icyA9IFJ4Lk9ic2VydmFibGUuY29tYmluZUxhdGVzdChvYnMxLCBvYnMyLCBvYnMzLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgKiAyIC0gb2JzID0gUnguT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KFtvYnMxLCBvYnMyLCBvYnMzXSwgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgKi9cbiAgdmFyIGNvbWJpbmVMYXRlc3QgPSBPYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG4gICAgcmV0dXJuIG5ldyBDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzLiAgVGhpcyB0YWtlcyBpbiBlaXRoZXIgYW4gYXJyYXkgb3IgdmFyaWFibGUgYXJndW1lbnRzIHRvIGNvbmNhdGVuYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdpdmVuIHNlcXVlbmNlLCBpbiBzZXF1ZW50aWFsIG9yZGVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IodmFyIGFyZ3MgPSBbXSwgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUNvbmNhdC5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgQ29uY2F0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29uY2F0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0T2JzZXJ2ZXIocywgZm4pIHtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENvbmNhdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcy5vLm9uTmV4dCh4KTsgfTtcbiAgICBDb25jYXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm8ub25FcnJvcihlKTsgfTtcbiAgICBDb25jYXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zLmkrKzsgdGhpcy5fZm4odGhpcy5fcyk7IH07XG5cbiAgICByZXR1cm4gQ29uY2F0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBDb25jYXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbmNhdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0T2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlIChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgIGlmIChzdGF0ZS5pID09PSBzdGF0ZS5zb3VyY2VzLmxlbmd0aCkgeyByZXR1cm4gc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBzdGF0ZS5zb3VyY2VzW3N0YXRlLmldO1xuICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHN0YXRlLnN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUobmV3IENvbmNhdE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgIH1cblxuICAgIENvbmNhdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gZGlzcG9zYWJsZUNyZWF0ZShub29wKTtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgaTogMCxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgICAgIGRpc3Bvc2FibGU6IGRpc3Bvc2FibGUsXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXNcbiAgICAgIH07XG5cbiAgICAgIHZhciBjYW5jZWxhYmxlID0gaW1tZWRpYXRlU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtzdWJzY3JpcHRpb24sIGRpc3Bvc2FibGUsIGNhbmNlbGFibGVdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbmNhdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIGNvbmNhdCB0byB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgZWFjaCBnaXZlbiBzZXF1ZW5jZSwgaW4gc2VxdWVudGlhbCBvcmRlci5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlQ29uY2F0ID0gT2JzZXJ2YWJsZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29uY2F0T2JzZXJ2YWJsZShhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggb2JzZXJ2ZWQgaW5uZXIgc2VxdWVuY2UsIGluIHNlcXVlbnRpYWwgb3JkZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29uY2F0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlKDEpO1xuICB9O1xuXG4gIHZhciBNZXJnZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1lcmdlT2JzZXJ2YWJsZShzb3VyY2UsIG1heENvbmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5tYXhDb25jdXJyZW50ID0gbWF4Q29uY3VycmVudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE1lcmdlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBnLmFkZCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHRoaXMubWF4Q29uY3VycmVudCwgZykpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VPYnNlcnZhYmxlO1xuXG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTWVyZ2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VPYnNlcnZlcihvLCBtYXgsIGcpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgIHRoaXMuZyA9IGc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucSA9IFtdO1xuICAgICAgdGhpcy5hY3RpdmVDb3VudCA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhNZXJnZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUuaGFuZGxlU3Vic2NyaWJlID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICB2YXIgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmcuYWRkKHNhZCk7XG4gICAgICBpc1Byb21pc2UoeHMpICYmICh4cyA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh4cykpO1xuICAgICAgc2FkLnNldERpc3Bvc2FibGUoeHMuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMsIHNhZCkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xuICAgICAgaWYodGhpcy5hY3RpdmVDb3VudCA8IHRoaXMubWF4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ291bnQrKztcbiAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpYmUoaW5uZXJTb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xLnB1c2goaW5uZXJTb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLm8ub25FcnJvcihlKTsgfTtcbiAgICBNZXJnZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZG9uZSA9IHRydWU7IHRoaXMuYWN0aXZlQ291bnQgPT09IDAgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHBhcmVudCwgc2FkKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuc2FkID0gc2FkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLnBhcmVudC5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMucGFyZW50Lm8ub25FcnJvcihlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhcmVudC5nLnJlbW92ZSh0aGlzLnNhZCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQucS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmhhbmRsZVN1YnNjcmliZSh0aGlzLnBhcmVudC5xLnNoaWZ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWN0aXZlQ291bnQtLTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZG9uZSAmJiB0aGlzLnBhcmVudC5hY3RpdmVDb3VudCA9PT0gMCAmJiB0aGlzLnBhcmVudC5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNZXJnZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBNZXJnZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBzdWJzY3JpcHRpb25zIHRvIGlubmVyIHNlcXVlbmNlcy5cbiAgKiBPciBtZXJnZXMgdHdvIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcGFyYW0ge01peGVkfSBbbWF4Q29uY3VycmVudE9yT3RoZXJdIE1heGltdW0gbnVtYmVyIG9mIGlubmVyIG9ic2VydmFibGUgc2VxdWVuY2VzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5IG9yIHRoZSBzZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBtZXJnZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBzZXF1ZW5jZXMuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tZXJnZSA9IGZ1bmN0aW9uIChtYXhDb25jdXJyZW50T3JPdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgbWF4Q29uY3VycmVudE9yT3RoZXIgIT09ICdudW1iZXInID9cbiAgICAgIG9ic2VydmFibGVNZXJnZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcikgOlxuICAgICAgbmV3IE1lcmdlT2JzZXJ2YWJsZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogVGhlIHNjaGVkdWxlciBpcyBvcHRpb25hbCBhbmQgaWYgbm90IHNwZWNpZmllZCwgdGhlIGltbWVkaWF0ZSBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgbWVyZ2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZU1lcmdlID0gT2JzZXJ2YWJsZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZWR1bGVyLCBzb3VyY2VzID0gW10sIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcbiAgICAgIGZvcihpID0gMTsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXMucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgfSBlbHNlIGlmIChpc1NjaGVkdWxlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IoaSA9IDE7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXI7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VzWzBdKSkge1xuICAgICAgc291cmNlcyA9IHNvdXJjZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlT2Yoc2NoZWR1bGVyLCBzb3VyY2VzKS5tZXJnZUFsbCgpO1xuICB9O1xuXG4gIHZhciBNZXJnZUFsbE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlQWxsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTWVyZ2VBbGxPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSwgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgZy5hZGQobSk7XG4gICAgICBtLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZUFsbE9ic2VydmVyKG8sIGcpKSk7XG4gICAgICByZXR1cm4gZztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlQWxsT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBNZXJnZUFsbE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbE9ic2VydmVyKG8sIGcpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmcgPSBnO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhNZXJnZUFsbE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgTWVyZ2VBbGxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGlubmVyU291cmNlKSB7XG4gICAgICB2YXIgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmcuYWRkKHNhZCk7XG4gICAgICBpc1Byb21pc2UoaW5uZXJTb3VyY2UpICYmIChpbm5lclNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShpbm5lclNvdXJjZSkpO1xuICAgICAgc2FkLnNldERpc3Bvc2FibGUoaW5uZXJTb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMsIHNhZCkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VBbGxPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIE1lcmdlQWxsT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLmcubGVuZ3RoID09PSAxICYmIHRoaXMuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHBhcmVudCwgc2FkKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuc2FkID0gc2FkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5wYXJlbnQuby5vbk5leHQoeCk7XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnBhcmVudC5vLm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhcmVudC5nLnJlbW92ZSh0aGlzLnNhZCk7XG4gICAgICB0aGlzLnBhcmVudC5kb25lICYmIHRoaXMucGFyZW50LmcubGVuZ3RoID09PSAxICYmIHRoaXMucGFyZW50Lm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlQWxsT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIE1lcmdlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBtZXJnZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBzZXF1ZW5jZXMuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tZXJnZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE1lcmdlQWxsT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgQ29tcG9zaXRlRXJyb3IgPSBSeC5Db21wb3NpdGVFcnJvciA9IGZ1bmN0aW9uKGVycm9ycykge1xuICAgIHRoaXMuaW5uZXJFcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1RoaXMgY29udGFpbnMgbXVsdGlwbGUgZXJyb3JzLiBDaGVjayB0aGUgaW5uZXJFcnJvcnMnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIENvbXBvc2l0ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgQ29tcG9zaXRlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQ29tcG9zaXRlRXJyb3InO1xuXG4gIHZhciBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlRGVsYXlFcnJvck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxuICAgICAgICBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHN0YXRlID0geyBpc1N0b3BwZWQ6IGZhbHNlLCBlcnJvcnM6IFtdLCBvOiBvIH07XG5cbiAgICAgIGdyb3VwLmFkZChtKTtcbiAgICAgIG0uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlRGVsYXlFcnJvck9ic2VydmVyKGdyb3VwLCBzdGF0ZSkpKTtcblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBNZXJnZURlbGF5RXJyb3JPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhNZXJnZURlbGF5RXJyb3JPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNZXJnZURlbGF5RXJyb3JPYnNlcnZlcihncm91cCwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q29tcGxldGlvbihvLCBlcnJvcnMpIHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBvLm9uRXJyb3IoZXJyb3JzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ub25FcnJvcihuZXcgQ29tcG9zaXRlRXJyb3IoZXJyb3JzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9ncm91cC5hZGQoaW5uZXIpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZXMgc3VwcG9ydFxuICAgICAgaXNQcm9taXNlKHgpICYmICh4ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHgpKTtcbiAgICAgIGlubmVyLnNldERpc3Bvc2FibGUoeC5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIoaW5uZXIsIHRoaXMuX2dyb3VwLCB0aGlzLl9zdGF0ZSkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmVycm9ycy5wdXNoKGUpO1xuICAgICAgdGhpcy5fc3RhdGUuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2dyb3VwLmxlbmd0aCA9PT0gMSAmJiBzZXRDb21wbGV0aW9uKHRoaXMuX3N0YXRlLm8sIHRoaXMuX3N0YXRlLmVycm9ycyk7XG4gICAgfTtcblxuICAgIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKGlubmVyLCBncm91cCwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX2lubmVyID0gaW5uZXI7XG4gICAgICB0aGlzLl9ncm91cCA9IGdyb3VwO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9zdGF0ZS5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5lcnJvcnMucHVzaChlKTtcbiAgICAgIHRoaXMuX2dyb3VwLnJlbW92ZSh0aGlzLl9pbm5lcik7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgJiYgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2dyb3VwLnJlbW92ZSh0aGlzLl9pbm5lcik7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgJiYgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBGbGF0dGVucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMgaW50byBvbmUgT2JzZXJ2YWJsZSwgaW4gYSB3YXkgdGhhdCBhbGxvd3MgYW4gT2JzZXJ2ZXIgdG9cbiAgKiByZWNlaXZlIGFsbCBzdWNjZXNzZnVsbHkgZW1pdHRlZCBpdGVtcyBmcm9tIGFsbCBvZiB0aGUgc291cmNlIE9ic2VydmFibGVzIHdpdGhvdXQgYmVpbmcgaW50ZXJydXB0ZWQgYnlcbiAgKiBhbiBlcnJvciBub3RpZmljYXRpb24gZnJvbSBvbmUgb2YgdGhlbS5cbiAgKlxuICAqIFRoaXMgYmVoYXZlcyBsaWtlIE9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlQWxsIGV4Y2VwdCB0aGF0IGlmIGFueSBvZiB0aGUgbWVyZ2VkIE9ic2VydmFibGVzIG5vdGlmeSBvZiBhblxuICAqIGVycm9yIHZpYSB0aGUgT2JzZXJ2ZXIncyBvbkVycm9yLCBtZXJnZURlbGF5RXJyb3Igd2lsbCByZWZyYWluIGZyb20gcHJvcGFnYXRpbmcgdGhhdFxuICAqIGVycm9yIG5vdGlmaWNhdGlvbiB1bnRpbCBhbGwgb2YgdGhlIG1lcmdlZCBPYnNlcnZhYmxlcyBoYXZlIGZpbmlzaGVkIGVtaXR0aW5nIGl0ZW1zLlxuICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIG1lcmdlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIG9mIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBPYnNlcnZhYmxlcyBlbWl0dGVkIGJ5IHRoZSBPYnNlcnZhYmxlXG4gICovXG4gIE9ic2VydmFibGUubWVyZ2VEZWxheUVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIH1cbiAgICB2YXIgc291cmNlID0gb2JzZXJ2YWJsZU9mKG51bGwsIGFyZ3MpO1xuICAgIHJldHVybiBuZXcgTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZShzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgbm9ybWFsbHkgb3IgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzZWNvbmQgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgYWZ0ZXIgdGhlIGZpcnN0IHNlcXVlbmNlIHRlcm1pbmF0ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29uY2F0ZW5hdGVzIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHNlcXVlbmNlLCBldmVuIGlmIHRoZSBmaXJzdCBzZXF1ZW5jZSB0ZXJtaW5hdGVzIGV4Y2VwdGlvbmFsbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ub25FcnJvclJlc3VtZU5leHQgPSBmdW5jdGlvbiAoc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHsgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgb2JzZXJ2YWJsZSBpcyByZXF1aXJlZCcpOyB9XG4gICAgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0KFt0aGlzLCBzZWNvbmRdKTtcbiAgfTtcblxuICB2YXIgT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUoc291cmNlcykge1xuICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzdGF0ZS5zb3VyY2VzW3N0YXRlLnBvcysrXTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnQpICYmIChjdXJyZW50ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnQpKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICAgIGQuc2V0RGlzcG9zYWJsZShjdXJyZW50LnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgICAgc3RhdGUgPSB7cG9zOiAwLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiwgbzogbywgc291cmNlczogdGhpcy5zb3VyY2VzIH0sXG4gICAgICAgICAgY2FuY2VsbGFibGUgPSBpbW1lZGlhdGVTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsbGFibGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25FcnJvclJlc3VtZU5leHRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlY3Vyc2UodGhpcy5fc3RhdGUpOyB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVjdXJzZSh0aGlzLl9zdGF0ZSk7IH07XG5cbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbnRpbnVlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGVybWluYXRlZCBub3JtYWxseSBvciBieSBhbiBleGNlcHRpb24gd2l0aCB0aGUgbmV4dCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbmNhdGVuYXRlcyB0aGUgc291cmNlIHNlcXVlbmNlcywgZXZlbiBpZiBhIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseS5cbiAgICovXG4gIHZhciBvbkVycm9yUmVzdW1lTmV4dCA9IE9ic2VydmFibGUub25FcnJvclJlc3VtZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzb3VyY2VzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHNvdXJjZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlKHNvdXJjZXMpO1xuICB9O1xuXG4gIHZhciBTa2lwVW50aWxPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPYnNlcnZhYmxlKHNvdXJjZSwgb3RoZXIpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9vID0gaXNQcm9taXNlKG90aGVyKSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikgOiBvdGhlcjtcbiAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbGVmdFN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgbGVmdFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHRoaXMuX3Muc3Vic2NyaWJlKG5ldyBTa2lwVW50aWxTb3VyY2VPYnNlcnZlcihvLCB0aGlzKSkpO1xuXG4gICAgICBpc1Byb21pc2UodGhpcy5fbykgJiYgKHRoaXMuX28gPSBvYnNlcnZhYmxlRnJvbVByb21pc2UodGhpcy5fbykpO1xuXG4gICAgICB2YXIgcmlnaHRTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5fby5zdWJzY3JpYmUobmV3IFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIobywgdGhpcywgcmlnaHRTdWJzY3JpcHRpb24pKSk7XG5cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShsZWZ0U3Vic2NyaXB0aW9uLCByaWdodFN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbFNvdXJjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9wLl9vcGVuICYmIHRoaXMuX28ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuXG4gICAgU2tpcFVudGlsU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcC5fb3BlbiAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxTb3VyY2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsT3RoZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPdGhlck9ic2VydmVyKG8sIHAsIHIpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9yID0gcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wLl9vcGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3IuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxPdGhlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxPdGhlck9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3IuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFVudGlsT3RoZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvbmx5IGFmdGVyIHRoZSBvdGhlciBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2VzIGEgdmFsdWUuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZSB8IFByb21pc2V9IG90aGVyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB0cmlnZ2VycyBwcm9wYWdhdGlvbiBvZiBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHN0YXJ0aW5nIGZyb20gdGhlIHBvaW50IHRoZSBvdGhlciBzZXF1ZW5jZSB0cmlnZ2VyZWQgcHJvcGFnYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFVudGlsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBTa2lwVW50aWxPYnNlcnZhYmxlKHRoaXMsIG90aGVyKTtcbiAgfTtcblxuICB2YXIgU3dpdGNoT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGlubmVyID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSwgcyA9IHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoT2JzZXJ2ZXIobywgaW5uZXIpKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzLCBpbm5lcik7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKFN3aXRjaE9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPYnNlcnZlcihvLCBpbm5lcikge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXRlc3QgPSAwO1xuICAgICAgdGhpcy5oYXNMYXRlc3QgPSBmYWxzZTtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSwgaWQgPSArK3RoaXMubGF0ZXN0O1xuICAgICAgdGhpcy5oYXNMYXRlc3QgPSB0cnVlO1xuICAgICAgdGhpcy5pbm5lci5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgaXNQcm9taXNlKGlubmVyU291cmNlKSAmJiAoaW5uZXJTb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoaW5uZXJTb3VyY2UpKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShpbm5lclNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIodGhpcywgaWQpKSk7XG4gICAgfTtcblxuICAgIFN3aXRjaE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU3dpdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAhdGhpcy5oYXNMYXRlc3QgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIocGFyZW50LCBpZCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5wYXJlbnQubGF0ZXN0ID09PSB0aGlzLmlkICYmIHRoaXMucGFyZW50Lm8ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnBhcmVudC5sYXRlc3QgPT09IHRoaXMuaWQgJiYgdGhpcy5wYXJlbnQuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQubGF0ZXN0ID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmhhc0xhdGVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmVudC5zdG9wcGVkICYmIHRoaXMucGFyZW50Lm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFN3aXRjaE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiBUcmFuc2Zvcm1zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGF0IGFueSBwb2ludCBpbiB0aW1lIHByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgbW9zdCByZWNlbnQgaW5uZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ3N3aXRjaCddID0gb2JzZXJ2YWJsZVByb3RvLnN3aXRjaExhdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN3aXRjaE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFRha2VVbnRpbE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVVudGlsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFRha2VVbnRpbE9ic2VydmFibGUoc291cmNlLCBvdGhlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm90aGVyID0gaXNQcm9taXNlKG90aGVyKSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikgOiBvdGhlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VVbnRpbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShvKSxcbiAgICAgICAgdGhpcy5vdGhlci5zdWJzY3JpYmUobmV3IFRha2VVbnRpbE9ic2VydmVyKG8pKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VVbnRpbE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZVVudGlsT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVVudGlsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlVW50aWxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgVGFrZVVudGlsT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGVycik7XG4gICAgfTtcblxuICAgIFRha2VVbnRpbE9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IG5vb3A7XG5cbiAgICByZXR1cm4gVGFrZVVudGlsT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdW50aWwgdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlIHwgUHJvbWlzZX0gb3RoZXIgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgdGVybWluYXRlcyBwcm9wYWdhdGlvbiBvZiBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHVwIHRvIHRoZSBwb2ludCB0aGUgb3RoZXIgc2VxdWVuY2UgaW50ZXJydXB0ZWQgZnVydGhlciBwcm9wYWdhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlVW50aWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFRha2VVbnRpbE9ic2VydmFibGUodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIFdpdGhMYXRlc3RGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlKHNvdXJjZSwgc291cmNlcywgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zcyA9IHNvdXJjZXM7XG4gICAgICB0aGlzLl9jYiA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9zcy5sZW5ndGg7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGhhc1ZhbHVlOiBhcnJheUluaXRpYWxpemUobGVuLCBmYWxzZUZhY3RvcnkpLFxuICAgICAgICBoYXNWYWx1ZUFsbDogZmFsc2UsXG4gICAgICAgIHZhbHVlczogbmV3IEFycmF5KGxlbilcbiAgICAgIH07XG5cbiAgICAgIHZhciBuID0gdGhpcy5fc3MubGVuZ3RoLCBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHRoaXMuX3NzW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG5ldyBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIobywgaSwgc3RhdGUpKSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRlclNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgb3V0ZXJTYWQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zLnN1YnNjcmliZShuZXcgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlcihvLCB0aGlzLl9jYiwgc3RhdGUpKSk7XG4gICAgICBzdWJzY3JpcHRpb25zW25dID0gb3V0ZXJTYWQ7XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyKG8sIGksIHN0YXRlKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zdGF0ZS52YWx1ZXNbdGhpcy5faV0gPSB4O1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwgPSB0aGlzLl9zdGF0ZS5oYXNWYWx1ZS5ldmVyeShpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IG5vb3A7XG5cbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyKG8sIGNiLCBzdGF0ZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFdpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGFsbFZhbHVlcyA9IFt4XS5jb25jYXQodGhpcy5fc3RhdGUudmFsdWVzKTtcbiAgICAgIGlmICghdGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fY2IpLmFwcGx5KG51bGwsIGFsbFZhbHVlcyk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICB9O1xuXG4gICAgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogTWVyZ2VzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gb25seSB3aGVuIHRoZSAoZmlyc3QpIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2VzIGFuIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2l0aExhdGVzdEZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cycpOyB9XG5cbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihhcmdzW2xlbiAtIDFdKSA/IGFyZ3MucG9wKCkgOiBhcmd1bWVudHNUb0FycmF5O1xuICAgIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgKGFyZ3MgPSBhcmdzWzBdKTtcblxuICAgIHJldHVybiBuZXcgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlKHRoaXMsIGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmYWxzZUZhY3RvcnkoKSB7IHJldHVybiBmYWxzZTsgfVxuICBmdW5jdGlvbiBlbXB0eUFycmF5RmFjdG9yeSgpIHsgcmV0dXJuIFtdOyB9XG5cbiAgdmFyIFppcE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoWmlwT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBaaXBPYnNlcnZhYmxlKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl9zID0gc291cmNlcztcbiAgICAgIHRoaXMuX2NiID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBaaXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5fcy5sZW5ndGgsXG4gICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBkb25lID0gYXJyYXlJbml0aWFsaXplKG4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgICAgcSA9IGFycmF5SW5pdGlhbGl6ZShuLCBlbXB0eUFycmF5RmFjdG9yeSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9zW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uc1tpXSA9IHNhZDtcbiAgICAgICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShuZXcgWmlwT2JzZXJ2ZXIob2JzZXJ2ZXIsIGksIHRoaXMsIHEsIGRvbmUpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBaaXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFppcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhaaXBPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBaaXBPYnNlcnZlcihvLCBpLCBwLCBxLCBkKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9xID0gcTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90RW1wdHkoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9XG4gICAgZnVuY3Rpb24gc2hpZnRFYWNoKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfVxuICAgIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9PSBpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBaaXBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9xW3RoaXMuX2ldLnB1c2goeCk7XG4gICAgICBpZiAodGhpcy5fcS5ldmVyeShub3RFbXB0eSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlZFZhbHVlcyA9IHRoaXMuX3EubWFwKHNoaWZ0RWFjaCk7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9wLl9jYikuYXBwbHkobnVsbCwgcXVldWVkVmFsdWVzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZC5maWx0ZXIobm90VGhlU2FtZSh0aGlzLl9pKSkuZXZlcnkoaWRlbnRpdHkpKSB7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWmlwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgWmlwT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2RbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fZC5ldmVyeShpZGVudGl0eSkgJiYgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWmlwT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbGwgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIGFuIGFycmF5IGhhdmUgcHJvZHVjZWQgYW4gZWxlbWVudCBhdCBhIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gICAqIFRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGFyZ3VtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHNlcmllcyBvZiBlbGVtZW50cyBhdCBjb3JyZXNwb25kaW5nIGluZGV4ZXMgaW4gdGhlIGFyZ3MuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIGFyZ3MgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uemlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudHMnKTsgfVxuXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICBhcmdzLnVuc2hpZnQocGFyZW50KTtcblxuICAgIHJldHVybiBuZXcgWmlwT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFsbCBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGF2ZSBwcm9kdWNlZCBhbiBlbGVtZW50IGF0IGEgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICogQHBhcmFtIGFyZ3VtZW50cyBPYnNlcnZhYmxlIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBzb3VyY2VzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS56aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzID0gaXNGdW5jdGlvbihhcmdzWzFdKSA/IGFyZ3NbMF0uY29uY2F0KGFyZ3NbMV0pIDogYXJnc1swXTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gYXJncy5zaGlmdCgpO1xuICAgIHJldHVybiBmaXJzdC56aXAuYXBwbHkoZmlyc3QsIGFyZ3MpO1xuICB9O1xuXG5mdW5jdGlvbiBmYWxzZUZhY3RvcnkoKSB7IHJldHVybiBmYWxzZTsgfVxuZnVuY3Rpb24gZW1wdHlBcnJheUZhY3RvcnkoKSB7IHJldHVybiBbXTsgfVxuZnVuY3Rpb24gYXJndW1lbnRzVG9BcnJheSgpIHtcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbnZhciBaaXBJdGVyYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gIGluaGVyaXRzKFppcEl0ZXJhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gWmlwSXRlcmFibGVPYnNlcnZhYmxlKHNvdXJjZXMsIGNiKSB7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLl9jYiA9IGNiO1xuICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgWmlwSXRlcmFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuc291cmNlcywgbGVuID0gc291cmNlcy5sZW5ndGgsIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHE6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGVtcHR5QXJyYXlGYWN0b3J5KSxcbiAgICAgIGRvbmU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICBjYjogdGhpcy5fY2IsXG4gICAgICBvOiBvXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXSwgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIChpc0FycmF5TGlrZShzb3VyY2UpIHx8IGlzSXRlcmFibGUoc291cmNlKSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tKHNvdXJjZSkpO1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobmV3IFppcEl0ZXJhYmxlT2JzZXJ2ZXIoc3RhdGUsIGkpKSk7XG4gICAgICB9KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBaaXBJdGVyYWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVCYXNlKSk7XG5cbnZhciBaaXBJdGVyYWJsZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgaW5oZXJpdHMoWmlwSXRlcmFibGVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gWmlwSXRlcmFibGVPYnNlcnZlcihzLCBpKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5faSA9IGk7XG4gICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RFbXB0eSh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH1cbiAgZnVuY3Rpb24gc2hpZnRFYWNoKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfVxuICBmdW5jdGlvbiBub3RUaGVTYW1lKGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGopIHtcbiAgICAgIHJldHVybiBqICE9PSBpO1xuICAgIH07XG4gIH1cblxuICBaaXBJdGVyYWJsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9zLnFbdGhpcy5faV0ucHVzaCh4KTtcbiAgICBpZiAodGhpcy5fcy5xLmV2ZXJ5KG5vdEVtcHR5KSkge1xuICAgICAgdmFyIHF1ZXVlZFZhbHVlcyA9IHRoaXMuX3MucS5tYXAoc2hpZnRFYWNoKSxcbiAgICAgICAgICByZXMgPSB0cnlDYXRjaCh0aGlzLl9zLmNiKS5hcHBseShudWxsLCBxdWV1ZWRWYWx1ZXMpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX3Muby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5fcy5vLm9uTmV4dChyZXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcy5kb25lLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcblxuICBaaXBJdGVyYWJsZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuXG4gIFppcEl0ZXJhYmxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zLmRvbmVbdGhpcy5faV0gPSB0cnVlO1xuICAgIHRoaXMuX3MuZG9uZS5ldmVyeShpZGVudGl0eSkgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gIH07XG5cbiAgcmV0dXJuIFppcEl0ZXJhYmxlT2JzZXJ2ZXI7XG59KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbGwgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIGFuIGFycmF5IGhhdmUgcHJvZHVjZWQgYW4gZWxlbWVudCBhdCBhIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gKiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBhcmd1bWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBhcmdzLlxuICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgYXJncyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAqL1xub2JzZXJ2YWJsZVByb3RvLnppcEl0ZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzJyk7IH1cblxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKGFyZ3NbbGVuIC0gMV0pID8gYXJncy5wb3AoKSA6IGFyZ3VtZW50c1RvQXJyYXk7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG4gIGFyZ3MudW5zaGlmdChwYXJlbnQpO1xuICByZXR1cm4gbmV3IFppcEl0ZXJhYmxlT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG59O1xuXG4gIGZ1bmN0aW9uIGFzT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3Vic2NyaWJlKG8pIHsgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobyk7IH07XG4gIH1cblxuICAvKipcbiAgICogIEhpZGVzIHRoZSBpZGVudGl0eSBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhpZGVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoYXNPYnNlcnZhYmxlKHRoaXMpLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0FycmF5KHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9XG4gIGZ1bmN0aW9uIG5vdEVtcHR5KHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgYnVmZmVycyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gZWxlbWVudCBjb3VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IExlbmd0aCBvZiBlYWNoIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIGJ1ZmZlcnMuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gdGhlIGNvdW50LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhDb3VudCA9IG9ic2VydmFibGVQcm90by5idWZmZXJDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgc2tpcCkge1xuICAgIHR5cGVvZiBza2lwICE9PSAnbnVtYmVyJyAmJiAoc2tpcCA9IGNvdW50KTtcbiAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoQ291bnQoY291bnQsIHNraXApXG4gICAgICAuZmxhdE1hcCh0b0FycmF5KVxuICAgICAgLmZpbHRlcihub3RFbXB0eSk7XG4gIH07XG5cbiAgdmFyIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGVtYXRlcmlhbGl6ZU9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIERlbWF0ZXJpYWxpemVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVtYXRlcmlhbGl6ZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRGVtYXRlcmlhbGl6ZU9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgeC5hY2NlcHQodGhpcy5fbyk7IH07XG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIERlbWF0ZXJpYWxpemVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERlbWF0ZXJpYWxpemVzIHRoZSBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgaW1wbGljaXQgbm90aWZpY2F0aW9ucy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZXhoaWJpdGluZyB0aGUgYmVoYXZpb3IgY29ycmVzcG9uZGluZyB0byB0aGUgc291cmNlIHNlcXVlbmNlJ3Mgbm90aWZpY2F0aW9uIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kZW1hdGVyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZhYmxlKHNvdXJjZSwga2V5Rm4sIGNvbXBhcmVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMua2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyKG8sIHRoaXMua2V5Rm4sIHRoaXMuY29tcGFyZXIpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlcihvLCBrZXlGbiwgY29tcGFyZXIpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmtleUZuID0ga2V5Rm47XG4gICAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXI7XG4gICAgICB0aGlzLmhhc0N1cnJlbnRLZXkgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudEtleSA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrZXkgPSB4LCBjb21wYXJlckVxdWFscztcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMua2V5Rm4pKSB7XG4gICAgICAgIGtleSA9IHRyeUNhdGNoKHRoaXMua2V5Rm4pKHgpO1xuICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNDdXJyZW50S2V5KSB7XG4gICAgICAgIGNvbXBhcmVyRXF1YWxzID0gdHJ5Q2F0Y2godGhpcy5jb21wYXJlcikodGhpcy5jdXJyZW50S2V5LCBrZXkpO1xuICAgICAgICBpZiAoY29tcGFyZXJFcXVhbHMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLm8ub25FcnJvcihjb21wYXJlckVxdWFscy5lKTsgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmhhc0N1cnJlbnRLZXkgfHwgIWNvbXBhcmVyRXF1YWxzKSB7XG4gICAgICAgIHRoaXMuaGFzQ3VycmVudEtleSA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudEtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBvbmx5IGRpc3RpbmN0IGNvbnRpZ3VvdXMgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBrZXlGbiBhbmQgdGhlIGNvbXBhcmVyLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtrZXlGbl0gQSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBjb21wYXJpc29uIGtleSBmb3IgZWFjaCBlbGVtZW50LiBJZiBub3QgcHJvdmlkZWQsIGl0IHByb2plY3RzIHRoZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIEVxdWFsaXR5IGNvbXBhcmVyIGZvciBjb21wdXRlZCBrZXkgdmFsdWVzLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGFuIGVxdWFsaXR5IGNvbXBhcmVyIGZ1bmN0aW9uLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgY29udGFpbmluZyB0aGUgZGlzdGluY3QgY29udGlndW91cyBlbGVtZW50cywgYmFzZWQgb24gYSBjb21wdXRlZCBrZXkgdmFsdWUsIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZnVuY3Rpb24gKGtleUZuLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUodGhpcywga2V5Rm4sIGNvbXBhcmVyKTtcbiAgfTtcblxuICB2YXIgVGFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYXBPYnNlcnZhYmxlLF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFwT2JzZXJ2YWJsZShzb3VyY2UsIG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX29OID0gb2JzZXJ2ZXJPck9uTmV4dDtcbiAgICAgIHRoaXMuX29FID0gb25FcnJvcjtcbiAgICAgIHRoaXMuX29DID0gb25Db21wbGV0ZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMudCA9ICFwLl9vTiB8fCBpc0Z1bmN0aW9uKHAuX29OKSA/XG4gICAgICAgIG9ic2VydmVyQ3JlYXRlKHAuX29OIHx8IG5vb3AsIHAuX29FIHx8IG5vb3AsIHAuX29DIHx8IG5vb3ApIDpcbiAgICAgICAgcC5fb047XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMudC5vbk5leHQpLmNhbGwodGhpcy50LCB4KTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy50Lm9uRXJyb3IpLmNhbGwodGhpcy50LCBlcnIpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMudC5vbkNvbXBsZXRlZCkuY2FsbCh0aGlzLnQpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIGludm9rZXMgYW4gYWN0aW9uIHVwb24gZ3JhY2VmdWwgb3IgZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JzZXJ2ZXJ9IG9ic2VydmVyT3JPbk5leHQgQWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIGFuIG8uXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdICBBY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuIFVzZWQgaWYgb25seSB0aGUgb2JzZXJ2ZXJPck9uTmV4dCBwYXJhbWV0ZXIgaXMgYWxzbyBhIGZ1bmN0aW9uLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlZF0gIEFjdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVXNlZCBpZiBvbmx5IHRoZSBvYnNlcnZlck9yT25OZXh0IHBhcmFtZXRlciBpcyBhbHNvIGEgZnVuY3Rpb24uXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvWydkbyddID0gb2JzZXJ2YWJsZVByb3RvLnRhcCA9IG9ic2VydmFibGVQcm90by5kb0FjdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgIHJldHVybiBuZXcgVGFwT2JzZXJ2YWJsZSh0aGlzLCBvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCk7XG4gIH07XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgQWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uTmV4dCA9IG9ic2VydmFibGVQcm90by50YXBPbk5leHQgPSBmdW5jdGlvbiAob25OZXh0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICh4KSB7IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgpOyB9IDogb25OZXh0KTtcbiAgfTtcblxuICAvKipcbiAgKiAgSW52b2tlcyBhbiBhY3Rpb24gdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZywgbG9nZ2luZywgZXRjLiBvZiBxdWVyeSBiZWhhdmlvciBieSBpbnRlcmNlcHRpbmcgdGhlIG1lc3NhZ2Ugc3RyZWFtIHRvIHJ1biBhcmJpdHJhcnkgYWN0aW9ucyBmb3IgbWVzc2FnZXMgb24gdGhlIHBpcGVsaW5lLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQWN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uRXJyb3IgPSBvYnNlcnZhYmxlUHJvdG8udGFwT25FcnJvciA9IGZ1bmN0aW9uIChvbkVycm9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIChlKSB7IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlKTsgfSA6IG9uRXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAqICBJbnZva2VzIGFuIGFjdGlvbiB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nLCBsb2dnaW5nLCBldGMuIG9mIHF1ZXJ5IGJlaGF2aW9yIGJ5IGludGVyY2VwdGluZyB0aGUgbWVzc2FnZSBzdHJlYW0gdG8gcnVuIGFyYml0cmFyeSBhY3Rpb25zIGZvciBtZXNzYWdlcyBvbiB0aGUgcGlwZWxpbmUuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgQWN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uQ29tcGxldGVkID0gb2JzZXJ2YWJsZVByb3RvLnRhcE9uQ29tcGxldGVkID0gZnVuY3Rpb24gKG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICgpIHsgb25Db21wbGV0ZWQuY2FsbCh0aGlzQXJnKTsgfSA6IG9uQ29tcGxldGVkKTtcbiAgfTtcblxuICB2YXIgRmluYWxseU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZpbmFsbHlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlPYnNlcnZhYmxlKHNvdXJjZSwgZm4sIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBiaW5kQ2FsbGJhY2soZm4sIHRoaXNBcmcsIDApO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmluYWxseU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGQgPSB0cnlDYXRjaCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUpLmNhbGwodGhpcy5zb3VyY2UsIG8pO1xuICAgICAgaWYgKGQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX2ZuKCk7XG4gICAgICAgIHRocm93ZXIoZC5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBGaW5hbGx5RGlzcG9zYWJsZShkLCB0aGlzLl9mbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZpbmFsbHlEaXNwb3NhYmxlKHMsIGZuKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICB9XG4gICAgRmluYWxseURpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fcy5kaXNwb3NlKS5jYWxsKHRoaXMuX3MpO1xuICAgICAgICB0aGlzLl9mbigpO1xuICAgICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmluYWxseU9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgSW52b2tlcyBhIHNwZWNpZmllZCBhY3Rpb24gYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZ3JhY2VmdWxseSBvciBleGNlcHRpb25hbGx5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5hbGx5QWN0aW9uIEFjdGlvbiB0byBpbnZva2UgYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgYWN0aW9uLWludm9raW5nIHRlcm1pbmF0aW9uIGJlaGF2aW9yIGFwcGxpZWQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ2ZpbmFsbHknXSA9IGZ1bmN0aW9uIChhY3Rpb24sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZpbmFsbHlPYnNlcnZhYmxlKHRoaXMsIGFjdGlvbiwgdGhpc0FyZyk7XG4gIH07XG5cbiAgdmFyIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJZ25vcmVFbGVtZW50c09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c09ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUub25OZXh0ID0gbm9vcDtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vLm9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBJZ25vcmVFbGVtZW50c09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIElnbm9yZXMgYWxsIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgbGVhdmluZyBvbmx5IHRoZSB0ZXJtaW5hdGlvbiBtZXNzYWdlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIGVtcHR5IG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaWduYWxzIHRlcm1pbmF0aW9uLCBzdWNjZXNzZnVsIG9yIGV4Y2VwdGlvbmFsLCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmlnbm9yZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSWdub3JlRWxlbWVudHNPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBNYXRlcmlhbGl6ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1hdGVyaWFsaXplT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbGl6ZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNYXRlcmlhbGl6ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTWF0ZXJpYWxpemVPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXRlcmlhbGl6ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTWF0ZXJpYWxpemVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWF0ZXJpYWxpemVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0KHgpKSB9O1xuICAgIE1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25FcnJvcihlKSk7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcbiAgICBNYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkKCkpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gTWF0ZXJpYWxpemVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBNYXRlcmlhbGl6ZXMgdGhlIGltcGxpY2l0IG5vdGlmaWNhdGlvbnMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBtYXRlcmlhbGl6ZWQgbm90aWZpY2F0aW9uIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWF0ZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRlcmlhbGl6ZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBSZXBlYXRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIHJlcGVhdCBjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc2VxdWVuY2UgcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVwZWF0Q291bnRdICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzZXF1ZW5jZS4gSWYgbm90IHByb3ZpZGVkLCByZXBlYXRzIHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBwcm9kdWNpbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzZXF1ZW5jZSByZXBlYXRlZGx5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIChyZXBlYXRDb3VudCkge1xuICAgIHJldHVybiBlbnVtZXJhYmxlUmVwZWF0KHRoaXMsIHJlcGVhdENvdW50KS5jb25jYXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJlcGVhdHMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIG9yIHVudGlsIGl0IHN1Y2Nlc3NmdWxseSB0ZXJtaW5hdGVzLiBJZiB0aGUgcmV0cnkgY291bnQgaXMgbm90IHNwZWNpZmllZCwgaXQgcmV0cmllcyBpbmRlZmluaXRlbHkuXG4gICAqICBOb3RlIGlmIHlvdSBlbmNvdW50ZXIgYW4gZXJyb3IgYW5kIHdhbnQgaXQgdG8gcmV0cnkgb25jZSwgdGhlbiB5b3UgbXVzdCB1c2UgLnJldHJ5KDIpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHJldHJpZWQgPSByZXRyeS5yZXBlYXQoKTtcbiAgICogIHZhciByZXMgPSByZXRyaWVkID0gcmV0cnkucmVwZWF0KDIpO1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3JldHJ5Q291bnRdICBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgdGhlIHNlcXVlbmNlLiBJZiBub3QgcHJvdmlkZWQsIHJldHJ5IHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNlcXVlbmNlIHJlcGVhdGVkbHkgdW50aWwgaXQgdGVybWluYXRlcyBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmV0cnkgPSBmdW5jdGlvbiAocmV0cnlDb3VudCkge1xuICAgIHJldHVybiBlbnVtZXJhYmxlUmVwZWF0KHRoaXMsIHJldHJ5Q291bnQpLmNhdGNoRXJyb3IoKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAaXRlcmF0b3InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIFJldHJ5V2hlbk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGlzcG9zYWJsZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5PYnNlcnZhYmxlKHNvdXJjZSwgbm90aWZpZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fbm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFJldHJ5V2hlbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBSZXRyeVdoZW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBleGNlcHRpb25zID0gbmV3IFN1YmplY3QoKSxcbiAgICAgICAgbm90aWZpZXIgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBoYW5kbGVkID0gdGhpcy5fbm90aWZpZXIoZXhjZXB0aW9ucyksXG4gICAgICAgIG5vdGlmaWNhdGlvbkRpc3Bvc2FibGUgPSBoYW5kbGVkLnN1YnNjcmliZShub3RpZmllcik7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zb3VyY2VbJ0BAaXRlcmF0b3InXSgpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB7IGlzRGlzcG9zZWQ6IGZhbHNlIH0sXG4gICAgICAgIGxhc3RFcnJvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShudWxsLCBmdW5jdGlvbiAoXywgcmVjdXJzZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gZS5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHtcbiAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IobGFzdEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG5ldyBCaW5hcnlEaXNwb3NhYmxlKGlubmVyLCBvdXRlcikpO1xuICAgICAgICBvdXRlci5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24oeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7XG4gICAgICAgICAgICBpbm5lci5zZXREaXNwb3NhYmxlKG5vdGlmaWVyLnN1YnNjcmliZShyZWN1cnNlLCBmdW5jdGlvbihleCkge1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZXhjZXB0aW9ucy5vbk5leHQoZXhuKTtcbiAgICAgICAgICAgIG91dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvLm9uQ29tcGxldGVkKCk7IH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtub3RpZmljYXRpb25EaXNwb3NhYmxlLCBzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXRyeVdoZW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgb2JzZXJ2YWJsZVByb3RvLnJldHJ5V2hlbiA9IGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgIHJldHVybiBuZXcgUmV0cnlXaGVuT2JzZXJ2YWJsZShyZXBlYXQodGhpcyksIG5vdGlmaWVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAaXRlcmF0b3InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIFJlcGVhdFdoZW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVwZWF0V2hlbk9ic2VydmFibGUoc291cmNlLCBub3RpZmllcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoUmVwZWF0V2hlbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBSZXBlYXRXaGVuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgY29tcGxldGlvbnMgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBub3RpZmllciA9IG5ldyBTdWJqZWN0KCksXG4gICAgICAgIGhhbmRsZWQgPSB0aGlzLl9ub3RpZmllcihjb21wbGV0aW9ucyksXG4gICAgICAgIG5vdGlmaWNhdGlvbkRpc3Bvc2FibGUgPSBoYW5kbGVkLnN1YnNjcmliZShub3RpZmllcik7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zb3VyY2VbJ0BAaXRlcmF0b3InXSgpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB7IGlzRGlzcG9zZWQ6IGZhbHNlIH0sXG4gICAgICAgIGxhc3RFcnJvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShudWxsLCBmdW5jdGlvbiAoXywgcmVjdXJzZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gZS5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHtcbiAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IobGFzdEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG5ldyBCaW5hcnlEaXNwb3NhYmxlKGlubmVyLCBvdXRlcikpO1xuICAgICAgICBvdXRlci5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24oeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7IG8ub25FcnJvcihleG4pOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZShub3RpZmllci5zdWJzY3JpYmUocmVjdXJzZSwgZnVuY3Rpb24oZXgpIHtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGV4KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNvbXBsZXRpb25zLm9uTmV4dChudWxsKTtcbiAgICAgICAgICAgIG91dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbbm90aWZpY2F0aW9uRGlzcG9zYWJsZSwgc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlLCBjcmVhdGVEaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0V2hlbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBvYnNlcnZhYmxlUHJvdG8ucmVwZWF0V2hlbiA9IGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgIHJldHVybiBuZXcgUmVwZWF0V2hlbk9ic2VydmFibGUocmVwZWF0KHRoaXMpLCBub3RpZmllcik7XG4gIH07XG5cbiAgdmFyIFNjYW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNjYW5PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNjYW5PYnNlcnZhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTY2FuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNjYW5PYnNlcnZlcihvLHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjYW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNjYW5PYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2Nhbk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNjYW5PYnNlcnZlcihvLCBwYXJlbnQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHBhcmVudDtcbiAgICAgIHRoaXMuX2ZuID0gcGFyZW50LmFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5faHMgPSBwYXJlbnQuaGFzU2VlZDtcbiAgICAgIHRoaXMuX3MgPSBwYXJlbnQuc2VlZDtcbiAgICAgIHRoaXMuX2hhID0gZmFsc2U7XG4gICAgICB0aGlzLl9hID0gbnVsbDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNjYW5PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAhdGhpcy5faHYgJiYgKHRoaXMuX2h2ID0gdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5faGEpIHtcbiAgICAgICAgdGhpcy5fYSA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9hLCB4LCB0aGlzLl9pLCB0aGlzLl9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2EgPSB0aGlzLl9ocyA/IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9zLCB4LCB0aGlzLl9pLCB0aGlzLl9wKSA6IHg7XG4gICAgICAgIHRoaXMuX2hhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX2EuZSk7IH1cbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX2EpO1xuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG5cbiAgICBTY2FuT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU2Nhbk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAhdGhpcy5faHYgJiYgdGhpcy5faHMgJiYgdGhpcy5fby5vbk5leHQodGhpcy5fcyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2FuT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqICBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgcmV0dXJucyBlYWNoIGludGVybWVkaWF0ZSByZXN1bHQuIFRoZSBvcHRpb25hbCBzZWVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICogIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIG5vIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5hZ2dyZWdhdGUuXG4gICogQHBhcmFtIHtNaXhlZH0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGFjY3VtdWxhdGVkIHZhbHVlcy5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNjYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZSwgc2VlZCwgYWNjdW11bGF0b3IgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgICAgc2VlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTY2FuT2JzZXJ2YWJsZSh0aGlzLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCk7XG4gIH07XG5cbiAgdmFyIFNraXBMYXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0T2JzZXJ2YWJsZShzb3VyY2UsIGMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcExhc3RPYnNlcnZlcihvLCB0aGlzLl9jKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwTGFzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcExhc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwTGFzdE9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkpO1xuICAgIH07XG5cbiAgICBTa2lwTGFzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFNraXBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgQnlwYXNzZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgdGhlIGZpcnN0IGBjb3VudGAgZWxlbWVudHMuIEFzIG1vcmUgZWxlbWVudHMgYXJlXG4gICAqICByZWNlaXZlZCwgZWxlbWVudHMgYXJlIHRha2VuIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZC5cbiAgICogQHBhcmFtIGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byBieXBhc3MgYXQgdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UgZWxlbWVudHMgZXhjZXB0IGZvciB0aGUgYnlwYXNzZWQgb25lcyBhdCB0aGUgZW5kLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBMYXN0ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgU2tpcExhc3RPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICAvKipcbiAgICogIFByZXBlbmRzIGEgc2VxdWVuY2Ugb2YgdmFsdWVzIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBzY2hlZHVsZXIgYW5kIGFuIGFyZ3VtZW50IGxpc3Qgb2YgdmFsdWVzIHRvIHByZXBlbmQuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zdGFydFdpdGgoMSwgMiwgMyk7XG4gICAqICB2YXIgcmVzID0gc291cmNlLnN0YXJ0V2l0aChSeC5TY2hlZHVsZXIudGltZW91dCwgMSwgMiwgMyk7XG4gICAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmdzIFRoZSBzcGVjaWZpZWQgdmFsdWVzIHRvIHByZXBlbmQgdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2UgcHJlcGVuZGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3RhcnRXaXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMsIHNjaGVkdWxlciwgc3RhcnQgPSAwO1xuICAgIGlmICghIWFyZ3VtZW50cy5sZW5ndGggJiYgaXNTY2hlZHVsZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXI7XG4gICAgfVxuICAgIGZvcih2YXIgYXJncyA9IFtdLCBpID0gc3RhcnQsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlQ29uY2F0LmFwcGx5KG51bGwsIFtvYnNlcnZhYmxlRnJvbUFycmF5KGFyZ3MsIHNjaGVkdWxlciksIHRoaXNdKTtcbiAgfTtcblxuICB2YXIgVGFrZUxhc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdE9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9xLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVGFrZUxhc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCkgeyB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkpOyB9XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlTGFzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNvbnRpZ3VvdXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIGJ1ZmZlciB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyBjb3VudCBlbGVtZW50cy4gVXBvbiBjb21wbGV0aW9uIG9mXG4gICAqICB0aGUgc291cmNlIHNlcXVlbmNlLCB0aGlzIGJ1ZmZlciBpcyBkcmFpbmVkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBkZWxheWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RPYnNlcnZlcihvLCBjb3VudCkpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RCdWZmZXJPYnNlcnZlcihvLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fcSA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZUxhc3RCdWZmZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9xLnB1c2goeCk7XG4gICAgICB0aGlzLl9xLmxlbmd0aCA+IHRoaXMuX2MgJiYgdGhpcy5fcS5zaGlmdCgpO1xuICAgIH07XG5cbiAgICBUYWtlTGFzdEJ1ZmZlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3EpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZUxhc3RCdWZmZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgYnVmZmVyIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGNvdW50IGVsZW1lbnRzLiBVcG9uIGNvbXBsZXRpb24gb2YgdGhlXG4gICAqICBzb3VyY2Ugc2VxdWVuY2UsIHRoaXMgYnVmZmVyIGlzIHByb2R1Y2VkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZSBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VMYXN0QnVmZmVyID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIobywgY291bnQpKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gZWxlbWVudCBjb3VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IExlbmd0aCBvZiBlYWNoIHdpbmRvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIHdpbmRvd3MuIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBjb3VudC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoQ291bnQgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93Q291bnQgPSBmdW5jdGlvbiAoY291bnQsIHNraXApIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICArY291bnQgfHwgKGNvdW50ID0gMCk7XG4gICAgTWF0aC5hYnMoY291bnQpID09PSBJbmZpbml0eSAmJiAoY291bnQgPSAwKTtcbiAgICBpZiAoY291bnQgPD0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHNraXAgPT0gbnVsbCAmJiAoc2tpcCA9IGNvdW50KTtcbiAgICArc2tpcCB8fCAoc2tpcCA9IDApO1xuICAgIE1hdGguYWJzKHNraXApID09PSBJbmZpbml0eSAmJiAoc2tpcCA9IDApO1xuXG4gICAgaWYgKHNraXAgPD0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUobSksXG4gICAgICAgIG4gPSAwLFxuICAgICAgICBxID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyAoKSB7XG4gICAgICAgIHZhciBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgcS5wdXNoKHMpO1xuICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVXaW5kb3coKTtcblxuICAgICAgbS5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbk5leHQoeCk7IH1cbiAgICAgICAgICB2YXIgYyA9IG4gLSBjb3VudCArIDE7XG4gICAgICAgICAgYyA+PSAwICYmIGMgJSBza2lwID09PSAwICYmIHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICsrbiAlIHNraXAgPT09IDAgJiYgY3JlYXRlV2luZG93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkgeyBxLnNoaWZ0KCkub25FcnJvcihlKTsgfVxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7IHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29uY2F0TWFwKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgc2VsZWN0b3JGdW5jID0gYmluZENhbGxiYWNrKHNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gc291cmNlLm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlbGVjdG9yRnVuYyh4LCBpLCBzb3VyY2UpO1xuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgIChpc0FycmF5TGlrZShyZXN1bHQpIHx8IGlzSXRlcmFibGUocmVzdWx0KSkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tKHJlc3VsdCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KS5jb25jYXRBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgT25lIG9mIHRoZSBGb2xsb3dpbmc6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBtZXJnZXMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5jb25jYXRNYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUucmFuZ2UoMCwgeCk7IH0pO1xuICAgKiAgT3I6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCBpbnZva2VzIHRoZSByZXN1bHQgc2VsZWN0b3IgZm9yIHRoZSBzb3VyY2UgZWxlbWVudCBhbmQgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZyBpbm5lciBzZXF1ZW5jZSdzIGVsZW1lbnRzLCBhbmQgbWVyZ2VzIHRoZSByZXN1bHRzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqICB2YXIgcmVzID0gc291cmNlLmNvbmNhdE1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5yYW5nZSgwLCB4KTsgfSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggKyB5OyB9KTtcbiAgICogIE9yOlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byB0aGUgb3RoZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogIHZhciByZXMgPSBzb3VyY2UuY29uY2F0TWFwKFJ4Lk9ic2VydmFibGUuZnJvbUFycmF5KFsxLDIsM10pKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50IG9yIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gcHJvamVjdCBlYWNoIGVsZW1lbnQgZnJvbSB0aGVcbiAgICogc291cmNlIHNlcXVlbmNlIG9udG8gd2hpY2ggY291bGQgYmUgZWl0aGVyIGFuIG9ic2VydmFibGUgb3IgUHJvbWlzZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc3VsdFNlbGVjdG9yXSAgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnRlcm1lZGlhdGUgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29sbGVjdGlvblNlbGVjdG9yIG9uIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UgYW5kIHRoZW4gbWFwcGluZyBlYWNoIG9mIHRob3NlIHNlcXVlbmNlIGVsZW1lbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHNvdXJjZSBlbGVtZW50IHRvIGEgcmVzdWx0IGVsZW1lbnQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0Q29uY2F0ID0gb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE1hcCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikgJiYgaXNGdW5jdGlvbihyZXN1bHRTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmNhdE1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgc2VsZWN0b3JSZXN1bHQgPSBzZWxlY3Rvcih4LCBpKTtcbiAgICAgICAgaXNQcm9taXNlKHNlbGVjdG9yUmVzdWx0KSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc2VsZWN0b3JSZXN1bHQpKTtcbiAgICAgICAgKGlzQXJyYXlMaWtlKHNlbGVjdG9yUmVzdWx0KSB8fCBpc0l0ZXJhYmxlKHNlbGVjdG9yUmVzdWx0KSkgJiYgKHNlbGVjdG9yUmVzdWx0ID0gb2JzZXJ2YWJsZUZyb20oc2VsZWN0b3JSZXN1bHQpKTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3JSZXN1bHQubWFwKGZ1bmN0aW9uICh5LCBpMikge1xuICAgICAgICAgIHJldHVybiByZXN1bHRTZWxlY3Rvcih4LCB5LCBpLCBpMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICBjb25jYXRNYXAodGhpcywgc2VsZWN0b3IsIHRoaXNBcmcpIDpcbiAgICAgIGNvbmNhdE1hcCh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3RvcjsgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGVhY2ggbm90aWZpY2F0aW9uIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgY29uY2F0cyB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uTmV4dCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQ7IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgd2hlbiB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaXMgcmVhY2hlZC5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBcInRoaXNcIiB0byB1c2UgdG8gaW52b2tlIGVhY2ggdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgb25lLXRvLW1hbnkgdHJhbnNmb3JtIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBub3RpZmljYXRpb24gaW4gdGhlIGlucHV0IHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE1hcE9ic2VydmVyID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdENvbmNhdE9ic2VydmVyID0gZnVuY3Rpb24ob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCwgdGhpc0FyZykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLFxuICAgICAgICBvbk5leHRGdW5jID0gYmluZENhbGxiYWNrKG9uTmV4dCwgdGhpc0FyZywgMiksXG4gICAgICAgIG9uRXJyb3JGdW5jID0gYmluZENhbGxiYWNrKG9uRXJyb3IsIHRoaXNBcmcsIDEpLFxuICAgICAgICBvbkNvbXBsZXRlZEZ1bmMgPSBiaW5kQ2FsbGJhY2sob25Db21wbGV0ZWQsIHRoaXNBcmcsIDApO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvbk5leHRGdW5jKHgsIGluZGV4KyspO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvbkVycm9yRnVuYyhlcnIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uQ29tcGxldGVkRnVuYygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcykuY29uY2F0QWxsKCk7XG4gIH07XG5cbiAgdmFyIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVmYXVsdElmRW1wdHlPYnNlcnZlcihvLCBkKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fZiA9IGZhbHNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVmYXVsdElmRW1wdHlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9mID0gdHJ1ZTtcbiAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBEZWZhdWx0SWZFbXB0eU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICF0aGlzLl9mICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX2QpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHNlcXVlbmNlIG9yIHRoZSBzcGVjaWZpZWQgdmFsdWUgaW4gYSBzaW5nbGV0b24gc2VxdWVuY2UgaWYgdGhlIHNlcXVlbmNlIGlzIGVtcHR5LlxuICAgKlxuICAgKiAgdmFyIHJlcyA9IG9icyA9IHhzLmRlZmF1bHRJZkVtcHR5KCk7XG4gICAqICAyIC0gb2JzID0geHMuZGVmYXVsdElmRW1wdHkoZmFsc2UpO1xuICAgKlxuICAgKiBAbWVtYmVyT2YgT2JzZXJ2YWJsZSNcbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS4gSWYgbm90IHByb3ZpZGVkLCB0aGlzIGRlZmF1bHRzIHRvIG51bGwuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBkZWZhdWx0IHZhbHVlIGlmIHRoZSBzb3VyY2UgaXMgZW1wdHk7IG90aGVyd2lzZSwgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2UgaXRzZWxmLlxuICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uZGVmYXVsdElmRW1wdHkgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICAgIGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIChkZWZhdWx0VmFsdWUgPSBudWxsKTtcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVmYXVsdElmRW1wdHlPYnNlcnZlcihvLCBkZWZhdWx0VmFsdWUpKTtcbiAgICAgIH0sIHNvdXJjZSk7XG4gICAgfTtcblxuICAvLyBTd2FwIG91dCBmb3IgQXJyYXkuZmluZEluZGV4XG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZkNvbXBhcmVyKGFycmF5LCBpdGVtLCBjb21wYXJlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNvbXBhcmVyKGFycmF5W2ldLCBpdGVtKSkgeyByZXR1cm4gaTsgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBIYXNoU2V0KGNvbXBhcmVyKSB7XG4gICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xuICAgIHRoaXMuc2V0ID0gW107XG4gIH1cbiAgSGFzaFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJldFZhbHVlID0gYXJyYXlJbmRleE9mQ29tcGFyZXIodGhpcy5zZXQsIHZhbHVlLCB0aGlzLmNvbXBhcmVyKSA9PT0gLTE7XG4gICAgcmV0VmFsdWUgJiYgdGhpcy5zZXQucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldFZhbHVlO1xuICB9O1xuXG4gIHZhciBEaXN0aW5jdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdE9ic2VydmFibGUoc291cmNlLCBrZXlGbiwgY21wRm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fa2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuX2NtcEZuID0gY21wRm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEaXN0aW5jdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGlzdGluY3RPYnNlcnZlcihvLCB0aGlzLl9rZXlGbiwgdGhpcy5fY21wRm4pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEaXN0aW5jdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEaXN0aW5jdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0T2JzZXJ2ZXIobywga2V5Rm4sIGNtcEZuKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2tleUZuID0ga2V5Rm47XG4gICAgICB0aGlzLl9oID0gbmV3IEhhc2hTZXQoY21wRm4pO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGlzdGluY3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIga2V5ID0geDtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2tleUZuKSkge1xuICAgICAgICBrZXkgPSB0cnlDYXRjaCh0aGlzLl9rZXlGbikoeCk7XG4gICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oLnB1c2goa2V5KSAmJiB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICB9O1xuXG4gICAgRGlzdGluY3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgRGlzdGluY3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gRGlzdGluY3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBvbmx5IGRpc3RpbmN0IGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUga2V5U2VsZWN0b3IgYW5kIHRoZSBjb21wYXJlci5cbiAgICogIFVzYWdlIG9mIHRoaXMgb3BlcmF0b3Igc2hvdWxkIGJlIGNvbnNpZGVyZWQgY2FyZWZ1bGx5IGR1ZSB0byB0aGUgbWFpbnRlbmFuY2Ugb2YgYW4gaW50ZXJuYWwgbG9va3VwIHN0cnVjdHVyZSB3aGljaCBjYW4gZ3JvdyBsYXJnZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBvYnMgPSB4cy5kaXN0aW5jdCgpO1xuICAgKiAgMiAtIG9icyA9IHhzLmRpc3RpbmN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcbiAgICogIDIgLSBvYnMgPSB4cy5kaXN0aW5jdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSwgZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSA9PT0gYjsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtrZXlTZWxlY3Rvcl0gIEEgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgY29tcGFyaXNvbiBrZXkgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAgVXNlZCB0byBjb21wYXJlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvbmx5IGNvbnRhaW5pbmcgdGhlIGRpc3RpbmN0IGVsZW1lbnRzLCBiYXNlZCBvbiBhIGNvbXB1dGVkIGtleSB2YWx1ZSwgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRpc3RpbmN0ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBEaXN0aW5jdE9ic2VydmFibGUodGhpcywga2V5U2VsZWN0b3IsIGNvbXBhcmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIEdyb3VwcyB0aGUgZWxlbWVudHMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gYSBzcGVjaWZpZWQga2V5IHNlbGVjdG9yIGZ1bmN0aW9uIGFuZCBjb21wYXJlciBhbmQgc2VsZWN0cyB0aGUgcmVzdWx0aW5nIGVsZW1lbnRzIGJ5IHVzaW5nIGEgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IG9ic2VydmFibGUuZ3JvdXBCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSk7XG4gICAqICAyIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSk7XG4gICAqICAzIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcoKTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gZXh0cmFjdCB0aGUga2V5IGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbGVtZW50U2VsZWN0b3JdICBBIGZ1bmN0aW9uIHRvIG1hcCBlYWNoIHNvdXJjZSBlbGVtZW50IHRvIGFuIGVsZW1lbnQgaW4gYW4gb2JzZXJ2YWJsZSBncm91cC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEEgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBncm91cHMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlLCBjb250YWluaW5nIGFsbCBlbGVtZW50cyB0aGF0IHNoYXJlIHRoYXQgc2FtZSBrZXkgdmFsdWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZ3JvdXBCeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBCeVVudGlsKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIG9ic2VydmFibGVOZXZlcik7XG4gIH07XG5cbiAgICAvKipcbiAgICAgKiAgR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBrZXkgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAgICogIEEgZHVyYXRpb24gc2VsZWN0b3IgZnVuY3Rpb24gaXMgdXNlZCB0byBjb250cm9sIHRoZSBsaWZldGltZSBvZiBncm91cHMuIFdoZW4gYSBncm91cCBleHBpcmVzLCBpdCByZWNlaXZlcyBhbiBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24uIFdoZW4gYSBuZXcgZWxlbWVudCB3aXRoIHRoZSBzYW1lXG4gICAgICogIGtleSB2YWx1ZSBhcyBhIHJlY2xhaW1lZCBncm91cCBvY2N1cnMsIHRoZSBncm91cCB3aWxsIGJlIHJlYm9ybiB3aXRoIGEgbmV3IGxpZmV0aW1lIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICB2YXIgcmVzID0gb2JzZXJ2YWJsZS5ncm91cEJ5VW50aWwoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0sIG51bGwsICBmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLm5ldmVyKCk7IH0pO1xuICAgICAqICAyIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSwgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUubmV2ZXIoKTsgfSk7XG4gICAgICogIDMgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9LCAgZnVuY3Rpb24gKCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5uZXZlcigpOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9KTtcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBBIGZ1bmN0aW9uIHRvIGV4dHJhY3QgdGhlIGtleSBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzaWduYWwgdGhlIGV4cGlyYXRpb24gb2YgYSBncm91cC5cbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX1cbiAgICAgKiAgQSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIGdyb3VwcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUsIGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIHRoYXQgc2hhcmUgdGhhdCBzYW1lIGtleSB2YWx1ZS5cbiAgICAgKiAgSWYgYSBncm91cCdzIGxpZmV0aW1lIGV4cGlyZXMsIGEgbmV3IGdyb3VwIHdpdGggdGhlIHNhbWUga2V5IHZhbHVlIGNhbiBiZSBjcmVhdGVkIG9uY2UgYW4gZWxlbWVudCB3aXRoIHN1Y2ggYSBrZXkgdmFsdWUgaXMgZW5jb3V0ZXJlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9ic2VydmFibGVQcm90by5ncm91cEJ5VW50aWwgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgICAgICBncm91cERpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxuICAgICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKSxcbiAgICAgICAgICBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBmdW5jdGlvbiAoaXRlbSkgeyBpdGVtLm9uRXJyb3IoZSk7IH07IH07XG5cbiAgICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChcbiAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdHJ5Q2F0Y2goa2V5U2VsZWN0b3IpKHgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgbWFwLmZvckVhY2goaGFuZGxlRXJyb3Ioa2V5LmUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihrZXkuZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaXJlTmV3TWFwRW50cnkgPSBmYWxzZSwgd3JpdGVyID0gbWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHdyaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB3cml0ZXIpO1xuICAgICAgICAgICAgICBmaXJlTmV3TWFwRW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyZU5ld01hcEVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBHcm91cGVkT2JzZXJ2YWJsZShrZXksIHdyaXRlciwgcmVmQ291bnREaXNwb3NhYmxlKSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbkdyb3VwID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2goZHVyYXRpb25TZWxlY3RvcikoZHVyYXRpb25Hcm91cCk7XG4gICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBtYXAuZm9yRWFjaChoYW5kbGVFcnJvcihkdXJhdGlvbi5lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG8ub25OZXh0KGdyb3VwKTtcblxuICAgICAgICAgICAgICB2YXIgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChtZCk7XG5cbiAgICAgICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBtYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFwWydkZWxldGUnXShrZXkpKSB7IHdyaXRlci5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgICAgICAgICAgICBncm91cERpc3Bvc2FibGUucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0geDtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGVsZW1lbnRTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgZWxlbWVudCA9IHRyeUNhdGNoKGVsZW1lbnRTZWxlY3RvcikoeCk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGVsZW1lbnQuZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvLm9uRXJyb3IoZWxlbWVudC5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cml0ZXIub25OZXh0KGVsZW1lbnQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyBpdGVtLm9uQ29tcGxldGVkKCk7IH0pO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIE1hcE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1hcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBNYXBPYnNlcnZhYmxlKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IGJpbmRDYWxsYmFjayhzZWxlY3RvciwgdGhpc0FyZywgMyk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbm5lck1hcChzZWxlY3Rvciwgc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBpLCBvKSB7IHJldHVybiBzZWxlY3Rvci5jYWxsKHRoaXMsIHNlbGYuc2VsZWN0b3IoeCwgaSwgbyksIGksIG8pOyB9O1xuICAgIH1cblxuICAgIE1hcE9ic2VydmFibGUucHJvdG90eXBlLmludGVybmFsTWFwID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcE9ic2VydmFibGUodGhpcy5zb3VyY2UsIGlubmVyTWFwKHNlbGVjdG9yLCB0aGlzKSwgdGhpc0FyZyk7XG4gICAgfTtcblxuICAgIE1hcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzLnNlbGVjdG9yLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgc2VsZWN0b3IsIHNvdXJjZSkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuc2VsZWN0b3IpKHgsIHRoaXMuaSsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICB0aGlzLm8ub25OZXh0KHJlc3VsdCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gYSBuZXcgZm9ybSBieSBpbmNvcnBvcmF0aW5nIHRoZSBlbGVtZW50J3MgaW5kZXguXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBzb3VyY2UgZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBzb3VyY2UuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tYXAgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNlbGVjdG9yRm4gPSB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RvciA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yOyB9O1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgTWFwT2JzZXJ2YWJsZSA/XG4gICAgICB0aGlzLmludGVybmFsTWFwKHNlbGVjdG9yRm4sIHRoaXNBcmcpIDpcbiAgICAgIG5ldyBNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yRm4sIHRoaXNBcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBsdWNrZXIoYXJncywgbGVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcHBlcih4KSB7XG4gICAgICB2YXIgY3VycmVudFByb3AgPSB4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IGN1cnJlbnRQcm9wW2FyZ3NbaV1dO1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3VycmVudFByb3AgPSBwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50UHJvcDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluXG4gICAqIHRoZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0FyZ3VtZW50c30gYXJndW1lbnRzIFRoZSBuZXN0ZWQgcHJvcGVydGllcyB0byBwbHVjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGx1Y2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBpZiAobGVuID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignTGlzdCBvZiBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBlbXB0eS4nKTsgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIHRoaXMubWFwKHBsdWNrZXIoYXJncywgbGVuKSk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnkgPSBvYnNlcnZhYmxlUHJvdG8ubWVyZ2VNYXAgPSBmdW5jdGlvbihzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykubWVyZ2VBbGwoKTtcbn07XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGVhY2ggbm90aWZpY2F0aW9uIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyByZWFjaGVkLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIFwidGhpc1wiIHRvIHVzZSB0byBpbnZva2UgZWFjaCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG5vdGlmaWNhdGlvbiBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcE9ic2VydmVyID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnlPYnNlcnZlciA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25OZXh0LmNhbGwodGhpc0FyZywgeCwgaW5kZXgrKyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlcnIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9LCBzb3VyY2UpLm1lcmdlQWxsKCk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwTGF0ZXN0ID0gb2JzZXJ2YWJsZVByb3RvLnN3aXRjaE1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5zd2l0Y2hMYXRlc3QoKTtcbn07XG5cbiAgdmFyIFNraXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBPYnNlcnZhYmxlKHNvdXJjZSwgY291bnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBPYnNlcnZlcihvLCB0aGlzLl9jb3VudCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBTa2lwT2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9yID0gYztcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhTa2lwT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuXG4gICAgU2tpcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9yIDw9IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yLS07XG4gICAgICB9XG4gICAgfTtcbiAgICBTa2lwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbigpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIEJ5cGFzc2VzIGEgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCB0aGVuIHJldHVybnMgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIHRoYXQgb2NjdXIgYWZ0ZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFNraXBPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICB2YXIgU2tpcFdoaWxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdoaWxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBXaGlsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdoaWxlT2JzZXJ2ZXIobywgdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFdoaWxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwV2hpbGVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdoaWxlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9yID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXRoaXMuX3IpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3AuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3ApO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICB0aGlzLl9yID0gIXJlcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3IgJiYgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgfTtcbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcFdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBXaGlsZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIEJ5cGFzc2VzIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgbG9uZyBhcyBhIHNwZWNpZmllZCBjb25kaXRpb24gaXMgdHJ1ZSBhbmQgdGhlbiByZXR1cm5zIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gICAqICBUaGUgZWxlbWVudCdzIGluZGV4IGlzIHVzZWQgaW4gdGhlIGxvZ2ljIG9mIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqICB2YXIgcmVzID0gc291cmNlLnNraXBXaGlsZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlIDwgMTA7IH0pO1xuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5za2lwV2hpbGUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gdmFsdWUgPCAxMCB8fCBpbmRleCA8IDEwOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2Ugc3RhcnRpbmcgYXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpbmVhciBzZXJpZXMgdGhhdCBkb2VzIG5vdCBwYXNzIHRoZSB0ZXN0IHNwZWNpZmllZCBieSBwcmVkaWNhdGUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFdoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU2tpcFdoaWxlT2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIFRha2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VPYnNlcnZhYmxlKHNvdXJjZSwgY291bnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VPYnNlcnZlcihvLCB0aGlzLl9jb3VudCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBUYWtlT2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHRoaXMuX3IgPSBjO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFRha2VPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBUYWtlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX3ItLSA+IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIHRoaXMuX3IgPD0gMCAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRha2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGFrZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUYWtlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciBmb3IgdGhlIGVkZ2UgY2FzZSBvZiB0YWtlKDApLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdXNlZCB0byBwcm9kdWNlIGFuIE9uQ29tcGxldGVkIG1lc3NhZ2UgaW4gY2FzZSA8cGFyYW1yZWYgbmFtZT1cImNvdW50IGNvdW50PC9wYXJhbXJlZj4gaXMgc2V0IHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2UgPSBmdW5jdGlvbiAoY291bnQsIHNjaGVkdWxlcikge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICBpZiAoY291bnQgPT09IDApIHsgcmV0dXJuIG9ic2VydmFibGVFbXB0eShzY2hlZHVsZXIpOyB9XG4gICAgcmV0dXJuIG5ldyBUYWtlT2JzZXJ2YWJsZSh0aGlzLCBjb3VudCk7XG4gIH07XG5cbiAgdmFyIFRha2VXaGlsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaGlsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlV2hpbGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VXaGlsZU9ic2VydmVyKG8sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VXaGlsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZVdoaWxlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaGlsZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fciA9IHRydWU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlV2hpbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fcikge1xuICAgICAgICB0aGlzLl9yID0gdHJ5Q2F0Y2godGhpcy5fcC5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcCk7XG4gICAgICAgIGlmICh0aGlzLl9yID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX3IuZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgVGFrZVdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFRha2VXaGlsZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUYWtlV2hpbGVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGVsZW1lbnRzIGZyb20gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBsb25nIGFzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbiBpcyB0cnVlLlxuICAgKiAgVGhlIGVsZW1lbnQncyBpbmRleCBpcyB1c2VkIGluIHRoZSBsb2dpYyBvZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb247IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBzZXF1ZW5jZSB0aGF0IG9jY3VyIGJlZm9yZSB0aGUgZWxlbWVudCBhdCB3aGljaCB0aGUgdGVzdCBubyBsb25nZXIgcGFzc2VzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFRha2VXaGlsZU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIHZhciBGaWx0ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaWx0ZXJPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRmlsdGVyT2JzZXJ2YWJsZShzb3VyY2UsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlsdGVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8sIHRoaXMucHJlZGljYXRlLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlubmVyUHJlZGljYXRlKHByZWRpY2F0ZSwgc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgsIGksIG8pIHsgcmV0dXJuIHNlbGYucHJlZGljYXRlKHgsIGksIG8pICYmIHByZWRpY2F0ZS5jYWxsKHRoaXMsIHgsIGksIG8pOyB9XG4gICAgfVxuXG4gICAgRmlsdGVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW50ZXJuYWxGaWx0ZXIgPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBuZXcgRmlsdGVyT2JzZXJ2YWJsZSh0aGlzLnNvdXJjZSwgaW5uZXJQcmVkaWNhdGUocHJlZGljYXRlLCB0aGlzKSwgdGhpc0FyZyk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgcHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHNob3VsZFlpZWxkID0gdHJ5Q2F0Y2godGhpcy5wcmVkaWNhdGUpKHgsIHRoaXMuaSsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAoc2hvdWxkWWllbGQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm8ub25FcnJvcihzaG91bGRZaWVsZC5lKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFlpZWxkICYmIHRoaXMuby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbHRlck9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqICBGaWx0ZXJzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIG9uIGEgcHJlZGljYXRlIGJ5IGluY29ycG9yYXRpbmcgdGhlIGVsZW1lbnQncyBpbmRleC5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggc291cmNlIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2UgdGhhdCBzYXRpc2Z5IHRoZSBjb25kaXRpb24uXG4gICovXG4gIG9ic2VydmFibGVQcm90by5maWx0ZXIgPSBvYnNlcnZhYmxlUHJvdG8ud2hlcmUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBGaWx0ZXJPYnNlcnZhYmxlID8gdGhpcy5pbnRlcm5hbEZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIDpcbiAgICAgIG5ldyBGaWx0ZXJPYnNlcnZhYmxlKHRoaXMsIHByZWRpY2F0ZSwgdGhpc0FyZyk7XG4gIH07XG5cbiAgdmFyIEV4dHJlbWFCeU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV4dHJlbWFCeU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXh0cmVtYUJ5T2JzZXJ2YWJsZShzb3VyY2UsIGssIGMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fayA9IGs7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV4dHJlbWFCeU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRXh0cmVtYUJ5T2JzZXJ2ZXIobywgdGhpcy5faywgdGhpcy5fYykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXh0cmVtYUJ5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFeHRyZW1hQnlPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXh0cmVtYUJ5T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXh0cmVtYUJ5T2JzZXJ2ZXIobywgaywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fdiA9IG51bGw7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5fbCA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXh0cmVtYUJ5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGtleSA9IHRyeUNhdGNoKHRoaXMuX2spKHgpO1xuICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihrZXkuZSk7IH1cbiAgICAgIHZhciBjb21wYXJpc29uID0gMDtcbiAgICAgIGlmICghdGhpcy5faHYpIHtcbiAgICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgICB0aGlzLl92ID0ga2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGFyaXNvbiA9IHRyeUNhdGNoKHRoaXMuX2MpKGtleSwgdGhpcy5fdik7XG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGNvbXBhcmlzb24uZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJpc29uID4gMCkge1xuICAgICAgICB0aGlzLl92ID0ga2V5O1xuICAgICAgICB0aGlzLl9sID0gW107XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyaXNvbiA+PSAwKSB7IHRoaXMuX2wucHVzaCh4KTsgfVxuICAgIH07XG5cbiAgICBFeHRyZW1hQnlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBFeHRyZW1hQnlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fbCk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHRyZW1hQnlPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgZnVuY3Rpb24gZmlyc3RPbmx5KHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVtcHR5RXJyb3IoKTsgfVxuICAgIHJldHVybiB4WzBdO1xuICB9XG5cbiAgdmFyIFJlZHVjZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVkdWNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VPYnNlcnZhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZWR1Y2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFJlZHVjZU9ic2VydmVyKG9ic2VydmVyLHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlZHVjZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgUmVkdWNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlZHVjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFJlZHVjZU9ic2VydmVyKG8sIHBhcmVudCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fZm4gPSBwYXJlbnQuYWNjdW11bGF0b3I7XG4gICAgICB0aGlzLl9ocyA9IHBhcmVudC5oYXNTZWVkO1xuICAgICAgdGhpcy5fcyA9IHBhcmVudC5zZWVkO1xuICAgICAgdGhpcy5faGEgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2EgPSBudWxsO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUmVkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgIXRoaXMuX2h2ICYmICh0aGlzLl9odiA9IHRydWUpO1xuICAgICAgaWYgKHRoaXMuX2hhKSB7XG4gICAgICAgIHRoaXMuX2EgPSB0cnlDYXRjaCh0aGlzLl9mbikodGhpcy5fYSwgeCwgdGhpcy5faSwgdGhpcy5fcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hID0gdGhpcy5faHMgPyB0cnlDYXRjaCh0aGlzLl9mbikodGhpcy5fcywgeCwgdGhpcy5faSwgdGhpcy5fcCkgOiB4O1xuICAgICAgICB0aGlzLl9oYSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcih0aGlzLl9hLmUpOyB9XG4gICAgICB0aGlzLl9pKys7XG4gICAgfTtcblxuICAgIFJlZHVjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFJlZHVjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9odiAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9hKTtcbiAgICAgICF0aGlzLl9odiAmJiB0aGlzLl9ocyAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9zKTtcbiAgICAgICF0aGlzLl9odiAmJiAhdGhpcy5faHMgJiYgdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVkdWNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgYWdncmVnYXRpb24gYXMgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgcmVzdWx0IHNlcXVlbmNlLiBUaGUgc3BlY2lmaWVkIHNlZWQgdmFsdWUgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgKiBGb3IgYWdncmVnYXRpb24gYmVoYXZpb3Igd2l0aCBpbmNyZW1lbnRhbCBpbnRlcm1lZGlhdGUgcmVzdWx0cywgc2VlIE9ic2VydmFibGUuc2Nhbi5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY2N1bXVsYXRvciBBbiBhY2N1bXVsYXRvciBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIGVhY2ggZWxlbWVudC5cbiAgKiBAcGFyYW0ge0FueX0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBmaW5hbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzU2VlZCA9IGZhbHNlLCBzZWVkLCBhY2N1bXVsYXRvciA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaGFzU2VlZCA9IHRydWU7XG4gICAgICBzZWVkID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZHVjZU9ic2VydmFibGUodGhpcywgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpO1xuICB9O1xuXG4gIHZhciBTb21lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU29tZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU29tZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU29tZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU29tZU9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU29tZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU29tZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTb21lT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTb21lT2JzZXJ2ZXIobywgZm4sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTb21lT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlmIChCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNvbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU29tZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dChmYWxzZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTb21lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW55IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBzYXRpc2ZpZXMgYSBjb25kaXRpb24gaWYgcHJlc2VudCwgZWxzZSBpZiBhbnkgaXRlbXMgYXJlIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV0gQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCBkZXRlcm1pbmluZyB3aGV0aGVyIGFueSBlbGVtZW50cyBpbiB0aGUgc291cmNlIHNlcXVlbmNlIHBhc3MgdGhlIHRlc3QgaW4gdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUgaWYgZ2l2ZW4sIGVsc2UgaWYgYW55IGl0ZW1zIGFyZSBpbiB0aGUgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc29tZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFNvbWVPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgSXNFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKElzRW1wdHlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJc0VtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJc0VtcHR5T2JzZXJ2ZXIobykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSXNFbXB0eU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgSXNFbXB0eU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKElzRW1wdHlPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJc0VtcHR5T2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJc0VtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dChmYWxzZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcbiAgICBJc0VtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIElzRW1wdHlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBJc0VtcHR5T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpcyBlbXB0eS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyBlbXB0eS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSXNFbXB0eU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIEV2ZXJ5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXZlcnlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV2ZXJ5T2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFdmVyeU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRXZlcnlPYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZXJ5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFdmVyeU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFdmVyeU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRXZlcnlPYnNlcnZlcihvLCBmbiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV2ZXJ5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlmICghQm9vbGVhbihyZXN1bHQpKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRXZlcnlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgRXZlcnlPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBFdmVyeU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFsbCBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHNhdGlzZnkgYSBjb25kaXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGVdIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UgcGFzcyB0aGUgdGVzdCBpbiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5ldmVyeSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IEV2ZXJ5T2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIEluY2x1ZGVzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW5jbHVkZXNPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluY2x1ZGVzT2JzZXJ2YWJsZShzb3VyY2UsIGVsZW0sIGlkeCkge1xuICAgICAgdmFyIG4gPSAraWR4IHx8IDA7XG4gICAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcblxuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5jbHVkZXNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9uIDwgMCkge1xuICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5jbHVkZXNPYnNlcnZlcihvLCB0aGlzLl9lbGVtLCB0aGlzLl9uKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbmNsdWRlc09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgSW5jbHVkZXNPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW5jbHVkZXNPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbmNsdWRlc09ic2VydmVyKG8sIGVsZW0sIG4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZXIoYSwgYikge1xuICAgICAgcmV0dXJuIChhID09PSAwICYmIGIgPT09IDApIHx8IChhID09PSBiIHx8IChpc05hTihhKSAmJiBpc05hTihiKSkpO1xuICAgIH1cblxuICAgIEluY2x1ZGVzT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2krKyA+PSB0aGlzLl9uICYmIGNvbXBhcmVyKHgsIHRoaXMuX2VsZW0pKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbmNsdWRlc09ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBJbmNsdWRlc09ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KGZhbHNlKTsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIEluY2x1ZGVzT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbmNsdWRlcyBhIHNwZWNpZmllZCBlbGVtZW50IHdpdGggYW4gb3B0aW9uYWwgZXF1YWxpdHkgY29tcGFyZXIuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSB2YWx1ZSB0byBsb2NhdGUgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIEFuIGVxdWFsaXR5IGNvbXBhcmVyIHRvIGNvbXBhcmUgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaW5jbHVkZXMgYW4gZWxlbWVudCB0aGF0IGhhcyB0aGUgc3BlY2lmaWVkIHZhbHVlIGZyb20gdGhlIGdpdmVuIGluZGV4LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmluY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiBuZXcgSW5jbHVkZXNPYnNlcnZhYmxlKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH07XG5cbiAgdmFyIENvdW50T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ291bnRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvdW50T2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb3VudE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgQ291bnRPYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvdW50T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBDb3VudE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb3VudE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQ291bnRPYnNlcnZlcihvLCBmbiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX2MgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ291bnRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICBCb29sZWFuKHJlc3VsdCkgJiYgKHRoaXMuX2MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jKys7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb3VudE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBDb3VudE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9jKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvdW50T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBob3cgbWFueSBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2Ugc2F0aXNmeSBhIGNvbmRpdGlvbiBpZiBwcm92aWRlZCwgZWxzZSB0aGUgY291bnQgb2YgaXRlbXMuXG4gICAqIEBleGFtcGxlXG4gICAqIHJlcyA9IHNvdXJjZS5jb3VudCgpO1xuICAgKiByZXMgPSBzb3VyY2UuY291bnQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAzOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV1BIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyBob3cgbWFueSBlbGVtZW50cyBpbiB0aGUgaW5wdXQgc2VxdWVuY2Ugc2F0aXNmeSB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaWYgcHJvdmlkZWQsIGVsc2UgdGhlIGNvdW50IG9mIGl0ZW1zIGluIHRoZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb3VudCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IENvdW50T2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIEluZGV4T2ZPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmRleE9mT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbmRleE9mT2JzZXJ2YWJsZShzb3VyY2UsIGUsIG4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEluZGV4T2ZPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9uIDwgMCkge1xuICAgICAgICBvLm9uTmV4dCgtMSk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5kZXhPZk9ic2VydmVyKG8sIHRoaXMuX2UsIHRoaXMuX24pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEluZGV4T2ZPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEluZGV4T2ZPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSW5kZXhPZk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluZGV4T2ZPYnNlcnZlcihvLCBlLCBuKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5fbiA9IG47XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9uICYmIHggPT09IHRoaXMuX2UpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5faSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuICAgIEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgSW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KC0xKTsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIEluZGV4T2ZPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0FueX0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4XSBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5pbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIG4gPSArZnJvbUluZGV4IHx8IDA7XG4gICAgTWF0aC5hYnMobikgPT09IEluZmluaXR5ICYmIChuID0gMCk7XG4gICAgcmV0dXJuIG5ldyBJbmRleE9mT2JzZXJ2YWJsZSh0aGlzLCBzZWFyY2hFbGVtZW50LCBuKTtcbiAgfTtcblxuICB2YXIgU3VtT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3VtT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTdW1PYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN1bU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3VtT2JzZXJ2ZXIobywgdGhpcy5fZm4sIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdW1PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFN1bU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdW1PYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFN1bU9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fYyA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTdW1PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICB0aGlzLl9jICs9IHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2MgKz0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFN1bU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTdW1PYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fYyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdW1PYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgYSBzZXF1ZW5jZSBvZiB2YWx1ZXMgdGhhdCBhcmUgb2J0YWluZWQgYnkgaW52b2tpbmcgYW4gb3B0aW9uYWwgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UsIGVsc2UgaWYgbm90IHNwZWNpZmllZCBjb21wdXRlcyB0aGUgc3VtIG9uIGVhY2ggaXRlbSBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3VtID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIGZuID0gYmluZENhbGxiYWNrKGtleVNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFN1bU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50cyBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIG1pbmltdW0ga2V5IHZhbHVlIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbXBhcmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbkJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9KTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5taW5CeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC52YWx1ZTsgfSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggLSB5OyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgS2V5IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBrZXkgdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgbGlzdCBvZiB6ZXJvIG9yIG1vcmUgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWluaW11bSBrZXkgdmFsdWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWluQnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGNvbXBhcmVyKSB7XG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdFN1YkNvbXBhcmVyKTtcbiAgICByZXR1cm4gbmV3IEV4dHJlbWFCeU9ic2VydmFibGUodGhpcywga2V5U2VsZWN0b3IsIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlcih4LCB5KSAqIC0xOyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBlbGVtZW50IGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25hbCBjb21wYXJlciBlbHNlIGEgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVzcyB0aGFuIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbigpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbihmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC52YWx1ZSAtIHkudmFsdWU7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBlbGVtZW50cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1pbiA9IGZ1bmN0aW9uIChjb21wYXJlcikge1xuICAgIHJldHVybiB0aGlzLm1pbkJ5KGlkZW50aXR5LCBjb21wYXJlcikubWFwKGZpcnN0T25seSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgbWF4aW11bSAga2V5IHZhbHVlIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbXBhcmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLm1heEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9KTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXhCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC52YWx1ZTsgfSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggLSB5OzsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEtleSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAgQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGtleSB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHplcm8gb3IgbW9yZSBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXhpbXVtIGtleSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5tYXhCeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgY29tcGFyZXIpIHtcbiAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0U3ViQ29tcGFyZXIpO1xuICAgIHJldHVybiBuZXcgRXh0cmVtYUJ5T2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgY29tcGFyZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWF4KCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UubWF4KGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlIC0geS52YWx1ZTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgbWF4aW11bSBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWF4ID0gZnVuY3Rpb24gKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QnkoaWRlbnRpdHksIGNvbXBhcmVyKS5tYXAoZmlyc3RPbmx5KTtcbiAgfTtcblxuICB2YXIgQXZlcmFnZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEF2ZXJhZ2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEF2ZXJhZ2VPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEF2ZXJhZ2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IEF2ZXJhZ2VPYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF2ZXJhZ2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEF2ZXJhZ2VPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBdmVyYWdlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQXZlcmFnZU9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2MgPSAwO1xuICAgICAgdGhpcy5fdCA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBBdmVyYWdlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYodGhpcy5fZm4pIHtcbiAgICAgICAgdmFyIHIgPSB0cnlDYXRjaCh0aGlzLl9mbikoeCwgdGhpcy5fYysrLCB0aGlzLl9zKTtcbiAgICAgICAgaWYgKHIgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioci5lKTsgfVxuICAgICAgICB0aGlzLl90ICs9IHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jKys7XG4gICAgICAgIHRoaXMuX3QgKz0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIEF2ZXJhZ2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgQXZlcmFnZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fYyA9PT0gMCkgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpOyB9XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl90IC8gdGhpcy5fYyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBdmVyYWdlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgYXZlcmFnZSBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgc2VxdWVuY2Ugb3Igb2J0YWluZWQgYnkgaW52b2tpbmcgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSBpZiBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBhdmVyYWdlIG9mIHRoZSBzZXF1ZW5jZSBvZiB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYXZlcmFnZSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBmbjtcbiAgICBpZiAoaXNGdW5jdGlvbihrZXlTZWxlY3RvcikpIHtcbiAgICAgIGZuID0gYmluZENhbGxiYWNrKGtleVNlbGVjdG9yLCB0aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBdmVyYWdlT2JzZXJ2YWJsZShzb3VyY2UsIGZuKTtcbiAgfTtcblxuICAvKipcbiAgICogIERldGVybWluZXMgd2hldGhlciB0d28gc2VxdWVuY2VzIGFyZSBlcXVhbCBieSBjb21wYXJpbmcgdGhlIGVsZW1lbnRzIHBhaXJ3aXNlIHVzaW5nIGEgc3BlY2lmaWVkIGVxdWFsaXR5IGNvbXBhcmVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoWzEsMiwzXSk7XG4gICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2Uuc2VxdWVuY2VFcXVhbChbeyB2YWx1ZTogNDIgfV0sIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlID09PSB5LnZhbHVlOyB9KTtcbiAgICogMyAtIHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFJ4Lk9ic2VydmFibGUucmV0dXJuVmFsdWUoNDIpKTtcbiAgICogNCAtIHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFJ4Lk9ic2VydmFibGUucmV0dXJuVmFsdWUoeyB2YWx1ZTogNDIgfSksIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlID09PSB5LnZhbHVlOyB9KTtcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzZWNvbmQgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgYXJyYXkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYm90aCBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgYSBzaW5nbGUgZWxlbWVudCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciBib3RoIHNlcXVlbmNlcyBhcmUgb2YgZXF1YWwgbGVuZ3RoIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGFyZSBlcXVhbCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBlcXVhbGl0eSBjb21wYXJlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zZXF1ZW5jZUVxdWFsID0gZnVuY3Rpb24gKHNlY29uZCwgY29tcGFyZXIpIHtcbiAgICB2YXIgZmlyc3QgPSB0aGlzO1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZG9uZWwgPSBmYWxzZSwgZG9uZXIgPSBmYWxzZSwgcWwgPSBbXSwgcXIgPSBbXTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24xID0gZmlyc3Quc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChxci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHYgPSBxci5zaGlmdCgpO1xuICAgICAgICAgIHZhciBlcXVhbCA9IHRyeUNhdGNoKGNvbXBhcmVyKSh2LCB4KTtcbiAgICAgICAgICBpZiAoZXF1YWwgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZXF1YWwuZSk7IH1cbiAgICAgICAgICBpZiAoIWVxdWFsKSB7XG4gICAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmVyKSB7XG4gICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxbC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlKSB7IG8ub25FcnJvcihlKTsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lbCA9IHRydWU7XG4gICAgICAgIGlmIChxbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAocXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9uZXIpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KHRydWUpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIChpc0FycmF5TGlrZShzZWNvbmQpIHx8IGlzSXRlcmFibGUoc2Vjb25kKSkgJiYgKHNlY29uZCA9IG9ic2VydmFibGVGcm9tKHNlY29uZCkpO1xuICAgICAgaXNQcm9taXNlKHNlY29uZCkgJiYgKHNlY29uZCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzZWNvbmQpKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24yID0gc2Vjb25kLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAocWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB2ID0gcWwuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgZXF1YWwgPSB0cnlDYXRjaChjb21wYXJlcikodiwgeCk7XG4gICAgICAgICAgaWYgKGVxdWFsID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGVxdWFsLmUpOyB9XG4gICAgICAgICAgaWYgKCFlcXVhbCkge1xuICAgICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkb25lbCkge1xuICAgICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXIucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oZSkgeyBvLm9uRXJyb3IoZSk7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZXIgPSB0cnVlO1xuICAgICAgICBpZiAocXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvbmVsKSB7XG4gICAgICAgICAgICBvLm9uTmV4dCh0cnVlKTtcbiAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbjEsIHN1YnNjcmlwdGlvbjIpO1xuICAgIH0sIGZpcnN0KTtcbiAgfTtcblxuICB2YXIgRWxlbWVudEF0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRWxlbWVudEF0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50QXRPYnNlcnZhYmxlKHNvdXJjZSwgaSwgZCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9pID0gaTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRWxlbWVudEF0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBFbGVtZW50QXRPYnNlcnZlcihvLCB0aGlzLl9pLCB0aGlzLl9kKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFbGVtZW50QXRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEVsZW1lbnRBdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFbGVtZW50QXRPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIEVsZW1lbnRBdE9ic2VydmVyKG8sIGksIGQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEVsZW1lbnRBdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pLS0gPT09IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnRBdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBFbGVtZW50QXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9vLm9uRXJyb3IobmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fZCk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEVsZW1lbnRBdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleCBpbiBhIHNlcXVlbmNlIG9yIGRlZmF1bHQgdmFsdWUgaWYgbm90IGZvdW5kLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0cmlldmUuXG4gICAqIEBwYXJhbSB7QW55fSBbZGVmYXVsdFZhbHVlXSBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgZWxlbWVudEF0IGRvZXMgbm90IGZpbmQgYSB2YWx1ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZWxlbWVudEF0ID0gIGZ1bmN0aW9uIChpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGluZGV4IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudEF0T2JzZXJ2YWJsZSh0aGlzLCBpbmRleCwgZGVmYXVsdFZhbHVlKTtcbiAgfTtcblxuICB2YXIgU2luZ2xlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2luZ2xlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2luZ2xlT2JzZXJ2ZXIobywgb2JqLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5fdiA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTaW5nbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgc2hvdWxkWWllbGQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYmoucHJlZGljYXRlKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICBCb29sZWFuKHJlcykgJiYgKHNob3VsZFlpZWxkID0gdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHNob3VsZFlpZWxkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRZaWVsZCkge1xuICAgICAgICBpZiAodGhpcy5faHYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fby5vbkVycm9yKG5ldyBFcnJvcignU2VxdWVuY2UgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBtYXRjaGluZyBlbGVtZW50JykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2h2ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdiA9IHg7XG4gICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2luZ2xlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX29iai5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTaW5nbGVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9ubHkgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIG9wdGlvbmFsIHByZWRpY2F0ZSwgYW5kIHJlcG9ydHMgYW4gZXhjZXB0aW9uIGlmIHRoZXJlIGlzIG5vdCBleGFjdGx5IG9uZSBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnNpbmdsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBvYmogPSB7fSwgc291cmNlID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSB7XG4gICAgICAgICAgcHJlZGljYXRlOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgdGhpc0FyZzogYXJndW1lbnRzWzFdLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbiAob2JqLnByZWRpY2F0ZSkpIHtcbiAgICAgICAgdmFyIGZuID0gb2JqLnByZWRpY2F0ZTtcbiAgICAgICAgb2JqLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhmbiwgb2JqLnRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTaW5nbGVPYnNlcnZlcihvLCBvYmosIHNvdXJjZSkpO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9O1xuXG4gIHZhciBGaXJzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZpcnN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGaXJzdE9ic2VydmFibGUoc291cmNlLCBvYmopIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlyc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IEZpcnN0T2JzZXJ2ZXIobywgdGhpcy5fb2JqLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmlyc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEZpcnN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmlyc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGaXJzdE9ic2VydmVyKG8sIG9iaiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlyc3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fb2JqLnByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fb2JqLnByZWRpY2F0ZSkoeCwgdGhpcy5faSsrLCB0aGlzLl9zKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgaWYgKEJvb2xlYW4ocmVzKSkge1xuICAgICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fb2JqLnByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX29iai5kZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9vLm9uRXJyb3IobmV3IEVtcHR5RXJyb3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9vYmouZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmlyc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgaWYgcHJlc2VudCBlbHNlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlIGlmIHByb3ZpZGVkLCBlbHNlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5maXJzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge30sIHNvdXJjZSA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IHtcbiAgICAgICAgcHJlZGljYXRlOiBhcmd1bWVudHNbMF0sXG4gICAgICAgIHRoaXNBcmc6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uIChvYmoucHJlZGljYXRlKSkge1xuICAgICAgdmFyIGZuID0gb2JqLnByZWRpY2F0ZTtcbiAgICAgIG9iai5wcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2soZm4sIG9iai50aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaXJzdE9ic2VydmFibGUodGhpcywgb2JqKTtcbiAgfTtcblxuICB2YXIgTGFzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKExhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIExhc3RPYnNlcnZhYmxlKHNvdXJjZSwgb2JqKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIExhc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IExhc3RPYnNlcnZlcihvLCB0aGlzLl9vYmosIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMYXN0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBMYXN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTGFzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIExhc3RPYnNlcnZlcihvLCBvYmosIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIExhc3RPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgc2hvdWxkWWllbGQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYmoucHJlZGljYXRlKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICBCb29sZWFuKHJlcykgJiYgKHNob3VsZFlpZWxkID0gdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHNob3VsZFlpZWxkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRZaWVsZCkge1xuICAgICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3YgPSB4O1xuICAgICAgfVxuICAgIH07XG4gICAgTGFzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX29iai5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMYXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgaWYgc3BlY2lmaWVkLCBlbHNlIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHt9LCBzb3VyY2UgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgb2JqID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHByZWRpY2F0ZTogYXJndW1lbnRzWzBdLFxuICAgICAgICB0aGlzQXJnOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogYXJndW1lbnRzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbiAob2JqLnByZWRpY2F0ZSkpIHtcbiAgICAgIHZhciBmbiA9IG9iai5wcmVkaWNhdGU7XG4gICAgICBvYmoucHJlZGljYXRlID0gYmluZENhbGxiYWNrKGZuLCBvYmoudGhpc0FyZywgMyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGFzdE9ic2VydmFibGUodGhpcywgb2JqKTtcbiAgfTtcblxuICB2YXIgRmluZFZhbHVlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmluZFZhbHVlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRmluZFZhbHVlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHNvdXJjZSwgY2FsbGJhY2ssIHlpZWxkSW5kZXgpIHtcbiAgICAgIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jYiA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5feSA9IHlpZWxkSW5kZXg7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEZpbmRWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaG91bGRSdW4gPSB0cnlDYXRjaCh0aGlzLl9jYikoeCwgdGhpcy5faSwgdGhpcy5fcyk7XG4gICAgICBpZiAoc2hvdWxkUnVuID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHNob3VsZFJ1bi5lKTsgfVxuICAgICAgaWYgKHNob3VsZFJ1bikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl95ID8gdGhpcy5faSA6IHgpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pKys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEZpbmRWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIEZpbmRWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl95ICYmIHRoaXMuX28ub25OZXh0KC0xKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbmRWYWx1ZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICBmdW5jdGlvbiBmaW5kVmFsdWUgKHNvdXJjZSwgcHJlZGljYXRlLCB0aGlzQXJnLCB5aWVsZEluZGV4KSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluZFZhbHVlT2JzZXJ2ZXIobywgc291cmNlLCBjYWxsYmFjaywgeWllbGRJbmRleCkpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBvY2N1cnJlbmNlIHdpdGhpbiB0aGUgZW50aXJlIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRoYXQgZGVmaW5lcyB0aGUgY29uZGl0aW9ucyBvZiB0aGUgZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSBwcmVkaWNhdGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGlmIGZvdW5kOyBvdGhlcndpc2UsIHVuZGVmaW5lZC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5maW5kID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmaW5kVmFsdWUodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgY29uZGl0aW9ucyBkZWZpbmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJlZGljYXRlLCBhbmQgcmV0dXJuc1xuICAgKiBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugd2l0aGluIHRoZSBlbnRpcmUgT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdGhhdCBkZWZpbmVzIHRoZSBjb25kaXRpb25zIG9mIHRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgY29uZGl0aW9ucyBkZWZpbmVkIGJ5IG1hdGNoLCBpZiBmb3VuZDsgb3RoZXJ3aXNlLCDigJMxLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZmluZEluZGV4ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmaW5kVmFsdWUodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnLCB0cnVlKTtcbiAgfTtcblxuICB2YXIgVG9TZXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb1NldE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9TZXRPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb1NldE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVG9TZXRPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb1NldE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVG9TZXRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVG9TZXRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUb1NldE9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IG5ldyByb290LlNldCgpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9TZXRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zLmFkZCh4KTtcbiAgICB9O1xuXG4gICAgVG9TZXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUb1NldE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9zKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvU2V0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIFNldCBpZiBpdCBleGlzdHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgdmFsdWUgb2YgYSBTZXQgY29udGFpbmluZyB0aGUgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udG9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiByb290LlNldCA9PT0gJ3VuZGVmaW5lZCcpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyB9XG4gICAgcmV0dXJuIG5ldyBUb1NldE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFRvTWFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVG9NYXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvTWFwT2JzZXJ2YWJsZShzb3VyY2UsIGssIGUpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fayA9IGs7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRvTWFwT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUb01hcE9ic2VydmVyKG8sIHRoaXMuX2ssIHRoaXMuX2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvTWFwT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUb01hcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb01hcE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvTWFwT2JzZXJ2ZXIobywgaywgZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5fbSA9IG5ldyByb290Lk1hcCgpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9NYXBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIga2V5ID0gdHJ5Q2F0Y2godGhpcy5faykoeCk7XG4gICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGtleS5lKTsgfVxuICAgICAgdmFyIGVsZW0gPSB4O1xuICAgICAgaWYgKHRoaXMuX2UpIHtcbiAgICAgICAgZWxlbSA9IHRyeUNhdGNoKHRoaXMuX2UpKHgpO1xuICAgICAgICBpZiAoZWxlbSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihlbGVtLmUpOyB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX20uc2V0KGtleSwgZWxlbSk7XG4gICAgfTtcblxuICAgIFRvTWFwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVG9NYXBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fbSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb01hcE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBDb252ZXJ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIE1hcCBpZiBpdCBleGlzdHMuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgQSBmdW5jdGlvbiB3aGljaCBwcm9kdWNlcyB0aGUga2V5IGZvciB0aGUgTWFwLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbGVtZW50U2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIHRoZSBlbGVtZW50IGZvciB0aGUgTWFwLiBJZiBub3QgcHJlc2VudCwgZGVmYXVsdHMgdG8gdGhlIHZhbHVlIGZyb20gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSB2YWx1ZSBvZiBhIE1hcCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRvTWFwID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpIHtcbiAgICBpZiAodHlwZW9mIHJvb3QuTWFwID09PSAndW5kZWZpbmVkJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFRvTWFwT2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yKTtcbiAgfTtcblxuICB2YXIgU2xpY2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTbGljZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2xpY2VPYnNlcnZhYmxlKHNvdXJjZSwgYiwgZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9iID0gYjtcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2xpY2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNsaWNlT2JzZXJ2ZXIobywgdGhpcy5fYiwgdGhpcy5fZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2xpY2VPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNsaWNlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNsaWNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTbGljZU9ic2VydmVyKG8sIGIsIGUpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2xpY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9iKSB7XG4gICAgICAgIGlmICh0aGlzLl9lID09PSB0aGlzLl9pKSB7XG4gICAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pKys7XG4gICAgfTtcbiAgICBTbGljZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTbGljZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBTbGljZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKlxuICAqIFRoZSBzbGljZSgpIG1ldGhvZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhbiBPYnNlcnZhYmxlIGludG8gYSBuZXcgT2JzZXJ2YWJsZSBvYmplY3QuXG4gICogVW5saWtlIHRoZSBhcnJheSB2ZXJzaW9uLCB0aGlzIGRvZXMgbm90IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVycyBmb3IgYmVpbmcgb3IgZW5kLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW5dIFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gYmVnaW4gZXh0cmFjdGlvbi4gSWYgb21pdHRlZCwgdGhpcyB3aWxsIGRlZmF1bHQgdG8gemVyby5cbiAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBlbmQgZXh0cmFjdGlvbi4gc2xpY2UgZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLlxuICAqIElmIG9taXR0ZWQsIHRoaXMgd2lsbCBlbWl0IHRoZSByZXN0IG9mIHRoZSBPYnNlcnZhYmxlIG9iamVjdC5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIGFuIE9ic2VydmFibGUgaW50byBhIG5ldyBPYnNlcnZhYmxlIG9iamVjdC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNsaWNlID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc3RhcnQgPSBiZWdpbiB8fCAwO1xuICAgIGlmIChzdGFydCA8IDApIHsgdGhyb3cgbmV3IFJ4LkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiYgZW5kIDwgc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBSeC5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlT2JzZXJ2YWJsZSh0aGlzLCBzdGFydCwgZW5kKTtcbiAgfTtcblxuICB2YXIgTGFzdEluZGV4T2ZPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhMYXN0SW5kZXhPZk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTGFzdEluZGV4T2ZPYnNlcnZhYmxlKHNvdXJjZSwgZSwgbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdEluZGV4T2ZPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9uIDwgMCkge1xuICAgICAgICBvLm9uTmV4dCgtMSk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTGFzdEluZGV4T2ZPYnNlcnZlcihvLCB0aGlzLl9lLCB0aGlzLl9uKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMYXN0SW5kZXhPZk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTGFzdEluZGV4T2ZPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTGFzdEluZGV4T2ZPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBMYXN0SW5kZXhPZk9ic2VydmVyKG8sIGUsIG4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIHRoaXMuX3YgPSAwO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSA+PSB0aGlzLl9uICYmIHggPT09IHRoaXMuX2UpIHtcbiAgICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgICB0aGlzLl92ID0gdGhpcy5faTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuICAgIExhc3RJbmRleE9mT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIExhc3RJbmRleE9mT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KC0xKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RJbmRleE9mT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0FueX0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4XSBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIG4gPSArZnJvbUluZGV4IHx8IDA7XG4gICAgTWF0aC5hYnMobikgPT09IEluZmluaXR5ICYmIChuID0gMCk7XG4gICAgcmV0dXJuIG5ldyBMYXN0SW5kZXhPZk9ic2VydmFibGUodGhpcywgc2VhcmNoRWxlbWVudCwgbik7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS53cmFwID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZSgpIHtcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLnNwYXduLmNhbGwodGhpcywgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlT2JzZXJ2YWJsZS5fX2dlbmVyYXRvckZ1bmN0aW9uX18gPSBmbjtcbiAgICByZXR1cm4gY3JlYXRlT2JzZXJ2YWJsZTtcbiAgfTtcblxuICB2YXIgc3Bhd24gPSBPYnNlcnZhYmxlLnNwYXduID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBhcmd1bWVudHNbMF0sIHNlbGYgPSB0aGlzLCBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGdlbikpIHsgZ2VuID0gZ2VuLmFwcGx5KHNlbGYsIGFyZ3MpOyB9XG4gICAgICBpZiAoIWdlbiB8fCAhaXNGdW5jdGlvbihnZW4ubmV4dCkpIHtcbiAgICAgICAgby5vbk5leHQoZ2VuKTtcbiAgICAgICAgcmV0dXJuIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyYXRvcihyZXMpIHtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGdlbi5uZXh0KS5jYWxsKGdlbiwgcmVzKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXQuZSk7IH1cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzR2VuZXJhdG9yKCk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChnZW4ubmV4dCkuY2FsbChnZW4sIGVycik7XG4gICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmV0LmUpOyB9XG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dChyZXQpIHtcbiAgICAgICAgaWYgKHJldC5kb25lKSB7XG4gICAgICAgICAgby5vbk5leHQocmV0LnZhbHVlKTtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYnMgPSB0b09ic2VydmFibGUuY2FsbChzZWxmLCByZXQudmFsdWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG9icykpIHtcbiAgICAgICAgICBnLmFkZChvYnMuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG4gICAgICAgICAgfSwgb25FcnJvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYXNWYWx1ZSAmJiBwcm9jZXNzR2VuZXJhdG9yKHZhbHVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25FcnJvcihuZXcgVHlwZUVycm9yKCd0eXBlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9PYnNlcnZhYmxlKG9iaikge1xuICAgIGlmICghb2JqKSB7IHJldHVybiBvYmo7IH1cbiAgICBpZiAoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob2JqKSkgeyByZXR1cm4gb2JqOyB9XG4gICAgaWYgKGlzUHJvbWlzZShvYmopKSB7IHJldHVybiBPYnNlcnZhYmxlLmZyb21Qcm9taXNlKG9iaik7IH1cbiAgICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbihvYmopIHx8IGlzR2VuZXJhdG9yKG9iaikpIHsgcmV0dXJuIHNwYXduLmNhbGwodGhpcywgb2JqKTsgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpIHsgcmV0dXJuIHRodW5rVG9PYnNlcnZhYmxlLmNhbGwodGhpcywgb2JqKTsgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopIHx8IGlzSXRlcmFibGUob2JqKSkgeyByZXR1cm4gYXJyYXlUb09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmopOyB9XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtyZXR1cm4gb2JqZWN0VG9PYnNlcnZhYmxlLmNhbGwodGhpcywgb2JqKTt9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5VG9PYnNlcnZhYmxlIChvYmopIHtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5mcm9tKG9iaikuY29uY2F0TWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmKE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG8pIHx8IGlzT2JqZWN0KG8pKSB7XG4gICAgICAgIHJldHVybiB0b09ic2VydmFibGUuY2FsbChudWxsLCBvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmp1c3Qobyk7XG4gICAgICB9XG4gICAgfSkudG9BcnJheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0VG9PYnNlcnZhYmxlIChvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBvYmouY29uc3RydWN0b3IoKSwga2V5cyA9IE9iamVjdC5rZXlzKG9iaiksIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0b09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmpba2V5XSk7XG5cbiAgICAgIGlmKG9ic2VydmFibGUgJiYgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob2JzZXJ2YWJsZSkpIHtcbiAgICAgICAgZGVmZXIob2JzZXJ2YWJsZSwga2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYnNlcnZhYmxlLmZvcmtKb2luLmFwcGx5KE9ic2VydmFibGUsIG9ic2VydmFibGVzKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcblxuXG4gICAgZnVuY3Rpb24gZGVmZXIgKG9ic2VydmFibGUsIGtleSkge1xuICAgICAgcmVzdWx0c1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgb2JzZXJ2YWJsZXMucHVzaChvYnNlcnZhYmxlLm1hcChmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXN1bHRzW2tleV0gPSBuZXh0O1xuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRodW5rVG9PYnNlcnZhYmxlKGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgZm4uY2FsbChzZWxmLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF0sIHJlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gby5vbkVycm9yKGVycik7IH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3MucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgICAgICAgcmVzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBvLm9uTmV4dChyZXMpO1xuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzR2VuZXJhdG9yKG9iaikge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uIChvYmoubmV4dCkgJiYgaXNGdW5jdGlvbiAob2JqWyd0aHJvdyddKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgaWYgKCFjdG9yKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjdG9yLm5hbWUgPT09ICdHZW5lcmF0b3JGdW5jdGlvbicgfHwgY3Rvci5kaXNwbGF5TmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJykgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJldHVybiBpc0dlbmVyYXRvcihjdG9yLnByb3RvdHlwZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0ID09IHZhbC5jb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIsIHN1cmZhY2luZyB0aGUgcmVzdWx0IHRocm91Z2ggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuc3RhcnQoZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnaGVsbG8nKTsgfSk7XG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnN0YXJ0KGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2hlbGxvJyk7IH0sIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuc3RhcnQoZnVuY3Rpb24gKCkgeyB0aGlzLmxvZygnaGVsbG8nKTsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQsIGNvbnNvbGUpO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHRvIHJ1biBhc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSBmdW5jdGlvbiBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEBwYXJhbSBbY29udGV4dF0gIFRoZSBjb250ZXh0IGZvciB0aGUgZnVuYyBwYXJhbWV0ZXIgdG8gYmUgZXhlY3V0ZWQuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGV4cG9zaW5nIHRoZSBmdW5jdGlvbidzIHJlc3VsdCB2YWx1ZSwgb3IgYW4gZXhjZXB0aW9uLlxuICAgKlxuICAgKiBSZW1hcmtzXG4gICAqICogVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwgbm90IGR1cmluZyB0aGUgc3Vic2NyaXB0aW9uIG9mIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UuXG4gICAqICogTXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgcmVzdWx0aW5nIHNlcXVlbmNlIGNhbiBvYnNlcnZlIHRoZSBmdW5jdGlvbidzIHJlc3VsdC5cbiAgICovXG4gIE9ic2VydmFibGUuc3RhcnQgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVUb0FzeW5jKGZ1bmMsIGNvbnRleHQsIHNjaGVkdWxlcikoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGZ1bmN0aW9uIGludG8gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLiBFYWNoIGludm9jYXRpb24gb2YgdGhlIHJlc3VsdGluZyBhc3luY2hyb25vdXMgZnVuY3Rpb24gY2F1c2VzIGFuIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiBGdW5jdGlvbiB0byBjb252ZXJ0IHRvIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGZ1bmN0aW9uIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cbiAgICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHRdIFRoZSBjb250ZXh0IGZvciB0aGUgZnVuYyBwYXJhbWV0ZXIgdG8gYmUgZXhlY3V0ZWQuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQXN5bmNocm9ub3VzIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVUb0FzeW5jID0gT2JzZXJ2YWJsZS50b0FzeW5jID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3QoKTtcblxuICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc3ViamVjdC5vbkVycm9yKGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJqZWN0Lm9uTmV4dChyZXN1bHQpO1xuICAgICAgICBzdWJqZWN0Lm9uQ29tcGxldGVkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gIH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNiT2JzZXJ2YWJsZShmbiwgY3R4LCBzZWxlY3RvciwgYXJncykge1xuICB2YXIgbyA9IG5ldyBBc3luY1N1YmplY3QoKTtcblxuICBhcmdzLnB1c2goY3JlYXRlQ2JIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpKTtcbiAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcblxuICByZXR1cm4gby5hc09ic2VydmFibGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2JIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIgKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN1bHRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHJlc3VsdHNbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgcmVzdWx0cyA9IHRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseShjdHgsIHJlc3VsdHMpO1xuICAgICAgaWYgKHJlc3VsdHMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0cy5lKTsgfVxuICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgby5vbkNvbXBsZXRlZCgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvIGNvbnZlcnQgdG8gYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjdHhdIFRoZSBjb250ZXh0IGZvciB0aGUgZnVuYyBwYXJhbWV0ZXIgdG8gYmUgZXhlY3V0ZWQuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIEEgc2VsZWN0b3Igd2hpY2ggdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBjYWxsYmFjayB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiwgd2hlbiBleGVjdXRlZCB3aXRoIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIG1pbnVzIHRoZSBjYWxsYmFjaywgcHJvZHVjZXMgYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIHZhbHVlIG9mIHRoZSBhcmd1bWVudHMgdG8gdGhlIGNhbGxiYWNrIGFzIGFuIGFycmF5LlxuICovXG5PYnNlcnZhYmxlLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmbiwgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHR5cGVvZiBjdHggPT09ICd1bmRlZmluZWQnICYmIChjdHggPSB0aGlzKTsgXG5cbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gY3JlYXRlQ2JPYnNlcnZhYmxlKGZuLCBjdHgsIHNlbGVjdG9yLCBhcmdzKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVPYnNlcnZhYmxlKGZuLCBjdHgsIHNlbGVjdG9yLCBhcmdzKSB7XG4gIHZhciBvID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuXG4gIGFyZ3MucHVzaChjcmVhdGVOb2RlSGFuZGxlcihvLCBjdHgsIHNlbGVjdG9yKSk7XG4gIGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgcmV0dXJuIG8uYXNPYnNlcnZhYmxlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIgKCkge1xuICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGVycikgeyByZXR1cm4gby5vbkVycm9yKGVycik7IH1cblxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN1bHRzID0gW107XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7IHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldOyB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KGN0eCwgcmVzdWx0cyk7XG4gICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgby5vbk5leHQocmVzdWx0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvLm9uQ29tcGxldGVkKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBOb2RlLmpzIGNhbGxiYWNrIHN0eWxlIGZ1bmN0aW9uIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuICBUaGlzIG11c3QgYmUgaW4gZnVuY3Rpb24gKGVyciwgLi4uKSBmb3JtYXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtNaXhlZH0gW2N0eF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGNhbGxiYWNrIG1pbnVzIHRoZSBlcnJvciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggd2hlbiBhcHBsaWVkLCByZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgY2FsbGJhY2sgYXJndW1lbnRzIGFzIGFuIGFycmF5LlxuICovXG5PYnNlcnZhYmxlLmZyb21Ob2RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4sIGN0eCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0eXBlb2YgY3R4ID09PSAndW5kZWZpbmVkJyAmJiAoY3R4ID0gdGhpcyk7IFxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gY3JlYXRlTm9kZU9ic2VydmFibGUoZm4sIGN0eCwgc2VsZWN0b3IsIGFyZ3MpO1xuICB9O1xufTtcblxuICBmdW5jdGlvbiBpc05vZGVMaXN0KGVsKSB7XG4gICAgaWYgKHJvb3QuU3RhdGljTm9kZUxpc3QpIHtcbiAgICAgIC8vIElFOCBTcGVjaWZpY1xuICAgICAgLy8gaW5zdGFuY2VvZiBpcyBzbG93ZXIgdGhhbiBPYmplY3QjdG9TdHJpbmcsIGJ1dCBPYmplY3QjdG9TdHJpbmcgd2lsbCBub3Qgd29yayBhcyBpbnRlbmRlZCBpbiBJRThcbiAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIHJvb3QuU3RhdGljTm9kZUxpc3QgfHwgZWwgaW5zdGFuY2VvZiByb290Lk5vZGVMaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBMaXN0ZW5EaXNwb3NhYmxlKGUsIG4sIGZuKSB7XG4gICAgdGhpcy5fZSA9IGU7XG4gICAgdGhpcy5fbiA9IG47XG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9lLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fbiwgdGhpcy5fZm4sIGZhbHNlKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgfVxuICBMaXN0ZW5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLl9lLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fbiwgdGhpcy5fZm4sIGZhbHNlKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXIgKGVsLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB2YXIgZGlzcG9zYWJsZXMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuXG4gICAgLy8gQXN1bWUgTm9kZUxpc3Qgb3IgSFRNTENvbGxlY3Rpb25cbiAgICB2YXIgZWxlbVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsKTtcbiAgICBpZiAoaXNOb2RlTGlzdChlbCkgfHwgZWxlbVRvU3RyaW5nID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZGlzcG9zYWJsZXMuYWRkKGNyZWF0ZUV2ZW50TGlzdGVuZXIoZWwuaXRlbShpKSwgZXZlbnROYW1lLCBoYW5kbGVyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgZGlzcG9zYWJsZXMuYWRkKG5ldyBMaXN0ZW5EaXNwb3NhYmxlKGVsLCBldmVudE5hbWUsIGhhbmRsZXIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzcG9zYWJsZXM7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBvcHRpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIG5hdGl2ZSBldmVudHMgb25seVxuICAgKi9cbiAgUnguY29uZmlnLnVzZU5hdGl2ZUV2ZW50cyA9IGZhbHNlO1xuXG4gIHZhciBFdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXZlbnRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV2ZW50T2JzZXJ2YWJsZShlbCwgbmFtZSwgZm4pIHtcbiAgICAgIHRoaXMuX2VsID0gZWw7XG4gICAgICB0aGlzLl9uID0gbmFtZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKG8sIGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICByZXN1bHRzID0gdHJ5Q2F0Y2goZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdHMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0cy5lKTsgfVxuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBFdmVudE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHRoaXMuX2VsLFxuICAgICAgICB0aGlzLl9uLFxuICAgICAgICBjcmVhdGVIYW5kbGVyKG8sIHRoaXMuX2ZuKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFdmVudE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGFkZGluZyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWF0Y2hpbmcgRE9NRWxlbWVudCBvciBlYWNoIGl0ZW0gaW4gdGhlIE5vZGVMaXN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBUaGUgRE9NRWxlbWVudCBvciBOb2RlTGlzdCB0byBhdHRhY2ggYSBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBhdHRhY2ggdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgdG8gcHJvZHVjZSBhIHNpbmdsZSBpdGVtIHRvIHlpZWxkIG9uIG5leHQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGV2ZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBhbmQgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICovXG4gIE9ic2VydmFibGUuZnJvbUV2ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IpIHtcbiAgICAvLyBOb2RlLmpzIHNwZWNpZmljXG4gICAgaWYgKGVsZW1lbnQuYWRkTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmcm9tRXZlbnRQYXR0ZXJuKFxuICAgICAgICBmdW5jdGlvbiAoaCkgeyBlbGVtZW50LmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaCk7IH0sXG4gICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBoKTsgfSxcbiAgICAgICAgc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8vIFVzZSBvbmx5IGlmIG5vbi1uYXRpdmUgZXZlbnRzIGFyZSBhbGxvd2VkXG4gICAgaWYgKCFSeC5jb25maWcudXNlTmF0aXZlRXZlbnRzKSB7XG4gICAgICAvLyBIYW5kbGVzIGpxLCBBbmd1bGFyLmpzLCBaZXB0bywgTWFyaW9uZXR0ZSwgRW1iZXIuanNcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZWxlbWVudC5vZmYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZyb21FdmVudFBhdHRlcm4oXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5vbihldmVudE5hbWUsIGgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQub2ZmKGV2ZW50TmFtZSwgaCk7IH0sXG4gICAgICAgICAgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRXZlbnRPYnNlcnZhYmxlKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IpLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIHZhciBFdmVudFBhdHRlcm5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV2ZW50UGF0dGVybk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGQsIGRlbCwgZm4pIHtcbiAgICAgIHRoaXMuX2FkZCA9IGFkZDtcbiAgICAgIHRoaXMuX2RlbCA9IGRlbDtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKG8sIGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICByZXN1bHRzID0gdHJ5Q2F0Y2goZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdHMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0cy5lKTsgfVxuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBFdmVudFBhdHRlcm5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBmbiA9IGNyZWF0ZUhhbmRsZXIobywgdGhpcy5fZm4pO1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdGhpcy5fYWRkKGZuKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZSh0aGlzLl9kZWwsIGZuLCByZXR1cm5WYWx1ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEV2ZW50UGF0dGVybkRpc3Bvc2FibGUoZGVsLCBmbiwgcmV0KSB7XG4gICAgICB0aGlzLl9kZWwgPSBkZWw7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcmV0ID0gcmV0O1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgaXNGdW5jdGlvbih0aGlzLl9kZWwpICYmIHRoaXMuX2RlbCh0aGlzLl9mbiwgdGhpcy5fcmV0KTtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50UGF0dGVybk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYW4gZXZlbnQgZW1pdHRlciB2aWEgYW4gYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyIHBhaXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFkZEhhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGFkZCBhIGhhbmRsZXIgdG8gdGhlIGVtaXR0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZW1vdmVIYW5kbGVyXSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gcmVtb3ZlIGEgaGFuZGxlciBmcm9tIGFuIGVtaXR0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgdG8gcHJvZHVjZSBhIHNpbmdsZSBpdGVtIHRvIHlpZWxkIG9uIG5leHQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHdyYXBzIGFuIGV2ZW50IGZyb20gYW4gZXZlbnQgZW1pdHRlclxuICAgKi9cbiAgdmFyIGZyb21FdmVudFBhdHRlcm4gPSBPYnNlcnZhYmxlLmZyb21FdmVudFBhdHRlcm4gPSBmdW5jdGlvbiAoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50UGF0dGVybk9ic2VydmFibGUoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24sIHN1cmZhY2luZyB0aGUgcmVzdWx0IHRocm91Z2ggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25Bc3luYyBBc3luY2hyb25vdXMgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UgdG8gcnVuLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBleHBvc2luZyB0aGUgZnVuY3Rpb24ncyByZXN1bHQgdmFsdWUsIG9yIGFuIGV4Y2VwdGlvbi5cbiAgICovXG4gIE9ic2VydmFibGUuc3RhcnRBc3luYyA9IGZ1bmN0aW9uIChmdW5jdGlvbkFzeW5jKSB7XG4gICAgdmFyIHByb21pc2UgPSB0cnlDYXRjaChmdW5jdGlvbkFzeW5jKSgpO1xuICAgIGlmIChwcm9taXNlID09PSBlcnJvck9iaikgeyByZXR1cm4gb2JzZXJ2YWJsZVRocm93KHByb21pc2UuZSk7IH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHByb21pc2UpO1xuICB9O1xuXG4gIHZhciBQYXVzYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzYWJsZU9ic2VydmFibGUoc291cmNlLCBwYXVzZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKHBhdXNlciAmJiBwYXVzZXIuc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyLm1lcmdlKHBhdXNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdXNlciA9IHRoaXMuY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUGF1c2FibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjb25uID0gdGhpcy5zb3VyY2UucHVibGlzaCgpLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBjb25uLnN1YnNjcmliZShvKSxcbiAgICAgICAgY29ubmVjdGlvbiA9IGRpc3Bvc2FibGVFbXB0eTtcblxuICAgICAgdmFyIHBhdXNhYmxlID0gdGhpcy5wYXVzZXIuc3RhcnRXaXRoKCF0aGlzLnBhdXNlZCkuZGlzdGluY3RVbnRpbENoYW5nZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBjb25uZWN0aW9uID0gY29ubi5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgY29ubmVjdGlvbiA9IGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoW3N1YnNjcmlwdGlvbiwgY29ubmVjdGlvbiwgcGF1c2FibGVdKTtcbiAgICB9O1xuXG4gICAgUGF1c2FibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBQYXVzYWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KHRydWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF1c2FibGVPYnNlcnZhYmxlO1xuXG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIHVuZGVybHlpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBiYXNlZCB1cG9uIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHlpZWxkcyB0cnVlL2ZhbHNlLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGF1c2VyID0gbmV3IFJ4LlN1YmplY3QoKTtcbiAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwKS5wYXVzYWJsZShwYXVzZXIpO1xuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHBhdXNlciBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHBhdXNlIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgcGF1c2VkIGJhc2VkIHVwb24gdGhlIHBhdXNlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wYXVzYWJsZSA9IGZ1bmN0aW9uIChwYXVzZXIpIHtcbiAgICByZXR1cm4gbmV3IFBhdXNhYmxlT2JzZXJ2YWJsZSh0aGlzLCBwYXVzZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3RTb3VyY2Uoc291cmNlLCBzdWJqZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGhhc1ZhbHVlID0gW2ZhbHNlLCBmYWxzZV0sXG4gICAgICAgIGhhc1ZhbHVlQWxsID0gZmFsc2UsXG4gICAgICAgIGlzRG9uZSA9IGZhbHNlLFxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkoMiksXG4gICAgICAgIGVycjtcblxuICAgICAgZnVuY3Rpb24gbmV4dCh4LCBpKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHg7XG4gICAgICAgIGhhc1ZhbHVlW2ldID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc1ZhbHVlQWxsIHx8IChoYXNWYWx1ZUFsbCA9IGhhc1ZhbHVlLmV2ZXJ5KGlkZW50aXR5KSkpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBvLm9uRXJyb3IoZXJyKTsgfVxuICAgICAgICAgIHZhciByZXMgPSB0cnlDYXRjaChyZXN1bHRTZWxlY3RvcikuYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICAgIG8ub25OZXh0KHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNEb25lICYmIHZhbHVlc1sxXSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgbmV4dCh4LCAwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzWzFdKSB7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWVzWzFdICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgc3ViamVjdC5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIG5leHQoeCwgMSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQodHJ1ZSwgMSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgdmFyIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZShzb3VyY2UsIHBhdXNlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gICAgICBpZiAocGF1c2VyICYmIHBhdXNlci5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXIubWVyZ2UocGF1c2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgcSA9IFtdLCBwcmV2aW91c1Nob3VsZEZpcmU7XG5cbiAgICAgIGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7IHdoaWxlIChxLmxlbmd0aCA+IDApIHsgby5vbk5leHQocS5zaGlmdCgpKTsgfSB9XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPVxuICAgICAgICBjb21iaW5lTGF0ZXN0U291cmNlKFxuICAgICAgICAgIHRoaXMuc291cmNlLFxuICAgICAgICAgIHRoaXMucGF1c2VyLnN0YXJ0V2l0aCghdGhpcy5wYXVzZWQpLmRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgICAgZnVuY3Rpb24gKGRhdGEsIHNob3VsZEZpcmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHNob3VsZEZpcmU6IHNob3VsZEZpcmUgfTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICBpZiAocHJldmlvdXNTaG91bGRGaXJlICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0cy5zaG91bGRGaXJlICE9PSBwcmV2aW91c1Nob3VsZEZpcmUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Nob3VsZEZpcmUgPSByZXN1bHRzLnNob3VsZEZpcmU7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIGluIHNob3VsZEZpcmVcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5zaG91bGRGaXJlKSB7IGRyYWluUXVldWUoKTsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkRmlyZSA9IHJlc3VsdHMuc2hvdWxkRmlyZTtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLnNob3VsZEZpcmUpIHtcbiAgICAgICAgICAgICAgICAgIG8ub25OZXh0KHJlc3VsdHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHEucHVzaChyZXN1bHRzLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRyYWluUXVldWUoKTtcbiAgICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uOyAgICAgIFxuICAgIH07XG5cbiAgICBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KGZhbHNlKTtcbiAgICB9O1xuXG4gICAgUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KHRydWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIHVwb24gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggeWllbGRzIHRydWUvZmFsc2UsXG4gICAqIGFuZCB5aWVsZHMgdGhlIHZhbHVlcyB0aGF0IHdlcmUgYnVmZmVyZWQgd2hpbGUgcGF1c2VkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGF1c2VyID0gbmV3IFJ4LlN1YmplY3QoKTtcbiAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwKS5wYXVzYWJsZUJ1ZmZlcmVkKHBhdXNlcik7XG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcGF1c2VyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHVzZWQgdG8gcGF1c2UgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhdXNhYmxlQnVmZmVyZWQgPSBmdW5jdGlvbiAocGF1c2VyKSB7XG4gICAgcmV0dXJuIG5ldyBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZSh0aGlzLCBwYXVzZXIpO1xuICB9O1xuXG4gIHZhciBDb250cm9sbGVkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29udHJvbGxlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29udHJvbGxlZE9ic2VydmFibGUgKHNvdXJjZSwgZW5hYmxlUXVldWUsIHNjaGVkdWxlcikge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnN1YmplY3QgPSBuZXcgQ29udHJvbGxlZFN1YmplY3QoZW5hYmxlUXVldWUsIHNjaGVkdWxlcik7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZS5tdWx0aWNhc3QodGhpcy5zdWJqZWN0KS5yZWZDb3VudCgpO1xuICAgIH1cblxuICAgIENvbnRyb2xsZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobyk7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG51bWJlck9mSXRlbXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YmplY3QucmVxdWVzdChudW1iZXJPZkl0ZW1zID09IG51bGwgPyAtMSA6IG51bWJlck9mSXRlbXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29udHJvbGxlZE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIENvbnRyb2xsZWRTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb250cm9sbGVkU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb250cm9sbGVkU3ViamVjdChlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICBlbmFibGVRdWV1ZSA9PSBudWxsICYmIChlbmFibGVRdWV1ZSA9IHRydWUpO1xuXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICB0aGlzLmVuYWJsZVF1ZXVlID0gZW5hYmxlUXVldWU7XG4gICAgICB0aGlzLnF1ZXVlID0gZW5hYmxlUXVldWUgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLnJlcXVlc3RlZENvdW50ID0gMDtcbiAgICAgIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMuaGFzRmFpbGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXIgfHwgY3VycmVudFRocmVhZFNjaGVkdWxlcjtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKENvbnRyb2xsZWRTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmplY3Quc3Vic2NyaWJlKG8pO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVF1ZXVlIHx8IHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5zdWJqZWN0Lm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlQ3VycmVudFJlcXVlc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goTm90aWZpY2F0aW9uLmNyZWF0ZU9uQ29tcGxldGVkKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFzRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUXVldWUgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnN1YmplY3Qub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlQ3VycmVudFJlcXVlc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goTm90aWZpY2F0aW9uLmNyZWF0ZU9uRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RlZENvdW50IDw9IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZVF1ZXVlICYmIHRoaXMucXVldWUucHVzaChOb3RpZmljYXRpb24uY3JlYXRlT25OZXh0KHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHRoaXMucmVxdWVzdGVkQ291bnQtLSA9PT0gMCkgJiYgdGhpcy5kaXNwb3NlQ3VycmVudFJlcXVlc3QoKTtcbiAgICAgICAgICB0aGlzLnN1YmplY3Qub25OZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9wcm9jZXNzUmVxdWVzdDogZnVuY3Rpb24gKG51bWJlck9mSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUXVldWUpIHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIChudW1iZXJPZkl0ZW1zID4gMCB8fCB0aGlzLnF1ZXVlWzBdLmtpbmQgIT09ICdOJykpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGZpcnN0LmFjY2VwdCh0aGlzLnN1YmplY3QpO1xuICAgICAgICAgICAgaWYgKGZpcnN0LmtpbmQgPT09ICdOJykge1xuICAgICAgICAgICAgICBudW1iZXJPZkl0ZW1zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlck9mSXRlbXM7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUobnVtYmVyLFxuICAgICAgICBmdW5jdGlvbihzLCBpKSB7XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHNlbGYuX3Byb2Nlc3NSZXF1ZXN0KGkpO1xuICAgICAgICAgIHZhciBzdG9wcGVkID0gc2VsZi5oYXNDb21wbGV0ZWQgfHwgc2VsZi5oYXNGYWlsZWQ7XG4gICAgICAgICAgaWYgKCFzdG9wcGVkICYmIHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdGVkQ291bnQgPSByZW1haW5pbmc7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gU2NoZWR1bGVkIGl0ZW0gaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuIFJldHVybiBhIG5ld1xuICAgICAgICAgICAgICAvLyBkaXNwb3NhYmxlIHRvIGFsbG93IHRoZSByZXF1ZXN0IHRvIGJlIGludGVycnVwdGVkXG4gICAgICAgICAgICAgIC8vIHZpYSBkaXNwb3NlLlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZTtcbiAgICAgIH0sXG4gICAgICBkaXNwb3NlQ3VycmVudFJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZSkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIENvbnRyb2xsZWRTdWJqZWN0O1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogQXR0YWNoZXMgYSBjb250cm9sbGVyIHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGFiaWxpdHkgdG8gcXVldWUuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMCkuY29udHJvbGxlZCgpO1xuICAgKiBzb3VyY2UucmVxdWVzdCgzKTsgLy8gUmVhZHMgMyB2YWx1ZXNcbiAgICogQHBhcmFtIHtib29sfSBlbmFibGVRdWV1ZSB0cnV0aHkgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBzaG91bGQgYmUgcXVldWVkIHBlbmRpbmcgdGhlIG5leHQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIGRldGVybWluZXMgaG93IHRoZSByZXF1ZXN0cyB3aWxsIGJlIHNjaGVkdWxlZFxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggb25seSBwcm9wYWdhdGVzIHZhbHVlcyBvbiByZXF1ZXN0LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbnRyb2xsZWQgPSBmdW5jdGlvbiAoZW5hYmxlUXVldWUsIHNjaGVkdWxlcikge1xuXG4gICAgaWYgKGVuYWJsZVF1ZXVlICYmIGlzU2NoZWR1bGVyKGVuYWJsZVF1ZXVlKSkge1xuICAgICAgc2NoZWR1bGVyID0gZW5hYmxlUXVldWU7XG4gICAgICBlbmFibGVRdWV1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZVF1ZXVlID09IG51bGwpIHsgIGVuYWJsZVF1ZXVlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBuZXcgQ29udHJvbGxlZE9ic2VydmFibGUodGhpcywgZW5hYmxlUXVldWUsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFN0b3BBbmRXYWl0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3RvcEFuZFdhaXRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN0b3BBbmRXYWl0T2JzZXJ2YWJsZSAoc291cmNlKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLnNvdXJjZS5yZXF1ZXN0KDEpO1xuICAgIH1cblxuICAgIFN0b3BBbmRXYWl0T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3RvcEFuZFdhaXRPYnNlcnZlcihvLCB0aGlzLCB0aGlzLnN1YnNjcmlwdGlvbikpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbixcbiAgICAgICAgZGVmYXVsdFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBzY2hlZHVsZU1ldGhvZClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBTdG9wQW5kV2FpdE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1Yl9fKSB7XG4gICAgICBpbmhlcml0cyhTdG9wQW5kV2FpdE9ic2VydmVyLCBfX3N1Yl9fKTtcbiAgICAgIGZ1bmN0aW9uIFN0b3BBbmRXYWl0T2JzZXJ2ZXIgKG9ic2VydmVyLCBvYnNlcnZhYmxlLCBjYW5jZWwpIHtcbiAgICAgICAgX19zdWJfXy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH07XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gaW5uZXJTY2hlZHVsZU1ldGhvZChzLCBzZWxmKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm9ic2VydmFibGUuc291cmNlLnJlcXVlc3QoMSk7XG4gICAgICB9XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IGRlZmF1bHRTY2hlZHVsZXIuc2NoZWR1bGUodGhpcywgaW5uZXJTY2hlZHVsZU1ldGhvZCk7XG4gICAgICB9O1xuXG4gICAgICBTdG9wQW5kV2FpdE9ic2VydmVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbC5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSkge1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgX19zdWJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFN0b3BBbmRXYWl0T2JzZXJ2ZXI7XG4gICAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgICByZXR1cm4gU3RvcEFuZFdhaXRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIHN0b3AgYW5kIHdhaXQgb2JzZXJ2YWJsZSB0byB0aGUgY3VycmVudCBvYnNlcnZhYmxlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzdG9wIGFuZCB3YWl0IG9ic2VydmFibGUuXG4gICAqL1xuICBDb250cm9sbGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3RvcEFuZFdhaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9wQW5kV2FpdE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFdpbmRvd2VkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoV2luZG93ZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFdpbmRvd2VkT2JzZXJ2YWJsZShzb3VyY2UsIHdpbmRvd1NpemUpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLnNvdXJjZS5yZXF1ZXN0KHNlbGYud2luZG93U2l6ZSk7XG4gICAgfVxuXG4gICAgV2luZG93ZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dlZE9ic2VydmVyKG8sIHRoaXMsIHRoaXMuc3Vic2NyaXB0aW9uKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLFxuICAgICAgICBkZWZhdWx0U2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIHNjaGVkdWxlTWV0aG9kKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIFdpbmRvd2VkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3ViX18pIHtcbiAgICAgIGluaGVyaXRzKFdpbmRvd2VkT2JzZXJ2ZXIsIF9fc3ViX18pO1xuICAgICAgZnVuY3Rpb24gV2luZG93ZWRPYnNlcnZlcihvYnNlcnZlciwgb2JzZXJ2YWJsZSwgY2FuY2VsKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICAgIF9fc3ViX18uY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgV2luZG93ZWRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgV2luZG93ZWRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBpbm5lclNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYub2JzZXJ2YWJsZS5zb3VyY2UucmVxdWVzdChzZWxmLm9ic2VydmFibGUud2luZG93U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIFdpbmRvd2VkT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gKyt0aGlzLnJlY2VpdmVkICUgdGhpcy5vYnNlcnZhYmxlLndpbmRvd1NpemU7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPT09IDAgJiYgKHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gZGVmYXVsdFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBpbm5lclNjaGVkdWxlTWV0aG9kKSk7XG4gICAgICB9O1xuXG4gICAgICBXaW5kb3dlZE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWwuZGlzcG9zZSgpO1xuICAgICAgICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlZHVsZURpc3Bvc2FibGUpIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZURpc3Bvc2FibGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF9fc3ViX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBXaW5kb3dlZE9ic2VydmVyO1xuICAgIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gICAgcmV0dXJuIFdpbmRvd2VkT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzbGlkaW5nIHdpbmRvd2VkIG9ic2VydmFibGUgYmFzZWQgdXBvbiB0aGUgd2luZG93IHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dTaXplIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHdpbmRvd1xuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSB3aW5kb3dlZCBvYnNlcnZhYmxlIGJhc2VkIHVwb24gdGhlIHdpbmRvdyBzaXplLlxuICAgKi9cbiAgQ29udHJvbGxlZE9ic2VydmFibGUucHJvdG90eXBlLndpbmRvd2VkID0gZnVuY3Rpb24gKHdpbmRvd1NpemUpIHtcbiAgICByZXR1cm4gbmV3IFdpbmRvd2VkT2JzZXJ2YWJsZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogUGlwZXMgdGhlIGV4aXN0aW5nIE9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIE5vZGUuanMgU3RyZWFtLlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gZGVzdCBUaGUgZGVzdGluYXRpb24gTm9kZS5qcyBzdHJlYW0uXG4gICAqIEByZXR1cm5zIHtTdHJlYW19IFRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMucGF1c2FibGVCdWZmZXJlZCgpO1xuXG4gICAgZnVuY3Rpb24gb25EcmFpbigpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICBkZXN0LmFkZExpc3RlbmVyKCdkcmFpbicsIG9uRHJhaW4pO1xuXG4gICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICFkZXN0LndyaXRlKHgpICYmIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBIYWNrIGNoZWNrIGJlY2F1c2UgU1RESU8gaXMgbm90IGNsb3NhYmxlXG4gICAgICAgICFkZXN0Ll9pc1N0ZGlvICYmIGRlc3QuZW5kKCk7XG4gICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25EcmFpbik7XG4gICAgICB9KTtcblxuICAgIHNvdXJjZS5yZXN1bWUoKTtcblxuICAgIHJldHVybiBkZXN0O1xuICB9O1xuXG4gIHZhciBNdWx0aWNhc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhNdWx0aWNhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE11bHRpY2FzdE9ic2VydmFibGUoc291cmNlLCBmbjEsIGZuMikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbjEgPSBmbjE7XG4gICAgICB0aGlzLl9mbjIgPSBmbjI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNdWx0aWNhc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuc291cmNlLm11bHRpY2FzdCh0aGlzLl9mbjEoKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUodGhpcy5fZm4yKGNvbm5lY3RhYmxlKS5zdWJzY3JpYmUobyksIGNvbm5lY3RhYmxlLmNvbm5lY3QoKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNdWx0aWNhc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIE11bHRpY2FzdHMgdGhlIHNvdXJjZSBzZXF1ZW5jZSBub3RpZmljYXRpb25zIHRocm91Z2ggYW4gaW5zdGFudGlhdGVkIHN1YmplY3QgaW50byBhbGwgdXNlcyBvZiB0aGUgc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uIEVhY2hcbiAgICogc3Vic2NyaXB0aW9uIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2F1c2VzIGEgc2VwYXJhdGUgbXVsdGljYXN0IGludm9jYXRpb24sIGV4cG9zaW5nIHRoZSBzZXF1ZW5jZSByZXN1bHRpbmcgZnJvbSB0aGUgc2VsZWN0b3IgZnVuY3Rpb24nc1xuICAgKiBpbnZvY2F0aW9uLiBGb3Igc3BlY2lhbGl6YXRpb25zIHdpdGggZml4ZWQgc3ViamVjdCB0eXBlcywgc2VlIFB1Ymxpc2gsIFB1Ymxpc2hMYXN0LCBhbmQgUmVwbGF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAxIC0gcmVzID0gc291cmNlLm11bHRpY2FzdChvYnNlcnZhYmxlKTtcbiAgICogMiAtIHJlcyA9IHNvdXJjZS5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3QoKTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN1YmplY3R9IHN1YmplY3RPclN1YmplY3RTZWxlY3RvclxuICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgc3ViamVjdCB0aHJvdWdoIHdoaWNoIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBlbGVtZW50cyB3aWxsIGJlIG11bHRpY2FzdCB0byB0aGUgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqIE9yOlxuICAgKiBTdWJqZWN0IHRvIHB1c2ggc291cmNlIGVsZW1lbnRzIGludG8uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIHN1YmplY3QgdG8gdGhlIHBvbGljaWVzIGVuZm9yY2VkIGJ5IHRoZSBjcmVhdGVkIHN1YmplY3QuIFNwZWNpZmllZCBvbmx5IGlmIDxwYXJhbXJlZiBuYW1lPVwic3ViamVjdE9yU3ViamVjdFNlbGVjdG9yXCIgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm11bHRpY2FzdCA9IGZ1bmN0aW9uIChzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yKSA/XG4gICAgICBuZXcgTXVsdGljYXN0T2JzZXJ2YWJsZSh0aGlzLCBzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSA6XG4gICAgICBuZXcgQ29ubmVjdGFibGVPYnNlcnZhYmxlKHRoaXMsIHN1YmplY3RPclN1YmplY3RTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSByZWd1bGFyIFN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXNyZXMgPSBzb3VyY2UucHVibGlzaCgpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIFNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IFN1YmplY3QoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoIHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCkucmVmQ291bnQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBjb250YWluaW5nIG9ubHkgdGhlIGxhc3Qgbm90aWZpY2F0aW9uLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgQXN5bmNTdWJqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hMYXN0KCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaExhc3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgW09wdGlvbmFsXSBTZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCBvbmx5IHJlY2VpdmUgdGhlIGxhc3Qgbm90aWZpY2F0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaExhc3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgJiYgaXNGdW5jdGlvbihzZWxlY3RvcikgP1xuICAgICAgdGhpcy5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFzeW5jU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IEFzeW5jU3ViamVjdCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBhbmQgc3RhcnRzIHdpdGggaW5pdGlhbFZhbHVlLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgQmVoYXZpb3JTdWJqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hWYWx1ZSg0Mik7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaFZhbHVlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNlbGVjdChmdW5jdGlvbiAoeSkgeyByZXR1cm4geSAqIHk7IH0pIH0sIDQyKTtcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGltbWVkaWF0ZWx5IHJlY2VpdmUgdGhlIGluaXRpYWwgdmFsdWUsIGZvbGxvd2VkIGJ5IGFsbCBub3RpZmljYXRpb25zIG9mIHRoZSBzb3VyY2UgZnJvbSB0aGUgdGltZSBvZiB0aGUgc3Vic2NyaXB0aW9uIG9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsVmFsdWUgSW5pdGlhbCB2YWx1ZSByZWNlaXZlZCBieSBvYnNlcnZlcnMgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaFZhbHVlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IsIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAyID9cbiAgICAgIHRoaXMubXVsdGljYXN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sIGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IpIDpcbiAgICAgIHRoaXMubXVsdGljYXN0KG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlT3JTZWxlY3RvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIGFuZCBzdGFydHMgd2l0aCBhbiBpbml0aWFsVmFsdWUuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoVmFsdWUgd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsVmFsdWUgSW5pdGlhbCB2YWx1ZSByZWNlaXZlZCBieSBvYnNlcnZlcnMgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2hhcmVWYWx1ZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoVmFsdWUoaW5pdGlhbFZhbHVlKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiBhIGNvbm5lY3RhYmxlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIHJlcGxheWluZyBub3RpZmljYXRpb25zIHN1YmplY3QgdG8gYSBtYXhpbXVtIHRpbWUgbGVuZ3RoIGZvciB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIE11bHRpY2FzdCB1c2luZyBhIFJlcGxheVN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KG51bGwsIDMpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDApO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDAsIHNjaGVkdWxlcik7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRha2UoNikucmVwZWF0KCk7IH0sIDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIFtPcHRpb25hbF0gU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgdGhlIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBzdWJqZWN0IHRvIHRoZSBzcGVjaWZpZWQgcmVwbGF5IGJ1ZmZlciB0cmltbWluZyBwb2xpY3kuXG4gICAqIEBwYXJhbSBidWZmZXJTaXplIFtPcHRpb25hbF0gTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gd2luZG93U2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gdGltZSBsZW5ndGggb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSBzY2hlZHVsZXIgW09wdGlvbmFsXSBTY2hlZHVsZXIgd2hlcmUgY29ubmVjdGVkIG9ic2VydmVycyB3aXRoaW4gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5yZXBsYXkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGJ1ZmZlclNpemUsIHdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgcmVwbGF5aW5nIG5vdGlmaWNhdGlvbnMgc3ViamVjdCB0byBhIG1heGltdW0gdGltZSBsZW5ndGggZm9yIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgcmVwbGF5IHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZVJlcGxheSgzKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZVJlcGxheSgzLCA1MDApO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICpcblxuICAgKiBAcGFyYW0gYnVmZmVyU2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gZWxlbWVudCBjb3VudCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHdpbmRvdyBbT3B0aW9uYWxdIE1heGltdW0gdGltZSBsZW5ndGggb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSBzY2hlZHVsZXIgW09wdGlvbmFsXSBTY2hlZHVsZXIgd2hlcmUgY29ubmVjdGVkIG9ic2VydmVycyB3aXRoaW4gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZVJlcGxheSA9IGZ1bmN0aW9uIChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYXkobnVsbCwgYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIHZhciBJbm5lclN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzLCBvKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fbyA9IG87XG4gIH07XG5cbiAgSW5uZXJTdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9zLmlzRGlzcG9zZWQgJiYgdGhpcy5fbyAhPT0gbnVsbCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuX3Mub2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5fbyk7XG4gICAgICB0aGlzLl9zLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHRoaXMuX28gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgUmVmQ291bnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSZWZDb3VudE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICB0aGlzLl9jb25uZWN0YWJsZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZWZDb3VudE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc291cmNlLnN1YnNjcmliZShvKTtcbiAgICAgICsrdGhpcy5fY291bnQgPT09IDEgJiYgKHRoaXMuX2Nvbm5lY3RhYmxlU3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2UuY29ubmVjdCgpKTtcbiAgICAgIHJldHVybiBuZXcgUmVmQ291bnREaXNwb3NhYmxlKHRoaXMsIHN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlZkNvdW50RGlzcG9zYWJsZShwLCBzKSB7XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgUmVmQ291bnREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcy5kaXNwb3NlKCk7XG4gICAgICAgIC0tdGhpcy5fcC5fY291bnQgPT09IDAgJiYgdGhpcy5fcC5fY29ubmVjdGFibGVTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUmVmQ291bnRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IFJ4LkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHN1YmplY3QpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICB0aGlzLl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbm5lY3REaXNwb3NhYmxlKHBhcmVudCwgc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBDb25uZWN0RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zKSB7XG4gICAgICAgIHRoaXMuX3MuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcC5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zb3VyY2Uuc3Vic2NyaWJlKHRoaXMuX3N1YmplY3QpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbmV3IENvbm5lY3REaXNwb3NhYmxlKHRoaXMsIHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbjtcbiAgICB9O1xuXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0LnN1YnNjcmliZShvKTtcbiAgICB9O1xuXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVmQ291bnRPYnNlcnZhYmxlKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS4gVGhpcyBvYnNlcnZhYmxlIHNlcXVlbmNlXG4gICAqIGNhbiBiZSByZXN1YnNjcmliZWQgdG8sIGV2ZW4gaWYgYWxsIHByaW9yIHN1YnNjcmlwdGlvbnMgaGF2ZSBlbmRlZC4gKHVubGlrZSBgLnB1Ymxpc2goKS5yZWZDb3VudCgpYClcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaW5nbGVJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBoYXNPYnNlcnZhYmxlID0gZmFsc2UsIG9ic2VydmFibGU7XG5cbiAgICBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlKCkge1xuICAgICAgaWYgKCFoYXNPYnNlcnZhYmxlKSB7XG4gICAgICAgIGhhc09ic2VydmFibGUgPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlID0gc291cmNlWydmaW5hbGx5J10oZnVuY3Rpb24oKSB7IGhhc09ic2VydmFibGUgPSBmYWxzZTsgfSkucHVibGlzaCgpLnJlZkNvdW50KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIGdldE9ic2VydmFibGUoKS5zdWJzY3JpYmUobyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDb3JyZWxhdGVzIHRoZSBlbGVtZW50cyBvZiB0d28gc2VxdWVuY2VzIGJhc2VkIG9uIG92ZXJsYXBwaW5nIGR1cmF0aW9ucy5cbiAgICpcbiAgICogIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcmlnaHQgVGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UgdG8gam9pbiBlbGVtZW50cyBmb3IuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBsZWZ0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIGxlZnQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNlZCB0byBkZXRlcm1pbmUgb3ZlcmxhcC5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJpZ2h0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBBIGZ1bmN0aW9uIGludm9rZWQgdG8gY29tcHV0ZSBhIHJlc3VsdCBlbGVtZW50IGZvciBhbnkgdHdvIG92ZXJsYXBwaW5nIGVsZW1lbnRzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlcy4gVGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBjb3JyZXNwb25kIHdpdGggdGhlIGVsZW1lbnRzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IHNvdXJjZSBzZXF1ZW5jZXMgZm9yIHdoaWNoIG92ZXJsYXAgb2NjdXJzLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyByZXN1bHQgZWxlbWVudHMgY29tcHV0ZWQgZnJvbSBzb3VyY2UgZWxlbWVudHMgdGhhdCBoYXZlIGFuIG92ZXJsYXBwaW5nIGR1cmF0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmpvaW4gPSBmdW5jdGlvbiAocmlnaHQsIGxlZnREdXJhdGlvblNlbGVjdG9yLCByaWdodER1cmF0aW9uU2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBsZWZ0RG9uZSA9IGZhbHNlLCByaWdodERvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBsZWZ0SWQgPSAwLCByaWdodElkID0gMDtcbiAgICAgIHZhciBsZWZ0TWFwID0gbmV3IE1hcCgpLCByaWdodE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfTtcblxuICAgICAgZ3JvdXAuYWRkKGxlZnQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaWQgPSBsZWZ0SWQrKywgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcblxuICAgICAgICAgIGxlZnRNYXAuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoKGxlZnREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpOyB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBsZWZ0TWFwWydkZWxldGUnXShpZCkgJiYgbGVmdE1hcC5zaXplID09PSAwICYmIGxlZnREb25lICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHJpZ2h0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChyZXN1bHRTZWxlY3RvcikodmFsdWUsIHYpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgICAgICAgIG8ub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGVmdERvbmUgPSB0cnVlO1xuICAgICAgICAgIChyaWdodERvbmUgfHwgbGVmdE1hcC5zaXplID09PSAwKSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBncm91cC5hZGQocmlnaHQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaWQgPSByaWdodElkKyssIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgICAgICByaWdodE1hcC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgICBncm91cC5hZGQobWQpO1xuXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2gocmlnaHREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpOyB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByaWdodE1hcFsnZGVsZXRlJ10oaWQpICYmIHJpZ2h0TWFwLnNpemUgPT09IDAgJiYgcmlnaHREb25lICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKSh2LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgICAgICAgby5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByaWdodERvbmUgPSB0cnVlO1xuICAgICAgICAgIChsZWZ0RG9uZSB8fCByaWdodE1hcC5zaXplID09PSAwKSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sIGxlZnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgQ29ycmVsYXRlcyB0aGUgZWxlbWVudHMgb2YgdHdvIHNlcXVlbmNlcyBiYXNlZCBvbiBvdmVybGFwcGluZyBkdXJhdGlvbnMsIGFuZCBncm91cHMgdGhlIHJlc3VsdHMuXG4gICAqXG4gICAqICBAcGFyYW0ge09ic2VydmFibGV9IHJpZ2h0IFRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGpvaW4gZWxlbWVudHMgZm9yLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gbGVmdER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSBsZWZ0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSByaWdodER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2VkIHRvIGRldGVybWluZSBvdmVybGFwLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgQSBmdW5jdGlvbiBpbnZva2VkIHRvIGNvbXB1dGUgYSByZXN1bHQgZWxlbWVudCBmb3IgYW55IGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VxdWVuY2Ugd2l0aCBvdmVybGFwcGluZyBlbGVtZW50cyBmcm9tIHRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlLiBUaGUgZmlyc3QgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gaXMgYW4gZWxlbWVudCBvZiB0aGUgbGVmdCBzZXF1ZW5jZS4gVGhlIHNlY29uZCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBpcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggZWxlbWVudHMgZnJvbSB0aGUgcmlnaHQgc2VxdWVuY2UgdGhhdCBvdmVybGFwIHdpdGggdGhlIGxlZnQgc2VxdWVuY2UncyBlbGVtZW50LlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyByZXN1bHQgZWxlbWVudHMgY29tcHV0ZWQgZnJvbSBzb3VyY2UgZWxlbWVudHMgdGhhdCBoYXZlIGFuIG92ZXJsYXBwaW5nIGR1cmF0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmdyb3VwSm9pbiA9IGZ1bmN0aW9uIChyaWdodCwgbGVmdER1cmF0aW9uU2VsZWN0b3IsIHJpZ2h0RHVyYXRpb25TZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICB2YXIgbGVmdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgdmFyIHIgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGdyb3VwKTtcbiAgICAgIHZhciBsZWZ0TWFwID0gbmV3IE1hcCgpLCByaWdodE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBsZWZ0SWQgPSAwLCByaWdodElkID0gMDtcbiAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyB2Lm9uRXJyb3IoZSk7IH07IH07XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGUpIHsgfTtcblxuICAgICAgZ3JvdXAuYWRkKGxlZnQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgdmFyIGlkID0gbGVmdElkKys7XG4gICAgICAgICAgbGVmdE1hcC5zZXQoaWQsIHMpO1xuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKSh2YWx1ZSwgYWRkUmVmKHMsIHIpKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKHJlc3VsdC5lKSk7XG4gICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKHJlc3VsdC5lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5vbk5leHQocmVzdWx0KTtcblxuICAgICAgICAgIHJpZ2h0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcy5vbk5leHQodik7IH0pO1xuXG4gICAgICAgICAgdmFyIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoKGxlZnREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGR1cmF0aW9uLmUpKTtcbiAgICAgICAgICAgIHJldHVybiBvLm9uRXJyb3IoZHVyYXRpb24uZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBsZWZ0TWFwWydkZWxldGUnXShpZCkgJiYgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgICBncm91cC5yZW1vdmUobWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IG8ub25Db21wbGV0ZWQoKTsgfSlcbiAgICAgICk7XG5cbiAgICAgIGdyb3VwLmFkZChyaWdodC5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IHJpZ2h0SWQrKztcbiAgICAgICAgICByaWdodE1hcC5zZXQoaWQsIHZhbHVlKTtcblxuICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgIGdyb3VwLmFkZChtZCk7XG5cbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChyaWdodER1cmF0aW9uU2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZHVyYXRpb24uZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgbm9vcCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJpZ2h0TWFwWydkZWxldGUnXShpZCk7XG4gICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5vbk5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIGxlZnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoeCkgeyByZXR1cm4geC50b0FycmF5KCk7IH1cblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gemVybyBvciBtb3JlIGJ1ZmZlcnMuXG4gICAqICBAcGFyYW0ge01peGVkfSBidWZmZXJPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yIE9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgZGVub3RlIHRoZSBjcmVhdGlvbiBvZiBuZXcgd2luZG93cywgb3IsIGEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHByb2R1Y2VkIHdpbmRvd3MgKGEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWQsIHJlc3VsdGluZyBpbiBub24tb3ZlcmxhcHBpbmcgd2luZG93cykuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbYnVmZmVyQ2xvc2luZ1NlbGVjdG9yXSBBIGZ1bmN0aW9uIGludm9rZWQgdG8gZGVmaW5lIHRoZSBjbG9zaW5nIG9mIGVhY2ggcHJvZHVjZWQgd2luZG93LiBJZiBhIGNsb3Npbmcgc2VsZWN0b3IgZnVuY3Rpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyLCB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMud2luZG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIC5mbGF0TWFwKHRvQXJyYXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cy5cbiAgICpcbiAgICogIEBwYXJhbSB7TWl4ZWR9IHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBkZW5vdGUgdGhlIGNyZWF0aW9uIG9mIG5ldyB3aW5kb3dzLCBvciwgYSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcHJvZHVjZWQgd2luZG93cyAoYSBuZXcgd2luZG93IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb25lIGlzIGNsb3NlZCwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzKS5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFt3aW5kb3dDbG9zaW5nU2VsZWN0b3JdIEEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGNsb3Npbmcgb2YgZWFjaCBwcm9kdWNlZCB3aW5kb3cuIElmIGEgY2xvc2luZyBzZWxlY3RvciBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQuXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLndpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVdpbmRvd1dpdGhCb3VuZGFyaWVzLmNhbGwodGhpcywgd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBvYnNlcnZhYmxlV2luZG93V2l0aENsb3NpbmdTZWxlY3Rvci5jYWxsKHRoaXMsIHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IpIDpcbiAgICAgIG9ic2VydmFibGVXaW5kb3dXaXRoT3BlbmluZ3MuY2FsbCh0aGlzLCB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVXaW5kb3dXaXRoT3BlbmluZ3Mod2luZG93T3BlbmluZ3MsIHdpbmRvd0Nsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB3aW5kb3dPcGVuaW5ncy5ncm91cEpvaW4odGhpcywgd2luZG93Q2xvc2luZ1NlbGVjdG9yLCBvYnNlcnZhYmxlRW1wdHksIGZ1bmN0aW9uIChfLCB3aW4pIHtcbiAgICAgIHJldHVybiB3aW47XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aEJvdW5kYXJpZXMod2luZG93Qm91bmRhcmllcykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciB3aW4gPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcbiAgICAgICAgciA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZCk7XG5cbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG5cbiAgICAgIGQuYWRkKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgd2luLm9uTmV4dCh4KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcblxuICAgICAgaXNQcm9taXNlKHdpbmRvd0JvdW5kYXJpZXMpICYmICh3aW5kb3dCb3VuZGFyaWVzID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHdpbmRvd0JvdW5kYXJpZXMpKTtcblxuICAgICAgZC5hZGQod2luZG93Qm91bmRhcmllcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHdpbiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHdpbi5vbkVycm9yKGVycik7XG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aENsb3NpbmdTZWxlY3Rvcih3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShtKSxcbiAgICAgICAgciA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZCksXG4gICAgICAgIHdpbiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHdpbiwgcikpO1xuICAgICAgZC5hZGQoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHdpbi5vbk5leHQoeCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlV2luZG93Q2xvc2UgKCkge1xuICAgICAgICB2YXIgd2luZG93Q2xvc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93Q2xvc2UgPSB3aW5kb3dDbG9zaW5nU2VsZWN0b3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNQcm9taXNlKHdpbmRvd0Nsb3NlKSAmJiAod2luZG93Q2xvc2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uod2luZG93Q2xvc2UpKTtcblxuICAgICAgICB2YXIgbTEgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKG0xKTtcbiAgICAgICAgbTEuc2V0RGlzcG9zYWJsZSh3aW5kb3dDbG9zZS50YWtlKDEpLnN1YnNjcmliZShub29wLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB3aW4gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XG4gICAgICAgICAgY3JlYXRlV2luZG93Q2xvc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVXaW5kb3dDbG9zZSgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIHZhciBQYWlyd2lzZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJ3aXNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFBhaXJ3aXNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBQYWlyd2lzZU9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhaXJ3aXNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBQYWlyd2lzZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJ3aXNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUGFpcndpc2VPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBudWxsO1xuICAgICAgdGhpcy5faHAgPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFBhaXJ3aXNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2hwKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KFt0aGlzLl9wLCB4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ocCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9wID0geDtcbiAgICB9O1xuICAgIFBhaXJ3aXNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikgeyB0aGlzLl9vLm9uRXJyb3IoZXJyKTsgfTtcbiAgICBQYWlyd2lzZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBQYWlyd2lzZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYnNlcnZhYmxlIHRoYXQgdHJpZ2dlcnMgb24gdGhlIHNlY29uZCBhbmQgc3Vic2VxdWVudCB0cmlnZ2VyaW5ncyBvZiB0aGUgaW5wdXQgb2JzZXJ2YWJsZS5cbiAgICogVGhlIE50aCB0cmlnZ2VyaW5nIG9mIHRoZSBpbnB1dCBvYnNlcnZhYmxlIHBhc3NlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIE4tMXRoIGFuZCBOdGggdHJpZ2dlcmluZyBhcyBhIHBhaXIuXG4gICAqIFRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIE4tMXRoIHRyaWdnZXJpbmcgaXMgaGVsZCBpbiBoaWRkZW4gaW50ZXJuYWwgc3RhdGUgdW50aWwgdGhlIE50aCB0cmlnZ2VyaW5nIG9jY3Vycy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCB0cmlnZ2VycyBvbiBzdWNjZXNzaXZlIHBhaXJzIG9mIG9ic2VydmF0aW9ucyBmcm9tIHRoZSBpbnB1dCBvYnNlcnZhYmxlIGFzIGFuIGFycmF5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhaXJ3aXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUGFpcndpc2VPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHR3byBvYnNlcnZhYmxlcyB3aGljaCBwYXJ0aXRpb24gdGhlIG9ic2VydmF0aW9ucyBvZiB0aGUgc291cmNlIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICogVGhlIGZpcnN0IHdpbGwgdHJpZ2dlciBvYnNlcnZhdGlvbnMgZm9yIHRob3NlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuXG4gICAqIFRoZSBzZWNvbmQgd2lsbCB0cmlnZ2VyIG9ic2VydmF0aW9ucyBmb3IgdGhvc2UgdmFsdWVzIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyBmYWxzZS5cbiAgICogVGhlIHByZWRpY2F0ZSBpcyBleGVjdXRlZCBvbmNlIGZvciBlYWNoIHN1YnNjcmliZWQgb2JzZXJ2ZXIuXG4gICAqIEJvdGggYWxzbyBwcm9wYWdhdGUgYWxsIGVycm9yIG9ic2VydmF0aW9ucyBhcmlzaW5nIGZyb20gdGhlIHNvdXJjZSBhbmQgZWFjaCBjb21wbGV0ZXNcbiAgICogd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAqICAgIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggb3V0cHV0IE9ic2VydmFibGUgd2lsbCB0cmlnZ2VyIGEgcGFydGljdWxhciBvYnNlcnZhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiAgICBBbiBhcnJheSBvZiBvYnNlcnZhYmxlcy4gVGhlIGZpcnN0IHRyaWdnZXJzIHdoZW4gdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUsXG4gICAqICAgIGFuZCB0aGUgc2Vjb25kIHRyaWdnZXJzIHdoZW4gdGhlIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGFydGl0aW9uID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdmFyIGZuID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZyksXG4gICAgICB0aGlzLmZpbHRlcihmdW5jdGlvbiAoeCwgaSwgbykgeyByZXR1cm4gIWZuKHgsIGksIG8pOyB9KVxuICAgIF07XG4gIH07XG5cbiAgdmFyIFdoaWxlRW51bWVyYWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaGlsZUVudW1lcmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2hpbGVFbnVtZXJhYmxlKGMsIHMpIHtcbiAgICAgIHRoaXMuYyA9IGM7XG4gICAgICB0aGlzLnMgPSBzO1xuICAgIH1cbiAgICBXaGlsZUVudW1lcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmMoKSA/XG4gICAgICAgICAgIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzZWxmLnMgfSA6XG4gICAgICAgICAgIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFdoaWxlRW51bWVyYWJsZTtcbiAgfShFbnVtZXJhYmxlKSk7XG4gIFxuICBmdW5jdGlvbiBlbnVtZXJhYmxlV2hpbGUoY29uZGl0aW9uLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFdoaWxlRW51bWVyYWJsZShjb25kaXRpb24sIHNvdXJjZSk7XG4gIH0gIFxuXG4gICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zLlxuICAgKiAgVGhpcyBvcGVyYXRvciBhbGxvd3MgZm9yIGEgZmx1ZW50IHN0eWxlIG9mIHdyaXRpbmcgcXVlcmllcyB0aGF0IHVzZSB0aGUgc2FtZSBzZXF1ZW5jZSBtdWx0aXBsZSB0aW1lcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IHNoYXJpbmcgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmxldEJpbmQgPSBvYnNlcnZhYmxlUHJvdG9bJ2xldCddID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYyh0aGlzKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHZhbHVlcy4gXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pZihjb25kaXRpb24sIG9iczEpO1xuICAgKiAgMiAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaWYoY29uZGl0aW9uLCBvYnMxLCBvYnMyKTtcbiAgICogIDMgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSwgc2NoZWR1bGVyKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgdGhlblNvdXJjZSBvciBlbHNlU291cmNlIHdpbGwgYmUgcnVuLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHRoZW5Tb3VyY2UgVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBjb25kaXRpb24gZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IFtlbHNlU291cmNlXSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gUnguT2JzZXJ2YWJlLkVtcHR5IHdpdGggdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIGVpdGhlciB0aGUgdGhlblNvdXJjZSBvciBlbHNlU291cmNlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZVsnaWYnXSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2VPclNjaGVkdWxlcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgZWxzZVNvdXJjZU9yU2NoZWR1bGVyIHx8IChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoKSk7XG5cbiAgICAgIGlzUHJvbWlzZSh0aGVuU291cmNlKSAmJiAodGhlblNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh0aGVuU291cmNlKSk7XG4gICAgICBpc1Byb21pc2UoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSAmJiAoZWxzZVNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGVsc2VTb3VyY2VPclNjaGVkdWxlcikpO1xuXG4gICAgICAvLyBBc3N1bWUgYSBzY2hlZHVsZXIgZm9yIGVtcHR5IG9ubHlcbiAgICAgIHR5cGVvZiBlbHNlU291cmNlT3JTY2hlZHVsZXIubm93ID09PSAnZnVuY3Rpb24nICYmIChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSk7XG4gICAgICByZXR1cm4gY29uZGl0aW9uKCkgPyB0aGVuU291cmNlIDogZWxzZVNvdXJjZU9yU2NoZWR1bGVyO1xuICAgIH0pO1xuICB9O1xuXG4gICAvKipcbiAgICogIENvbmNhdGVuYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb2J0YWluZWQgYnkgcnVubmluZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmb3IgZWFjaCBlbGVtZW50IGluIHNvdXJjZS5cbiAgICogVGhlcmUgaXMgYW4gYWxpYXMgZm9yIHRoaXMgbWV0aG9kIGNhbGxlZCAnZm9ySW4nIGZvciBicm93c2VycyA8SUU5XG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZXMgQW4gYXJyYXkgb2YgdmFsdWVzIHRvIHR1cm4gaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiB0aGUgc291cmNlcyBhcnJheSB0byB0dXJuIGl0IGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSB0aGUgY29uY2F0ZW5hdGVkIG9ic2VydmFibGUgc2VxdWVuY2VzLlxuICAgKi9cbiAgT2JzZXJ2YWJsZVsnZm9yJ10gPSBPYnNlcnZhYmxlLmZvckluID0gZnVuY3Rpb24gKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGVudW1lcmFibGVPZihzb3VyY2VzLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykuY29uY2F0KCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgUmVwZWF0cyBzb3VyY2UgYXMgbG9uZyBhcyBjb25kaXRpb24gaG9sZHMgZW11bGF0aW5nIGEgd2hpbGUgbG9vcC5cbiAgICogVGhlcmUgaXMgYW4gYWxpYXMgZm9yIHRoaXMgbWV0aG9kIGNhbGxlZCAnd2hpbGVEbycgZm9yIGJyb3dzZXJzIDxJRTlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgc291cmNlIHdpbGwgYmUgcmVwZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc291cmNlIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIHRydWUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIHJlcGVhdGVkIGFzIGxvbmcgYXMgdGhlIGNvbmRpdGlvbiBob2xkcy5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlV2hpbGVEbyA9IE9ic2VydmFibGVbJ3doaWxlJ10gPSBPYnNlcnZhYmxlLndoaWxlRG8gPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBzb3VyY2UpIHtcbiAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgIHJldHVybiBlbnVtZXJhYmxlV2hpbGUoY29uZGl0aW9uLCBzb3VyY2UpLmNvbmNhdCgpO1xuICB9O1xuXG4gICAvKipcbiAgICogIFJlcGVhdHMgc291cmNlIGFzIGxvbmcgYXMgY29uZGl0aW9uIGhvbGRzIGVtdWxhdGluZyBhIGRvIHdoaWxlIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHNvdXJjZSB3aWxsIGJlIHJlcGVhdGVkLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNvdXJjZSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBjb25kaXRpb24gZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyByZXBlYXRlZCBhcyBsb25nIGFzIHRoZSBjb25kaXRpb24gaG9sZHMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZG9XaGlsZSA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUNvbmNhdChbdGhpcywgb2JzZXJ2YWJsZVdoaWxlRG8oY29uZGl0aW9uLCB0aGlzKV0pO1xuICB9O1xuXG4gICAvKipcbiAgICogIFVzZXMgc2VsZWN0b3IgdG8gZGV0ZXJtaW5lIHdoaWNoIHNvdXJjZSBpbiBzb3VyY2VzIHRvIHVzZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIGZ1bmN0aW9uIHdoaWNoIGV4dHJhY3RzIHRoZSB2YWx1ZSBmb3IgdG8gdGVzdCBpbiBhIGNhc2Ugc3RhdGVtZW50LlxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIEEgb2JqZWN0IHdoaWNoIGhhcyBrZXlzIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNhc2Ugc3RhdGVtZW50IGxhYmVscy5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZWxzZVNvdXJjZV0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBzb3VyY2VzIGFyZSBub3QgbWF0Y2hlZC4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIFJ4Lk9ic2VydmFiZS5lbXB0eSB3aXRoIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBkZXRlcm1pbmVkIGJ5IGEgY2FzZSBzdGF0ZW1lbnQuXG4gICAqL1xuICBPYnNlcnZhYmxlWydjYXNlJ10gPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNvdXJjZXMsIGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgaXNQcm9taXNlKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikgJiYgKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpKTtcbiAgICAgIGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciB8fCAoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUVtcHR5KCkpO1xuXG4gICAgICBpc1NjaGVkdWxlcihkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpICYmIChkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBzb3VyY2VzW3NlbGVjdG9yKCldO1xuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBkZWZhdWx0U291cmNlT3JTY2hlZHVsZXI7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEV4cGFuZE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXhwYW5kT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHBhbmRPYnNlcnZhYmxlKHNvdXJjZSwgZm4sIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUoYXJncywgcmVjdXJzZSkge1xuICAgICAgdmFyIHN0YXRlID0gYXJnc1swXSwgc2VsZiA9IGFyZ3NbMV07XG4gICAgICB2YXIgd29yaztcbiAgICAgIGlmIChzdGF0ZS5xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd29yayA9IHN0YXRlLnEuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmlzQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG0xID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBzdGF0ZS5kLmFkZChtMSk7XG4gICAgICBtMS5zZXREaXNwb3NhYmxlKHdvcmsuc3Vic2NyaWJlKG5ldyBFeHBhbmRPYnNlcnZlcihzdGF0ZSwgc2VsZiwgbTEpKSk7XG4gICAgICByZWN1cnNlKFtzdGF0ZSwgc2VsZl0pO1xuICAgIH1cblxuICAgIEV4cGFuZE9ic2VydmFibGUucHJvdG90eXBlLl9lbnN1cmVBY3RpdmUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBpc093bmVyID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUucS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzT3duZXIgPSAhc3RhdGUuaXNBY3F1aXJlZDtcbiAgICAgICAgc3RhdGUuaXNBY3F1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpc093bmVyICYmIHN0YXRlLm0uc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoW3N0YXRlLCB0aGlzXSwgc2NoZWR1bGVSZWN1cnNpdmUpKTtcbiAgICB9O1xuXG4gICAgRXhwYW5kT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShtKSxcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgcTogW10sXG4gICAgICAgICAgbTogbSxcbiAgICAgICAgICBkOiBkLFxuICAgICAgICAgIGFjdGl2ZUNvdW50OiAwLFxuICAgICAgICAgIGlzQWNxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgIG86IG9cbiAgICAgICAgfTtcblxuICAgICAgc3RhdGUucS5wdXNoKHRoaXMuc291cmNlKTtcbiAgICAgIHN0YXRlLmFjdGl2ZUNvdW50Kys7XG4gICAgICB0aGlzLl9lbnN1cmVBY3RpdmUoc3RhdGUpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHBhbmRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEV4cGFuZE9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV4cGFuZE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEV4cGFuZE9ic2VydmVyKHN0YXRlLCBwYXJlbnQsIG0xKSB7XG4gICAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgICB0aGlzLl9wID0gcGFyZW50O1xuICAgICAgdGhpcy5fbTEgPSBtMTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV4cGFuZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3Muby5vbk5leHQoeCk7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fcC5fZm4pKHgpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX3Muby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgdGhpcy5fcy5xLnB1c2gocmVzdWx0KTtcbiAgICAgIHRoaXMuX3MuYWN0aXZlQ291bnQrKztcbiAgICAgIHRoaXMuX3AuX2Vuc3VyZUFjdGl2ZSh0aGlzLl9zKTtcbiAgICB9O1xuXG4gICAgRXhwYW5kT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3Muby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBFeHBhbmRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcy5kLnJlbW92ZSh0aGlzLl9tMSk7XG4gICAgICB0aGlzLl9zLmFjdGl2ZUNvdW50LS07XG4gICAgICB0aGlzLl9zLmFjdGl2ZUNvdW50ID09PSAwICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXhwYW5kT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gICAvKipcbiAgICogIEV4cGFuZHMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSByZWN1cnNpdmVseSBpbnZva2luZyBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHByb2R1Y2VkIGVsZW1lbnQsIHJlc3VsdGluZyBpbiBhbm90aGVyIHNlcXVlbmNlIHRvIHdoaWNoIHRoZSBzZWxlY3RvciB3aWxsIGJlIGludm9rZWQgcmVjdXJzaXZlbHkgYWdhaW4uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcGVyZm9ybSB0aGUgZXhwYW5zaW9uLiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgdGhyZWFkIHNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIHByb2R1Y2VkIGJ5IHRoZSByZWN1cnNpdmUgZXhwYW5zaW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmV4cGFuZCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBFeHBhbmRPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIEZvcmtKb2luT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRm9ya0pvaW5PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZvcmtKb2luT2JzZXJ2YWJsZShzb3VyY2VzLCBjYikge1xuICAgICAgdGhpcy5fc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRm9ya0pvaW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBmaW5pc2hlZDogZmFsc2UsXG4gICAgICAgIGhhc1Jlc3VsdHM6IG5ldyBBcnJheShjb3VudCksXG4gICAgICAgIGhhc0NvbXBsZXRlZDogbmV3IEFycmF5KGNvdW50KSxcbiAgICAgICAgcmVzdWx0czogbmV3IEFycmF5KGNvdW50KVxuICAgICAgfTtcblxuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXNbaV07XG4gICAgICAgIGlzUHJvbWlzZShzb3VyY2UpICYmIChzb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc291cmNlKSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuYWRkKHNvdXJjZS5zdWJzY3JpYmUobmV3IEZvcmtKb2luT2JzZXJ2ZXIobywgc3RhdGUsIGksIHRoaXMuX2NiLCBzdWJzY3JpcHRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9ucztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcmtKb2luT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBGb3JrSm9pbk9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZvcmtKb2luT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRm9ya0pvaW5PYnNlcnZlcihvLCBzLCBpLCBjYiwgc3Vicykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fY2IgPSBjYjtcbiAgICAgIHRoaXMuX3N1YnMgPSBzdWJzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRm9ya0pvaW5PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXRoaXMuX3MuZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5fcy5oYXNSZXN1bHRzW3RoaXMuX2ldID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcy5yZXN1bHRzW3RoaXMuX2ldID0geDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ya0pvaW5PYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgICB0aGlzLl9zdWJzLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgRm9ya0pvaW5PYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9zLmZpbmlzaGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fcy5oYXNSZXN1bHRzW3RoaXMuX2ldKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zLmhhc0NvbXBsZXRlZFt0aGlzLl9pXSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcy5yZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9zLmhhc0NvbXBsZXRlZFtpXSkgeyByZXR1cm47IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zLmZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fY2IpLmFwcGx5KG51bGwsIHRoaXMuX3MucmVzdWx0cyk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG5cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRm9ya0pvaW5PYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgIC8qKlxuICAgKiAgUnVucyBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gcGFyYWxsZWwgYW5kIGNvbGxlY3QgdGhlaXIgbGFzdCBlbGVtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmZvcmtKb2luKFtvYnMxLCBvYnMyXSk7XG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5mb3JrSm9pbihvYnMxLCBvYnMyLCAuLi4pO1xuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGFuIGFycmF5IGNvbGxlY3RpbmcgdGhlIGxhc3QgZWxlbWVudHMgb2YgYWxsIHRoZSBpbnB1dCBzZXF1ZW5jZXMuXG4gICAqL1xuICBPYnNlcnZhYmxlLmZvcmtKb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKGFyZ3NbbGVuIC0gMV0pID8gYXJncy5wb3AoKSA6IGFyZ3VtZW50c1RvQXJyYXk7XG4gICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiAoYXJncyA9IGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXcgRm9ya0pvaW5PYnNlcnZhYmxlKGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBSdW5zIHR3byBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiBwYXJhbGxlbCBhbmQgY29tYmluZXMgdGhlaXIgbGFzdCBlbGVtZW5ldHMuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc2Vjb25kIFNlY29uZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBSZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24gdG8gaW52b2tlIHdpdGggdGhlIGxhc3QgZWxlbWVudHMgb2YgYm90aCBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aXRoIHRoZSBsYXN0IGVsZW1lbnRzIG9mIGJvdGggaW5wdXQgc2VxdWVuY2VzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZvcmtKb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgYXJnc1swXS51bnNoaWZ0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZhYmxlLmZvcmtKb2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21vbmFkaWMgYmluZCBvcGVyYXRvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZWR1bGVyIFNjaGVkdWxlciB1c2VkIHRvIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdGhlIEltbWVkaWF0ZVNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggcmVzdWx0cyBmcm9tIHRoZSBjb21vbmFkaWMgYmluZCBvcGVyYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWFueVNlbGVjdCA9IG9ic2VydmFibGVQcm90by5leHRlbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlci5pbW1lZGlhdGUpO1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoYWluO1xuXG4gICAgICByZXR1cm4gc291cmNlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgY3VyciA9IG5ldyBDaGFpbk9ic2VydmFibGUoeCk7XG5cbiAgICAgICAgICBjaGFpbiAmJiBjaGFpbi5vbk5leHQoeCk7XG4gICAgICAgICAgY2hhaW4gPSBjdXJyO1xuXG4gICAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICAgIH0pXG4gICAgICAgIC50YXAoXG4gICAgICAgICAgbm9vcCxcbiAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBjaGFpbiAmJiBjaGFpbi5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHsgY2hhaW4gJiYgY2hhaW4ub25Db21wbGV0ZWQoKTsgfVxuICAgICAgICApXG4gICAgICAgIC5vYnNlcnZlT24oc2NoZWR1bGVyKVxuICAgICAgICAubWFwKHNlbGVjdG9yKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBDaGFpbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENoYWluT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDaGFpbk9ic2VydmFibGUoaGVhZCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgICAgdGhpcy50YWlsID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoQ2hhaW5PYnNlcnZhYmxlLnByb3RvdHlwZSwgT2JzZXJ2ZXIsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgICAgZy5hZGQoY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBmdW5jdGlvbiAoXywgc2VsZikge1xuICAgICAgICAgIG8ub25OZXh0KHNlbGYuaGVhZCk7XG4gICAgICAgICAgZy5hZGQoc2VsZi50YWlsLm1lcmdlQWxsKCkuc3Vic2NyaWJlKG8pKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25OZXh0KE9ic2VydmFibGUuZW1wdHkoKSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5vbk5leHQoT2JzZXJ2YWJsZVsndGhyb3cnXShlKSk7XG4gICAgICB9LFxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLnRhaWwub25OZXh0KHYpO1xuICAgICAgICB0aGlzLnRhaWwub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBDaGFpbk9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIE1hcCA9IHJvb3QuTWFwIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIH1cblxuICAgIE1hcC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9rZXlzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNYXA7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBSZXByZXNlbnRzIGEgam9pbiBwYXR0ZXJuIG92ZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqL1xuICBmdW5jdGlvbiBQYXR0ZXJuKHBhdHRlcm5zKSB7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuICB9XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGEgcGF0dGVybiB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnQgcGxhbiBtYXRjaGVzIGFuZCB3aGVuIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGFzIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICogIEBwYXJhbSBvdGhlciBPYnNlcnZhYmxlIHNlcXVlbmNlIHRvIG1hdGNoIGluIGFkZGl0aW9uIHRvIHRoZSBjdXJyZW50IHBhdHRlcm4uXG4gICAqICBAcmV0dXJuIHtQYXR0ZXJufSBQYXR0ZXJuIG9iamVjdCB0aGF0IG1hdGNoZXMgd2hlbiBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4gaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUuXG4gICAqL1xuICBQYXR0ZXJuLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFBhdHRlcm4odGhpcy5wYXR0ZXJucy5jb25jYXQob3RoZXIpKTtcbiAgfTtcblxuICAvKipcbiAgICogIE1hdGNoZXMgd2hlbiBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4gKHNwZWNpZmllZCB1c2luZyBhIGNoYWluIG9mIGFuZCBvcGVyYXRvcnMpIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlIGFuZCBwcm9qZWN0cyB0aGUgdmFsdWVzLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgdGhhdCB3aWxsIGJlIGludm9rZWQgd2l0aCBhdmFpbGFibGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZXMsIGluIHRoZSBzYW1lIG9yZGVyIG9mIHRoZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4uXG4gICAqICBAcmV0dXJuIHtQbGFufSBQbGFuIHRoYXQgcHJvZHVjZXMgdGhlIHByb2plY3RlZCB2YWx1ZXMsIHRvIGJlIGZlZCAod2l0aCBvdGhlciBwbGFucykgdG8gdGhlIHdoZW4gb3BlcmF0b3IuXG4gICAqL1xuICBQYXR0ZXJuLnByb3RvdHlwZS50aGVuRG8gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBsYW4odGhpcywgc2VsZWN0b3IpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFBsYW4oZXhwcmVzc2lvbiwgc2VsZWN0b3IpIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9uRXJyb3IobykgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9OyB9XG4gIGZ1bmN0aW9uIGhhbmRsZU9uTmV4dChzZWxmLCBvYnNlcnZlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk5leHQgKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHNlbGYuc2VsZWN0b3IpLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gb2JzZXJ2ZXIub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBQbGFuLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChleHRlcm5hbFN1YnNjcmlwdGlvbnMsIG9ic2VydmVyLCBkZWFjdGl2YXRlKSB7XG4gICAgdmFyIGpvaW5PYnNlcnZlcnMgPSBbXSwgZXJySGFuZGxlciA9IGhhbmRsZU9uRXJyb3Iob2JzZXJ2ZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmV4cHJlc3Npb24ucGF0dGVybnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGpvaW5PYnNlcnZlcnMucHVzaChwbGFuQ3JlYXRlT2JzZXJ2ZXIoZXh0ZXJuYWxTdWJzY3JpcHRpb25zLCB0aGlzLmV4cHJlc3Npb24ucGF0dGVybnNbaV0sIGVyckhhbmRsZXIpKTtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZVBsYW4gPSBuZXcgQWN0aXZlUGxhbihqb2luT2JzZXJ2ZXJzLCBoYW5kbGVPbk5leHQodGhpcywgb2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGpvaW5PYnNlcnZlcnMubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIGpvaW5PYnNlcnZlcnNbal0ucmVtb3ZlQWN0aXZlUGxhbihhY3RpdmVQbGFuKTtcbiAgICAgIH1cbiAgICAgIGRlYWN0aXZhdGUoYWN0aXZlUGxhbik7XG4gICAgfSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gam9pbk9ic2VydmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgam9pbk9ic2VydmVyc1tpXS5hZGRBY3RpdmVQbGFuKGFjdGl2ZVBsYW4pO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlUGxhbjtcbiAgfTtcblxuICBmdW5jdGlvbiBwbGFuQ3JlYXRlT2JzZXJ2ZXIoZXh0ZXJuYWxTdWJzY3JpcHRpb25zLCBvYnNlcnZhYmxlLCBvbkVycm9yKSB7XG4gICAgdmFyIGVudHJ5ID0gZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmdldChvYnNlcnZhYmxlKTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSm9pbk9ic2VydmVyKG9ic2VydmFibGUsIG9uRXJyb3IpO1xuICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLnNldChvYnNlcnZhYmxlLCBvYnNlcnZlcik7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFjdGl2ZVBsYW4oam9pbk9ic2VydmVyQXJyYXksIG9uTmV4dCwgb25Db21wbGV0ZWQpIHtcbiAgICB0aGlzLmpvaW5PYnNlcnZlckFycmF5ID0gam9pbk9ic2VydmVyQXJyYXk7XG4gICAgdGhpcy5vbk5leHQgPSBvbk5leHQ7XG4gICAgdGhpcy5vbkNvbXBsZXRlZCA9IG9uQ29tcGxldGVkO1xuICAgIHRoaXMuam9pbk9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGpvaW5PYnNlcnZlciA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV07XG4gICAgICB0aGlzLmpvaW5PYnNlcnZlcnMuc2V0KGpvaW5PYnNlcnZlciwgam9pbk9ic2VydmVyKTtcbiAgICB9XG4gIH1cblxuICBBY3RpdmVQbGFuLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuam9pbk9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYucXVldWUuc2hpZnQoKTsgfSk7XG4gIH07XG5cbiAgQWN0aXZlUGxhbi5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksIGxlbiwgaGFzVmFsdWVzID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmpvaW5PYnNlcnZlckFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXS5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaGFzVmFsdWVzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzVmFsdWVzKSB7XG4gICAgICB2YXIgZmlyc3RWYWx1ZXMgPSBbXSxcbiAgICAgICAgICBpc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaXJzdFZhbHVlcy5wdXNoKHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV0ucXVldWVbMF0pO1xuICAgICAgICB0aGlzLmpvaW5PYnNlcnZlckFycmF5W2ldLnF1ZXVlWzBdLmtpbmQgPT09ICdDJyAmJiAoaXNDb21wbGV0ZWQgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbXBsZXRlZCkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaXJzdFZhbHVlcy5sZW5ndGg7IGkgPCBmaXJzdFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGZpcnN0VmFsdWVzW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTmV4dC5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgSm9pbk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhKb2luT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBKb2luT2JzZXJ2ZXIoc291cmNlLCBvbkVycm9yKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMgPSBbXTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgSm9pbk9ic2VydmVyUHJvdG90eXBlID0gSm9pbk9ic2VydmVyLnByb3RvdHlwZTtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5raW5kID09PSAnRScpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKG5vdGlmaWNhdGlvbi5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG5vdGlmaWNhdGlvbik7XG4gICAgICAgIHZhciBhY3RpdmVQbGFucyA9IHRoaXMuYWN0aXZlUGxhbnMuc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhY3RpdmVQbGFucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGFjdGl2ZVBsYW5zW2ldLm1hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmVycm9yID0gbm9vcDtcbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuY29tcGxldGVkID0gbm9vcDtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5hZGRBY3RpdmVQbGFuID0gZnVuY3Rpb24gKGFjdGl2ZVBsYW4pIHtcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMucHVzaChhY3RpdmVQbGFuKTtcbiAgICB9O1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2UubWF0ZXJpYWxpemUoKS5zdWJzY3JpYmUodGhpcykpO1xuICAgIH07XG5cbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUucmVtb3ZlQWN0aXZlUGxhbiA9IGZ1bmN0aW9uIChhY3RpdmVQbGFuKSB7XG4gICAgICB0aGlzLmFjdGl2ZVBsYW5zLnNwbGljZSh0aGlzLmFjdGl2ZVBsYW5zLmluZGV4T2YoYWN0aXZlUGxhbiksIDEpO1xuICAgICAgdGhpcy5hY3RpdmVQbGFucy5sZW5ndGggPT09IDAgJiYgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBKb2luT2JzZXJ2ZXI7XG4gIH0gKEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyB3aGVuIGJvdGggb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUuXG4gICAqXG4gICAqICBAcGFyYW0gcmlnaHQgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHNlcXVlbmNlLlxuICAgKiAgQHJldHVybiB7UGF0dGVybn0gUGF0dGVybiBvYmplY3QgdGhhdCBtYXRjaGVzIHdoZW4gYm90aCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXZlIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5hbmQgPSBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IFBhdHRlcm4oW3RoaXMsIHJpZ2h0XSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBNYXRjaGVzIHdoZW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgaGFzIGFuIGF2YWlsYWJsZSB2YWx1ZSBhbmQgcHJvamVjdHMgdGhlIHZhbHVlLlxuICAgKlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgdGhhdCB3aWxsIGJlIGludm9rZWQgZm9yIHZhbHVlcyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiAgQHJldHVybnMge1BsYW59IFBsYW4gdGhhdCBwcm9kdWNlcyB0aGUgcHJvamVjdGVkIHZhbHVlcywgdG8gYmUgZmVkICh3aXRoIG90aGVyIHBsYW5zKSB0byB0aGUgd2hlbiBvcGVyYXRvci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50aGVuRG8gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBhdHRlcm4oW3RoaXNdKS50aGVuRG8oc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgSm9pbnMgdG9nZXRoZXIgdGhlIHJlc3VsdHMgZnJvbSBzZXZlcmFsIHBhdHRlcm5zLlxuICAgKlxuICAgKiAgQHBhcmFtIHBsYW5zIEEgc2VyaWVzIG9mIHBsYW5zIChzcGVjaWZpZWQgYXMgYW4gQXJyYXkgb2YgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzKSBjcmVhdGVkIGJ5IHVzZSBvZiB0aGUgVGhlbiBvcGVyYXRvciBvbiBwYXR0ZXJucy5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHJlc3VsdHMgZm9ybSBtYXRjaGluZyBzZXZlcmFsIHBhdHRlcm5zLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS53aGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbGFucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBwbGFucyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGxhbnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBwbGFuc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhY3RpdmVQbGFucyA9IFtdLFxuICAgICAgICAgIGV4dGVybmFsU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBvdXRPYnNlcnZlciA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAoeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGV4dGVybmFsU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYub25FcnJvcihlcnIpOyB9KTtcbiAgICAgICAgICBvLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHgpIHsgby5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBsYW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYWN0aXZlUGxhbnMucHVzaChwbGFuc1tpXS5hY3RpdmF0ZShleHRlcm5hbFN1YnNjcmlwdGlvbnMsIG91dE9ic2VydmVyLCBmdW5jdGlvbiAoYWN0aXZlUGxhbikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGFjdGl2ZVBsYW5zLmluZGV4T2YoYWN0aXZlUGxhbik7XG4gICAgICAgICAgICBhY3RpdmVQbGFucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGFjdGl2ZVBsYW5zLmxlbmd0aCA9PT0gMCAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlVGhyb3coZSkuc3Vic2NyaWJlKG8pO1xuICAgICAgfVxuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGV4dGVybmFsU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChqb2luT2JzZXJ2ZXIpIHtcbiAgICAgICAgam9pbk9ic2VydmVyLnN1YnNjcmliZSgpO1xuICAgICAgICBncm91cC5hZGQoam9pbk9ic2VydmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFRpbWVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lck9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGltZXJPYnNlcnZhYmxlKGR0LCBzKSB7XG4gICAgICB0aGlzLl9kdCA9IGR0O1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lck9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUobywgdGhpcy5fZHQsIHNjaGVkdWxlTWV0aG9kKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgbykge1xuICAgICAgby5vbk5leHQoMCk7XG4gICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRpbWVyT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIGZ1bmN0aW9uIF9vYnNlcnZhYmxlVGltZXIoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lck9ic2VydmFibGUoZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVUaW1lckRhdGVBbmRQZXJpb2QoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZCA9IGR1ZVRpbWUsIHAgPSBub3JtYWxpemVUaW1lKHBlcmlvZCk7XG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKDAsIGQsIGZ1bmN0aW9uIChjb3VudCwgc2VsZikge1xuICAgICAgICBpZiAocCA+IDApIHtcbiAgICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICAgIGQgPSBuZXcgRGF0ZShkLmdldFRpbWUoKSArIHApO1xuICAgICAgICAgIGQuZ2V0VGltZSgpIDw9IG5vdyAmJiAoZCA9IG5ldyBEYXRlKG5vdyArIHApKTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5vbk5leHQoY291bnQpO1xuICAgICAgICBzZWxmKGNvdW50ICsgMSwgbmV3IERhdGUoZCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlVGltZXJUaW1lU3BhbkFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBkdWVUaW1lID09PSBwZXJpb2QgP1xuICAgICAgbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVQZXJpb2RpYygwLCBwZXJpb2QsIGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChjb3VudCk7XG4gICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfSk7XG4gICAgICB9KSA6XG4gICAgICBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChuZXcgRGF0ZShzY2hlZHVsZXIubm93KCkgKyBkdWVUaW1lKSwgcGVyaW9kLCBzY2hlZHVsZXIpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZWFjaCBwZXJpb2QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICogIDIgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZCBQZXJpb2QgZm9yIHByb2R1Y2luZyB0aGUgdmFsdWVzIGluIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgUnguU2NoZWR1bGVyLnRpbWVvdXQgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGVhY2ggcGVyaW9kLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVpbnRlcnZhbCA9IE9ic2VydmFibGUuaW50ZXJ2YWwgPSBmdW5jdGlvbiAocGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW5BbmRQZXJpb2QocGVyaW9kLCBwZXJpb2QsIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgPyBzY2hlZHVsZXIgOiBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZHVlVGltZSBoYXMgZWxhcHNlZCBhbmQgdGhlbiBhZnRlciBlYWNoIHBlcmlvZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgKHNwZWNpZmllZCBhcyBhIERhdGUgb2JqZWN0KSBvciByZWxhdGl2ZSB0aW1lIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpIGF0IHdoaWNoIHRvIHByb2R1Y2UgdGhlIGZpcnN0IHZhbHVlLlxuICAgKiBAcGFyYW0ge01peGVkfSBbcGVyaW9kT3JTY2hlZHVsZXJdICBQZXJpb2QgdG8gcHJvZHVjZSBzdWJzZXF1ZW50IHZhbHVlcyAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSwgb3IgdGhlIHNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcmVzdWx0aW5nIHRpbWVyIGlzIG5vdCByZWN1cnJpbmcuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZHVlIHRpbWUgaGFzIGVsYXBzZWQgYW5kIHRoZW4gZWFjaCBwZXJpb2QuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZVRpbWVyID0gT2JzZXJ2YWJsZS50aW1lciA9IGZ1bmN0aW9uIChkdWVUaW1lLCBwZXJpb2RPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XG4gICAgdmFyIHBlcmlvZDtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICBpZiAocGVyaW9kT3JTY2hlZHVsZXIgIT0gbnVsbCAmJiB0eXBlb2YgcGVyaW9kT3JTY2hlZHVsZXIgPT09ICdudW1iZXInKSB7XG4gICAgICBwZXJpb2QgPSBwZXJpb2RPclNjaGVkdWxlcjtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZWR1bGVyKHBlcmlvZE9yU2NoZWR1bGVyKSkge1xuICAgICAgc2NoZWR1bGVyID0gcGVyaW9kT3JTY2hlZHVsZXI7XG4gICAgfVxuICAgIGlmICgoZHVlVGltZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGR1ZVRpbWUgPT09ICdudW1iZXInKSAmJiBwZXJpb2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlVGltZXIoZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgICB9XG4gICAgaWYgKGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlICYmIHBlcmlvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2RPclNjaGVkdWxlciwgc2NoZWR1bGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmFibGVUaW1lclRpbWVTcGFuQW5kUGVyaW9kKGR1ZVRpbWUsIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlRGVsYXlSZWxhdGl2ZShzb3VyY2UsIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgZXhjZXB0aW9uID0gbnVsbCxcbiAgICAgICAgcSA9IFtdLFxuICAgICAgICBydW5uaW5nID0gZmFsc2UsXG4gICAgICAgIHN1YnNjcmlwdGlvbjtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5tYXRlcmlhbGl6ZSgpLnRpbWVzdGFtcChzY2hlZHVsZXIpLnN1YnNjcmliZShmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHZhciBkLCBzaG91bGRSdW47XG4gICAgICAgIGlmIChub3RpZmljYXRpb24udmFsdWUua2luZCA9PT0gJ0UnKSB7XG4gICAgICAgICAgcSA9IFtdO1xuICAgICAgICAgIHEucHVzaChub3RpZmljYXRpb24pO1xuICAgICAgICAgIGV4Y2VwdGlvbiA9IG5vdGlmaWNhdGlvbi52YWx1ZS5lcnJvcjtcbiAgICAgICAgICBzaG91bGRSdW4gPSAhcnVubmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxLnB1c2goeyB2YWx1ZTogbm90aWZpY2F0aW9uLnZhbHVlLCB0aW1lc3RhbXA6IG5vdGlmaWNhdGlvbi50aW1lc3RhbXAgKyBkdWVUaW1lIH0pO1xuICAgICAgICAgIHNob3VsZFJ1biA9ICFhY3RpdmU7XG4gICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUnVuKSB7XG4gICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgby5vbkVycm9yKGV4Y2VwdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICAgIGNhbmNlbGFibGUuc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVGdXR1cmUobnVsbCwgZHVlVGltZSwgZnVuY3Rpb24gKF8sIHNlbGYpIHtcbiAgICAgICAgICAgICAgdmFyIGUsIHJlY3Vyc2VEdWVUaW1lLCByZXN1bHQsIHNob3VsZFJlY3Vyc2U7XG4gICAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA+IDAgJiYgcVswXS50aW1lc3RhbXAgLSBzY2hlZHVsZXIubm93KCkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcS5zaGlmdCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuYWNjZXB0KG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSB3aGlsZSAocmVzdWx0ICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgc2hvdWxkUmVjdXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZWN1cnNlRHVlVGltZSA9IDA7XG4gICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzaG91bGRSZWN1cnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWN1cnNlRHVlVGltZSA9IE1hdGgubWF4KDAsIHFbMF0udGltZXN0YW1wIC0gc2NoZWR1bGVyLm5vdygpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlID0gZXhjZXB0aW9uO1xuICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmKG51bGwsIHJlY3Vyc2VEdWVUaW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZURlbGF5QWJzb2x1dGUoc291cmNlLCBkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlRGVsYXlSZWxhdGl2ZShzb3VyY2UsIGR1ZVRpbWUgLSBzY2hlZHVsZXIubm93KCksIHNjaGVkdWxlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxheVdpdGhTZWxlY3Rvcihzb3VyY2UsIHN1YnNjcmlwdGlvbkRlbGF5LCBkZWxheUR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViRGVsYXksIHNlbGVjdG9yO1xuICAgIGlmIChpc0Z1bmN0aW9uKHN1YnNjcmlwdGlvbkRlbGF5KSkge1xuICAgICAgc2VsZWN0b3IgPSBzdWJzY3JpcHRpb25EZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViRGVsYXkgPSBzdWJzY3JpcHRpb25EZWxheTtcbiAgICAgIHNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkZWxheXMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLCBhdEVuZCA9IGZhbHNlLCBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuXG4gICAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdHJ5Q2F0Y2goc2VsZWN0b3IpKHgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKGRlbGF5LmUpOyB9XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgICAgZGVsYXlzLmFkZChkKTtcbiAgICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZShkZWxheS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICAgICAgICBkZWxheXMucmVtb3ZlKGQpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgby5vbk5leHQoeCk7XG4gICAgICAgICAgICAgICAgZGVsYXlzLnJlbW92ZShkKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgICAgIGF0RW5kICYmIGRlbGF5cy5sZW5ndGggPT09IDAgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN1YkRlbGF5KSB7XG4gICAgICAgIHN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShzdWJEZWxheS5zdWJzY3JpYmUoc3RhcnQsIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSwgc3RhcnQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgZGVsYXlzKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqICBUaW1lIHNoaWZ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBkdWVUaW1lLlxuICAgKiAgVGhlIHJlbGF0aXZlIHRpbWUgaW50ZXJ2YWxzIGJldHdlZW4gdGhlIHZhbHVlcyBhcmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSAoc3BlY2lmaWVkIGFzIGEgRGF0ZSBvYmplY3QpIG9yIHJlbGF0aXZlIHRpbWUgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykgYnkgd2hpY2ggdG8gc2hpZnQgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSBkZWxheSB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGltZS1zaGlmdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRlbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnbnVtYmVyJyB8fCBmaXJzdEFyZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHZhciBkdWVUaW1lID0gZmlyc3RBcmcsIHNjaGVkdWxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgICAgcmV0dXJuIGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgb2JzZXJ2YWJsZURlbGF5QWJzb2x1dGUodGhpcywgZHVlVGltZSwgc2NoZWR1bGVyKSA6XG4gICAgICAgIG9ic2VydmFibGVEZWxheVJlbGF0aXZlKHRoaXMsIGR1ZVRpbWUsIHNjaGVkdWxlcik7XG4gICAgfSBlbHNlIGlmIChPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShmaXJzdEFyZykgfHwgaXNGdW5jdGlvbihmaXJzdEFyZykpIHtcbiAgICAgIHJldHVybiBkZWxheVdpdGhTZWxlY3Rvcih0aGlzLCBmaXJzdEFyZywgYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgRGVib3VuY2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWJvdW5jZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VPYnNlcnZhYmxlKHNvdXJjZSwgZHQsIHMpIHtcbiAgICAgIGlzU2NoZWR1bGVyKHMpIHx8IChzID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2R0ID0gZHQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERlYm91bmNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgY2FuY2VsYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VPYnNlcnZlcihvLCB0aGlzLl9kdCwgdGhpcy5fcywgY2FuY2VsYWJsZSkpLFxuICAgICAgICBjYW5jZWxhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlYm91bmNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEZWJvdW5jZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWJvdW5jZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlT2JzZXJ2ZXIob2JzZXJ2ZXIsIGR1ZVRpbWUsIHNjaGVkdWxlciwgY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5fZCA9IGR1ZVRpbWU7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLl9jID0gY2FuY2VsYWJsZTtcbiAgICAgIHRoaXMuX3YgPSBudWxsO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lkID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRnV0dXJlKHMsIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5zZWxmLl9odiAmJiBzdGF0ZS5zZWxmLl9pZCA9PT0gc3RhdGUuY3VycmVudElkICYmIHN0YXRlLnNlbGYuX28ub25OZXh0KHN0YXRlLngpO1xuICAgICAgc3RhdGUuc2VsZi5faHYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBEZWJvdW5jZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX2h2ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3YgPSB4O1xuICAgICAgdmFyIGN1cnJlbnRJZCA9ICsrdGhpcy5faWQsIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX2Muc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUodGhpcywgdGhpcy5fZCwgZnVuY3Rpb24gKF8sIHNlbGYpIHtcbiAgICAgICAgc2VsZi5faHYgJiYgc2VsZi5faWQgPT09IGN1cnJlbnRJZCAmJiBzZWxmLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgc2VsZi5faHYgPSBmYWxzZTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgRGVib3VuY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fYy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faWQrKztcbiAgICB9O1xuXG4gICAgRGVib3VuY2VPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9odiAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl92KTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZCsrO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGVib3VuY2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VXaXRoU2VsZWN0b3Ioc291cmNlLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgdmFsdWUsIGhhc1ZhbHVlID0gZmFsc2UsIGNhbmNlbGFibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLCBpZCA9IDA7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgdGhyb3R0bGUgPSB0cnlDYXRjaChkdXJhdGlvblNlbGVjdG9yKSh4KTtcbiAgICAgICAgICBpZiAodGhyb3R0bGUgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IodGhyb3R0bGUuZSk7IH1cblxuICAgICAgICAgIGlzUHJvbWlzZSh0aHJvdHRsZSkgJiYgKHRocm90dGxlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHRocm90dGxlKSk7XG5cbiAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgdmFsdWUgPSB4O1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgdmFyIGN1cnJlbnRpZCA9IGlkLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgY2FuY2VsYWJsZS5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aHJvdHRsZS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlICYmIGlkID09PSBjdXJyZW50aWQgJiYgby5vbk5leHQodmFsdWUpO1xuICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlICYmIGlkID09PSBjdXJyZW50aWQgJiYgby5vbk5leHQodmFsdWUpO1xuICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjYW5jZWxhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FuY2VsYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgaGFzVmFsdWUgJiYgby5vbk5leHQodmFsdWUpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlkKys7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgb2JzZXJ2YWJsZVByb3RvLmRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0Z1bmN0aW9uIChhcmd1bWVudHNbMF0pKSB7XG4gICAgICByZXR1cm4gZGVib3VuY2VXaXRoU2VsZWN0b3IodGhpcywgYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gbmV3IERlYm91bmNlT2JzZXJ2YWJsZSh0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSB3aW5kb3dzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiB0aW1pbmcgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBMZW5ndGggb2YgZWFjaCB3aW5kb3cgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aW1lU2hpZnRPclNjaGVkdWxlcl0gIEludGVydmFsIGJldHdlZW4gY3JlYXRpb24gb2YgY29uc2VjdXRpdmUgd2luZG93cyAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSwgb3IgYW4gb3B0aW9uYWwgc2NoZWR1bGVyIHBhcmFtZXRlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWUgc2hpZnQgY29ycmVzcG9uZHMgdG8gdGhlIHRpbWVTcGFuIHBhcmFtZXRlciwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyBhZGphY2VudCB3aW5kb3dzLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gd2luZG93aW5nIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHdpbmRvd3MuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2luZG93V2l0aFRpbWUgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93VGltZSA9IGZ1bmN0aW9uICh0aW1lU3BhbiwgdGltZVNoaWZ0T3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLCB0aW1lU2hpZnQ7XG4gICAgdGltZVNoaWZ0T3JTY2hlZHVsZXIgPT0gbnVsbCAmJiAodGltZVNoaWZ0ID0gdGltZVNwYW4pO1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIGlmICh0eXBlb2YgdGltZVNoaWZ0T3JTY2hlZHVsZXIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aW1lU2hpZnQgPSB0aW1lU2hpZnRPclNjaGVkdWxlcjtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZWR1bGVyKHRpbWVTaGlmdE9yU2NoZWR1bGVyKSkge1xuICAgICAgdGltZVNoaWZ0ID0gdGltZVNwYW47XG4gICAgICBzY2hlZHVsZXIgPSB0aW1lU2hpZnRPclNjaGVkdWxlcjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGdyb3VwRGlzcG9zYWJsZSxcbiAgICAgICAgbmV4dFNoaWZ0ID0gdGltZVNoaWZ0LFxuICAgICAgICBuZXh0U3BhbiA9IHRpbWVTcGFuLFxuICAgICAgICBxID0gW10sXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSxcbiAgICAgICAgdGltZXJEID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgdG90YWxUaW1lID0gMDtcbiAgICAgICAgZ3JvdXBEaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUodGltZXJEKSxcbiAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cERpc3Bvc2FibGUpO1xuXG4gICAgICAgZnVuY3Rpb24gY3JlYXRlVGltZXIgKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICAgIGlzU3BhbiA9IGZhbHNlLFxuICAgICAgICAgIGlzU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgdGltZXJELnNldERpc3Bvc2FibGUobSk7XG4gICAgICAgIGlmIChuZXh0U3BhbiA9PT0gbmV4dFNoaWZ0KSB7XG4gICAgICAgICAgaXNTcGFuID0gdHJ1ZTtcbiAgICAgICAgICBpc1NoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3BhbiA8IG5leHRTaGlmdCkge1xuICAgICAgICAgICAgaXNTcGFuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1NoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VG90YWxUaW1lID0gaXNTcGFuID8gbmV4dFNwYW4gOiBuZXh0U2hpZnQsXG4gICAgICAgICAgdHMgPSBuZXdUb3RhbFRpbWUgLSB0b3RhbFRpbWU7XG4gICAgICAgIHRvdGFsVGltZSA9IG5ld1RvdGFsVGltZTtcbiAgICAgICAgaWYgKGlzU3Bhbikge1xuICAgICAgICAgIG5leHRTcGFuICs9IHRpbWVTaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGlmdCkge1xuICAgICAgICAgIG5leHRTaGlmdCArPSB0aW1lU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShudWxsLCB0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc1NoaWZ0KSB7XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICBxLnB1c2gocyk7XG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1NwYW4gJiYgcS5zaGlmdCgpLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgY3JlYXRlVGltZXIoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIHEucHVzaChuZXcgU3ViamVjdCgpKTtcbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocVswXSwgcmVmQ291bnREaXNwb3NhYmxlKSk7XG4gICAgICBjcmVhdGVUaW1lcigpO1xuICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IHFbaV0ub25OZXh0KHgpOyB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbkVycm9yKGUpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IHFbaV0ub25Db21wbGV0ZWQoKTsgfVxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuIHJlZkNvdW50RGlzcG9zYWJsZTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIHdpbmRvdyB0aGF0IGlzIGNvbXBsZXRlZCB3aGVuIGVpdGhlciBpdCdzIGZ1bGwgb3IgYSBnaXZlbiBhbW91bnQgb2YgdGltZSBoYXMgZWxhcHNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIE1heGltdW0gdGltZSBsZW5ndGggb2YgYSB3aW5kb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgYSB3aW5kb3cuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB3aW5kb3dpbmcgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoVGltZU9yQ291bnQgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93VGltZU9yQ291bnQgPSBmdW5jdGlvbiAodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgdGltZXJEID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgICBncm91cERpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSh0aW1lckQpLFxuICAgICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKSxcbiAgICAgICAgICBuID0gMCxcbiAgICAgICAgICB3aW5kb3dJZCA9IDAsXG4gICAgICAgICAgcyA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRpbWVyKGlkKSB7XG4gICAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRpbWVyRC5zZXREaXNwb3NhYmxlKG0pO1xuICAgICAgICBtLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKG51bGwsIHRpbWVTcGFuLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlkICE9PSB3aW5kb3dJZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBuID0gMDtcbiAgICAgICAgICB2YXIgbmV3SWQgPSArK3dpbmRvd0lkO1xuICAgICAgICAgIHMub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgICAgIGNyZWF0ZVRpbWVyKG5ld0lkKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgY3JlYXRlVGltZXIoMCk7XG5cbiAgICAgIGdyb3VwRGlzcG9zYWJsZS5hZGQoc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgbmV3SWQgPSAwLCBuZXdXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICBzLm9uTmV4dCh4KTtcbiAgICAgICAgICBpZiAoKytuID09PSBjb3VudCkge1xuICAgICAgICAgICAgbmV3V2luZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgbmV3SWQgPSArK3dpbmRvd0lkO1xuICAgICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdXaW5kb3cgJiYgY3JlYXRlVGltZXIobmV3SWQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHMub25FcnJvcihlKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuIHJlZkNvdW50RGlzcG9zYWJsZTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoeCkgeyByZXR1cm4geC50b0FycmF5KCk7IH1cblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gemVybyBvciBtb3JlIGJ1ZmZlcnMgd2hpY2ggYXJlIHByb2R1Y2VkIGJhc2VkIG9uIHRpbWluZyBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIExlbmd0aCBvZiBlYWNoIGJ1ZmZlciAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RpbWVTaGlmdE9yU2NoZWR1bGVyXSAgSW50ZXJ2YWwgYmV0d2VlbiBjcmVhdGlvbiBvZiBjb25zZWN1dGl2ZSBidWZmZXJzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciBhbiBvcHRpb25hbCBzY2hlZHVsZXIgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZSBzaGlmdCBjb3JyZXNwb25kcyB0byB0aGUgdGltZVNwYW4gcGFyYW1ldGVyLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIGFkamFjZW50IGJ1ZmZlcnMuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biBidWZmZXIgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgYnVmZmVycy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5idWZmZXJXaXRoVGltZSA9IG9ic2VydmFibGVQcm90by5idWZmZXJUaW1lID0gZnVuY3Rpb24gKHRpbWVTcGFuLCB0aW1lU2hpZnRPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIHRoaXMud2luZG93V2l0aFRpbWUodGltZVNwYW4sIHRpbWVTaGlmdE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpLmZsYXRNYXAodG9BcnJheSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9BcnJheSh4KSB7IHJldHVybiB4LnRvQXJyYXkoKTsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIGJ1ZmZlciB0aGF0IGlzIGNvbXBsZXRlZCB3aGVuIGVpdGhlciBpdCdzIGZ1bGwgb3IgYSBnaXZlbiBhbW91bnQgb2YgdGltZSBoYXMgZWxhcHNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIE1heGltdW0gdGltZSBsZW5ndGggb2YgYSBidWZmZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgYSBidWZmZXIuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biBidWZmZXJpbiB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhUaW1lT3JDb3VudCA9IG9ic2VydmFibGVQcm90by5idWZmZXJUaW1lT3JDb3VudCA9IGZ1bmN0aW9uICh0aW1lU3BhbiwgY291bnQsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiB0aGlzLndpbmRvd1dpdGhUaW1lT3JDb3VudCh0aW1lU3BhbiwgY291bnQsIHNjaGVkdWxlcikuZmxhdE1hcCh0b0FycmF5KTtcbiAgfTtcblxuICB2YXIgVGltZUludGVydmFsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZUludGVydmFsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlKHNvdXJjZSwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRpbWVJbnRlcnZhbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGltZUludGVydmFsT2JzZXJ2ZXIobywgdGhpcy5fcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGltZUludGVydmFsT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUaW1lSW50ZXJ2YWxPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZUludGVydmFsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBUaW1lSW50ZXJ2YWxPYnNlcnZlcihvLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fbCA9IHMubm93KCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lSW50ZXJ2YWxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKSwgc3BhbiA9IG5vdyAtIHRoaXMuX2w7XG4gICAgICB0aGlzLl9sID0gbm93O1xuICAgICAgdGhpcy5fby5vbk5leHQoeyB2YWx1ZTogeCwgaW50ZXJ2YWw6IHNwYW4gfSk7XG4gICAgfTtcbiAgICBUaW1lSW50ZXJ2YWxPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGltZUludGVydmFsT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFRpbWVJbnRlcnZhbE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJlY29yZHMgdGhlIHRpbWUgaW50ZXJ2YWwgYmV0d2VlbiBjb25zZWN1dGl2ZSB2YWx1ZXMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGltZUludGVydmFsKCk7XG4gICAqICAyIC0gcmVzID0gc291cmNlLnRpbWVJbnRlcnZhbChSeC5TY2hlZHVsZXIudGltZW91dCk7XG4gICAqXG4gICAqIEBwYXJhbSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHVzZWQgdG8gY29tcHV0ZSB0aW1lIGludGVydmFscy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGltZSBpbnRlcnZhbCBpbmZvcm1hdGlvbiBvbiB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGltZUludGVydmFsID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBUaW1lc3RhbXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lc3RhbXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRpbWVzdGFtcE9ic2VydmFibGUoc291cmNlLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZXN0YW1wT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lc3RhbXBPYnNlcnZlcihvLCB0aGlzLl9zKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUaW1lc3RhbXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRpbWVzdGFtcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUaW1lc3RhbXBPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBPYnNlcnZlcihvLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZXN0YW1wT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fby5vbk5leHQoeyB2YWx1ZTogeCwgdGltZXN0YW1wOiB0aGlzLl9zLm5vdygpIH0pO1xuICAgIH07XG5cbiAgICBUaW1lc3RhbXBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUaW1lc3RhbXBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGltZXN0YW1wT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmVjb3JkcyB0aGUgdGltZXN0YW1wIGZvciBlYWNoIHZhbHVlIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLnRpbWVzdGFtcCgpOyAvLyBwcm9kdWNlcyB7IHZhbHVlOiB4LCB0aW1lc3RhbXA6IHRzIH1cbiAgICogIDIgLSByZXMgPSBzb3VyY2UudGltZXN0YW1wKFJ4LlNjaGVkdWxlci5kZWZhdWx0KTtcbiAgICpcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdXNlZCB0byBjb21wdXRlIHRpbWVzdGFtcHMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRpbWVzdGFtcCBpbmZvcm1hdGlvbiBvbiB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGltZXN0YW1wID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTYW1wbGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNhbXBsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2FtcGxlT2JzZXJ2YWJsZShzb3VyY2UsIHNhbXBsZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fc2FtcGxlciA9IHNhbXBsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTYW1wbGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgYXRFbmQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgICBzb3VyY2VTdWJzY3JpcHRpb246IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpXG4gICAgICB9O1xuXG4gICAgICBzdGF0ZS5zb3VyY2VTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNhbXBsZVNvdXJjZU9ic2VydmVyKHN0YXRlKSkpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICBzdGF0ZS5zb3VyY2VTdWJzY3JpcHRpb24sXG4gICAgICAgIHRoaXMuX3NhbXBsZXIuc3Vic2NyaWJlKG5ldyBTYW1wbGVyT2JzZXJ2ZXIoc3RhdGUpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNhbXBsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2FtcGxlck9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNhbXBsZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTYW1wbGVyT2JzZXJ2ZXIocykge1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTYW1wbGVyT2JzZXJ2ZXIucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3MuaGFzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zLm8ub25OZXh0KHRoaXMuX3MudmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcy5hdEVuZCAmJiB0aGlzLl9zLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgU2FtcGxlck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oYW5kbGVNZXNzYWdlKCk7IH07XG4gICAgU2FtcGxlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Mub25FcnJvcihlKTsgfTtcbiAgICBTYW1wbGVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGFuZGxlTWVzc2FnZSgpOyB9O1xuXG4gICAgcmV0dXJuIFNhbXBsZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIFNhbXBsZVNvdXJjZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNhbXBsZVNvdXJjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNhbXBsZVNvdXJjZU9ic2VydmVyKHMpIHtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2FtcGxlU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICB0aGlzLl9zLnZhbHVlID0geDtcbiAgICB9O1xuICAgIFNhbXBsZVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuICAgIFNhbXBsZVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zLmF0RW5kID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Muc291cmNlU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNhbXBsZVNvdXJjZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFNhbXBsZXMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYXQgZWFjaCBpbnRlcnZhbC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKHNhbXBsZU9ic2VydmFibGUpOyAvLyBTYW1wbGVyIHRpY2sgc2VxdWVuY2VcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKDUwMDApOyAvLyA1IHNlY29uZHNcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKDUwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTsgLy8gNSBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGludGVydmFsT3JTYW1wbGVyIEludGVydmFsIGF0IHdoaWNoIHRvIHNhbXBsZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSBvciBTYW1wbGVyIE9ic2VydmFibGUuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgc2FtcGxpbmcgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gU2FtcGxlZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNhbXBsZSA9IGZ1bmN0aW9uIChpbnRlcnZhbE9yU2FtcGxlciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnRlcnZhbE9yU2FtcGxlciA9PT0gJ251bWJlcicgP1xuICAgICAgbmV3IFNhbXBsZU9ic2VydmFibGUodGhpcywgb2JzZXJ2YWJsZWludGVydmFsKGludGVydmFsT3JTYW1wbGVyLCBzY2hlZHVsZXIpKSA6XG4gICAgICBuZXcgU2FtcGxlT2JzZXJ2YWJsZSh0aGlzLCBpbnRlcnZhbE9yU2FtcGxlcik7XG4gIH07XG5cbiAgdmFyIFRpbWVvdXRFcnJvciA9IFJ4LlRpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCc7XG4gICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgVGltZW91dEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiB0aW1lb3V0V2l0aFNlbGVjdG9yKHNvdXJjZSwgZmlyc3RUaW1lb3V0LCB0aW1lb3V0RHVyYXRpb25TZWxlY3Rvciwgb3RoZXIpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmaXJzdFRpbWVvdXQpKSB7XG4gICAgICBvdGhlciA9IHRpbWVvdXREdXJhdGlvblNlbGVjdG9yO1xuICAgICAgdGltZW91dER1cmF0aW9uU2VsZWN0b3IgPSBmaXJzdFRpbWVvdXQ7XG4gICAgICBmaXJzdFRpbWVvdXQgPSBvYnNlcnZhYmxlTmV2ZXIoKTtcbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob3RoZXIpIHx8IChvdGhlciA9IG9ic2VydmFibGVUaHJvdyhuZXcgVGltZW91dEVycm9yKCkpKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICB0aW1lciA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIG9yaWdpbmFsID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG9yaWdpbmFsKTtcblxuICAgICAgdmFyIGlkID0gMCwgc3dpdGNoZWQgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gc2V0VGltZXIodGltZW91dCkge1xuICAgICAgICB2YXIgbXlJZCA9IGlkLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdGltZXJXaW5zKCkge1xuICAgICAgICAgIHN3aXRjaGVkID0gKG15SWQgPT09IGlkKTtcbiAgICAgICAgICByZXR1cm4gc3dpdGNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lci5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgICBkLnNldERpc3Bvc2FibGUodGltZW91dC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVyV2lucygpICYmIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShvKSk7XG4gICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGltZXJXaW5zKCkgJiYgby5vbkVycm9yKGUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGltZXJXaW5zKCkgJiYgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG8pKTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgc2V0VGltZXIoZmlyc3RUaW1lb3V0KTtcblxuICAgICAgZnVuY3Rpb24gb1dpbnMoKSB7XG4gICAgICAgIHZhciByZXMgPSAhc3dpdGNoZWQ7XG4gICAgICAgIGlmIChyZXMpIHsgaWQrKzsgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKG9XaW5zKCkpIHtcbiAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICB2YXIgdGltZW91dCA9IHRyeUNhdGNoKHRpbWVvdXREdXJhdGlvblNlbGVjdG9yKSh4KTtcbiAgICAgICAgICBpZiAodGltZW91dCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcih0aW1lb3V0LmUpOyB9XG4gICAgICAgICAgc2V0VGltZXIoaXNQcm9taXNlKHRpbWVvdXQpID8gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHRpbWVvdXQpIDogdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIG9XaW5zKCkgJiYgby5vbkVycm9yKGUpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBvV2lucygpICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIHRpbWVyKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZW91dChzb3VyY2UsIGR1ZVRpbWUsIG90aGVyLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoaXNTY2hlZHVsZXIob3RoZXIpKSB7XG4gICAgICBzY2hlZHVsZXIgPSBvdGhlcjtcbiAgICAgIG90aGVyID0gb2JzZXJ2YWJsZVRocm93KG5ldyBUaW1lb3V0RXJyb3IoKSk7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEVycm9yKSB7IG90aGVyID0gb2JzZXJ2YWJsZVRocm93KG90aGVyKTsgfVxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG90aGVyKSB8fCAob3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cobmV3IFRpbWVvdXRFcnJvcigpKSk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgaWQgPSAwLFxuICAgICAgICBvcmlnaW5hbCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBzd2l0Y2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lciA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG9yaWdpbmFsKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVGltZXIoKSB7XG4gICAgICAgIHZhciBteUlkID0gaWQ7XG4gICAgICAgIHRpbWVyLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKG51bGwsIGR1ZVRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzd2l0Y2hlZCA9IGlkID09PSBteUlkO1xuICAgICAgICAgIGlmIChzd2l0Y2hlZCkge1xuICAgICAgICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShvKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZVRpbWVyKCk7XG5cbiAgICAgIG9yaWdpbmFsLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXN3aXRjaGVkKSB7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICBjcmVhdGVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIXN3aXRjaGVkKSB7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlZCkge1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCB0aW1lcik7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIG9ic2VydmFibGVQcm90by50aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZmlyc3RBcmcgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBmaXJzdEFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aW1lb3V0KHRoaXMsIGZpcnN0QXJnLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgfSBlbHNlIGlmIChPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShmaXJzdEFyZykgfHwgaXNGdW5jdGlvbihmaXJzdEFyZykpIHtcbiAgICAgIHJldHVybiB0aW1lb3V0V2l0aFNlbGVjdG9yKHRoaXMsIGZpcnN0QXJnLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZShzdGF0ZSwgY25kRm4sIGl0ckZuLCByZXNGbiwgdGltZUZuLCBzKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fY25kRm4gPSBjbmRGbjtcbiAgICAgIHRoaXMuX2l0ckZuID0gaXRyRm47XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fdGltZUZuID0gdGltZUZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlY3Vyc2l2ZShzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgc3RhdGUuaGFzUmVzdWx0ICYmIHN0YXRlLm8ub25OZXh0KHN0YXRlLnJlc3VsdCk7XG5cbiAgICAgIGlmIChzdGF0ZS5maXJzdCkge1xuICAgICAgICBzdGF0ZS5maXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubmV3U3RhdGUgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9pdHJGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUubmV3U3RhdGUgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUubmV3U3RhdGUuZSk7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2NuZEZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuaGFzUmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLmhhc1Jlc3VsdC5lKTsgfVxuICAgICAgaWYgKHN0YXRlLmhhc1Jlc3VsdCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9yZXNGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUucmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLnJlc3VsdC5lKTsgfVxuICAgICAgICB2YXIgdGltZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3RpbWVGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAodGltZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcih0aW1lLmUpOyB9XG4gICAgICAgIHJlY3Vyc2Uoc3RhdGUsIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICAgICAgbmV3U3RhdGU6IHRoaXMuX3N0YXRlLFxuICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgaGFzUmVzdWx0OiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9zLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKHN0YXRlLCBuZXcgRGF0ZSh0aGlzLl9zLm5vdygpKSwgc2NoZWR1bGVSZWN1cnNpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIEdlbmVyYXRlQWJzb2x1dGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgaXRlcmF0aW5nIGEgc3RhdGUgZnJvbSBhbiBpbml0aWFsIHN0YXRlIHVudGlsIHRoZSBjb25kaXRpb24gZmFpbHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICByZXMgPSBzb3VyY2UuZ2VuZXJhdGVXaXRoQWJzb2x1dGVUaW1lKDAsXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHJldHVybiB0cnVlOyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gbmV3IERhdGUoKTsgfVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQ29uZGl0aW9uIHRvIHRlcm1pbmF0ZSBnZW5lcmF0aW9uICh1cG9uIHJldHVybmluZyBmYWxzZSkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGUgSXRlcmF0aW9uIHN0ZXAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZVNlbGVjdG9yIFRpbWUgc2VsZWN0b3IgZnVuY3Rpb24gdG8gY29udHJvbCB0aGUgc3BlZWQgb2YgdmFsdWVzIGJlaW5nIHByb2R1Y2VkIGVhY2ggaXRlcmF0aW9uLCByZXR1cm5pbmcgRGF0ZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3AuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIGdlbmVyYXRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIE9ic2VydmFibGUuZ2VuZXJhdGVXaXRoQWJzb2x1dGVUaW1lID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciwgdGltZVNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciwgdGltZVNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUoc3RhdGUsIGNuZEZuLCBpdHJGbiwgcmVzRm4sIHRpbWVGbiwgcykge1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX2NuZEZuID0gY25kRm47XG4gICAgICB0aGlzLl9pdHJGbiA9IGl0ckZuO1xuICAgICAgdGhpcy5fcmVzRm4gPSByZXNGbjtcbiAgICAgIHRoaXMuX3RpbWVGbiA9IHRpbWVGbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCAmJiBzdGF0ZS5vLm9uTmV4dChzdGF0ZS5yZXN1bHQpO1xuXG4gICAgICBpZiAoc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgc3RhdGUuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm5ld1N0YXRlID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5faXRyRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLm5ld1N0YXRlID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLm5ld1N0YXRlLmUpOyB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2NuZEZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuaGFzUmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLmhhc1Jlc3VsdC5lKTsgfVxuICAgICAgaWYgKHN0YXRlLmhhc1Jlc3VsdCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9yZXNGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUucmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLnJlc3VsdC5lKTsgfVxuICAgICAgICB2YXIgdGltZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3RpbWVGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAodGltZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcih0aW1lLmUpOyB9XG4gICAgICAgIHJlY3Vyc2Uoc3RhdGUsIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICAgICAgbmV3U3RhdGU6IHRoaXMuX3N0YXRlLFxuICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgaGFzUmVzdWx0OiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9zLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKHN0YXRlLCAwLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgaXRlcmF0aW5nIGEgc3RhdGUgZnJvbSBhbiBpbml0aWFsIHN0YXRlIHVudGlsIHRoZSBjb25kaXRpb24gZmFpbHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICByZXMgPSBzb3VyY2UuZ2VuZXJhdGVXaXRoUmVsYXRpdmVUaW1lKDAsXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHJldHVybiB0cnVlOyB9LFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gNTAwOyB9XG4gICAqICApO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsU3RhdGUgSW5pdGlhbCBzdGF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIENvbmRpdGlvbiB0byB0ZXJtaW5hdGUgZ2VuZXJhdGlvbiAodXBvbiByZXR1cm5pbmcgZmFsc2UpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiBmb3IgcmVzdWx0cyBwcm9kdWNlZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVTZWxlY3RvciBUaW1lIHNlbGVjdG9yIGZ1bmN0aW9uIHRvIGNvbnRyb2wgdGhlIHNwZWVkIG9mIHZhbHVlcyBiZWluZyBwcm9kdWNlZCBlYWNoIGl0ZXJhdGlvbiwgcmV0dXJuaW5nIGludGVnZXIgdmFsdWVzIGRlbm90aW5nIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5nZW5lcmF0ZVdpdGhSZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIERlbGF5U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERlbGF5U3Vic2NyaXB0aW9uLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlbGF5U3Vic2NyaXB0aW9uKHNvdXJjZSwgZHQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZHQgPSBkdDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVsYXlTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuXG4gICAgICBkLnNldERpc3Bvc2FibGUodGhpcy5fcy5zY2hlZHVsZUZ1dHVyZShbdGhpcy5zb3VyY2UsIG8sIGRdLCB0aGlzLl9kdCwgc2NoZWR1bGVNZXRob2QpKTtcblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHN0YXRlKSB7XG4gICAgICB2YXIgc291cmNlID0gc3RhdGVbMF0sIG8gPSBzdGF0ZVsxXSwgZCA9IHN0YXRlWzJdO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobykpO1xuICAgIH1cblxuICAgIHJldHVybiBEZWxheVN1YnNjcmlwdGlvbjtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgVGltZSBzaGlmdHMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgZGVsYXlpbmcgdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgdGltZSBkdXJhdGlvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDEgLSByZXMgPSBzb3VyY2UuZGVsYXlTdWJzY3JpcHRpb24oNTAwMCk7IC8vIDVzXG4gICAqICAyIC0gcmVzID0gc291cmNlLmRlbGF5U3Vic2NyaXB0aW9uKDUwMDAsIFJ4LlNjaGVkdWxlci5kZWZhdWx0KTsgLy8gNSBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIG9yIGFic29sdXRlIHRpbWUgc2hpZnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSBzdWJzY3JpcHRpb24gZGVsYXkgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGltZS1zaGlmdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRlbGF5U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRGVsYXlTdWJzY3JpcHRpb24odGhpcywgZHVlVGltZSwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgZCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU2tpcExhc3RXaXRoVGltZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHAuX3M7XG4gICAgICB0aGlzLl9kID0gcC5fZDtcbiAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHRoaXMuX3EucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB4IH0pO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCAmJiBub3cgLSB0aGlzLl9xWzBdLmludGVydmFsID49IHRoaXMuX2QpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fcS5zaGlmdCgpLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcExhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHdoaWxlICh0aGlzLl9xLmxlbmd0aCA+IDAgJiYgbm93IC0gdGhpcy5fcVswXS5pbnRlcnZhbCA+PSB0aGlzLl9kKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3Euc2hpZnQoKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgU2tpcHMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBpbml0aWFsIGR1cmF0aW9uIHdpbmRvdy5cbiAgICogIEFzIG1vcmUgZWxlbWVudHMgYXJlIHJlY2VpdmVkLCBlbGVtZW50cyBvbGRlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gYXJlIHRha2VuIGZyb20gdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGVcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHNraXBwaW5nIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0XG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHNraXBwZWQgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcExhc3RXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSh0aGlzLCBkdXJhdGlvbiwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgZCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMuX2QsIHRoaXMuX3MpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyKG8sIGQsIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHRoaXMuX3EucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB4IH0pO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCAmJiBub3cgLSB0aGlzLl9xWzBdLmludGVydmFsID49IHRoaXMuX2QpIHtcbiAgICAgICAgdGhpcy5fcS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub3cgPSB0aGlzLl9zLm5vdygpO1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMuX3Euc2hpZnQoKTtcbiAgICAgICAgaWYgKG5vdyAtIG5leHQuaW50ZXJ2YWwgPD0gdGhpcy5fZCkgeyB0aGlzLl9vLm9uTmV4dChuZXh0LnZhbHVlKTsgfVxuICAgICAgfVxuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgZWxlbWVudHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXJzIHRvIHJ1biB0aW1lcnMgYW5kIHRvIGRyYWluIHRoZSBjb2xsZWN0ZWQgZWxlbWVudHMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VMYXN0V2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUodGhpcywgZHVyYXRpb24sIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGFrZW4gZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3RCdWZmZXJXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgcSA9IFtdO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcbiAgICAgICAgcS5wdXNoKHsgaW50ZXJ2YWw6IG5vdywgdmFsdWU6IHggfSk7XG4gICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDAgJiYgbm93IC0gcVswXS5pbnRlcnZhbCA+PSBkdXJhdGlvbikge1xuICAgICAgICAgIHEuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCksIHJlcyA9IFtdO1xuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBxLnNoaWZ0KCk7XG4gICAgICAgICAgbm93IC0gbmV4dC5pbnRlcnZhbCA8PSBkdXJhdGlvbiAmJiByZXMucHVzaChuZXh0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvLm9uTmV4dChyZXMpO1xuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlV2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBkLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBvKSB7XG4gICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgfVxuXG4gICAgVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUobywgdGhpcy5fZCwgc2NoZWR1bGVNZXRob2QpLFxuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBUYWtlcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLnRha2VXaXRoVGltZSg1MDAwLCAgW29wdGlvbmFsIHNjaGVkdWxlcl0pO1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxuICAgKiAgQXMgbW9yZSBlbGVtZW50cyBhcmUgcmVjZWl2ZWQsIGVsZW1lbnRzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBhcmUgdGFrZW4gZnJvbSB0aGUgcXVldWUgYW5kIHByb2R1Y2VkIG9uIHRoZVxuICAgKiAgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkIHdpdGggZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3IgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZVdpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFRha2VXaXRoVGltZU9ic2VydmFibGUodGhpcywgZHVyYXRpb24sIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFNraXBXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBXaXRoVGltZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZShzb3VyY2UsIGQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgIHNlbGYuX29wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIFNraXBXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLl9zLnNjaGVkdWxlRnV0dXJlKHRoaXMsIHRoaXMuX2QsIHNjaGVkdWxlTWV0aG9kKSxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwV2l0aFRpbWVPYnNlcnZlcihvLCB0aGlzKSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBXaXRoVGltZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwV2l0aFRpbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNraXBXaXRoVGltZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3AuX29wZW4gJiYgdGhpcy5fby5vbk5leHQoeCk7IH07XG4gICAgU2tpcFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFNraXBXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBTa2lwV2l0aFRpbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBTa2lwcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgU3BlY2lmeWluZyBhIHplcm8gdmFsdWUgZm9yIGR1cmF0aW9uIGRvZXNuJ3QgZ3VhcmFudGVlIG5vIGVsZW1lbnRzIHdpbGwgYmUgZHJvcHBlZCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiAgVGhpcyBpcyBhIHNpZGUtZWZmZWN0IG9mIHRoZSBhc3luY2hyb255IGludHJvZHVjZWQgYnkgdGhlIHNjaGVkdWxlciwgd2hlcmUgdGhlIGFjdGlvbiB0aGF0IGNhdXNlcyBjYWxsYmFja3MgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlIHRvIGJlIGZvcndhcmRlZFxuICAgKiAgbWF5IG5vdCBleGVjdXRlIGltbWVkaWF0ZWx5LCBkZXNwaXRlIHRoZSB6ZXJvIGR1ZSB0aW1lLlxuICAgKlxuICAgKiAgRXJyb3JzIHByb2R1Y2VkIGJ5IHRoZSBzb3VyY2Ugc2VxdWVuY2UgYXJlIGFsd2F5cyBmb3J3YXJkZWQgdG8gdGhlIHJlc3VsdCBzZXF1ZW5jZSwgZXZlbiBpZiB0aGUgZXJyb3Igb2NjdXJzIGJlZm9yZSB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3Igc2tpcHBpbmcgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgc2tpcHBlZCBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlKHRoaXMsIGR1cmF0aW9uLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBzdGFydFRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zdCA9IHN0YXJ0VGltZTtcbiAgICAgIHRoaXMuX3MgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuX29wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUodGhpcywgdGhpcy5fc3QsIHNjaGVkdWxlTWV0aG9kKSxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyKG8sIHRoaXMpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwVW50aWxXaXRoVGltZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3AuX29wZW4gJiYgdGhpcy5fby5vbk5leHQoeCk7IH07XG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cblxuICAvKipcbiAgICogIFNraXBzIGVsZW1lbnRzIGZyb20gdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlIHVudGlsIHRoZSBzcGVjaWZpZWQgc3RhcnQgdGltZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogIEVycm9ycyBwcm9kdWNlZCBieSB0aGUgc291cmNlIHNlcXVlbmNlIGFyZSBhbHdheXMgZm9yd2FyZGVkIHRvIHRoZSByZXN1bHQgc2VxdWVuY2UsIGV2ZW4gaWYgdGhlIGVycm9yIG9jY3VycyBiZWZvcmUgdGhlIHN0YXJ0IHRpbWUuXG4gICAqXG4gICAqIEBleGFtcGxlc1xuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5za2lwVW50aWxXaXRoVGltZShuZXcgRGF0ZSgpLCBbc2NoZWR1bGVyXSk7XG4gICAqICAyIC0gcmVzID0gc291cmNlLnNraXBVbnRpbFdpdGhUaW1lKDUwMDAsIFtzY2hlZHVsZXJdKTtcbiAgICogQHBhcmFtIHtEYXRlfE51bWJlcn0gc3RhcnRUaW1lIFRpbWUgdG8gc3RhcnQgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gSWYgdGhpcyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gRGF0ZSgpLCBubyBlbGVtZW50cyB3aWxsIGJlIHNraXBwZWQuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHNraXBwZWQgdW50aWwgdGhlIHNwZWNpZmllZCBzdGFydCB0aW1lLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBVbnRpbFdpdGhUaW1lID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUodGhpcywgc3RhcnRUaW1lLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgVGFrZXMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gdW50aWwgdGhlIHNwZWNpZmllZCBlbmQgdGltZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cbiAgICogQHBhcmFtIHtOdW1iZXIgfCBEYXRlfSBlbmRUaW1lIFRpbWUgdG8gc3RvcCB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLiBJZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuZXcgRGF0ZSgpLCB0aGUgcmVzdWx0IHN0cmVhbSB3aWxsIGNvbXBsZXRlIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIHVudGlsIHRoZSBzcGVjaWZpZWQgZW5kIHRpbWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZVVudGlsV2l0aFRpbWUgPSBmdW5jdGlvbiAoZW5kVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShvLCBlbmRUaW1lLCBmdW5jdGlvbiAoXywgbykgeyBvLm9uQ29tcGxldGVkKCk7IH0pLFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKG8pKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGR1cmluZyBzZXF1ZW50aWFsIHRpbWUgd2luZG93cyBvZiBhIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd0R1cmF0aW9uIHRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgYW5vdGhlciBpdGVtIGFmdGVyIGVtaXR0aW5nIHRoZSBsYXN0IGl0ZW1cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIHRoZSBTY2hlZHVsZXIgdG8gdXNlIGludGVybmFsbHkgdG8gbWFuYWdlIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGltZW91dCBmb3IgZWFjaCBpdGVtLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHRoZSB0aHJvdHRsZSBvcGVyYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGhyb3R0bGUgPSBmdW5jdGlvbiAod2luZG93RHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHZhciBkdXJhdGlvbiA9ICt3aW5kb3dEdXJhdGlvbiB8fCAwO1xuICAgIGlmIChkdXJhdGlvbiA8PSAwKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKCd3aW5kb3dEdXJhdGlvbiBjYW5ub3QgYmUgbGVzcyBvciBlcXVhbCB6ZXJvLicpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbGFzdE9uTmV4dCA9IDA7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICAgIGlmIChsYXN0T25OZXh0ID09PSAwIHx8IG5vdyAtIGxhc3RPbk5leHQgPj0gZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGxhc3RPbk5leHQgPSBub3c7XG4gICAgICAgICAgICBvLm9uTmV4dCh4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LCBmdW5jdGlvbiAoKSB7IG8ub25Db21wbGV0ZWQoKTsgfVxuICAgICAgKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBUcmFuc2R1Y2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVHJhbnNkdWNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVHJhbnNkdWNlT2JzZXJ2ZXIobywgeGZvcm0pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5feGZvcm0gPSB4Zm9ybTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRyYW5zZHVjZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl94Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSkuY2FsbCh0aGlzLl94Zm9ybSwgdGhpcy5fbywgeCk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgfTtcblxuICAgIFRyYW5zZHVjZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcblxuICAgIFRyYW5zZHVjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl94Zm9ybVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHRoaXMuX28pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHJhbnNkdWNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUZvck9ic2VydmVyKG8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAdHJhbnNkdWNlci9pbml0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSxcbiAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uKG9icywgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG9icy5vbk5leHQoaW5wdXQpO1xuICAgICAgfSxcbiAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24ob2JzKSB7XG4gICAgICAgIHJldHVybiBvYnMub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgdHJhbnNkdWNlciB0byB0cmFuc2Zvcm0gdGhlIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogQHBhcmFtIHtUcmFuc2R1Y2VyfSB0cmFuc2R1Y2VyIEEgdHJhbnNkdWNlciB0byBleGVjdXRlXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgZnJvbSB0aGUgdHJhbnNkdWNlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50cmFuc2R1Y2UgPSBmdW5jdGlvbih0cmFuc2R1Y2VyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciB4Zm9ybSA9IHRyYW5zZHVjZXIodHJhbnNmb3JtRm9yT2JzZXJ2ZXIobykpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRyYW5zZHVjZU9ic2VydmVyKG8sIHhmb3JtKSk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgU3dpdGNoRmlyc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hGaXJzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hGaXJzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGhhc0N1cnJlbnQ6IGZhbHNlLFxuICAgICAgICAgIGlzU3RvcHBlZDogZmFsc2UsXG4gICAgICAgICAgbzogbyxcbiAgICAgICAgICBnOiBnXG4gICAgICAgIH07XG5cbiAgICAgIGcuYWRkKG0pO1xuICAgICAgbS5zZXREaXNwb3NhYmxlKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoRmlyc3RPYnNlcnZlcihzdGF0ZSkpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3dpdGNoRmlyc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFN3aXRjaEZpcnN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3dpdGNoRmlyc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE9ic2VydmVyKHN0YXRlKSB7XG4gICAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICghdGhpcy5fcy5oYXNDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuX3MuaGFzQ3VycmVudCA9IHRydWU7XG4gICAgICAgIGlzUHJvbWlzZSh4KSAmJiAoeCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh4KSk7XG4gICAgICAgIHZhciBpbm5lciA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aGlzLl9zLmcuYWRkKGlubmVyKTtcbiAgICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZSh4LnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcih0aGlzLl9zLCBpbm5lcikpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU3dpdGNoRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFN3aXRjaEZpcnN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3MuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICF0aGlzLl9zLmhhc0N1cnJlbnQgJiYgdGhpcy5fcy5nLmxlbmd0aCA9PT0gMSAmJiB0aGlzLl9zLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHN0YXRlLCBpbm5lcikge1xuICAgICAgdGhpcy5fcyA9IHN0YXRlO1xuICAgICAgdGhpcy5faSA9IGlubmVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3Muby5vbk5leHQoeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm8ub25FcnJvcihlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zLmcucmVtb3ZlKHRoaXMuX2kpO1xuICAgICAgdGhpcy5fcy5oYXNDdXJyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLl9zLmlzU3RvcHBlZCAmJiB0aGlzLl9zLmcubGVuZ3RoID09PSAxICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3dpdGNoRmlyc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZXhjbHVzaXZlIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCB0byBmaW5pc2ggYmVmb3JlIHN1YnNjcmliaW5nIHRvIGFub3RoZXIgb2JzZXJ2YWJsZS5cbiAgICogT2JzZXJ2YWJsZXMgdGhhdCBjb21lIGluIGJldHdlZW4gc3Vic2NyaXB0aW9ucyB3aWxsIGJlIGRyb3BwZWQgb24gdGhlIGZsb29yLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBleGNsdXNpdmUgb2JzZXJ2YWJsZSB3aXRoIG9ubHkgdGhlIHJlc3VsdHMgdGhhdCBoYXBwZW4gd2hlbiBzdWJzY3JpYmVkLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnN3aXRjaEZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3dpdGNoRmlyc3RPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG5vYnNlcnZhYmxlUHJvdG8uZmxhdE1hcEZpcnN0ID0gb2JzZXJ2YWJsZVByb3RvLmV4aGF1c3RNYXAgPSBmdW5jdGlvbihzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykuc3dpdGNoRmlyc3QoKTtcbn07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwV2l0aE1heENvbmN1cnJlbnQgPSBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcE1heENvbmN1cnJlbnQgPSBmdW5jdGlvbihsaW1pdCwgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0TWFwT2JzZXJ2YWJsZSh0aGlzLCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpLm1lcmdlKGxpbWl0KTtcbn07XG5cbiAgLyoqIFByb3ZpZGVzIGEgc2V0IG9mIGV4dGVuc2lvbiBtZXRob2RzIGZvciB2aXJ0dWFsIHRpbWUgc2NoZWR1bGluZy4gKi9cbiAgdmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyID0gUnguVmlydHVhbFRpbWVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFZpcnR1YWxUaW1lU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyIHdpdGggdGhlIHNwZWNpZmllZCBpbml0aWFsIGNsb2NrIHZhbHVlIGFuZCBhYnNvbHV0ZSB0aW1lIGNvbXBhcmVyLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluaXRpYWxDbG9jayBJbml0aWFsIHZhbHVlIGZvciB0aGUgY2xvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgQ29tcGFyZXIgdG8gZGV0ZXJtaW5lIGNhdXNhbGl0eSBvZiBldmVudHMgYmFzZWQgb24gYWJzb2x1dGUgdGltZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaXJ0dWFsVGltZVNjaGVkdWxlcihpbml0aWFsQ2xvY2ssIGNvbXBhcmVyKSB7XG4gICAgICB0aGlzLmNsb2NrID0gaW5pdGlhbENsb2NrO1xuICAgICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgxMDI0KTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZSA9IFZpcnR1YWxUaW1lU2NoZWR1bGVyLnByb3RvdHlwZTtcblxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWJzb2x1dGVUaW1lKHRoaXMuY2xvY2spO1xuICAgIH07XG5cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUFic29sdXRlKHN0YXRlLCB0aGlzLmNsb2NrLCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgZHQgPSBkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgIHRoaXMudG9SZWxhdGl2ZVRpbWUoZHVlVGltZSAtIHRoaXMubm93KCkpIDpcbiAgICAgICAgdGhpcy50b1JlbGF0aXZlVGltZShkdWVUaW1lKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVSZWxhdGl2ZShzdGF0ZSwgZHQsIGFjdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZWxhdGl2ZSB0aW1lIHZhbHVlIHRvIGFuIGFic29sdXRlIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFic29sdXRlIEFic29sdXRlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXRpdmUgUmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJlc3VsdGluZyBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgc3VtIHZhbHVlLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkZCA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gYWJzb2x1dGUgdGltZSB0byBhIG51bWJlclxuICAgICAqIEBwYXJhbSB7QW55fSBUaGUgYWJzb2x1dGUgdGltZS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYWJzb2x1dGUgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnRvQWJzb2x1dGVUaW1lID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgVGltZVNwYW4gdmFsdWUgdG8gYSByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDb3JyZXNwb25kaW5nIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS50b1JlbGF0aXZlVGltZSA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgcGVyaW9kaWMgcGllY2Ugb2Ygd29yayBieSBkeW5hbWljYWxseSBkaXNjb3ZlcmluZyB0aGUgc2NoZWR1bGVyJ3MgY2FwYWJpbGl0aWVzLiBUaGUgcGVyaW9kaWMgdGFzayB3aWxsIGJlIGVtdWxhdGVkIHVzaW5nIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIEluaXRpYWwgc3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdXBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBydW5uaW5nIHRoZSB3b3JrIHBlcmlvZGljYWxseS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLCBwb3RlbnRpYWxseSB1cGRhdGluZyB0aGUgc3RhdGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIHJlY3VycmluZyBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZVBlcmlvZGljID0gZnVuY3Rpb24gKHN0YXRlLCBwZXJpb2QsIGFjdGlvbikge1xuICAgICAgdmFyIHMgPSBuZXcgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZSh0aGlzLCBzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pO1xuICAgICAgcmV0dXJuIHMuc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkdWVUaW1lLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlUmVsYXRpdmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdmFyIHJ1bkF0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgZHVlVGltZSk7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUFic29sdXRlKHN0YXRlLCBydW5BdCwgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVyKG5leHQuZHVlVGltZSwgdGhpcy5jbG9jaykgPiAwICYmICh0aGlzLmNsb2NrID0gbmV4dC5kdWVUaW1lKTtcbiAgICAgICAgICAgIG5leHQuaW52b2tlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLmlzRW5hYmxlZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgdG8gdGhlIHNwZWNpZmllZCB0aW1lLCBydW5uaW5nIGFsbCB3b3JrIHRpbGwgdGhhdCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBBYnNvbHV0ZSB0aW1lIHRvIGFkdmFuY2UgdGhlIHNjaGVkdWxlcidzIGNsb2NrIHRvLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkdmFuY2VUbyA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgZHVlVG9DbG9jayA9IHRoaXMuY29tcGFyZXIodGhpcy5jbG9jaywgdGltZSk7XG4gICAgICBpZiAodGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCB0aW1lKSA+IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICAgIGlmIChkdWVUb0Nsb2NrID09PSAwKSB7IHJldHVybjsgfVxuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsICYmIHRoaXMuY29tcGFyZXIobmV4dC5kdWVUaW1lLCB0aW1lKSA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVyKG5leHQuZHVlVGltZSwgdGhpcy5jbG9jaykgPiAwICYmICh0aGlzLmNsb2NrID0gbmV4dC5kdWVUaW1lKTtcbiAgICAgICAgICAgIG5leHQuaW52b2tlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLmlzRW5hYmxlZCk7XG4gICAgICAgIHRoaXMuY2xvY2sgPSB0aW1lO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSB0aW1lLCBydW5uaW5nIGFsbCB3b3JrIHNjaGVkdWxlZCBmb3IgdGhhdCB0aW1lc3Bhbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBSZWxhdGl2ZSB0aW1lIHRvIGFkdmFuY2UgdGhlIHNjaGVkdWxlcidzIGNsb2NrIGJ5LlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkdmFuY2VCeSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLmFkZCh0aGlzLmNsb2NrLCB0aW1lKSxcbiAgICAgICAgICBkdWVUb0Nsb2NrID0gdGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCBkdCk7XG4gICAgICBpZiAoZHVlVG9DbG9jayA+IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICAgIGlmIChkdWVUb0Nsb2NrID09PSAwKSB7ICByZXR1cm47IH1cblxuICAgICAgdGhpcy5hZHZhbmNlVG8oZHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSB0aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFJlbGF0aXZlIHRpbWUgdG8gYWR2YW5jZSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgdmFyIGR0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgdGltZSk7XG4gICAgICBpZiAodGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCBkdCkgPj0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuXG4gICAgICB0aGlzLmNsb2NrID0gZHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgc2NoZWR1bGVkIGl0ZW0gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMge1NjaGVkdWxlZEl0ZW19IFRoZSBuZXh0IHNjaGVkdWxlZCBpdGVtLlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5xdWV1ZS5wZWVrKCk7XG4gICAgICAgIGlmIChuZXh0LmlzQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgZHVlVGltZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSB0aW1lIGF0IHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZUFic29sdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gcnVuKHNjaGVkdWxlciwgc3RhdGUxKSB7XG4gICAgICAgIHNlbGYucXVldWUucmVtb3ZlKHNpKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbihzY2hlZHVsZXIsIHN0YXRlMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaSA9IG5ldyBTY2hlZHVsZWRJdGVtKHRoaXMsIHN0YXRlLCBydW4sIGR1ZVRpbWUsIHRoaXMuY29tcGFyZXIpO1xuICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKHNpKTtcblxuICAgICAgcmV0dXJuIHNpLmRpc3Bvc2FibGU7XG4gICAgfTtcblxuICAgIHJldHVybiBWaXJ0dWFsVGltZVNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxuICAvKiogUHJvdmlkZXMgYSB2aXJ0dWFsIHRpbWUgc2NoZWR1bGVyIHRoYXQgdXNlcyBEYXRlIGZvciBhYnNvbHV0ZSB0aW1lIGFuZCBudW1iZXIgZm9yIHJlbGF0aXZlIHRpbWUuICovXG4gIFJ4Lkhpc3RvcmljYWxTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEhpc3RvcmljYWxTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGhpc3RvcmljYWwgc2NoZWR1bGVyIHdpdGggdGhlIHNwZWNpZmllZCBpbml0aWFsIGNsb2NrIHZhbHVlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbml0aWFsQ2xvY2sgSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIENvbXBhcmVyIHRvIGRldGVybWluZSBjYXVzYWxpdHkgb2YgZXZlbnRzIGJhc2VkIG9uIGFic29sdXRlIHRpbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGlzdG9yaWNhbFNjaGVkdWxlcihpbml0aWFsQ2xvY2ssIGNvbXBhcmVyKSB7XG4gICAgICB2YXIgY2xvY2sgPSBpbml0aWFsQ2xvY2sgPT0gbnVsbCA/IDAgOiBpbml0aWFsQ2xvY2s7XG4gICAgICB2YXIgY21wID0gY29tcGFyZXIgfHwgZGVmYXVsdFN1YkNvbXBhcmVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgY2xvY2ssIGNtcCk7XG4gICAgfVxuXG4gICAgdmFyIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90byA9IEhpc3RvcmljYWxTY2hlZHVsZXIucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHRpbWUgdmFsdWUgdG8gYW4gYWJzb2x1dGUgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxhdGl2ZSBSZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXG4gICAgICovXG4gICAgSGlzdG9yaWNhbFNjaGVkdWxlclByb3RvLmFkZCA9IGZ1bmN0aW9uIChhYnNvbHV0ZSwgcmVsYXRpdmUpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZSArIHJlbGF0aXZlO1xuICAgIH07XG5cbiAgICBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8udG9BYnNvbHV0ZVRpbWUgPSBmdW5jdGlvbiAoYWJzb2x1dGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShhYnNvbHV0ZSkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgVGltZVNwYW4gdmFsdWUgdG8gYSByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQG1lbWJlck9mIEhpc3RvcmljYWxTY2hlZHVsZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gVGltZVNwYW4gdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvcnJlc3BvbmRpbmcgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqL1xuICAgIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90by50b1JlbGF0aXZlVGltZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xuICAgICAgcmV0dXJuIHRpbWVTcGFuO1xuICAgIH07XG5cbiAgICByZXR1cm4gSGlzdG9yaWNhbFNjaGVkdWxlcjtcbiAgfShSeC5WaXJ0dWFsVGltZVNjaGVkdWxlcikpO1xuXG5mdW5jdGlvbiBPbk5leHRQcmVkaWNhdGUocHJlZGljYXRlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG59XG5cbk9uTmV4dFByZWRpY2F0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAob3RoZXIgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG90aGVyLmtpbmQgIT09ICdOJykgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRoaXMucHJlZGljYXRlKG90aGVyLnZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIE9uRXJyb3JQcmVkaWNhdGUocHJlZGljYXRlKSB7XG4gIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xufVxuXG5PbkVycm9yUHJlZGljYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmIChvdGhlciA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAob3RoZXIua2luZCAhPT0gJ0UnKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdGhpcy5wcmVkaWNhdGUob3RoZXIuZXJyb3IpO1xufTtcblxudmFyIFJlYWN0aXZlVGVzdCA9IFJ4LlJlYWN0aXZlVGVzdCA9IHtcbiAgLyoqIERlZmF1bHQgdmlydHVhbCB0aW1lIHVzZWQgZm9yIGNyZWF0aW9uIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHVuaXQgdGVzdHMuICovXG4gIGNyZWF0ZWQ6IDEwMCxcbiAgLyoqIERlZmF1bHQgdmlydHVhbCB0aW1lIHVzZWQgdG8gc3Vic2NyaWJlIHRvIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHVuaXQgdGVzdHMuICovXG4gIHN1YnNjcmliZWQ6IDIwMCxcbiAgLyoqIERlZmF1bHQgdmlydHVhbCB0aW1lIHVzZWQgdG8gZGlzcG9zZSBzdWJzY3JpcHRpb25zIGluIHVuaXQgdGVzdHMuICovXG4gIGRpc3Bvc2VkOiAxMDAwLFxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYW4gT25OZXh0IG5vdGlmaWNhdGlvbiByZWNvcmQgYXQgYSBnaXZlbiB0aW1lIHdpdGggYSBnaXZlbiB2YWx1ZSBvciBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogMSAtIFJlYWN0aXZlVGVzdC5vbk5leHQoMjAwLCA0Mik7XG4gICAqIDIgLSBSZWFjdGl2ZVRlc3Qub25OZXh0KDIwMCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID09IDI7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gdGlja3MgUmVjb3JkZWQgdmlydHVhbCB0aW1lIHRoZSBPbk5leHQgbm90aWZpY2F0aW9uIG9jY3Vycy5cbiAgICogQHBhcmFtIHZhbHVlIFJlY29yZGVkIHZhbHVlIHN0b3JlZCBpbiB0aGUgT25OZXh0IG5vdGlmaWNhdGlvbiBvciBhIHByZWRpY2F0ZS5cbiAgICogQHJldHVybiBSZWNvcmRlZCBPbk5leHQgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgb25OZXh0OiBmdW5jdGlvbiAodGlja3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIG5ldyBPbk5leHRQcmVkaWNhdGUodmFsdWUpKSA6XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQodmFsdWUpKTtcbiAgfSxcbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBhbiBPbkVycm9yIG5vdGlmaWNhdGlvbiByZWNvcmQgYXQgYSBnaXZlbiB0aW1lIHdpdGggYSBnaXZlbiBlcnJvci5cbiAgICpcbiAgICogMSAtIFJlYWN0aXZlVGVzdC5vbk5leHQoMjAwLCBuZXcgRXJyb3IoJ2Vycm9yJykpO1xuICAgKiAyIC0gUmVhY3RpdmVUZXN0Lm9uTmV4dCgyMDAsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLm1lc3NhZ2UgPT09ICdlcnJvcic7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gdGlja3MgUmVjb3JkZWQgdmlydHVhbCB0aW1lIHRoZSBPbkVycm9yIG5vdGlmaWNhdGlvbiBvY2N1cnMuXG4gICAqIEBwYXJhbSBleGNlcHRpb24gUmVjb3JkZWQgZXhjZXB0aW9uIHN0b3JlZCBpbiB0aGUgT25FcnJvciBub3RpZmljYXRpb24uXG4gICAqIEByZXR1cm4gUmVjb3JkZWQgT25FcnJvciBub3RpZmljYXRpb24uXG4gICAqL1xuICBvbkVycm9yOiBmdW5jdGlvbiAodGlja3MsIGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIG5ldyBPbkVycm9yUHJlZGljYXRlKGVycm9yKSkgOlxuICAgICAgbmV3IFJlY29yZGVkKHRpY2tzLCBOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvcihlcnJvcikpO1xuICB9LFxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgZm9yIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiByZWNvcmQgYXQgYSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gdGlja3MgUmVjb3JkZWQgdmlydHVhbCB0aW1lIHRoZSBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24gb2NjdXJzLlxuICAgKiBAcmV0dXJuIFJlY29yZGVkIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAodGlja3MpIHtcbiAgICByZXR1cm4gbmV3IFJlY29yZGVkKHRpY2tzLCBOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQoKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYSBzdWJzY3JpcHRpb24gcmVjb3JkIGJhc2VkIG9uIGEgZ2l2ZW4gc3Vic2NyaXB0aW9uIGFuZCBkaXNwb3NhbCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnQgVmlydHVhbCB0aW1lIGluZGljYXRpbmcgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gZW5kIFZpcnR1YWwgdGltZSBpbmRpY2F0aW5nIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB3YXMgZGlzcG9zZWQuXG4gICAqIEByZXR1cm4gU3Vic2NyaXB0aW9uIG9iamVjdC5cbiAgICovXG4gIHN1YnNjcmliZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihzdGFydCwgZW5kKTtcbiAgfVxufTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgcmVjb3JkaW5nIHRoZSBwcm9kdWN0aW9uIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHZpcnR1YWwgdGltZS5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFZpcnR1YWwgdGltZSB0aGUgdmFsdWUgd2FzIHByb2R1Y2VkIG9uLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBWYWx1ZSB0aGF0IHdhcyBwcm9kdWNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgQW4gb3B0aW9uYWwgY29tcGFyZXIuXG4gICAqL1xuICB2YXIgUmVjb3JkZWQgPSBSeC5SZWNvcmRlZCA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSwgY29tcGFyZXIpIHtcbiAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXIgfHwgZGVmYXVsdENvbXBhcmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcmVjb3JkZWQgb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlY29yZGVkfSBvdGhlciBSZWNvcmRlZCBvYmplY3QgdG8gY2hlY2sgZm9yIGVxdWFsaXR5LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBib3RoIG9iamVjdHMgYXJlIGVxdWFsOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBSZWNvcmRlZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZSA9PT0gb3RoZXIudGltZSAmJiB0aGlzLmNvbXBhcmVyKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBSZWNvcmRlZCB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFJlY29yZGVkIHZhbHVlLlxuICAgKi9cbiAgUmVjb3JkZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgKyAnQCcgKyB0aGlzLnRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3Vic2NyaXB0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2aXJ0dWFsIHN1YnNjcmlwdGlvbiBhbmQgdW5zdWJzY3JpcHRpb24gdGltZS5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdWJzY3JpYmUgVmlydHVhbCB0aW1lIGF0IHdoaWNoIHRoZSBzdWJzY3JpcHRpb24gb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB1bnN1YnNjcmliZSBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdGhlIHVuc3Vic2NyaXB0aW9uIG9jY3VycmVkLlxuICAgKi9cbiAgdmFyIFN1YnNjcmlwdGlvbiA9IFJ4LlN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSBzdGFydDtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZW5kIHx8IE51bWJlci5NQVhfVkFMVUU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdWJzY3JpcHRpb24gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvdGhlciBTdWJzY3JpcHRpb24gb2JqZWN0IHRvIGNoZWNrIGZvciBlcXVhbGl0eS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYm90aCBvYmplY3RzIGFyZSBlcXVhbDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUgPT09IG90aGVyLnN1YnNjcmliZSAmJiB0aGlzLnVuc3Vic2NyaWJlID09PSBvdGhlci51bnN1YnNjcmliZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdmFsdWUuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdmFsdWUuXG4gICAqL1xuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnKCcgKyB0aGlzLnN1YnNjcmliZSArICcsICcgKyAodGhpcy51bnN1YnNjcmliZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/ICdJbmZpbml0ZScgOiB0aGlzLnVuc3Vic2NyaWJlKSArICcpJztcbiAgfTtcblxuICB2YXIgTW9ja0Rpc3Bvc2FibGUgPSBSeC5Nb2NrRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLmRpc3Bvc2VzID0gW107XG4gICAgdGhpcy5kaXNwb3Nlcy5wdXNoKHRoaXMuc2NoZWR1bGVyLmNsb2NrKTtcbiAgfTtcblxuICBNb2NrRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc3Bvc2VzLnB1c2godGhpcy5zY2hlZHVsZXIuY2xvY2spO1xuICB9O1xuXG4gIHZhciBNb2NrT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1vY2tPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1vY2tPYnNlcnZlcihzY2hlZHVsZXIpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgfVxuXG4gICAgdmFyIE1vY2tPYnNlcnZlclByb3RvdHlwZSA9IE1vY2tPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgICBNb2NrT2JzZXJ2ZXJQcm90b3R5cGUub25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobmV3IFJlY29yZGVkKHRoaXMuc2NoZWR1bGVyLmNsb2NrLCBOb3RpZmljYXRpb24uY3JlYXRlT25OZXh0KHZhbHVlKSkpO1xuICAgIH07XG5cbiAgICBNb2NrT2JzZXJ2ZXJQcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobmV3IFJlY29yZGVkKHRoaXMuc2NoZWR1bGVyLmNsb2NrLCBOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvcihlKSkpO1xuICAgIH07XG5cbiAgICBNb2NrT2JzZXJ2ZXJQcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobmV3IFJlY29yZGVkKHRoaXMuc2NoZWR1bGVyLmNsb2NrLCBOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQoKSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9ja09ic2VydmVyO1xuICB9KShPYnNlcnZlcik7XG5cbiAgZnVuY3Rpb24gTW9ja1Byb21pc2Uoc2NoZWR1bGVyLCBtZXNzYWdlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldLFxuICAgICAgICAgIG5vdGlmaWNhdGlvbiA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAoZnVuY3Rpb24gKGlubmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZUFic29sdXRlKG51bGwsIG1lc3NhZ2UudGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBvYnMgPSBzZWxmLm9ic2VydmVycy5zbGljZSgwKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gb2JzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgaW5uZXJOb3RpZmljYXRpb24uYWNjZXB0KG9ic1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH0pO1xuICAgICAgfSkobm90aWZpY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBNb2NrUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2gobmV3IFN1YnNjcmlwdGlvbih0aGlzLnNjaGVkdWxlci5jbG9jaykpO1xuICAgIHZhciBpbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgdmFyIG5ld1Byb21pc2U7XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBSeC5PYnNlcnZlci5jcmVhdGUoXG4gICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmV0VmFsdWUgPSBvblJlc29sdmVkKHgpO1xuICAgICAgICBpZiAocmV0VmFsdWUgJiYgdHlwZW9mIHJldFZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBuZXdQcm9taXNlID0gcmV0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRpY2tzID0gc2VsZi5zY2hlZHVsZXIuY2xvY2s7XG4gICAgICAgICAgbmV3UHJvbWlzZSA9IG5ldyBNb2NrUHJvbWlzZShzZWxmLnNjaGVkdWxlciwgW1J4LlJlYWN0aXZlVGVzdC5vbk5leHQodGlja3MsIHVuZGVmaW5lZCksIFJ4LlJlYWN0aXZlVGVzdC5vbkNvbXBsZXRlZCh0aWNrcyldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gc2VsZi5vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgIHNlbGYub2JzZXJ2ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbihzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdLnN1YnNjcmliZSwgc2VsZi5zY2hlZHVsZXIuY2xvY2spO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgb25SZWplY3RlZChlcnIpO1xuICAgICAgICB2YXIgaWR4ID0gc2VsZi5vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgIHNlbGYub2JzZXJ2ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbihzZWxmLnN1YnNjcmlwdGlvbnNbaW5kZXhdLnN1YnNjcmliZSwgc2VsZi5zY2hlZHVsZXIuY2xvY2spO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG5cbiAgICByZXR1cm4gbmV3UHJvbWlzZSB8fCBuZXcgTW9ja1Byb21pc2UodGhpcy5zY2hlZHVsZXIsIHRoaXMubWVzc2FnZXMpO1xuICB9O1xuXG4gIHZhciBIb3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhIb3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gSG90T2JzZXJ2YWJsZShzY2hlZHVsZXIsIG1lc3NhZ2VzKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHZhciBtZXNzYWdlLCBub3RpZmljYXRpb24sIG9ic2VydmFibGUgPSB0aGlzO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgICAgbm90aWZpY2F0aW9uID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgKGZ1bmN0aW9uIChpbm5lck5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZUFic29sdXRlKG51bGwsIG1lc3NhZ2UudGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9icyA9IG9ic2VydmFibGUub2JzZXJ2ZXJzLnNsaWNlKDApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IG9icy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgaW5uZXJOb3RpZmljYXRpb24uYWNjZXB0KG9ic1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KShub3RpZmljYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIEhvdE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzO1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb24odGhpcy5zY2hlZHVsZXIuY2xvY2spKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnMuaW5kZXhPZihvKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5vYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBvYnNlcnZhYmxlLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhvdE9ic2VydmFibGU7XG4gIH0pKE9ic2VydmFibGUpO1xuXG4gIHZhciBDb2xkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29sZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBDb2xkT2JzZXJ2YWJsZShzY2hlZHVsZXIsIG1lc3NhZ2VzKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuXG4gICAgQ29sZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG1lc3NhZ2UsIG5vdGlmaWNhdGlvbiwgb2JzZXJ2YWJsZSA9IHRoaXM7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc2NoZWR1bGVyLmNsb2NrKSk7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgICBub3RpZmljYXRpb24gPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAoZnVuY3Rpb24gKGlubmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgZC5hZGQob2JzZXJ2YWJsZS5zY2hlZHVsZXIuc2NoZWR1bGVSZWxhdGl2ZShudWxsLCBtZXNzYWdlLnRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlubmVyTm90aWZpY2F0aW9uLmFjY2VwdChvKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KShub3RpZmljYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZhYmxlLnN1YnNjcmlwdGlvbnNbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZhYmxlLnN1YnNjcmlwdGlvbnNbaW5kZXhdLnN1YnNjcmliZSwgb2JzZXJ2YWJsZS5zY2hlZHVsZXIuY2xvY2spO1xuICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29sZE9ic2VydmFibGU7XG4gIH0pKE9ic2VydmFibGUpO1xuXG4gIC8qKiBWaXJ0dWFsIHRpbWUgc2NoZWR1bGVyIHVzZWQgZm9yIHRlc3RpbmcgYXBwbGljYXRpb25zIGFuZCBsaWJyYXJpZXMgYnVpbHQgdXNpbmcgUmVhY3RpdmUgRXh0ZW5zaW9ucy4gKi9cbiAgUnguVGVzdFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGVzdFNjaGVkdWxlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIGJhc2VDb21wYXJlcih4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHkgPyAxIDogKHggPCB5ID8gLTEgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUZXN0U2NoZWR1bGVyKCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgMCwgYmFzZUNvbXBhcmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IHRoZSBzcGVjaWZpZWQgdmlydHVhbCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSBkdWVUaW1lIEFic29sdXRlIHZpcnR1YWwgdGltZSBhdCB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybiBEaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlQWJzb2x1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgZHVlVGltZSA8PSB0aGlzLmNsb2NrICYmIChkdWVUaW1lID0gdGhpcy5jbG9jayArIDEpO1xuICAgICAgcmV0dXJuIF9fc3VwZXJfXy5wcm90b3R5cGUuc2NoZWR1bGVBYnNvbHV0ZS5jYWxsKHRoaXMsIHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB0byBhbiBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSByZWxhdGl2ZSBSZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYWRkLlxuICAgICAqIEByZXR1cm4gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFic29sdXRlLCByZWxhdGl2ZSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlICsgcmVsYXRpdmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGEgRGF0ZVRpbWVPZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiBDb3JyZXNwb25kaW5nIERhdGVUaW1lT2Zmc2V0IHZhbHVlLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLnRvQWJzb2x1dGVUaW1lID0gZnVuY3Rpb24gKGFic29sdXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYWJzb2x1dGUpLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBUaW1lU3BhbiB2YWx1ZSB0byBhIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lU3BhbiBUaW1lU3BhbiB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm4gQ29ycmVzcG9uZGluZyByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUudG9SZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiAodGltZVNwYW4pIHtcbiAgICAgIHJldHVybiB0aW1lU3BhbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdGVzdCBzY2hlZHVsZXIgYW5kIHVzZXMgdGhlIHNwZWNpZmllZCB2aXJ0dWFsIHRpbWVzIHRvIGludm9rZSB0aGUgZmFjdG9yeSBmdW5jdGlvbiwgc3Vic2NyaWJlIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UsIGFuZCBkaXNwb3NlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3JlYXRlIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBjcmVhdGVkIFZpcnR1YWwgdGltZSBhdCB3aGljaCB0byBpbnZva2UgdGhlIGZhY3RvcnkgdG8gY3JlYXRlIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHN1YnNjcmliZWQgVmlydHVhbCB0aW1lIGF0IHdoaWNoIHRvIHN1YnNjcmliZSB0byB0aGUgY3JlYXRlZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBkaXNwb3NlZCBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdG8gZGlzcG9zZSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqIEByZXR1cm4gT2JzZXJ2ZXIgd2l0aCB0aW1lc3RhbXBlZCByZWNvcmRpbmdzIG9mIG5vdGlmaWNhdGlvbiBtZXNzYWdlcyB0aGF0IHdlcmUgcmVjZWl2ZWQgZHVyaW5nIHRoZSB2aXJ0dWFsIHRpbWUgd2luZG93IHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgc291cmNlIHNlcXVlbmNlIHdhcyBhY3RpdmUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuc3RhcnRTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY3JlYXRlRm4sIHNldHRpbmdzKSB7XG4gICAgICBzZXR0aW5ncyB8fCAoc2V0dGluZ3MgPSB7fSk7XG4gICAgICBzZXR0aW5ncy5jcmVhdGVkID09IG51bGwgJiYgKHNldHRpbmdzLmNyZWF0ZWQgPSBSZWFjdGl2ZVRlc3QuY3JlYXRlZCk7XG4gICAgICBzZXR0aW5ncy5zdWJzY3JpYmVkID09IG51bGwgJiYgKHNldHRpbmdzLnN1YnNjcmliZWQgPSBSZWFjdGl2ZVRlc3Quc3Vic2NyaWJlZCk7XG4gICAgICBzZXR0aW5ncy5kaXNwb3NlZCA9PSBudWxsICYmIChzZXR0aW5ncy5kaXNwb3NlZCA9IFJlYWN0aXZlVGVzdC5kaXNwb3NlZCk7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMuY3JlYXRlT2JzZXJ2ZXIoKSwgc291cmNlLCBzdWJzY3JpcHRpb247XG5cbiAgICAgIHRoaXMuc2NoZWR1bGVBYnNvbHV0ZShudWxsLCBzZXR0aW5ncy5jcmVhdGVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvdXJjZSA9IGNyZWF0ZUZuKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2hlZHVsZUFic29sdXRlKG51bGwsIHNldHRpbmdzLnN1YnNjcmliZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2hlZHVsZUFic29sdXRlKG51bGwsIHNldHRpbmdzLmRpc3Bvc2VkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zdGFydCgpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBob3Qgb2JzZXJ2YWJsZSB1c2luZyB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcGVkIG5vdGlmaWNhdGlvbiBtZXNzYWdlcyBlaXRoZXIgYXMgYW4gYXJyYXkgb3IgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBOb3RpZmljYXRpb25zIHRvIHN1cmZhY2UgdGhyb3VnaCB0aGUgY3JlYXRlZCBzZXF1ZW5jZSBhdCB0aGVpciBzcGVjaWZpZWQgYWJzb2x1dGUgdmlydHVhbCB0aW1lcy5cbiAgICAgKiBAcmV0dXJuIEhvdCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB0aW1pbmcgb2Ygc3Vic2NyaXB0aW9ucyBhbmQgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVIb3RPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3M7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBIb3RPYnNlcnZhYmxlKHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29sZCBvYnNlcnZhYmxlIHVzaW5nIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wZWQgbm90aWZpY2F0aW9uIG1lc3NhZ2VzIGVpdGhlciBhcyBhbiBhcnJheSBvciBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIE5vdGlmaWNhdGlvbnMgdG8gc3VyZmFjZSB0aHJvdWdoIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGF0IHRoZWlyIHNwZWNpZmllZCB2aXJ0dWFsIHRpbWUgb2Zmc2V0cyBmcm9tIHRoZSBzZXF1ZW5jZSBzdWJzY3JpcHRpb24gdGltZS5cbiAgICAgKiBAcmV0dXJuIENvbGQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdGltaW5nIG9mIHN1YnNjcmlwdGlvbnMgYW5kIG5vdGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlQ29sZE9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbGRPYnNlcnZhYmxlKHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVzb2x2ZWQgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBhbmQgdGlja3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGlja3MgVGhlIGFic29sdXRlIHRpbWUgb2YgdGhlIHJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byB5aWVsZCBhdCB0aGUgZ2l2ZW4gdGljay5cbiAgICAgKiBAcmV0dXJucyB7TW9ja1Byb21pc2V9IEEgbW9jayBQcm9taXNlIHdoaWNoIGZ1bGZpbGxzIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZVJlc29sdmVkUHJvbWlzZSA9IGZ1bmN0aW9uICh0aWNrcywgdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ja1Byb21pc2UodGhpcywgW1J4LlJlYWN0aXZlVGVzdC5vbk5leHQodGlja3MsIHZhbHVlKSwgUnguUmVhY3RpdmVUZXN0Lm9uQ29tcGxldGVkKHRpY2tzKV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiByZWFzb24gYW5kIHRpY2tzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpY2tzIFRoZSBhYnNvbHV0ZSB0aW1lIG9mIHRoZSByZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7QW55fSByZWFzb24gVGhlIHJlYXNvbiBmb3IgcmVqZWN0aW9uIHRvIHlpZWxkIGF0IHRoZSBnaXZlbiB0aWNrLlxuICAgICAqIEByZXR1cm5zIHtNb2NrUHJvbWlzZX0gQSBtb2NrIFByb21pc2Ugd2hpY2ggcmVqZWN0cyB3aXRoIHRoZSBnaXZlbiByZWFzb24uXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlUmVqZWN0ZWRQcm9taXNlID0gZnVuY3Rpb24gKHRpY2tzLCByZWFzb24pIHtcbiAgICAgIHJldHVybiBuZXcgTW9ja1Byb21pc2UodGhpcywgW1J4LlJlYWN0aXZlVGVzdC5vbkVycm9yKHRpY2tzLCByZWFzb24pXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgdGhhdCByZWNvcmRzIHJlY2VpdmVkIG5vdGlmaWNhdGlvbiBtZXNzYWdlcyBhbmQgdGltZXN0YW1wcyB0aG9zZS5cbiAgICAgKiBAcmV0dXJuIE9ic2VydmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB0aW1pbmcgb2YgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ja09ic2VydmVyKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGVzdFNjaGVkdWxlcjtcbiAgfSkoVmlydHVhbFRpbWVTY2hlZHVsZXIpO1xuXG4gIHZhciBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQW5vbnltb3VzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIC8vIEZpeCBzdWJzY3JpYmVyIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb3IgZnVuY3Rpb24gcmV0dXJuZWQgdG8gZGVjb3JhdGUgYXMgRGlzcG9zYWJsZVxuICAgIGZ1bmN0aW9uIGZpeFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIgJiYgaXNGdW5jdGlvbihzdWJzY3JpYmVyLmRpc3Bvc2UpID8gc3Vic2NyaWJlciA6XG4gICAgICAgIGlzRnVuY3Rpb24oc3Vic2NyaWJlcikgPyBkaXNwb3NhYmxlQ3JlYXRlKHN1YnNjcmliZXIpIDogZGlzcG9zYWJsZUVtcHR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERpc3Bvc2FibGUocywgc3RhdGUpIHtcbiAgICAgIHZhciBhZG8gPSBzdGF0ZVswXSwgc2VsZiA9IHN0YXRlWzFdO1xuICAgICAgdmFyIHN1YiA9IHRyeUNhdGNoKHNlbGYuX19zdWJzY3JpYmUpLmNhbGwoc2VsZiwgYWRvKTtcbiAgICAgIGlmIChzdWIgPT09IGVycm9yT2JqICYmICFhZG8uZmFpbChlcnJvck9iai5lKSkgeyB0aHJvd2VyKGVycm9yT2JqLmUpOyB9XG4gICAgICBhZG8uc2V0RGlzcG9zYWJsZShmaXhTdWJzY3JpYmVyKHN1YikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFub255bW91c09ic2VydmFibGUoc3Vic2NyaWJlLCBwYXJlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gcGFyZW50O1xuICAgICAgdGhpcy5fX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEFub255bW91c09ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFkbyA9IG5ldyBBdXRvRGV0YWNoT2JzZXJ2ZXIobyksIHN0YXRlID0gW2FkbywgdGhpc107XG5cbiAgICAgIGlmIChjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVxdWlyZWQoKSkge1xuICAgICAgICBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzZXREaXNwb3NhYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldERpc3Bvc2FibGUobnVsbCwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFub255bW91c09ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIEF1dG9EZXRhY2hPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQXV0b0RldGFjaE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQXV0b0RldGFjaE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMubSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgIH1cblxuICAgIHZhciBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUgPSBBdXRvRGV0YWNoT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uTmV4dCkuY2FsbCh0aGlzLm9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhyb3dlcihyZXN1bHQuZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uRXJyb3IpLmNhbGwodGhpcy5vYnNlcnZlciwgZXJyKTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgcmVzdWx0ID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlc3VsdC5lKTtcbiAgICB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKS5jYWxsKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICByZXN1bHQgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzdWx0LmUpO1xuICAgIH07XG5cbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLm0uc2V0RGlzcG9zYWJsZSh2YWx1ZSk7IH07XG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm0uZ2V0RGlzcG9zYWJsZSgpOyB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBdXRvRGV0YWNoT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBVbmRlcmx5aW5nT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVW5kZXJseWluZ09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVW5kZXJseWluZ09ic2VydmFibGUobSwgdSkge1xuICAgICAgdGhpcy5fbSA9IG07XG4gICAgICB0aGlzLl91ID0gdTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFVuZGVybHlpbmdPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZSh0aGlzLl9tLmdldERpc3Bvc2FibGUoKSwgdGhpcy5fdS5zdWJzY3JpYmUobykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVW5kZXJseWluZ09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgR3JvdXBlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEdyb3VwZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgdW5kZXJseWluZ09ic2VydmFibGUsIG1lcmdlZERpc3Bvc2FibGUpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnVuZGVybHlpbmdPYnNlcnZhYmxlID0gIW1lcmdlZERpc3Bvc2FibGUgP1xuICAgICAgICB1bmRlcmx5aW5nT2JzZXJ2YWJsZSA6XG4gICAgICAgIG5ldyBVbmRlcmx5aW5nT2JzZXJ2YWJsZShtZXJnZWREaXNwb3NhYmxlLCB1bmRlcmx5aW5nT2JzZXJ2YWJsZSk7XG4gICAgfVxuXG4gICAgR3JvdXBlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMudW5kZXJseWluZ09ic2VydmFibGUuc3Vic2NyaWJlKG8pO1xuICAgIH07XG5cbiAgICByZXR1cm4gR3JvdXBlZE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiAgUmVwcmVzZW50cyBhbiBvYmplY3QgdGhhdCBpcyBib3RoIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgd2VsbCBhcyBhbiBvYnNlcnZlci5cbiAgICogIEVhY2ggbm90aWZpY2F0aW9uIGlzIGJyb2FkY2FzdGVkIHRvIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycy5cbiAgICovXG4gIHZhciBTdWJqZWN0ID0gUnguU3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoU3ViamVjdC5wcm90b3R5cGUsIE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gobyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbm5lclN1YnNjcmlwdGlvbih0aGlzLCBvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIG8ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKi9cbiAgICAgIGhhc09ic2VydmVyczogZnVuY3Rpb24gKCkgeyBjaGVja0Rpc3Bvc2VkKHRoaXMpOyByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDsgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuICAgICAgICovXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb3NbaV0ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IGVycm9yIFRoZSBleGNlcHRpb24gdG8gc2VuZCB0byBhbGwgb2JzZXJ2ZXJzLlxuICAgICAgICovXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9zW2ldLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3ViamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgb2JzZXJ2ZXIgYW5kIG9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcn0gb2JzZXJ2ZXIgVGhlIG9ic2VydmVyIHVzZWQgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0ge09ic2VydmFibGV9IG9ic2VydmFibGUgVGhlIG9ic2VydmFibGUgdXNlZCB0byBzdWJzY3JpYmUgdG8gbWVzc2FnZXMgc2VudCBmcm9tIHRoZSBzdWJqZWN0LlxuICAgICAqIEByZXR1cm5zIHtTdWJqZWN0fSBTdWJqZWN0IGltcGxlbWVudGVkIHVzaW5nIHRoZSBnaXZlbiBvYnNlcnZlciBhbmQgb2JzZXJ2YWJsZS5cbiAgICAgKi9cbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvYnNlcnZlciwgb2JzZXJ2YWJsZSkge1xuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KG9ic2VydmVyLCBvYnNlcnZhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiAgUmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG4gICAqICBUaGUgbGFzdCB2YWx1ZSBiZWZvcmUgdGhlIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiwgb3IgdGhlIGVycm9yIHJlY2VpdmVkIHRocm91Z2ggT25FcnJvciwgaXMgc2VudCB0byBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMuXG4gICAqL1xuICB2YXIgQXN5bmNTdWJqZWN0ID0gUnguQXN5bmNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBc3luY1N1YmplY3QsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3ViamVjdCB0aGF0IGNhbiBvbmx5IHJlY2VpdmUgb25lIHZhbHVlIGFuZCB0aGF0IHZhbHVlIGlzIGNhY2hlZCBmb3IgYWxsIGZ1dHVyZSBvYnNlcnZhdGlvbnMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNTdWJqZWN0KCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoQXN5bmNTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobykge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTdWJzY3JpcHRpb24odGhpcywgbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIG8ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgby5vbk5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgYWxzbyBjYXVzaW5nIHRoZSBsYXN0IHJlY2VpdmVkIHZhbHVlIHRvIGJlIHNlbnQgb3V0IChpZiBhbnkpLlxuICAgICAgICovXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgbGVuO1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gb3NbaV07XG4gICAgICAgICAgICAgIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXJyb3IuXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBUaGUgRXJyb3IgdG8gc2VuZCB0byBhbGwgb2JzZXJ2ZXJzLlxuICAgICAgICovXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9zW2ldLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFNlbmRzIGEgdmFsdWUgdG8gdGhlIHN1YmplY3QuIFRoZSBsYXN0IHZhbHVlIHJlY2VpdmVkIGJlZm9yZSBzdWNjZXNzZnVsIHRlcm1pbmF0aW9uIHdpbGwgYmUgc2VudCB0byBhbGwgc3Vic2NyaWJlZCBhbmQgZnV0dXJlIG9ic2VydmVycy5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGUgc3ViamVjdC5cbiAgICAgICAqL1xuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICAgKi9cbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQXN5bmNTdWJqZWN0O1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogIFJlcHJlc2VudHMgYSB2YWx1ZSB0aGF0IGNoYW5nZXMgb3ZlciB0aW1lLlxuICAgKiAgT2JzZXJ2ZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlIHN1YmplY3QgdG8gcmVjZWl2ZSB0aGUgbGFzdCAob3IgaW5pdGlhbCkgdmFsdWUgYW5kIGFsbCBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICB2YXIgQmVoYXZpb3JTdWJqZWN0ID0gUnguQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhCZWhhdmlvclN1YmplY3QsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQmVoYXZpb3JTdWJqZWN0KHZhbHVlKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgICAgIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTdWJzY3JpcHRpb24odGhpcywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICBvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgKiBWYWx1ZSBpcyBmcm96ZW4gYWZ0ZXIgb25Db21wbGV0ZWQgaXMgY2FsbGVkLlxuICAgICAgICogQWZ0ZXIgb25FcnJvciBpcyBjYWxsZWQgYWx3YXlzIHRocm93cyB0aGUgc3BlY2lmaWVkIGV4Y2VwdGlvbi5cbiAgICAgICAqIEFuIGV4Y2VwdGlvbiBpcyBhbHdheXMgdGhyb3duIGFmdGVyIGRpc3Bvc2UgaXMgY2FsbGVkLlxuICAgICAgICogQHJldHVybnMge01peGVkfSBUaGUgaW5pdGlhbCB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHVudGlsIG9uTmV4dCBpcyBjYWxsZWQ7IGFmdGVyIHdoaWNoLCB0aGUgbGFzdCB2YWx1ZSBwYXNzZWQgdG8gb25OZXh0LlxuICAgICAgICovXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikgeyB0aHJvd2VyKHRoaXMuZXJyb3IpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqL1xuICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7IGNoZWNrRGlzcG9zZWQodGhpcyk7IHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGggPiAwOyB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbk5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGlzIGJvdGggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyB3ZWxsIGFzIGFuIG9ic2VydmVyLlxuICAgKiBFYWNoIG5vdGlmaWNhdGlvbiBpcyBicm9hZGNhc3RlZCB0byBhbGwgc3Vic2NyaWJlZCBhbmQgZnV0dXJlIG9ic2VydmVycywgc3ViamVjdCB0byBidWZmZXIgdHJpbW1pbmcgcG9saWNpZXMuXG4gICAqL1xuICB2YXIgUmVwbGF5U3ViamVjdCA9IFJ4LlJlcGxheVN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuXG4gICAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUoc3ViamVjdCwgb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzcG9zZSgpO1xuICAgICAgICAhc3ViamVjdC5pc0Rpc3Bvc2VkICYmIHN1YmplY3Qub2JzZXJ2ZXJzLnNwbGljZShzdWJqZWN0Lm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhSZXBsYXlTdWJqZWN0LCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSZXBsYXlTdWJqZWN0IGNsYXNzIHdpdGggdGhlIHNwZWNpZmllZCBidWZmZXIgc2l6ZSwgd2luZG93IHNpemUgYW5kIHNjaGVkdWxlci5cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtidWZmZXJTaXplXSBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAgICogIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZV0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0aGUgb2JzZXJ2ZXJzIGFyZSBpbnZva2VkIG9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplID09IG51bGwgPyBtYXhTYWZlSW50ZWdlciA6IGJ1ZmZlclNpemU7XG4gICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplID09IG51bGwgPyBtYXhTYWZlSW50ZWdlciA6IHdpbmRvd1NpemU7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlciB8fCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyO1xuICAgICAgdGhpcy5xID0gW107XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKFJlcGxheVN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIHZhciBzbyA9IG5ldyBTY2hlZHVsZWRPYnNlcnZlcih0aGlzLnNjaGVkdWxlciwgbyksIHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUodGhpcywgc28pO1xuXG4gICAgICAgIHRoaXMuX3RyaW0odGhpcy5zY2hlZHVsZXIubm93KCkpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHNvKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5xLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc28ub25OZXh0KHRoaXMucVtpXS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIHNvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICBzby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc28uZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICBfdHJpbTogZnVuY3Rpb24gKG5vdykge1xuICAgICAgICB3aGlsZSAodGhpcy5xLmxlbmd0aCA+IHRoaXMuYnVmZmVyU2l6ZSkge1xuICAgICAgICAgIHRoaXMucS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnEubGVuZ3RoID4gMCAmJiAobm93IC0gdGhpcy5xWzBdLmludGVydmFsKSA+IHRoaXMud2luZG93U2l6ZSkge1xuICAgICAgICAgIHRoaXMucS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLnEucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5fdHJpbShub3cpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG9zW2ldO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgb2JzZXJ2ZXIuZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLl90cmltKG5vdyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG9zW2ldO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIG9ic2VydmVyLmVuc3VyZUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gb3NbaV07XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBvYnNlcnZlci5lbnN1cmVBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICAgKi9cbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlcGxheVN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIHZhciBBbm9ueW1vdXNTdWJqZWN0ID0gUnguQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQW5vbnltb3VzU3ViamVjdCwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KG9ic2VydmVyLCBvYnNlcnZhYmxlKSB7XG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlLnN1YnNjcmliZShvKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XG4gICAgICB9LFxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAqIFVzZWQgdG8gcGF1c2UgYW5kIHJlc3VtZSBzdHJlYW1zLlxuICAqL1xuICBSeC5QYXVzZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAgICovXG4gICAgUGF1c2VyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5vbk5leHQoZmFsc2UpOyB9O1xuXG4gICAgLyoqXG4gICAgKiBSZXN1bWVzIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxuICAgICovXG4gICAgUGF1c2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMub25OZXh0KHRydWUpOyB9O1xuXG4gICAgcmV0dXJuIFBhdXNlcjtcbiAgfShTdWJqZWN0KSk7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgcm9vdC5SeCA9IFJ4O1xuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFJ4O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IFJ4KS5SeCA9IFJ4O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5SeCA9IFJ4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290LlJ4ID0gUng7XG4gIH1cblxuICAvLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxuICB2YXIgckVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG59LmNhbGwodGhpcykpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiAtMTtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHApO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDEpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXG4vLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1widXNlXCIsIFwib25cIiwgXCJvbmNlXCIsIFwic2V0XCIsIFwicXVlcnlcIiwgXCJ0eXBlXCIsIFwiYWNjZXB0XCIsIFwiYXV0aFwiLCBcIndpdGhDcmVkZW50aWFsc1wiLCBcInNvcnRRdWVyeVwiLCBcInJldHJ5XCIsIFwib2tcIiwgXCJyZWRpcmVjdHNcIixcbiBcInRpbWVvdXRcIiwgXCJidWZmZXJcIiwgXCJzZXJpYWxpemVcIiwgXCJwYXJzZVwiLCBcImNhXCIsIFwia2V5XCIsIFwicGZ4XCIsIFwiY2VydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC8qdmFyYXJncyovKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMucHVzaCh7Zm46Zm4sIGFyZ3VtZW50czphcmd1bWVudHN9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbkFnZW50LnByb3RvdHlwZS5fc2V0RGVmYXVsdHMgPSBmdW5jdGlvbihyZXEpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBkZWYuYXJndW1lbnRzKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnQ7XG4iLCIvKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHsgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIGNvbnNvbGUud2FybihcIlVzaW5nIGJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gIHJvb3QgPSB0aGlzO1xufVxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcbnZhciBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcbnZhciBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG52YXIgcmVxdWVzdCA9IGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciB0cmltID0gJycudHJpbVxuICA/IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9XG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSArICdbJyArIHN1YmtleSArICddJywgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFpcjtcbiAgdmFyIHBvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAndGV4dC94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnksXG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZSxcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIHZhciBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGlmIChzZWxmLnhocikge1xuICAgICAgICAvLyBpZTkgZG9lc24ndCBoYXZlICdyZXNwb25zZScgcHJvcGVydHlcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gdHlwZW9mIHNlbGYueGhyLnJlc3BvbnNlVHlwZSA9PSAndW5kZWZpbmVkJyA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IHNlbGYueGhyLnJlc3BvbnNlO1xuICAgICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgZXJyLnN0YXR1cyA9IHNlbGYueGhyLnN0YXR1cyA/IHNlbGYueGhyLnN0YXR1cyA6IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXNDb2RlID0gZXJyLnN0YXR1czsgLy8gYmFja3dhcmRzLWNvbXBhdCBvbmx5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIHZhciBuZXdfZXJyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXNlbGYuX2lzUmVzcG9uc2VPSyhyZXMpKSB7XG4gICAgICAgIG5ld19lcnIgPSBuZXcgRXJyb3IocmVzLnN0YXR1c1RleHQgfHwgJ1Vuc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChjdXN0b21fZXJyKSB7XG4gICAgICBuZXdfZXJyID0gY3VzdG9tX2VycjsgLy8gb2soKSBjYWxsYmFjayBjYW4gdGhyb3dcbiAgICB9XG5cbiAgICAvLyAjMTAwMCBkb24ndCBjYXRjaCBlcnJvcnMgZnJvbSB0aGUgY2FsbGJhY2sgdG8gYXZvaWQgZG91YmxlIGNhbGxpbmcgaXRcbiAgICBpZiAobmV3X2Vycikge1xuICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblJlcXVlc3RCYXNlKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3NdIG9wdGlvbmFsIGluIGNhc2Ugb2YgdXNpbmcgJ2JlYXJlcicgYXMgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nLCAnYmFzaWMnIG9yICdiZWFyZXInIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMpe1xuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcGFzcyA9ICcnO1xuICBpZiAodHlwZW9mIHBhc3MgPT09ICdvYmplY3QnICYmIHBhc3MgIT09IG51bGwpIHsgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGJ0b2EgPyAnYmFzaWMnIDogJ2F1dG8nLFxuICAgIH07XG4gIH1cblxuICB2YXIgZW5jb2RlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgdmFyIGZuID0gdGhpcy5fY2FsbGJhY2s7XG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgaWYgKGVycikge1xuICAgIGlmICh0aGlzLl9tYXhSZXRyaWVzKSBlcnIucmV0cmllcyA9IHRoaXMuX3JldHJpZXMgLSAxO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgZm4oZXJyLCByZXMpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24oKXtcbiAgY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbigpe1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyICYmIHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICBpZiAoNCAhPSByZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICB2YXIgaGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gc2VlICMxMTQ5XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmICdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5oZWFkZXJbZmllbGRdKSBjb250aW51ZTtcblxuICAgIGlmICh0aGlzLmhlYWRlci5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVR5cGUpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcblxuICAvLyBJRTExIHhoci5zZW5kKHVuZGVmaW5lZCkgc2VuZHMgJ3VuZGVmaW5lZCcgc3RyaW5nIGFzIFBPU1QgcGF5bG9hZCAoaW5zdGVhZCBvZiBub3RoaW5nKVxuICAvLyBXZSBuZWVkIG51bGwgaGVyZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIDogbnVsbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucmVxdWVzdC5hZ2VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEFnZW50KCk7XG59O1xuXG5bXCJHRVRcIiwgXCJQT1NUXCIsIFwiT1BUSU9OU1wiLCBcIlBBVENIXCIsIFwiUFVUXCIsIFwiREVMRVRFXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgdmFyIHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIHRoaXMuX3NldERlZmF1bHRzKHJlcSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICByZXEuZW5kKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn0pO1xuXG5BZ2VudC5wcm90b3R5cGUuZGVsID0gQWdlbnQucHJvdG90eXBlWydkZWxldGUnXTtcblxuLyoqXG4gKiBHRVQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE9QVElPTlMgcXVlcnkgdG8gYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdPUFRJT05TJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVsKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufVxuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVxdWVzdEJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBkZWxldGUgdGhpcy5fdGltZXI7XG4gIGRlbGV0ZSB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgYm9keSBwYXJzZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgaW5jb21pbmcgZGF0YSBpbnRvIHJlcXVlc3QuYm9keVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZm9ybWF0IG9mIGJpbmFyeSByZXNwb25zZSBib2R5LlxuICogSW4gYnJvd3NlciB2YWxpZCBmb3JtYXRzIGFyZSAnYmxvYicgYW5kICdhcnJheWJ1ZmZlcicsXG4gKiB3aGljaCByZXR1cm4gQmxvYiBhbmQgQXJyYXlCdWZmZXIsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJbiBOb2RlIGFsbCB2YWx1ZXMgcmVzdWx0IGluIEJ1ZmZlci5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24odmFsKXtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICB0aGlzLl9zZXJpYWxpemVyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGltZW91dHMuXG4gKlxuICogLSByZXNwb25zZSB0aW1lb3V0IGlzIHRpbWUgYmV0d2VlbiBzZW5kaW5nIHJlcXVlc3QgYW5kIHJlY2VpdmluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgcmVzcG9uc2UuIEluY2x1ZGVzIEROUyBhbmQgY29ubmVjdGlvbiB0aW1lLlxuICogLSBkZWFkbGluZSBpcyB0aGUgdGltZSBmcm9tIHN0YXJ0IG9mIHRoZSByZXF1ZXN0IHRvIHJlY2VpdmluZyByZXNwb25zZSBib2R5IGluIGZ1bGwuIElmIHRoZSBkZWFkbGluZSBpcyB0b28gc2hvcnQgbGFyZ2UgZmlsZXMgbWF5IG5vdCBsb2FkIGF0IGFsbCBvbiBzbG93IGNvbm5lY3Rpb25zLlxuICpcbiAqIFZhbHVlIG9mIDAgb3IgZmFsc2UgbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG1zIG9yIHtyZXNwb25zZSwgZGVhZGxpbmV9XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG9wdGlvbnMpe1xuICBpZiAoIW9wdGlvbnMgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvcih2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2gob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHRpbWVvdXQgb3B0aW9uXCIsIG9wdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIG9uIGVycm9yLlxuICpcbiAqIEZhaWxlZCByZXF1ZXN0cyB3aWxsIGJlIHJldHJpZWQgJ2NvdW50JyB0aW1lcyBpZiB0aW1lb3V0IG9yIGVyci5jb2RlID49IDUwMC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbiByZXRyeShjb3VudCwgZm4pe1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgdGhpcy5fcmV0cnlDYWxsYmFjayA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLl9yZXRyeUNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNTAwICYmIHJlcy5zdGF0dXMgIT0gNTAxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVycikge1xuICAgIGlmIChlcnIuY29kZSAmJiB+RVJST1JfQ09ERVMuaW5kZXhPZihlcnIuY29kZSkpIHJldHVybiB0cnVlO1xuICAgIC8vIFN1cGVyYWdlbnQgdGltZW91dFxuICAgIGlmIChlcnIudGltZW91dCAmJiBlcnIuY29kZSA9PSAnRUNPTk5BQk9SVEVEJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGVyci5jcm9zc0RvbWFpbikgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyeSByZXF1ZXN0XG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3JldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAvLyBub2RlXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGlubmVyUmVzb2x2ZSwgaW5uZXJSZWplY3QpIHtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIGlubmVyUmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYikgdGhyb3cgRXJyb3IoXCJDYWxsYmFjayByZXF1aXJlZFwiKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24ocmVzKSB7XG4gIGlmICghcmVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX29rQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fb2tDYWxsYmFjayhyZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDA7XG59O1xuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIGBmaWVsZGAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgZGVwcmVjYXRlZCBpbnRlcm5hbCBBUEkuIFVzZSBgLmdldChmaWVsZClgIGluc3RlYWQuXG4gKlxuICogKGdldEhlYWRlciBpcyBubyBsb25nZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzdXBlcmFnZW50IGNvZGUgYmFzZSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWwpe1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV0gPSB2YWw7XG4gIHRoaXMuaGVhZGVyW2ZpZWxkXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgdW5kZWZpbmVkID09PSBuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgIHRoaXMuZmllbGQoa2V5LCBuYW1lW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcbiAgaWYgKG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsKSB7XG4gICAgdmFsID0gJycgKyB2YWw7XG4gIH1cbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCk7IC8vIGJyb3dzZXJcbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBiYXNlNjRFbmNvZGVyKHVzZXIgKyAnOicgKyBwYXNzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmVhcmVyJzogLy8gdXNhZ2Ugd291bGQgYmUgLmF1dGgoYWNjZXNzVG9rZW4sIHsgdHlwZTogJ2JlYXJlcicgfSlcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgdXNlcik7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKG9uKSB7XG4gIC8vIFRoaXMgaXMgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uYWxpdHkuIE5vZGUgc2lkZSBpcyBuby1vcC5cbiAgaWYgKG9uID09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aW5nIGluIGJyb3dzZXIgWEhSIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLm1heFJlc3BvbnNlU2l6ZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBuKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgfVxuICB0aGlzLl9tYXhSZXNwb25zZVNpemUgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyLFxuICB9O1xufTtcblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgaXNPYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICh0aGlzLl9mb3JtRGF0YSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBtZXJnZSB0aGVzZSBzZW5kIGNhbGxzXCIpO1xuICB9XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKGlzT2JqICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAvLyBkZWZhdWx0IHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gdGhpcy5fZGF0YSArICcmJyArIGRhdGFcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTb3J0IGBxdWVyeXN0cmluZ2AgYnkgdGhlIHNvcnQgZnVuY3Rpb25cbiAqXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gZGVmYXVsdCBvcmRlclxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZWQgc29ydCBmdW5jdGlvblxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoZnVuY3Rpb24oYSwgYil7XG4gKiAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc29ydFF1ZXJ5ID0gZnVuY3Rpb24oc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDsgLy8gTWFrZXMgdGhlIGNhbGwgaWRlbXBvdGVudFxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9zb3J0KSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFyci5zb3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnN1YnN0cmluZygwLCBpbmRleCkgKyAnPycgKyBxdWVyeUFyci5qb2luKCcmJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdCBvbmx5XG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKSB7Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkXCIpO31cblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCB0aW1lb3V0LCBlcnJubyl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IocmVhc29uICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignVGltZW91dCBvZiAnLCBzZWxmLl90aW1lb3V0LCAnRVRJTUUnKTtcbiAgICB9LCB0aGlzLl90aW1lb3V0KTtcbiAgfVxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJywgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlQmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlQmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVzcG9uc2VCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVzcG9uc2VCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gICAgLy8gVE9ETzogbW9hciFcbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG5cbiAgICAvLyBjb250ZW50LXR5cGVcbiAgICB2YXIgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG5cbiAgICB0aGlzLmxpbmtzID0ge307XG5cbiAgICAvLyBsaW5rc1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gICAgdmFyIHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gICAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gICAgLy8gYmFzaWNzXG4gICAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICAgIHRoaXMub2sgPSAyID09IHR5cGU7XG4gICAgdGhpcy5yZWRpcmVjdCA9IDMgPT0gdHlwZTtcbiAgICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICAgIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gICAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgICAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvLyBzdWdhclxuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgICB2YXIgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICAgIHZhciByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqW3JlbF0gPSB1cmw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIGNoYW5nZXNPcmlnaW4pe1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlclsnaG9zdCddO1xuICAvLyBzZWN1aXJ0eVxuICBpZiAoY2hhbmdlc09yaWdpbikge1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgaGVhZGVyWydjb29raWUnXTtcbiAgfVxuICByZXR1cm4gaGVhZGVyO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8qIVxuICogd2F2ZXN1cmZlci5qcyAyLjEuMCAoTW9uIE9jdCAwMSAyMDE4IDExOjM0OjU0IEdNVCswMjAwIChDZW50cmFsIEV1cm9wZWFuIFN1bW1lciBUaW1lKSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rYXRzcGF1Z2gvd2F2ZXN1cmZlci5qc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlXG4gKi9cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwidGltZWxpbmVcIixbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnRpbWVsaW5lPXQoKTooZS5XYXZlU3VyZmVyPWUuV2F2ZVN1cmZlcnx8e30sZS5XYXZlU3VyZmVyLnRpbWVsaW5lPXQoKSl9KHdpbmRvdyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhKXt2YXIgcj17fTtmdW5jdGlvbiBuKGUpe2lmKHJbZV0pcmV0dXJuIHJbZV0uZXhwb3J0czt2YXIgdD1yW2VdPXtpOmUsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gYVtlXS5jYWxsKHQuZXhwb3J0cyx0LHQuZXhwb3J0cyxuKSx0Lmw9ITAsdC5leHBvcnRzfXJldHVybiBuLm09YSxuLmM9cixuLmQ9ZnVuY3Rpb24oZSx0LGEpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDphfSl9LG4ucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PW4odCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGE9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIoYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciByIGluIHQpbi5kKGEscixmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLHIpKTtyZXR1cm4gYX0sbi5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBuLmQodCxcImFcIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD1cImxvY2FsaG9zdDo4MDgwL2Rpc3QvcGx1Z2luL1wiLG4obi5zPTApfShbZnVuY3Rpb24oZSx0LGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtmb3IodmFyIGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIHI9dFthXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIG4oZSx0LGEpe3JldHVybiB0JiZyKGUucHJvdG90eXBlLHQpLGEmJnIoZSxhKSxlfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsdCl7dmFyIGE9dGhpcztpZihmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsciksby5jYWxsKHRoaXMpLHRoaXMuY29udGFpbmVyPVwic3RyaW5nXCI9PXR5cGVvZiBlLmNvbnRhaW5lcj9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUuY29udGFpbmVyKTplLmNvbnRhaW5lciwhdGhpcy5jb250YWluZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udGFpbmVyIGZvciB3YXZlc3VyZmVyIHRpbWVsaW5lXCIpO3RoaXMud2F2ZXN1cmZlcj10LHRoaXMudXRpbD10LnV0aWwsdGhpcy5wYXJhbXM9dGhpcy51dGlsLmV4dGVuZCh7fSx7aGVpZ2h0OjIwLG5vdGNoUGVyY2VudEhlaWdodDo5MCxsYWJlbFBhZGRpbmc6NSx1bmxhYmVsZWROb3RjaENvbG9yOlwiI2MwYzBjMFwiLHByaW1hcnlDb2xvcjpcIiMwMDBcIixzZWNvbmRhcnlDb2xvcjpcIiNjMGMwYzBcIixwcmltYXJ5Rm9udENvbG9yOlwiIzAwMFwiLHNlY29uZGFyeUZvbnRDb2xvcjpcIiMwMDBcIixmb250RmFtaWx5OlwiQXJpYWxcIixmb250U2l6ZToxMCx6b29tRGVib3VuY2U6ITEsZm9ybWF0VGltZUNhbGxiYWNrOnRoaXMuZGVmYXVsdEZvcm1hdFRpbWVDYWxsYmFjayx0aW1lSW50ZXJ2YWw6dGhpcy5kZWZhdWx0VGltZUludGVydmFsLHByaW1hcnlMYWJlbEludGVydmFsOnRoaXMuZGVmYXVsdFByaW1hcnlMYWJlbEludGVydmFsLHNlY29uZGFyeUxhYmVsSW50ZXJ2YWw6dGhpcy5kZWZhdWx0U2Vjb25kYXJ5TGFiZWxJbnRlcnZhbH0sZSksdGhpcy5jYW52YXNlcz1bXSx0aGlzLndyYXBwZXI9bnVsbCx0aGlzLmRyYXdlcj1udWxsLHRoaXMucGl4ZWxSYXRpbz1udWxsLHRoaXMubWF4Q2FudmFzV2lkdGg9bnVsbCx0aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aD1udWxsLHRoaXMuX29uWm9vbT10aGlzLnBhcmFtcy56b29tRGVib3VuY2U/dGhpcy53YXZlc3VyZmVyLnV0aWwuZGVib3VuY2UoZnVuY3Rpb24oKXtyZXR1cm4gYS5yZW5kZXIoKX0sdGhpcy5wYXJhbXMuem9vbURlYm91bmNlKTpmdW5jdGlvbigpe3JldHVybiBhLnJlbmRlcigpfX1yZXR1cm4gbihyLG51bGwsW3trZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm57bmFtZTpcInRpbWVsaW5lXCIsZGVmZXJJbml0OiEoIWV8fCFlLmRlZmVySW5pdCkmJmUuZGVmZXJJbml0LHBhcmFtczplLGluc3RhbmNlOnJ9fX1dKSxuKHIsW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLndhdmVzdXJmZXIub24oXCJyZWFkeVwiLHRoaXMuX29uUmVhZHkpLHRoaXMud2F2ZXN1cmZlci5pc1JlYWR5JiZ0aGlzLl9vblJlYWR5KCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy51bkFsbCgpLHRoaXMud2F2ZXN1cmZlci51bihcInJlZHJhd1wiLHRoaXMuX29uUmVkcmF3KSx0aGlzLndhdmVzdXJmZXIudW4oXCJ6b29tXCIsdGhpcy5fb25ab29tKSx0aGlzLndhdmVzdXJmZXIudW4oXCJyZWFkeVwiLHRoaXMuX29uUmVhZHkpLHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fb25TY3JvbGwpLHRoaXMud3JhcHBlciYmdGhpcy53cmFwcGVyLnBhcmVudE5vZGUmJih0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fb25XcmFwcGVyQ2xpY2spLHRoaXMud3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlciksdGhpcy53cmFwcGVyPW51bGwpfX0se2tleTpcImNyZWF0ZVdyYXBwZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMud2F2ZXN1cmZlci5wYXJhbXM7dGhpcy5jb250YWluZXIuaW5uZXJIVE1MPVwiXCIsdGhpcy53cmFwcGVyPXRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aW1lbGluZVwiKSksdGhpcy51dGlsLnN0eWxlKHRoaXMud3JhcHBlcix7ZGlzcGxheTpcImJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHVzZXJTZWxlY3Q6XCJub25lXCIsd2Via2l0VXNlclNlbGVjdDpcIm5vbmVcIixoZWlnaHQ6XCJcIi5jb25jYXQodGhpcy5wYXJhbXMuaGVpZ2h0LFwicHhcIil9KSwoZS5maWxsUGFyZW50fHxlLnNjcm9sbFBhcmVudCkmJnRoaXMudXRpbC5zdHlsZSh0aGlzLndyYXBwZXIse3dpZHRoOlwiMTAwJVwiLG92ZXJmbG93WDpcImhpZGRlblwiLG92ZXJmbG93WTpcImhpZGRlblwifSksdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uV3JhcHBlckNsaWNrKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMud3JhcHBlcnx8dGhpcy5jcmVhdGVXcmFwcGVyKCksdGhpcy51cGRhdGVDYW52YXNlcygpLHRoaXMudXBkYXRlQ2FudmFzZXNQb3NpdGlvbmluZygpLHRoaXMucmVuZGVyQ2FudmFzZXMoKX19LHtrZXk6XCJ1cGRhdGVDYW52YXNlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQsYT10aGlzLHI9TWF0aC5yb3VuZCh0aGlzLmRyYXdlci53cmFwcGVyLnNjcm9sbFdpZHRoKSxuPU1hdGguY2VpbChyL3RoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoKTt0aGlzLmNhbnZhc2VzLmxlbmd0aDxuOyl2b2lkIDAsZT1hLndyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSksYS5jYW52YXNlcy5wdXNoKGUpLGEudXRpbC5zdHlsZShlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsekluZGV4OjR9KTtmb3IoO3RoaXMuY2FudmFzZXMubGVuZ3RoPm47KXQ9dm9pZCAwLCh0PWEuY2FudmFzZXMucG9wKCkpLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodCl9fSx7a2V5OlwidXBkYXRlQ2FudmFzZXNQb3NpdGlvbmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcyxuPXRoaXMuY2FudmFzZXMubGVuZ3RoO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBhPXQ9PT1uLTE/ci5kcmF3ZXIud3JhcHBlci5zY3JvbGxXaWR0aC1yLm1heENhbnZhc0VsZW1lbnRXaWR0aCoobi0xKTpyLm1heENhbnZhc0VsZW1lbnRXaWR0aDtlLndpZHRoPWEqci5waXhlbFJhdGlvLGUuaGVpZ2h0PShyLnBhcmFtcy5oZWlnaHQrMSkqci5waXhlbFJhdGlvLHIudXRpbC5zdHlsZShlLHt3aWR0aDpcIlwiLmNvbmNhdChhLFwicHhcIiksaGVpZ2h0OlwiXCIuY29uY2F0KHIucGFyYW1zLmhlaWdodCxcInB4XCIpLGxlZnQ6XCJcIi5jb25jYXQodCpyLm1heENhbnZhc0VsZW1lbnRXaWR0aCxcInB4XCIpfSl9KX19LHtrZXk6XCJyZW5kZXJDYW52YXNlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcyxlPXRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLmdldER1cmF0aW9uKCk7aWYoIShlPD0wKSl7dmFyIHQsYT10aGlzLndhdmVzdXJmZXIucGFyYW1zLG49dGhpcy5wYXJhbXMuZm9udFNpemUqYS5waXhlbFJhdGlvLGk9cGFyc2VJbnQoZSwxMCkrMSxvPWEuZmlsbFBhcmVudCYmIWEuc2Nyb2xsUGFyZW50P3RoaXMuZHJhd2VyLmdldFdpZHRoKCk6dGhpcy5kcmF3ZXIud3JhcHBlci5zY3JvbGxXaWR0aCphLnBpeGVsUmF0aW8scz10aGlzLnBhcmFtcy5oZWlnaHQqdGhpcy5waXhlbFJhdGlvLGw9dGhpcy5wYXJhbXMuaGVpZ2h0Kih0aGlzLnBhcmFtcy5ub3RjaFBlcmNlbnRIZWlnaHQvMTAwKSp0aGlzLnBpeGVsUmF0aW8sYz1vL2UsdT10aGlzLnBhcmFtcy5mb3JtYXRUaW1lQ2FsbGJhY2ssaD1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UoYyk6ZX0scD1oKHRoaXMucGFyYW1zLnRpbWVJbnRlcnZhbCksZj1oKHRoaXMucGFyYW1zLnByaW1hcnlMYWJlbEludGVydmFsKSxkPWgodGhpcy5wYXJhbXMuc2Vjb25kYXJ5TGFiZWxJbnRlcnZhbCksdj0wLG09MCx5PVtdO2Zvcih0PTA7dDxpL3A7dCsrKXkucHVzaChbdCxtLHZdKSxtKz1wLHYrPWMqcDt2YXIgdz1mdW5jdGlvbih0KXt5LmZvckVhY2goZnVuY3Rpb24oZSl7dChlWzBdLGVbMV0sZVsyXSl9KX07dGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnByaW1hcnlDb2xvciksdGhpcy5zZXRGb250cyhcIlwiLmNvbmNhdChuLFwicHggXCIpLmNvbmNhdCh0aGlzLnBhcmFtcy5mb250RmFtaWx5KSksdGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnByaW1hcnlGb250Q29sb3IpLHcoZnVuY3Rpb24oZSx0LGEpe2UlZj09MCYmKHIuZmlsbFJlY3QoYSwwLDEscyksci5maWxsVGV4dCh1KHQsYyksYStyLnBhcmFtcy5sYWJlbFBhZGRpbmcqci5waXhlbFJhdGlvLHMpKX0pLHRoaXMuc2V0RmlsbFN0eWxlcyh0aGlzLnBhcmFtcy5zZWNvbmRhcnlDb2xvciksdGhpcy5zZXRGb250cyhcIlwiLmNvbmNhdChuLFwicHggXCIpLmNvbmNhdCh0aGlzLnBhcmFtcy5mb250RmFtaWx5KSksdGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnNlY29uZGFyeUZvbnRDb2xvciksdyhmdW5jdGlvbihlLHQsYSl7ZSVkPT0wJiYoci5maWxsUmVjdChhLDAsMSxzKSxyLmZpbGxUZXh0KHUodCxjKSxhK3IucGFyYW1zLmxhYmVsUGFkZGluZypyLnBpeGVsUmF0aW8scykpfSksdGhpcy5zZXRGaWxsU3R5bGVzKHRoaXMucGFyYW1zLnVubGFiZWxlZE5vdGNoQ29sb3IpLHcoZnVuY3Rpb24oZSx0LGEpe2UlZCE9MCYmZSVmIT0wJiZyLmZpbGxSZWN0KGEsMCwxLGwpfSl9fX0se2tleTpcInNldEZpbGxTdHlsZXNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5nZXRDb250ZXh0KFwiMmRcIikuZmlsbFN0eWxlPXR9KX19LHtrZXk6XCJzZXRGb250c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmdldENvbnRleHQoXCIyZFwiKS5mb250PXR9KX19LHtrZXk6XCJmaWxsUmVjdFwiLHZhbHVlOmZ1bmN0aW9uKG4saSxvLHMpe3ZhciBsPXRoaXM7dGhpcy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIGE9dCpsLm1heENhbnZhc1dpZHRoLHI9e3gxOk1hdGgubWF4KG4sdCpsLm1heENhbnZhc1dpZHRoKSx5MTppLHgyOk1hdGgubWluKG4rbyx0KmwubWF4Q2FudmFzV2lkdGgrZS53aWR0aCkseTI6aStzfTtyLngxPHIueDImJmUuZ2V0Q29udGV4dChcIjJkXCIpLmZpbGxSZWN0KHIueDEtYSxyLnkxLHIueDItci54MSxyLnkyLXIueTEpfSl9fSx7a2V5OlwiZmlsbFRleHRcIix2YWx1ZTpmdW5jdGlvbihyLG4saSl7dmFyIG8scz0wO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLmdldENvbnRleHQoXCIyZFwiKSxhPXQuY2FudmFzLndpZHRoO24rbzxzfHwobjxzK2EmJihvPXQubWVhc3VyZVRleHQocikud2lkdGgsdC5maWxsVGV4dChyLG4tcyxpKSkscys9YSl9KX19LHtrZXk6XCJkZWZhdWx0Rm9ybWF0VGltZUNhbGxiYWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigxPGUvNjApe3ZhciBhPXBhcnNlSW50KGUvNjAsMTApO3JldHVybiBlPShlPXBhcnNlSW50KGUlNjAsMTApKTwxMD9cIjBcIitlOmUsXCJcIi5jb25jYXQoYSxcIjpcIikuY29uY2F0KGUpfXJldHVybiBNYXRoLnJvdW5kKDFlMyplKS8xZTN9fSx7a2V5OlwiZGVmYXVsdFRpbWVJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiAyNTw9ZT8xOjI1PD01KmU/NToyNTw9MTUqZT8xNTo2MCpNYXRoLmNlaWwoLjUvZSl9fSx7a2V5OlwiZGVmYXVsdFByaW1hcnlMYWJlbEludGVydmFsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIDI1PD1lPzEwOjI1PD01KmU/Njo0fX0se2tleTpcImRlZmF1bHRTZWNvbmRhcnlMYWJlbEludGVydmFsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIDI1PD1lPzU6Mn19XSkscn0oKTt0LmRlZmF1bHQ9aTt2YXIgbz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5fb25TY3JvbGw9ZnVuY3Rpb24oKXthLndyYXBwZXImJmEuZHJhd2VyLndyYXBwZXImJihhLndyYXBwZXIuc2Nyb2xsTGVmdD1hLmRyYXdlci53cmFwcGVyLnNjcm9sbExlZnQpfSx0aGlzLl9vblJlZHJhdz1mdW5jdGlvbigpe3JldHVybiBhLnJlbmRlcigpfSx0aGlzLl9vblJlYWR5PWZ1bmN0aW9uKCl7dmFyIGU9YS53YXZlc3VyZmVyO2EuZHJhd2VyPWUuZHJhd2VyLGEucGl4ZWxSYXRpbz1lLmRyYXdlci5wYXJhbXMucGl4ZWxSYXRpbyxhLm1heENhbnZhc1dpZHRoPWUuZHJhd2VyLm1heENhbnZhc1dpZHRofHxlLmRyYXdlci53aWR0aCxhLm1heENhbnZhc0VsZW1lbnRXaWR0aD1lLmRyYXdlci5tYXhDYW52YXNFbGVtZW50V2lkdGh8fE1hdGgucm91bmQoYS5tYXhDYW52YXNXaWR0aC9hLnBpeGVsUmF0aW8pLGUuZHJhd2VyLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGEuX29uU2Nyb2xsKSxlLm9uKFwicmVkcmF3XCIsYS5fb25SZWRyYXcpLGUub24oXCJ6b29tXCIsYS5fb25ab29tKSxhLnJlbmRlcigpfSx0aGlzLl9vbldyYXBwZXJDbGljaz1mdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCk7dmFyIHQ9XCJvZmZzZXRYXCJpbiBlP2Uub2Zmc2V0WDplLmxheWVyWDthLmZpcmVFdmVudChcImNsaWNrXCIsdC9hLndyYXBwZXIuc2Nyb2xsV2lkdGh8fDApfX07ZS5leHBvcnRzPXQuZGVmYXVsdH1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci50aW1lbGluZS5taW4uanMubWFwIiwiLyohXG4gKiB3YXZlc3VyZmVyLmpzIDIuMS4wIChNb24gT2N0IDAxIDIwMTggMTE6MzQ6NDkgR01UKzAyMDAgKENlbnRyYWwgRXVyb3BlYW4gU3VtbWVyIFRpbWUpKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2thdHNwYXVnaC93YXZlc3VyZmVyLmpzXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcbiAqL1xuIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJXYXZlU3VyZmVyXCIsW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5XYXZlU3VyZmVyPXQoKTplLldhdmVTdXJmZXI9dCgpfSh3aW5kb3csZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIG49e307ZnVuY3Rpb24gaShlKXtpZihuW2VdKXJldHVybiBuW2VdLmV4cG9ydHM7dmFyIHQ9bltlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHJbZV0uY2FsbCh0LmV4cG9ydHMsdCx0LmV4cG9ydHMsaSksdC5sPSEwLHQuZXhwb3J0c31yZXR1cm4gaS5tPXIsaS5jPW4saS5kPWZ1bmN0aW9uKGUsdCxyKXtpLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxpLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1pKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgbiBpbiB0KWkuZChyLG4sZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxuKSk7cmV0dXJuIHJ9LGkubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gaS5kKHQsXCJhXCIsdCksdH0saS5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxpLnA9XCJcIixpKGkucz00KX0oW2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImFqYXhcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZ2V0SWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwibWF4XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIm1pblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJPYnNlcnZlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJleHRlbmRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic3R5bGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5kZWZhdWx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImZyYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlYm91bmNlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInByZXZlbnRDbGlja1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlZmF1bHR9fSk7dmFyIG49cChyKDUpKSxpPXAocig2KSksYT1wKHIoNykpLHM9cChyKDgpKSxvPXAocigxKSksdT1wKHIoOSkpLGw9cChyKDEwKSksYz1wKHIoMikpLGg9cChyKDExKSksZj1wKHIoMTIpKSxkPXAocigxMykpO2Z1bmN0aW9uIHAoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLmhhbmRsZXJzPW51bGx9dmFyIHQscixuO3JldHVybiB0PWUsKHI9W3trZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpczt0aGlzLmhhbmRsZXJzfHwodGhpcy5oYW5kbGVycz17fSk7dmFyIG49dGhpcy5oYW5kbGVyc1tlXTtyZXR1cm4gbnx8KG49dGhpcy5oYW5kbGVyc1tlXT1bXSksbi5wdXNoKHQpLHtuYW1lOmUsY2FsbGJhY2s6dCx1bjpmdW5jdGlvbihlLHQpe3JldHVybiByLnVuKGUsdCl9fX19LHtrZXk6XCJ1blwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5oYW5kbGVycyl7dmFyIHIsbj10aGlzLmhhbmRsZXJzW2VdO2lmKG4paWYodClmb3Iocj1uLmxlbmd0aC0xOzA8PXI7ci0tKW5bcl09PXQmJm4uc3BsaWNlKHIsMSk7ZWxzZSBuLmxlbmd0aD0wfX19LHtrZXk6XCJ1bkFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oYW5kbGVycz1udWxsfX0se2tleTpcIm9uY2VcIix2YWx1ZTpmdW5jdGlvbihpLGEpe3ZhciBzPXRoaXM7cmV0dXJuIHRoaXMub24oaSxmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkodCksbj0wO248dDtuKyspcltuXT1hcmd1bWVudHNbbl07YS5hcHBseShzLHIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzLnVuKGksZSl9LDApfSl9fSx7a2V5OlwiZmlyZUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkoMTx0P3QtMTowKSxuPTE7bjx0O24rKylyW24tMV09YXJndW1lbnRzW25dO2lmKHRoaXMuaGFuZGxlcnMpe3ZhciBpPXRoaXMuaGFuZGxlcnNbZV07aSYmaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYXBwbHkodm9pZCAwLHIpfSl9fX1dKSYmaSh0LnByb3RvdHlwZSxyKSxuJiZpKHQsbiksZX0oKTt0LmRlZmF1bHQ9bixlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgbj0od2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gc2V0VGltZW91dChlLDFlMy82MCl9KS5iaW5kKHdpbmRvdyk7dC5kZWZhdWx0PW4sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49ZnVuY3Rpb24oZSl7e2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpKXt2YXIgbj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOnt9O24uZ2V0fHxuLnNldD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4pOnRbcl09ZVtyXX1yZXR1cm4gdC5kZWZhdWx0PWUsdH19KHIoMCkpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuKGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIGEoZSx0LHIpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09cixlfWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PWkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZnVuY3Rpb24oZSl7aWYodm9pZCAwIT09ZSlyZXR1cm4gZTt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIil9KGUpOnR9ZnVuY3Rpb24gbyhlKXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gdShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbChlLHQscil7cmV0dXJuIHQmJnUoZS5wcm90b3R5cGUsdCksciYmdShlLHIpLGV9ZnVuY3Rpb24gYyhlLHQpe3JldHVybihjPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX12YXIgaD1cInBsYXlpbmdcIixmPVwicGF1c2VkXCIsZD1cImZpbmlzaGVkXCIscD1mdW5jdGlvbihlKXtmdW5jdGlvbiBpKGUpe3ZhciB0LHIsbjtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGkpLChuPXModGhpcyxvKGkpLmNhbGwodGhpcykpKS5hdWRpb0NvbnRleHQ9bnVsbCxuLm9mZmxpbmVBdWRpb0NvbnRleHQ9bnVsbCxuLnN0YXRlQmVoYXZpb3JzPShhKHQ9e30saCx7aW5pdDpmdW5jdGlvbigpe3RoaXMuYWRkT25BdWRpb1Byb2Nlc3MoKX0sZ2V0UGxheWVkUGVyY2VudHM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldER1cmF0aW9uKCk7cmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKS9lfHwwfSxnZXRDdXJyZW50VGltZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0UG9zaXRpb24rdGhpcy5nZXRQbGF5ZWRUaW1lKCl9fSksYSh0LGYse2luaXQ6ZnVuY3Rpb24oKXt0aGlzLnJlbW92ZU9uQXVkaW9Qcm9jZXNzKCl9LGdldFBsYXllZFBlcmNlbnRzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXREdXJhdGlvbigpO3JldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkvZXx8MH0sZ2V0Q3VycmVudFRpbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydFBvc2l0aW9ufX0pLGEodCxkLHtpbml0OmZ1bmN0aW9uKCl7dGhpcy5yZW1vdmVPbkF1ZGlvUHJvY2VzcygpLHRoaXMuZmlyZUV2ZW50KFwiZmluaXNoXCIpfSxnZXRQbGF5ZWRQZXJjZW50czpmdW5jdGlvbigpe3JldHVybiAxfSxnZXRDdXJyZW50VGltZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldER1cmF0aW9uKCl9fSksdCksbi5wYXJhbXM9ZSxuLmFjPWUuYXVkaW9Db250ZXh0fHxuLmdldEF1ZGlvQ29udGV4dCgpLG4ubGFzdFBsYXk9bi5hYy5jdXJyZW50VGltZSxuLnN0YXJ0UG9zaXRpb249MCxuLnNjaGVkdWxlZFBhdXNlPW51bGwsbi5zdGF0ZXM9KGEocj17fSxoLE9iamVjdC5jcmVhdGUobi5zdGF0ZUJlaGF2aW9yc1toXSkpLGEocixmLE9iamVjdC5jcmVhdGUobi5zdGF0ZUJlaGF2aW9yc1tmXSkpLGEocixkLE9iamVjdC5jcmVhdGUobi5zdGF0ZUJlaGF2aW9yc1tkXSkpLHIpLG4uYW5hbHlzZXI9bnVsbCxuLmJ1ZmZlcj1udWxsLG4uZmlsdGVycz1bXSxuLmdhaW5Ob2RlPW51bGwsbi5tZXJnZWRQZWFrcz1udWxsLG4ub2ZmbGluZUFjPW51bGwsbi5wZWFrcz1udWxsLG4ucGxheWJhY2tSYXRlPTEsbi5hbmFseXNlcj1udWxsLG4uc2NyaXB0Tm9kZT1udWxsLG4uc291cmNlPW51bGwsbi5zcGxpdFBlYWtzPVtdLG4uc3RhdGU9bnVsbCxuLmV4cGxpY2l0RHVyYXRpb249bnVsbCxufXJldHVybiBmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmYyhlLHQpfShpLG4uT2JzZXJ2ZXIpLGwoaSxbe2tleTpcInN1cHBvcnRzV2ViQXVkaW9cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiEoIXdpbmRvdy5BdWRpb0NvbnRleHQmJiF3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KX19LHtrZXk6XCJnZXRBdWRpb0NvbnRleHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dHx8KHdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0PW5ldyh3aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSksd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHR9fSx7a2V5OlwiZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHR8fCh3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQ9bmV3KHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCkoMSwyLGUpKSx3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHR9fV0pLGwoaSxbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3JlYXRlVm9sdW1lTm9kZSgpLHRoaXMuY3JlYXRlU2NyaXB0Tm9kZSgpLHRoaXMuY3JlYXRlQW5hbHlzZXJOb2RlKCksdGhpcy5zZXRTdGF0ZShmKSx0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBhcmFtcy5hdWRpb1JhdGUpLHRoaXMuc2V0TGVuZ3RoKDApfX0se2tleTpcImRpc2Nvbm5lY3RGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZpbHRlcnMmJih0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlJiZlLmRpc2Nvbm5lY3QoKX0pLHRoaXMuZmlsdGVycz1udWxsLHRoaXMuYW5hbHlzZXIuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKSl9fSx7a2V5Olwic2V0U3RhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnN0YXRlIT09dGhpcy5zdGF0ZXNbZV0mJih0aGlzLnN0YXRlPXRoaXMuc3RhdGVzW2VdLHRoaXMuc3RhdGUuaW5pdC5jYWxsKHRoaXMpKX19LHtrZXk6XCJzZXRGaWx0ZXJcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3RoaXMuc2V0RmlsdGVycyh0KX19LHtrZXk6XCJzZXRGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5kaXNjb25uZWN0RmlsdGVycygpLGUmJmUubGVuZ3RoJiYodGhpcy5maWx0ZXJzPWUsdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCksZS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb25uZWN0KHQpLHR9LHRoaXMuYW5hbHlzZXIpLmNvbm5lY3QodGhpcy5nYWluTm9kZSkpfX0se2tleTpcImNyZWF0ZVNjcmlwdE5vZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyYW1zLmF1ZGlvU2NyaXB0UHJvY2Vzc29yP3RoaXMuc2NyaXB0Tm9kZT10aGlzLnBhcmFtcy5hdWRpb1NjcmlwdFByb2Nlc3Nvcjp0aGlzLmFjLmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcj90aGlzLnNjcmlwdE5vZGU9dGhpcy5hYy5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoaS5zY3JpcHRCdWZmZXJTaXplKTp0aGlzLnNjcmlwdE5vZGU9dGhpcy5hYy5jcmVhdGVKYXZhU2NyaXB0Tm9kZShpLnNjcmlwdEJ1ZmZlclNpemUpLHRoaXMuc2NyaXB0Tm9kZS5jb25uZWN0KHRoaXMuYWMuZGVzdGluYXRpb24pfX0se2tleTpcImFkZE9uQXVkaW9Qcm9jZXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2Vzcz1mdW5jdGlvbigpe3ZhciBlPXQuZ2V0Q3VycmVudFRpbWUoKTtlPj10LmdldER1cmF0aW9uKCk/KHQuc2V0U3RhdGUoZCksdC5maXJlRXZlbnQoXCJwYXVzZVwiKSk6ZT49dC5zY2hlZHVsZWRQYXVzZT90LnBhdXNlKCk6dC5zdGF0ZT09PXQuc3RhdGVzW2hdJiZ0LmZpcmVFdmVudChcImF1ZGlvcHJvY2Vzc1wiLGUpfX19LHtrZXk6XCJyZW1vdmVPbkF1ZGlvUHJvY2Vzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzPW51bGx9fSx7a2V5OlwiY3JlYXRlQW5hbHlzZXJOb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmFuYWx5c2VyPXRoaXMuYWMuY3JlYXRlQW5hbHlzZXIoKSx0aGlzLmFuYWx5c2VyLmNvbm5lY3QodGhpcy5nYWluTm9kZSl9fSx7a2V5OlwiY3JlYXRlVm9sdW1lTm9kZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hYy5jcmVhdGVHYWluP3RoaXMuZ2Fpbk5vZGU9dGhpcy5hYy5jcmVhdGVHYWluKCk6dGhpcy5nYWluTm9kZT10aGlzLmFjLmNyZWF0ZUdhaW5Ob2RlKCksdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMuYWMuZGVzdGluYXRpb24pfX0se2tleTpcInNldFNpbmtJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciB0PW5ldyB3aW5kb3cuQXVkaW87aWYoIXQuc2V0U2lua0lkKXJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzZXRTaW5rSWQgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXJcIikpO3QuYXV0b3BsYXk9ITA7dmFyIHI9dGhpcy5hYy5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7cmV0dXJuIHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpLHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChyKSx0LnNyY09iamVjdD1yLnN0cmVhbSx0LnNldFNpbmtJZChlKX1yZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXZpY2VJZDogXCIrZSkpfX0se2tleTpcInNldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShlLHRoaXMuYWMuY3VycmVudFRpbWUpfX0se2tleTpcImdldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZX19LHtrZXk6XCJkZWNvZGVBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXt0aGlzLm9mZmxpbmVBY3x8KHRoaXMub2ZmbGluZUFjPXRoaXMuZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dCh0aGlzLmFjJiZ0aGlzLmFjLnNhbXBsZVJhdGU/dGhpcy5hYy5zYW1wbGVSYXRlOjQ0MTAwKSksdGhpcy5vZmZsaW5lQWMuZGVjb2RlQXVkaW9EYXRhKGUsZnVuY3Rpb24oZSl7cmV0dXJuIHQoZSl9LHIpfX0se2tleTpcInNldFBlYWtzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmV4cGxpY2l0RHVyYXRpb249dCx0aGlzLnBlYWtzPWV9fSx7a2V5Olwic2V0TGVuZ3RoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIXRoaXMubWVyZ2VkUGVha3N8fGUhPTIqdGhpcy5tZXJnZWRQZWFrcy5sZW5ndGgtMSsyKXt0aGlzLnNwbGl0UGVha3M9W10sdGhpcy5tZXJnZWRQZWFrcz1bXTt2YXIgdCxyPXRoaXMuYnVmZmVyP3RoaXMuYnVmZmVyLm51bWJlck9mQ2hhbm5lbHM6MTtmb3IodD0wO3Q8cjt0KyspdGhpcy5zcGxpdFBlYWtzW3RdPVtdLHRoaXMuc3BsaXRQZWFrc1t0XVsyKihlLTEpXT0wLHRoaXMuc3BsaXRQZWFrc1t0XVsyKihlLTEpKzFdPTA7dGhpcy5tZXJnZWRQZWFrc1syKihlLTEpXT0wLHRoaXMubWVyZ2VkUGVha3NbMiooZS0xKSsxXT0wfX19LHtrZXk6XCJnZXRQZWFrc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXtpZih0aGlzLnBlYWtzKXJldHVybiB0aGlzLnBlYWtzO2lmKHQ9dHx8MCxyPXJ8fGUtMSx0aGlzLnNldExlbmd0aChlKSwhdGhpcy5idWZmZXIubGVuZ3RoKXt2YXIgbj10aGlzLmNyZWF0ZUJ1ZmZlcigxLDQwOTYsdGhpcy5zYW1wbGVSYXRlKTt0aGlzLmJ1ZmZlcj1uLmJ1ZmZlcn12YXIgaSxhPXRoaXMuYnVmZmVyLmxlbmd0aC9lLHM9fn4oYS8xMCl8fDEsbz10aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO2ZvcihpPTA7aTxvO2krKyl7dmFyIHU9dGhpcy5zcGxpdFBlYWtzW2ldLGw9dGhpcy5idWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSksYz12b2lkIDA7Zm9yKGM9dDtjPD1yO2MrKyl7dmFyIGg9fn4oYyphKSxmPX5+KGgrYSksZD0wLHA9MCx2PXZvaWQgMDtmb3Iodj1oO3Y8Zjt2Kz1zKXt2YXIgeT1sW3ZdO3A8eSYmKHA9eSkseTxkJiYoZD15KX11WzIqY109cCx1WzIqYysxXT1kLCgwPT1pfHxwPnRoaXMubWVyZ2VkUGVha3NbMipjXSkmJih0aGlzLm1lcmdlZFBlYWtzWzIqY109cCksKDA9PWl8fGQ8dGhpcy5tZXJnZWRQZWFrc1syKmMrMV0pJiYodGhpcy5tZXJnZWRQZWFrc1syKmMrMV09ZCl9fXJldHVybiB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzP3RoaXMuc3BsaXRQZWFrczp0aGlzLm1lcmdlZFBlYWtzfX0se2tleTpcImdldFBsYXllZFBlcmNlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5nZXRQbGF5ZWRQZXJjZW50cy5jYWxsKHRoaXMpfX0se2tleTpcImRpc2Nvbm5lY3RTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc291cmNlJiZ0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZCgpfHx0aGlzLnBhdXNlKCksdGhpcy51bkFsbCgpLHRoaXMuYnVmZmVyPW51bGwsdGhpcy5kaXNjb25uZWN0RmlsdGVycygpLHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpLHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpLHRoaXMuc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCksdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCksdGhpcy5wYXJhbXMuY2xvc2VBdWRpb0NvbnRleHQmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmFjLmNsb3NlJiZcImNsb3NlZFwiIT10aGlzLmFjLnN0YXRlJiZ0aGlzLmFjLmNsb3NlKCksdGhpcy5hYz1udWxsLHRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dD90aGlzLnBhcmFtcy5hdWRpb0NvbnRleHQ9bnVsbDp3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dD1udWxsLHdpbmRvdy5XYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dD1udWxsKX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5zdGFydFBvc2l0aW9uPTAsdGhpcy5sYXN0UGxheT10aGlzLmFjLmN1cnJlbnRUaW1lLHRoaXMuYnVmZmVyPWUsdGhpcy5jcmVhdGVTb3VyY2UoKX19LHtrZXk6XCJjcmVhdGVTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGlzY29ubmVjdFNvdXJjZSgpLHRoaXMuc291cmNlPXRoaXMuYWMuY3JlYXRlQnVmZmVyU291cmNlKCksdGhpcy5zb3VyY2Uuc3RhcnQ9dGhpcy5zb3VyY2Uuc3RhcnR8fHRoaXMuc291cmNlLm5vdGVHcmFpbk9uLHRoaXMuc291cmNlLnN0b3A9dGhpcy5zb3VyY2Uuc3RvcHx8dGhpcy5zb3VyY2Uubm90ZU9mZix0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUodGhpcy5wbGF5YmFja1JhdGUsdGhpcy5hYy5jdXJyZW50VGltZSksdGhpcy5zb3VyY2UuYnVmZmVyPXRoaXMuYnVmZmVyLHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5hbmFseXNlcil9fSx7a2V5OlwiaXNQYXVzZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlIT09dGhpcy5zdGF0ZXNbaF19fSx7a2V5OlwiZ2V0RHVyYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1ZmZlcj90aGlzLmJ1ZmZlci5kdXJhdGlvbjp0aGlzLmV4cGxpY2l0RHVyYXRpb24/dGhpcy5leHBsaWNpdER1cmF0aW9uOjB9fSx7a2V5Olwic2Vla1RvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmJ1ZmZlcilyZXR1cm4odGhpcy5zY2hlZHVsZWRQYXVzZT1udWxsKT09ZSYmKGU9dGhpcy5nZXRDdXJyZW50VGltZSgpKT49dGhpcy5nZXREdXJhdGlvbigpJiYoZT0wKSxudWxsPT10JiYodD10aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuc3RhcnRQb3NpdGlvbj1lLHRoaXMubGFzdFBsYXk9dGhpcy5hYy5jdXJyZW50VGltZSx0aGlzLnN0YXRlPT09dGhpcy5zdGF0ZXNbZF0mJnRoaXMuc2V0U3RhdGUoZikse3N0YXJ0OmUsZW5kOnR9fX0se2tleTpcImdldFBsYXllZFRpbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybih0aGlzLmFjLmN1cnJlbnRUaW1lLXRoaXMubGFzdFBsYXkpKnRoaXMucGxheWJhY2tSYXRlfX0se2tleTpcInBsYXlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKHRoaXMuYnVmZmVyKXt0aGlzLmNyZWF0ZVNvdXJjZSgpO3ZhciByPXRoaXMuc2Vla1RvKGUsdCk7ZT1yLnN0YXJ0LHQ9ci5lbmQsdGhpcy5zY2hlZHVsZWRQYXVzZT10LHRoaXMuc291cmNlLnN0YXJ0KDAsZSx0LWUpLFwic3VzcGVuZGVkXCI9PXRoaXMuYWMuc3RhdGUmJnRoaXMuYWMucmVzdW1lJiZ0aGlzLmFjLnJlc3VtZSgpLHRoaXMuc2V0U3RhdGUoaCksdGhpcy5maXJlRXZlbnQoXCJwbGF5XCIpfX19LHtrZXk6XCJwYXVzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZWRQYXVzZT1udWxsLHRoaXMuc3RhcnRQb3NpdGlvbis9dGhpcy5nZXRQbGF5ZWRUaW1lKCksdGhpcy5zb3VyY2UmJnRoaXMuc291cmNlLnN0b3AoMCksdGhpcy5zZXRTdGF0ZShmKSx0aGlzLmZpcmVFdmVudChcInBhdXNlXCIpfX0se2tleTpcImdldEN1cnJlbnRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5nZXRDdXJyZW50VGltZS5jYWxsKHRoaXMpfX0se2tleTpcImdldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlfX0se2tleTpcInNldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2U9ZXx8MSx0aGlzLmlzUGF1c2VkKCk/dGhpcy5wbGF5YmFja1JhdGU9ZToodGhpcy5wYXVzZSgpLHRoaXMucGxheWJhY2tSYXRlPWUsdGhpcy5wbGF5KCkpfX1dKSxpfSgpOyh0LmRlZmF1bHQ9cCkuc2NyaXB0QnVmZmVyU2l6ZT0yNTYsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIGk9ZnVuY3Rpb24oZSl7e2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpKXt2YXIgbj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOnt9O24uZ2V0fHxuLnNldD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4pOnRbcl09ZVtyXX1yZXR1cm4gdC5kZWZhdWx0PWUsdH19KHIoMCkpLGE9bihyKDE0KSkscz1uKHIoMykpLG89bihyKDE2KSksdT1uKHIoMTcpKTtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBsKGUpe3JldHVybihsPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1sKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2QoZSk6dH1mdW5jdGlvbiBoKGUpe3JldHVybihoPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuKGY9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIGQoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gcChlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gdihlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24geShlLHQscil7cmV0dXJuIHQmJnYoZS5wcm90b3R5cGUsdCksciYmdihlLHIpLGV9dmFyIG09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlKXt2YXIgdDtpZihwKHRoaXMsbiksKHQ9Yyh0aGlzLGgobikuY2FsbCh0aGlzKSkpLmRlZmF1bHRQYXJhbXM9e2F1ZGlvQ29udGV4dDpudWxsLGF1ZGlvUmF0ZToxLGF1dG9DZW50ZXI6ITAsYmFja2VuZDpcIldlYkF1ZGlvXCIsYmFySGVpZ2h0OjEsYmFyR2FwOm51bGwsY29udGFpbmVyOm51bGwsY3Vyc29yQ29sb3I6XCIjMzMzXCIsY3Vyc29yV2lkdGg6MSxkcmFnU2VsZWN0aW9uOiEwLGZpbGxQYXJlbnQ6ITAsZm9yY2VEZWNvZGU6ITEsaGVpZ2h0OjEyOCxoaWRlU2Nyb2xsYmFyOiExLGludGVyYWN0OiEwLGxvb3BTZWxlY3Rpb246ITAsbWF4Q2FudmFzV2lkdGg6NGUzLG1lZGlhQ29udGFpbmVyOm51bGwsbWVkaWFDb250cm9sczohMSxtZWRpYVR5cGU6XCJhdWRpb1wiLG1pblB4UGVyU2VjOjIwLG5vcm1hbGl6ZTohMSxwYXJ0aWFsUmVuZGVyOiExLHBpeGVsUmF0aW86d2luZG93LmRldmljZVBpeGVsUmF0aW98fHNjcmVlbi5kZXZpY2VYRFBJL3NjcmVlbi5sb2dpY2FsWERQSSxwbHVnaW5zOltdLHByb2dyZXNzQ29sb3I6XCIjNTU1XCIscmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95OiEwLHJlbmRlcmVyOmEuZGVmYXVsdCxyZXNwb25zaXZlOiExLHNjcm9sbFBhcmVudDohMSxza2lwTGVuZ3RoOjIsc3BsaXRDaGFubmVsczohMSx3YXZlQ29sb3I6XCIjOTk5XCIseGhyOnt9fSx0LmJhY2tlbmRzPXtNZWRpYUVsZW1lbnQ6by5kZWZhdWx0LFdlYkF1ZGlvOnMuZGVmYXVsdH0sdC51dGlsPWksdC5wYXJhbXM9aS5leHRlbmQoe30sdC5kZWZhdWx0UGFyYW1zLGUpLHQuY29udGFpbmVyPVwic3RyaW5nXCI9PXR5cGVvZiBlLmNvbnRhaW5lcj9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQucGFyYW1zLmNvbnRhaW5lcik6dC5wYXJhbXMuY29udGFpbmVyLCF0LmNvbnRhaW5lcil0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgZWxlbWVudCBub3QgZm91bmRcIik7aWYobnVsbD09dC5wYXJhbXMubWVkaWFDb250YWluZXI/dC5tZWRpYUNvbnRhaW5lcj10LmNvbnRhaW5lcjpcInN0cmluZ1wiPT10eXBlb2YgdC5wYXJhbXMubWVkaWFDb250YWluZXI/dC5tZWRpYUNvbnRhaW5lcj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQucGFyYW1zLm1lZGlhQ29udGFpbmVyKTp0Lm1lZGlhQ29udGFpbmVyPXQucGFyYW1zLm1lZGlhQ29udGFpbmVyLCF0Lm1lZGlhQ29udGFpbmVyKXRocm93IG5ldyBFcnJvcihcIk1lZGlhIENvbnRhaW5lciBlbGVtZW50IG5vdCBmb3VuZFwiKTtpZih0LnBhcmFtcy5tYXhDYW52YXNXaWR0aDw9MSl0aHJvdyBuZXcgRXJyb3IoXCJtYXhDYW52YXNXaWR0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpO2lmKHQucGFyYW1zLm1heENhbnZhc1dpZHRoJTI9PTEpdGhyb3cgbmV3IEVycm9yKFwibWF4Q2FudmFzV2lkdGggbXVzdCBiZSBhbiBldmVuIG51bWJlclwiKTtpZih0LnNhdmVkVm9sdW1lPTAsdC5pc011dGVkPSExLHQudG1wRXZlbnRzPVtdLHQuY3VycmVudEFqYXg9bnVsbCx0LmFycmF5YnVmZmVyPW51bGwsdC5kcmF3ZXI9bnVsbCx0LmJhY2tlbmQ9bnVsbCx0LnBlYWtDYWNoZT1udWxsLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQucGFyYW1zLnJlbmRlcmVyKXRocm93IG5ldyBFcnJvcihcIlJlbmRlcmVyIHBhcmFtZXRlciBpcyBpbnZhbGlkXCIpO3QuRHJhd2VyPXQucGFyYW1zLnJlbmRlcmVyLHQuQmFja2VuZD10LmJhY2tlbmRzW3QucGFyYW1zLmJhY2tlbmRdLHQuaW5pdGlhbGlzZWRQbHVnaW5MaXN0PXt9LHQuaXNEZXN0cm95ZWQ9ITEsdC5pc1JlYWR5PSExO3ZhciByPTA7cmV0dXJuIHQuX29uUmVzaXplPWkuZGVib3VuY2UoZnVuY3Rpb24oKXtyPT10LmRyYXdlci53cmFwcGVyLmNsaWVudFdpZHRofHx0LnBhcmFtcy5zY3JvbGxQYXJlbnR8fChyPXQuZHJhd2VyLndyYXBwZXIuY2xpZW50V2lkdGgsdC5kcmF3ZXIuZmlyZUV2ZW50KFwicmVkcmF3XCIpKX0sXCJudW1iZXJcIj09dHlwZW9mIHQucGFyYW1zLnJlc3BvbnNpdmU/dC5wYXJhbXMucmVzcG9uc2l2ZToxMDApLGModCxkKGQodCkpKX1yZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJmYoZSx0KX0obixpLk9ic2VydmVyKSx5KG4sbnVsbCxbe2tleTpcImNyZWF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgbihlKS5pbml0KCl9fV0pLHkobixbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlZ2lzdGVyUGx1Z2lucyh0aGlzLnBhcmFtcy5wbHVnaW5zKSx0aGlzLmNyZWF0ZURyYXdlcigpLHRoaXMuY3JlYXRlQmFja2VuZCgpLHRoaXMuY3JlYXRlUGVha0NhY2hlKCksdGhpc319LHtrZXk6XCJyZWdpc3RlclBsdWdpbnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWRkUGx1Z2luKGUpfSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZGVmZXJJbml0fHx0LmluaXRQbHVnaW4oZS5uYW1lKX0pLHRoaXMuZmlyZUV2ZW50KFwicGx1Z2lucy1yZWdpc3RlcmVkXCIsZSksdGhpc319LHtrZXk6XCJhZGRQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10aGlzO2lmKCF0Lm5hbWUpdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIGRvZXMgbm90IGhhdmUgYSBuYW1lIVwiKTtpZighdC5pbnN0YW5jZSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KHQubmFtZSxcIiBkb2VzIG5vdCBoYXZlIGFuIGluc3RhbmNlIHByb3BlcnR5IVwiKSk7dC5zdGF0aWNQcm9wcyYmT2JqZWN0LmtleXModC5zdGF0aWNQcm9wcykuZm9yRWFjaChmdW5jdGlvbihlKXtyW2VdPXQuc3RhdGljUHJvcHNbZV19KTt2YXIgbj10Lmluc3RhbmNlO3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpLk9ic2VydmVyLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbihlKXtuLnByb3RvdHlwZVtlXT1pLk9ic2VydmVyLnByb3RvdHlwZVtlXX0pLHRoaXNbdC5uYW1lXT1uZXcgbih0LnBhcmFtc3x8e30sdGhpcyksdGhpcy5maXJlRXZlbnQoXCJwbHVnaW4tYWRkZWRcIix0Lm5hbWUpLHRoaXN9fSx7a2V5OlwiaW5pdFBsdWdpblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCF0aGlzW2VdKXRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQoZSxcIiBoYXMgbm90IGJlZW4gYWRkZWQgeWV0IVwiKSk7cmV0dXJuIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W2VdJiZ0aGlzLmRlc3Ryb3lQbHVnaW4oZSksdGhpc1tlXS5pbml0KCksdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbZV09ITAsdGhpcy5maXJlRXZlbnQoXCJwbHVnaW4taW5pdGlhbGlzZWRcIixlKSx0aGlzfX0se2tleTpcImRlc3Ryb3lQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbihlKXtpZighdGhpc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHlldCBhbmQgY2Fubm90IGJlIGRlc3Ryb3llZCFcIikpO2lmKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtlXSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgaXMgbm90IGFjdGl2ZSBhbmQgY2Fubm90IGJlIGRlc3Ryb3llZCFcIikpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXNbZV0uZGVzdHJveSl0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KGUsXCIgZG9lcyBub3QgaGF2ZSBhIGRlc3Ryb3kgZnVuY3Rpb24hXCIpKTtyZXR1cm4gdGhpc1tlXS5kZXN0cm95KCksZGVsZXRlIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W2VdLHRoaXMuZmlyZUV2ZW50KFwicGx1Z2luLWRlc3Ryb3llZFwiLGUpLHRoaXN9fSx7a2V5OlwiZGVzdHJveUFsbFBsdWdpbnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7T2JqZWN0LmtleXModGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuZGVzdHJveVBsdWdpbihlKX0pfX0se2tleTpcImNyZWF0ZURyYXdlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9dGhpczt0aGlzLmRyYXdlcj1uZXcgdGhpcy5EcmF3ZXIodGhpcy5jb250YWluZXIsdGhpcy5wYXJhbXMpLHRoaXMuZHJhd2VyLmluaXQoKSx0aGlzLmZpcmVFdmVudChcImRyYXdlci1jcmVhdGVkXCIsdGhpcy5kcmF3ZXIpLCExIT09dGhpcy5wYXJhbXMucmVzcG9uc2l2ZSYmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fb25SZXNpemUsITApLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLl9vblJlc2l6ZSwhMCkpLHRoaXMuZHJhd2VyLm9uKFwicmVkcmF3XCIsZnVuY3Rpb24oKXtyLmRyYXdCdWZmZXIoKSxyLmRyYXdlci5wcm9ncmVzcyhyLmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSl9KSx0aGlzLmRyYXdlci5vbihcImNsaWNrXCIsZnVuY3Rpb24oZSx0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHIuc2Vla1RvKHQpfSwwKX0pLHRoaXMuZHJhd2VyLm9uKFwic2Nyb2xsXCIsZnVuY3Rpb24oZSl7ci5wYXJhbXMucGFydGlhbFJlbmRlciYmci5kcmF3QnVmZmVyKCksci5maXJlRXZlbnQoXCJzY3JvbGxcIixlKX0pfX0se2tleTpcImNyZWF0ZUJhY2tlbmRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5iYWNrZW5kJiZ0aGlzLmJhY2tlbmQuZGVzdHJveSgpLFwiQXVkaW9FbGVtZW50XCI9PXRoaXMucGFyYW1zLmJhY2tlbmQmJih0aGlzLnBhcmFtcy5iYWNrZW5kPVwiTWVkaWFFbGVtZW50XCIpLFwiV2ViQXVkaW9cIiE9dGhpcy5wYXJhbXMuYmFja2VuZHx8dGhpcy5CYWNrZW5kLnByb3RvdHlwZS5zdXBwb3J0c1dlYkF1ZGlvLmNhbGwobnVsbCl8fCh0aGlzLnBhcmFtcy5iYWNrZW5kPVwiTWVkaWFFbGVtZW50XCIpLHRoaXMuYmFja2VuZD1uZXcgdGhpcy5CYWNrZW5kKHRoaXMucGFyYW1zKSx0aGlzLmJhY2tlbmQuaW5pdCgpLHRoaXMuZmlyZUV2ZW50KFwiYmFja2VuZC1jcmVhdGVkXCIsdGhpcy5iYWNrZW5kKSx0aGlzLmJhY2tlbmQub24oXCJmaW5pc2hcIixmdW5jdGlvbigpe3JldHVybiB0LmZpcmVFdmVudChcImZpbmlzaFwiKX0pLHRoaXMuYmFja2VuZC5vbihcInBsYXlcIixmdW5jdGlvbigpe3JldHVybiB0LmZpcmVFdmVudChcInBsYXlcIil9KSx0aGlzLmJhY2tlbmQub24oXCJwYXVzZVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZmlyZUV2ZW50KFwicGF1c2VcIil9KSx0aGlzLmJhY2tlbmQub24oXCJhdWRpb3Byb2Nlc3NcIixmdW5jdGlvbihlKXt0LmRyYXdlci5wcm9ncmVzcyh0LmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSksdC5maXJlRXZlbnQoXCJhdWRpb3Byb2Nlc3NcIixlKX0pfX0se2tleTpcImNyZWF0ZVBlYWtDYWNoZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wYXJhbXMucGFydGlhbFJlbmRlciYmKHRoaXMucGVha0NhY2hlPW5ldyB1LmRlZmF1bHQpfX0se2tleTpcImdldER1cmF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmdldER1cmF0aW9uKCl9fSx7a2V5OlwiZ2V0Q3VycmVudFRpbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuZ2V0Q3VycmVudFRpbWUoKX19LHtrZXk6XCJzZXRDdXJyZW50VGltZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2U+PXRoaXMuZ2V0RHVyYXRpb24oKT90aGlzLnNlZWtUbygxKTp0aGlzLnNlZWtUbyhlL3RoaXMuZ2V0RHVyYXRpb24oKSl9fSx7a2V5OlwicGxheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5maXJlRXZlbnQoXCJpbnRlcmFjdGlvblwiLGZ1bmN0aW9uKCl7cmV0dXJuIHIucGxheShlLHQpfSksdGhpcy5iYWNrZW5kLnBsYXkoZSx0KX19LHtrZXk6XCJwYXVzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuYmFja2VuZC5pc1BhdXNlZCgpKXJldHVybiB0aGlzLmJhY2tlbmQucGF1c2UoKX19LHtrZXk6XCJwbGF5UGF1c2VcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKT90aGlzLnBsYXkoKTp0aGlzLnBhdXNlKCl9fSx7a2V5OlwiaXNQbGF5aW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCl9fSx7a2V5Olwic2tpcEJhY2t3YXJkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5za2lwKC1lfHwtdGhpcy5wYXJhbXMuc2tpcExlbmd0aCl9fSx7a2V5Olwic2tpcEZvcndhcmRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNraXAoZXx8dGhpcy5wYXJhbXMuc2tpcExlbmd0aCl9fSx7a2V5Olwic2tpcFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0RHVyYXRpb24oKXx8MSxyPXRoaXMuZ2V0Q3VycmVudFRpbWUoKXx8MDtyPU1hdGgubWF4KDAsTWF0aC5taW4odCxyKyhlfHwwKSkpLHRoaXMuc2Vla0FuZENlbnRlcihyL3QpfX0se2tleTpcInNlZWtBbmRDZW50ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNlZWtUbyhlKSx0aGlzLmRyYXdlci5yZWNlbnRlcihlKX19LHtrZXk6XCJzZWVrVG9cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHwhaXNGaW5pdGUoZSl8fGU8MHx8MTxlKXJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyB3YXZlc3VyZmVyLnNlZWtUbywgcGFyYW1ldGVyIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIVwiKTt0aGlzLmZpcmVFdmVudChcImludGVyYWN0aW9uXCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5zZWVrVG8oZSl9KTt2YXIgcj10aGlzLmJhY2tlbmQuaXNQYXVzZWQoKTtyfHx0aGlzLmJhY2tlbmQucGF1c2UoKTt2YXIgbj10aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PSExLHRoaXMuYmFja2VuZC5zZWVrVG8oZSp0aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuZHJhd2VyLnByb2dyZXNzKGUpLHJ8fHRoaXMuYmFja2VuZC5wbGF5KCksdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PW4sdGhpcy5maXJlRXZlbnQoXCJzZWVrXCIsZSl9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wYXVzZSgpLHRoaXMuc2Vla1RvKDApLHRoaXMuZHJhd2VyLnByb2dyZXNzKDApfX0se2tleTpcInNldFNpbmtJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmJhY2tlbmQuc2V0U2lua0lkKGUpfX0se2tleTpcInNldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYmFja2VuZC5zZXRWb2x1bWUoZSksdGhpcy5maXJlRXZlbnQoXCJ2b2x1bWVcIixlKX19LHtrZXk6XCJnZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuZ2V0Vm9sdW1lKCl9fSx7a2V5Olwic2V0UGxheWJhY2tSYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5iYWNrZW5kLnNldFBsYXliYWNrUmF0ZShlKX19LHtrZXk6XCJnZXRQbGF5YmFja1JhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tlbmQuZ2V0UGxheWJhY2tSYXRlKCl9fSx7a2V5OlwidG9nZ2xlTXV0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXRNdXRlKCF0aGlzLmlzTXV0ZWQpfX0se2tleTpcInNldE11dGVcIix2YWx1ZTpmdW5jdGlvbihlKXtlIT09dGhpcy5pc011dGVkJiYoZT8odGhpcy5zYXZlZFZvbHVtZT10aGlzLmJhY2tlbmQuZ2V0Vm9sdW1lKCksdGhpcy5iYWNrZW5kLnNldFZvbHVtZSgwKSx0aGlzLmlzTXV0ZWQ9ITAsdGhpcy5maXJlRXZlbnQoXCJ2b2x1bWVcIiwwKSk6KHRoaXMuYmFja2VuZC5zZXRWb2x1bWUodGhpcy5zYXZlZFZvbHVtZSksdGhpcy5pc011dGVkPSExLHRoaXMuZmlyZUV2ZW50KFwidm9sdW1lXCIsdGhpcy5zYXZlZFZvbHVtZSkpKSx0aGlzLmZpcmVFdmVudChcIm11dGVcIix0aGlzLmlzTXV0ZWQpfX0se2tleTpcImdldE11dGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTXV0ZWR9fSx7a2V5OlwiaXNSZWFkeVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSZWFkeX19LHtrZXk6XCJnZXRGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmZpbHRlcnN8fFtdfX0se2tleTpcInRvZ2dsZVNjcm9sbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50PSF0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQsdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwidG9nZ2xlSW50ZXJhY3Rpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyYW1zLmludGVyYWN0PSF0aGlzLnBhcmFtcy5pbnRlcmFjdH19LHtrZXk6XCJnZXRXYXZlQ29sb3JcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtcy53YXZlQ29sb3J9fSx7a2V5Olwic2V0V2F2ZUNvbG9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMud2F2ZUNvbG9yPWUsdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwiZ2V0UHJvZ3Jlc3NDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyYW1zLnByb2dyZXNzQ29sb3J9fSx7a2V5Olwic2V0UHJvZ3Jlc3NDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGFyYW1zLnByb2dyZXNzQ29sb3I9ZSx0aGlzLmRyYXdCdWZmZXIoKX19LHtrZXk6XCJnZXRDdXJzb3JDb2xvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyYW1zLmN1cnNvckNvbG9yfX0se2tleTpcInNldEN1cnNvckNvbG9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMuY3Vyc29yQ29sb3I9ZSx0aGlzLmRyYXdlci51cGRhdGVDdXJzb3IoKX19LHtrZXk6XCJnZXRIZWlnaHRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtcy5oZWlnaHR9fSx7a2V5Olwic2V0SGVpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXMuaGVpZ2h0PWUsdGhpcy5kcmF3ZXIuc2V0SGVpZ2h0KGUqdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyksdGhpcy5kcmF3QnVmZmVyKCl9fSx7a2V5OlwiZHJhd0J1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD1NYXRoLnJvdW5kKHRoaXMuZ2V0RHVyYXRpb24oKSp0aGlzLnBhcmFtcy5taW5QeFBlclNlYyp0aGlzLnBhcmFtcy5waXhlbFJhdGlvKSxyPXRoaXMuZHJhd2VyLmdldFdpZHRoKCksbj10LGk9dGhpcy5kcmF3ZXIuZ2V0U2Nyb2xsWCgpLGE9TWF0aC5tYXgoaStyLG4pO2lmKHRoaXMucGFyYW1zLmZpbGxQYXJlbnQmJighdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50fHx0PHIpJiYoaT0wLGE9bj1yKSx0aGlzLnBhcmFtcy5wYXJ0aWFsUmVuZGVyKXt2YXIgcyxvPXRoaXMucGVha0NhY2hlLmFkZFJhbmdlVG9QZWFrQ2FjaGUobixpLGEpO2ZvcihzPTA7czxvLmxlbmd0aDtzKyspZT10aGlzLmJhY2tlbmQuZ2V0UGVha3MobixvW3NdWzBdLG9bc11bMV0pLHRoaXMuZHJhd2VyLmRyYXdQZWFrcyhlLG4sb1tzXVswXSxvW3NdWzFdKX1lbHNlIGU9dGhpcy5iYWNrZW5kLmdldFBlYWtzKG4saSxhKSx0aGlzLmRyYXdlci5kcmF3UGVha3MoZSxuLGksYSk7dGhpcy5maXJlRXZlbnQoXCJyZWRyYXdcIixlLG4pfX0se2tleTpcInpvb21cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQ9ZT8odGhpcy5wYXJhbXMubWluUHhQZXJTZWM9ZSwhMCk6KHRoaXMucGFyYW1zLm1pblB4UGVyU2VjPXRoaXMuZGVmYXVsdFBhcmFtcy5taW5QeFBlclNlYywhMSksdGhpcy5kcmF3QnVmZmVyKCksdGhpcy5kcmF3ZXIucHJvZ3Jlc3ModGhpcy5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpLHRoaXMuZHJhd2VyLnJlY2VudGVyKHRoaXMuZ2V0Q3VycmVudFRpbWUoKS90aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuZmlyZUV2ZW50KFwiem9vbVwiLGUpfX0se2tleTpcImxvYWRBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5kZWNvZGVBcnJheUJ1ZmZlcihlLGZ1bmN0aW9uKGUpe3QuaXNEZXN0cm95ZWR8fHQubG9hZERlY29kZWRCdWZmZXIoZSl9KX19LHtrZXk6XCJsb2FkRGVjb2RlZEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYmFja2VuZC5sb2FkKGUpLHRoaXMuZHJhd0J1ZmZlcigpLHRoaXMuZmlyZUV2ZW50KFwicmVhZHlcIiksdGhpcy5pc1JlYWR5PSEwfX0se2tleTpcImxvYWRCbG9iXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPW5ldyBGaWxlUmVhZGVyO3IuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQub25Qcm9ncmVzcyhlKX0pLHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5sb2FkQXJyYXlCdWZmZXIoZS50YXJnZXQucmVzdWx0KX0pLHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5maXJlRXZlbnQoXCJlcnJvclwiLFwiRXJyb3IgcmVhZGluZyBmaWxlXCIpfSksci5yZWFkQXNBcnJheUJ1ZmZlcihlKSx0aGlzLmVtcHR5KCl9fSx7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe2lmKHRoaXMuZW1wdHkoKSxyKXt2YXIgaT17XCJQcmVsb2FkIGlzIG5vdCAnYXV0bycsICdub25lJyBvciAnbWV0YWRhdGEnXCI6LTE9PT1bXCJhdXRvXCIsXCJtZXRhZGF0YVwiLFwibm9uZVwiXS5pbmRleE9mKHIpLFwiUGVha3MgYXJlIG5vdCBwcm92aWRlZFwiOiF0LFwiQmFja2VuZCBpcyBub3Qgb2YgdHlwZSBNZWRpYUVsZW1lbnRcIjpcIk1lZGlhRWxlbWVudFwiIT09dGhpcy5wYXJhbXMuYmFja2VuZCxcIlVybCBpcyBub3Qgb2YgdHlwZSBzdHJpbmdcIjpcInN0cmluZ1wiIT10eXBlb2YgZX0sYT1PYmplY3Qua2V5cyhpKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGlbZV19KTthLmxlbmd0aCYmKGNvbnNvbGUud2FybihcIlByZWxvYWQgcGFyYW1ldGVyIG9mIHdhdmVzdXJmZXIubG9hZCB3aWxsIGJlIGlnbm9yZWQgYmVjYXVzZTpcXG5cXHQtIFwiK2Euam9pbihcIlxcblxcdC0gXCIpKSxyPW51bGwpfXN3aXRjaCh0aGlzLnBhcmFtcy5iYWNrZW5kKXtjYXNlXCJXZWJBdWRpb1wiOnJldHVybiB0aGlzLmxvYWRCdWZmZXIoZSx0LG4pO2Nhc2VcIk1lZGlhRWxlbWVudFwiOnJldHVybiB0aGlzLmxvYWRNZWRpYUVsZW1lbnQoZSx0LHIsbil9fX0se2tleTpcImxvYWRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUscil7dmFyIG49dGhpcyxpPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZuLnRtcEV2ZW50cy5wdXNoKG4ub25jZShcInJlYWR5XCIsZSkpLG4uZ2V0QXJyYXlCdWZmZXIodCxmdW5jdGlvbihlKXtyZXR1cm4gbi5sb2FkQXJyYXlCdWZmZXIoZSl9KX07aWYoIWUpcmV0dXJuIGkoKTt0aGlzLmJhY2tlbmQuc2V0UGVha3MoZSxyKSx0aGlzLmRyYXdCdWZmZXIoKSx0aGlzLnRtcEV2ZW50cy5wdXNoKHRoaXMub25jZShcImludGVyYWN0aW9uXCIsaSkpfX0se2tleTpcImxvYWRNZWRpYUVsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXt2YXIgaT10aGlzLGE9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl0aGlzLmJhY2tlbmQubG9hZChhLHRoaXMubWVkaWFDb250YWluZXIsdCxyKTtlbHNle3ZhciBzPWU7dGhpcy5iYWNrZW5kLmxvYWRFbHQocyx0KSxhPXMuc3JjfXRoaXMudG1wRXZlbnRzLnB1c2godGhpcy5iYWNrZW5kLm9uY2UoXCJjYW5wbGF5XCIsZnVuY3Rpb24oKXtpLmRyYXdCdWZmZXIoKSxpLmZpcmVFdmVudChcInJlYWR5XCIpLGkuaXNSZWFkeT0hMH0pLHRoaXMuYmFja2VuZC5vbmNlKFwiZXJyb3JcIixmdW5jdGlvbihlKXtyZXR1cm4gaS5maXJlRXZlbnQoXCJlcnJvclwiLGUpfSkpLHQmJnRoaXMuYmFja2VuZC5zZXRQZWFrcyh0LG4pLHQmJiF0aGlzLnBhcmFtcy5mb3JjZURlY29kZXx8IXRoaXMuYmFja2VuZC5zdXBwb3J0c1dlYkF1ZGlvKCl8fHRoaXMuZ2V0QXJyYXlCdWZmZXIoYSxmdW5jdGlvbihlKXtpLmRlY29kZUFycmF5QnVmZmVyKGUsZnVuY3Rpb24oZSl7aS5iYWNrZW5kLmJ1ZmZlcj1lLGkuYmFja2VuZC5zZXRQZWFrcyhudWxsKSxpLmRyYXdCdWZmZXIoKSxpLmZpcmVFdmVudChcIndhdmVmb3JtLXJlYWR5XCIpfSl9KX19LHtrZXk6XCJkZWNvZGVBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIG49dGhpczt0aGlzLmFycmF5YnVmZmVyPXQsdGhpcy5iYWNrZW5kLmRlY29kZUFycmF5QnVmZmVyKHQsZnVuY3Rpb24oZSl7bi5pc0Rlc3Ryb3llZHx8bi5hcnJheWJ1ZmZlciE9dHx8KHIoZSksbi5hcnJheWJ1ZmZlcj1udWxsKX0sZnVuY3Rpb24oKXtyZXR1cm4gbi5maXJlRXZlbnQoXCJlcnJvclwiLFwiRXJyb3IgZGVjb2RpbmcgYXVkaW9idWZmZXJcIil9KX19LHtrZXk6XCJnZXRBcnJheUJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUscil7dmFyIG49dGhpcyx0PWkuYWpheCh7dXJsOmUscmVzcG9uc2VUeXBlOlwiYXJyYXlidWZmZXJcIix4aHI6dGhpcy5wYXJhbXMueGhyfSk7cmV0dXJuIHRoaXMuY3VycmVudEFqYXg9dCx0aGlzLnRtcEV2ZW50cy5wdXNoKHQub24oXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGUpe24ub25Qcm9ncmVzcyhlKX0pLHQub24oXCJzdWNjZXNzXCIsZnVuY3Rpb24oZSx0KXtyKGUpLG4uY3VycmVudEFqYXg9bnVsbH0pLHQub24oXCJlcnJvclwiLGZ1bmN0aW9uKGUpe24uZmlyZUV2ZW50KFwiZXJyb3JcIixcIlhIUiBlcnJvcjogXCIrZS50YXJnZXQuc3RhdHVzVGV4dCksbi5jdXJyZW50QWpheD1udWxsfSkpLHR9fSx7a2V5Olwib25Qcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0O3Q9ZS5sZW5ndGhDb21wdXRhYmxlP2UubG9hZGVkL2UudG90YWw6ZS5sb2FkZWQvKGUubG9hZGVkKzFlNiksdGhpcy5maXJlRXZlbnQoXCJsb2FkaW5nXCIsTWF0aC5yb3VuZCgxMDAqdCksZS50YXJnZXQpfX0se2tleTpcImV4cG9ydFBDTVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe2U9ZXx8MTAyNCxuPW58fDAsdD10fHwxZTQscj1yfHwhMTt2YXIgaT10aGlzLmJhY2tlbmQuZ2V0UGVha3MoZSxuKSxhPVtdLm1hcC5jYWxsKGksZnVuY3Rpb24oZSl7cmV0dXJuIE1hdGgucm91bmQoZSp0KS90fSkscz1KU09OLnN0cmluZ2lmeShhKTtyZXR1cm4gcnx8d2luZG93Lm9wZW4oXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCxcIitlbmNvZGVVUklDb21wb25lbnQocykpLHN9fSx7a2V5OlwiZXhwb3J0SW1hZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBlfHwoZT1cImltYWdlL3BuZ1wiKSx0fHwodD0xKSx0aGlzLmRyYXdlci5nZXRJbWFnZShlLHQpfX0se2tleTpcImNhbmNlbEFqYXhcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY3VycmVudEFqYXgmJih0aGlzLmN1cnJlbnRBamF4Lnhoci5hYm9ydCgpLHRoaXMuY3VycmVudEFqYXg9bnVsbCl9fSx7a2V5OlwiY2xlYXJUbXBFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudG1wRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUudW4oKX0pfX0se2tleTpcImVtcHR5XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKXx8KHRoaXMuc3RvcCgpLHRoaXMuYmFja2VuZC5kaXNjb25uZWN0U291cmNlKCkpLHRoaXMuaXNSZWFkeT0hMSx0aGlzLmNhbmNlbEFqYXgoKSx0aGlzLmNsZWFyVG1wRXZlbnRzKCksdGhpcy5kcmF3ZXIucHJvZ3Jlc3MoMCksdGhpcy5kcmF3ZXIuc2V0V2lkdGgoMCksdGhpcy5kcmF3ZXIuZHJhd1BlYWtzKHtsZW5ndGg6dGhpcy5kcmF3ZXIuZ2V0V2lkdGgoKX0sMCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95QWxsUGx1Z2lucygpLHRoaXMuZmlyZUV2ZW50KFwiZGVzdHJveVwiKSx0aGlzLmNhbmNlbEFqYXgoKSx0aGlzLmNsZWFyVG1wRXZlbnRzKCksdGhpcy51bkFsbCgpLCExIT09dGhpcy5wYXJhbXMucmVzcG9uc2l2ZSYmKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fb25SZXNpemUsITApLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLl9vblJlc2l6ZSwhMCkpLHRoaXMuYmFja2VuZC5kZXN0cm95KCksdGhpcy5kcmF3ZXIuZGVzdHJveSgpLHRoaXMuaXNEZXN0cm95ZWQ9ITAsdGhpcy5pc1JlYWR5PSExLHRoaXMuYXJyYXlidWZmZXI9bnVsbH19XSksbn0oKTsodC5kZWZhdWx0PW0pLlZFUlNJT049XCIyLjEuMFwiLG0udXRpbD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGkuZGVmYXVsdCxyPW5ldyBYTUxIdHRwUmVxdWVzdCxuPSExO3Iub3BlbihlLm1ldGhvZHx8XCJHRVRcIixlLnVybCwhMCksci5yZXNwb25zZVR5cGU9ZS5yZXNwb25zZVR5cGV8fFwianNvblwiLGUueGhyJiYoZS54aHIucmVxdWVzdEhlYWRlcnMmJmUueGhyLnJlcXVlc3RIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ci5zZXRSZXF1ZXN0SGVhZGVyKGUua2V5LGUudmFsdWUpfSksZS54aHIud2l0aENyZWRlbnRpYWxzJiYoci53aXRoQ3JlZGVudGlhbHM9ITApKTtyZXR1cm4gci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIixmdW5jdGlvbihlKXt0LmZpcmVFdmVudChcInByb2dyZXNzXCIsZSksZS5sZW5ndGhDb21wdXRhYmxlJiZlLmxvYWRlZD09ZS50b3RhbCYmKG49ITApfSksci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKGUpe258fHQuZmlyZUV2ZW50KFwicHJvZ3Jlc3NcIixlKSx0LmZpcmVFdmVudChcImxvYWRcIixlKSwyMDA9PXIuc3RhdHVzfHwyMDY9PXIuc3RhdHVzP3QuZmlyZUV2ZW50KFwic3VjY2Vzc1wiLHIucmVzcG9uc2UsZSk6dC5maXJlRXZlbnQoXCJlcnJvclwiLGUpfSksci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5maXJlRXZlbnQoXCJlcnJvclwiLGUpfSksci5zZW5kKCksdC54aHI9cix0fTt2YXIgbixpPShuPXIoMSkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKCl7cmV0dXJuXCJ3YXZlc3VyZmVyX1wiK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnN1YnN0cmluZygyKX0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbih0KXt2YXIgcj0tMS8wO3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV0+ciYmKHI9dFtlXSl9KSxyfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHQpe3ZhciByPU51bWJlcigxLzApO3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV08ciYmKHI9dFtlXSl9KSxyfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KDE8ZT9lLTE6MCksbj0xO248ZTtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24oZSl7cltlXT10W2VdfSl9KSxyfSxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHQscil7cmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goZnVuY3Rpb24oZSl7dC5zdHlsZVtlXSE9PXJbZV0mJih0LnN0eWxlW2VdPXJbZV0pfSksdH0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1mdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4oMCxpLmRlZmF1bHQpKGZ1bmN0aW9uKCl7cmV0dXJuIG4uYXBwbHkodm9pZCAwLHQpfSl9fTt2YXIgbixpPShuPXIoMikpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTtlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIodCxyLG4pe3ZhciBpLGEscyxvLHU7ZnVuY3Rpb24gbCgpe3ZhciBlPURhdGUubm93KCktbztlPHImJjA8PWU/aT1zZXRUaW1lb3V0KGwsci1lKTooaT1udWxsLG58fCh1PXQuYXBwbHkocyxhKSxzPWE9bnVsbCkpfW51bGw9PXImJihyPTEwMCk7dmFyIGU9ZnVuY3Rpb24oKXtzPXRoaXMsYT1hcmd1bWVudHMsbz1EYXRlLm5vdygpO3ZhciBlPW4mJiFpO3JldHVybiBpfHwoaT1zZXRUaW1lb3V0KGwscikpLGUmJih1PXQuYXBwbHkocyxhKSxzPWE9bnVsbCksdX07cmV0dXJuIGUuY2xlYXI9ZnVuY3Rpb24oKXtpJiYoY2xlYXJUaW1lb3V0KGkpLGk9bnVsbCl9LGUuZmx1c2g9ZnVuY3Rpb24oKXtpJiYodT10LmFwcGx5KHMsYSkscz1hPW51bGwsY2xlYXJUaW1lb3V0KGkpLGk9bnVsbCl9LGV9ci5kZWJvdW5jZT1yLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsbiwhMCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKGUpe2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsbiwhMCl9LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGE9KG49cigxNSkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxmPWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSl7dmFyIG49T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTp7fTtuLmdldHx8bi5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixuKTp0W3JdPWVbcl19cmV0dXJuIHQuZGVmYXVsdD1lLHR9fShyKDApKTtmdW5jdGlvbiBpKGUpe3JldHVybihpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBzKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1pKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIHUoZSl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9dmFyIGM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe3ZhciByO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbiksKHI9byh0aGlzLHUobikuY2FsbCh0aGlzLGUsdCkpKS5tYXhDYW52YXNXaWR0aD10Lm1heENhbnZhc1dpZHRoLHIubWF4Q2FudmFzRWxlbWVudFdpZHRoPU1hdGgucm91bmQodC5tYXhDYW52YXNXaWR0aC90LnBpeGVsUmF0aW8pLHIuaGFzUHJvZ3Jlc3NDYW52YXM9dC53YXZlQ29sb3IhPXQucHJvZ3Jlc3NDb2xvcixyLmhhbGZQaXhlbD0uNS90LnBpeGVsUmF0aW8sci5jYW52YXNlcz1bXSxyLnByb2dyZXNzV2F2ZT1udWxsLHJ9dmFyIHQscixpO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbChlLHQpfShuLGEuZGVmYXVsdCksdD1uLChyPVt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jcmVhdGVXcmFwcGVyKCksdGhpcy5jcmVhdGVFbGVtZW50cygpfX0se2tleTpcImNyZWF0ZUVsZW1lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb2dyZXNzV2F2ZT10aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwid2F2ZVwiKSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHpJbmRleDozLGxlZnQ6MCx0b3A6MCxib3R0b206MCxvdmVyZmxvdzpcImhpZGRlblwiLHdpZHRoOlwiMFwiLGRpc3BsYXk6XCJub25lXCIsYm94U2l6aW5nOlwiYm9yZGVyLWJveFwiLGJvcmRlclJpZ2h0U3R5bGU6XCJzb2xpZFwiLHBvaW50ZXJFdmVudHM6XCJub25lXCJ9KSksdGhpcy5hZGRDYW52YXMoKSx0aGlzLnVwZGF0ZUN1cnNvcigpfX0se2tleTpcInVwZGF0ZUN1cnNvclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zdHlsZSh0aGlzLnByb2dyZXNzV2F2ZSx7Ym9yZGVyUmlnaHRXaWR0aDp0aGlzLnBhcmFtcy5jdXJzb3JXaWR0aCtcInB4XCIsYm9yZGVyUmlnaHRDb2xvcjp0aGlzLnBhcmFtcy5jdXJzb3JDb2xvcn0pfX0se2tleTpcInVwZGF0ZVNpemVcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgbj10aGlzLGU9TWF0aC5yb3VuZCh0aGlzLndpZHRoL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pLHQ9TWF0aC5jZWlsKGUvdGhpcy5tYXhDYW52YXNFbGVtZW50V2lkdGgpO3RoaXMuY2FudmFzZXMubGVuZ3RoPHQ7KXRoaXMuYWRkQ2FudmFzKCk7Zm9yKDt0aGlzLmNhbnZhc2VzLmxlbmd0aD50Oyl0aGlzLnJlbW92ZUNhbnZhcygpO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciByPW4ubWF4Q2FudmFzV2lkdGgrMipNYXRoLmNlaWwobi5wYXJhbXMucGl4ZWxSYXRpby8yKTt0PT1uLmNhbnZhc2VzLmxlbmd0aC0xJiYocj1uLndpZHRoLW4ubWF4Q2FudmFzV2lkdGgqKG4uY2FudmFzZXMubGVuZ3RoLTEpKSxuLnVwZGF0ZURpbWVuc2lvbnMoZSxyLG4uaGVpZ2h0KSxuLmNsZWFyV2F2ZUZvckVudHJ5KGUpfSl9fSx7a2V5OlwiYWRkQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT17fSx0PXRoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoKnRoaXMuY2FudmFzZXMubGVuZ3RoO2Uud2F2ZT10aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHtwb3NpdGlvbjpcImFic29sdXRlXCIsekluZGV4OjIsbGVmdDp0K1wicHhcIix0b3A6MCxib3R0b206MCxoZWlnaHQ6XCIxMDAlXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIn0pKSxlLndhdmVDdHg9ZS53YXZlLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLmhhc1Byb2dyZXNzQ2FudmFzJiYoZS5wcm9ncmVzcz10aGlzLnByb2dyZXNzV2F2ZS5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixsZWZ0OnQrXCJweFwiLHRvcDowLGJvdHRvbTowLGhlaWdodDpcIjEwMCVcIn0pKSxlLnByb2dyZXNzQ3R4PWUucHJvZ3Jlc3MuZ2V0Q29udGV4dChcIjJkXCIpKSx0aGlzLmNhbnZhc2VzLnB1c2goZSl9fSx7a2V5OlwicmVtb3ZlQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmNhbnZhc2VzLnBvcCgpO2Uud2F2ZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGUud2F2ZSksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmZS5wcm9ncmVzcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGUucHJvZ3Jlc3MpfX0se2tleTpcInVwZGF0ZURpbWVuc2lvbnNcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7dmFyIG49TWF0aC5yb3VuZCh0L3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pLGk9TWF0aC5yb3VuZCh0aGlzLndpZHRoL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8pO2Uuc3RhcnQ9ZS53YXZlQ3R4LmNhbnZhcy5vZmZzZXRMZWZ0L2l8fDAsZS5lbmQ9ZS5zdGFydCtuL2ksZS53YXZlQ3R4LmNhbnZhcy53aWR0aD10LGUud2F2ZUN0eC5jYW52YXMuaGVpZ2h0PXIsdGhpcy5zdHlsZShlLndhdmVDdHguY2FudmFzLHt3aWR0aDpuK1wicHhcIn0pLHRoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUse2Rpc3BsYXk6XCJibG9ja1wifSksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmKGUucHJvZ3Jlc3NDdHguY2FudmFzLndpZHRoPXQsZS5wcm9ncmVzc0N0eC5jYW52YXMuaGVpZ2h0PXIsdGhpcy5zdHlsZShlLnByb2dyZXNzQ3R4LmNhbnZhcyx7d2lkdGg6bitcInB4XCJ9KSl9fSx7a2V5OlwiY2xlYXJXYXZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5jbGVhcldhdmVGb3JFbnRyeShlKX0pfX0se2tleTpcImNsZWFyV2F2ZUZvckVudHJ5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS53YXZlQ3R4LmNsZWFyUmVjdCgwLDAsZS53YXZlQ3R4LmNhbnZhcy53aWR0aCxlLndhdmVDdHguY2FudmFzLmhlaWdodCksdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyYmZS5wcm9ncmVzc0N0eC5jbGVhclJlY3QoMCwwLGUucHJvZ3Jlc3NDdHguY2FudmFzLndpZHRoLGUucHJvZ3Jlc3NDdHguY2FudmFzLmhlaWdodCl9fSx7a2V5OlwiZHJhd0JhcnNcIix2YWx1ZTpmdW5jdGlvbihlLHQsdix5KXt2YXIgbT10aGlzO3JldHVybiB0aGlzLnByZXBhcmVEcmF3KGUsdCx2LHksZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hYnNtYXgscj1lLmhhc01pblZhbHMsbj0oZS5oZWlnaHQsZS5vZmZzZXRZKSxpPWUuaGFsZkgsYT1lLnBlYWtzO2lmKHZvaWQgMCE9PXYpe3ZhciBzLG89cj8yOjEsdT1hLmxlbmd0aC9vLGw9bS5wYXJhbXMuYmFyV2lkdGgqbS5wYXJhbXMucGl4ZWxSYXRpbyxjPWwrKG51bGw9PT1tLnBhcmFtcy5iYXJHYXA/TWF0aC5tYXgobS5wYXJhbXMucGl4ZWxSYXRpbyx+fihsLzIpKTpNYXRoLm1heChtLnBhcmFtcy5waXhlbFJhdGlvLG0ucGFyYW1zLmJhckdhcCptLnBhcmFtcy5waXhlbFJhdGlvKSksaD11L20ud2lkdGgsZj15O2ZvcihzPXY7czxmO3MrPWMpe3ZhciBkPWFbTWF0aC5mbG9vcihzKmgqbyldfHwwLHA9TWF0aC5yb3VuZChkL3QqaSk7bS5maWxsUmVjdChzK20uaGFsZlBpeGVsLGktcCtuLGwrbS5oYWxmUGl4ZWwsMipwKX19fSl9fSx7a2V5OlwiZHJhd1dhdmVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbCxjKXt2YXIgaD10aGlzO3JldHVybiB0aGlzLnByZXBhcmVEcmF3KGUsdCxsLGMsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hYnNtYXgscj1lLmhhc01pblZhbHMsbj0oZS5oZWlnaHQsZS5vZmZzZXRZKSxpPWUuaGFsZkgsYT1lLnBlYWtzO2lmKCFyKXt2YXIgcyxvPVtdLHU9YS5sZW5ndGg7Zm9yKHM9MDtzPHU7cysrKW9bMipzXT1hW3NdLG9bMipzKzFdPS1hW3NdO2E9b312b2lkIDAhPT1sJiZoLmRyYXdMaW5lKGEsdCxpLG4sbCxjKSxoLmZpbGxSZWN0KDAsaStuLWguaGFsZlBpeGVsLGgud2lkdGgsaC5oYWxmUGl4ZWwpfSl9fSx7a2V5OlwiZHJhd0xpbmVcIix2YWx1ZTpmdW5jdGlvbih0LHIsbixpLGEscyl7dmFyIG89dGhpczt0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7by5zZXRGaWxsU3R5bGVzKGUpLG8uZHJhd0xpbmVUb0NvbnRleHQoZSxlLndhdmVDdHgsdCxyLG4saSxhLHMpLG8uZHJhd0xpbmVUb0NvbnRleHQoZSxlLnByb2dyZXNzQ3R4LHQscixuLGksYSxzKX0pfX0se2tleTpcImRyYXdMaW5lVG9Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbixpLGEscyxvKXtpZih0KXt2YXIgdT1yLmxlbmd0aC8yLGw9dGhpcy5wYXJhbXMuZmlsbFBhcmVudCYmdGhpcy53aWR0aCE9dT90aGlzLndpZHRoL3U6MSxjPU1hdGgucm91bmQodSplLnN0YXJ0KSxoPU1hdGgucm91bmQodSplLmVuZCkrMTtpZighKG88Y3x8aDxzKSl7dmFyIGYsZCxwPU1hdGgubWluKGMscyksdj1NYXRoLm1heChoLG8pO2Zvcih0LmJlZ2luUGF0aCgpLHQubW92ZVRvKChwLWMpKmwrdGhpcy5oYWxmUGl4ZWwsaSthKSxmPXA7Zjx2O2YrKyl7dmFyIHk9clsyKmZdfHwwLG09TWF0aC5yb3VuZCh5L24qaSk7dC5saW5lVG8oKGYtYykqbCt0aGlzLmhhbGZQaXhlbCxpLW0rYSl9Zm9yKGQ9di0xO3A8PWQ7ZC0tKXt2YXIgYj1yWzIqZCsxXXx8MCxnPU1hdGgucm91bmQoYi9uKmkpO3QubGluZVRvKChkLWMpKmwrdGhpcy5oYWxmUGl4ZWwsaS1nK2EpfXQuY2xvc2VQYXRoKCksdC5maWxsKCl9fX19LHtrZXk6XCJmaWxsUmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpLGE9TWF0aC5mbG9vcihlL3RoaXMubWF4Q2FudmFzV2lkdGgpLHM9TWF0aC5taW4oTWF0aC5jZWlsKChlK3IpL3RoaXMubWF4Q2FudmFzV2lkdGgpKzEsdGhpcy5jYW52YXNlcy5sZW5ndGgpO2ZvcihpPWE7aTxzO2krKyl7dmFyIG89dGhpcy5jYW52YXNlc1tpXSx1PWkqdGhpcy5tYXhDYW52YXNXaWR0aCxsPXt4MTpNYXRoLm1heChlLGkqdGhpcy5tYXhDYW52YXNXaWR0aCkseTE6dCx4MjpNYXRoLm1pbihlK3IsaSp0aGlzLm1heENhbnZhc1dpZHRoK28ud2F2ZUN0eC5jYW52YXMud2lkdGgpLHkyOnQrbn07bC54MTxsLngyJiYodGhpcy5zZXRGaWxsU3R5bGVzKG8pLHRoaXMuZmlsbFJlY3RUb0NvbnRleHQoby53YXZlQ3R4LGwueDEtdSxsLnkxLGwueDItbC54MSxsLnkyLWwueTEpLHRoaXMuZmlsbFJlY3RUb0NvbnRleHQoby5wcm9ncmVzc0N0eCxsLngxLXUsbC55MSxsLngyLWwueDEsbC55Mi1sLnkxKSl9fX0se2tleTpcInByZXBhcmVEcmF3XCIsdmFsdWU6ZnVuY3Rpb24ocyxvLHUsbCxjKXt2YXIgaD10aGlzO3JldHVybiBmLmZyYW1lKGZ1bmN0aW9uKCl7aWYoc1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBlPXM7aWYoaC5wYXJhbXMuc3BsaXRDaGFubmVscylyZXR1cm4gaC5zZXRIZWlnaHQoZS5sZW5ndGgqaC5wYXJhbXMuaGVpZ2h0KmgucGFyYW1zLnBpeGVsUmF0aW8pLGUuZm9yRWFjaChmdW5jdGlvbihlLHQpe3JldHVybiBoLnByZXBhcmVEcmF3KGUsdCx1LGwsYyl9KTtzPWVbMF19dmFyIHQ9MS9oLnBhcmFtcy5iYXJIZWlnaHQ7aWYoaC5wYXJhbXMubm9ybWFsaXplKXt2YXIgcj1mLm1heChzKSxuPWYubWluKHMpO3Q9cjwtbj8tbjpyfXZhciBpPVtdLnNvbWUuY2FsbChzLGZ1bmN0aW9uKGUpe3JldHVybiBlPDB9KSxhPWgucGFyYW1zLmhlaWdodCpoLnBhcmFtcy5waXhlbFJhdGlvO3JldHVybiBjKHthYnNtYXg6dCxoYXNNaW5WYWxzOmksaGVpZ2h0OmEsb2Zmc2V0WTphKm98fDAsaGFsZkg6YS8yLHBlYWtzOnN9KX0pKCl9fSx7a2V5OlwiZmlsbFJlY3RUb0NvbnRleHRcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuLGkpe2UmJmUuZmlsbFJlY3QodCxyLG4saSl9fSx7a2V5Olwic2V0RmlsbFN0eWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2Uud2F2ZUN0eC5maWxsU3R5bGU9dGhpcy5wYXJhbXMud2F2ZUNvbG9yLHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMmJihlLnByb2dyZXNzQ3R4LmZpbGxTdHlsZT10aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yKX19LHtrZXk6XCJnZXRJbWFnZVwiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIGU9dGhpcy5jYW52YXNlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUud2F2ZS50b0RhdGFVUkwodCxyKX0pO3JldHVybiAxPGUubGVuZ3RoP2U6ZVswXX19LHtrZXk6XCJ1cGRhdGVQcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUse3dpZHRoOmUrXCJweFwifSl9fV0pJiZzKHQucHJvdG90eXBlLHIpLGkmJnModCxpKSxufSgpO3QuZGVmYXVsdD1jLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBhPWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSl7dmFyIG49T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTp7fTtuLmdldHx8bi5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixuKTp0W3JdPWVbcl19cmV0dXJuIHQuZGVmYXVsdD1lLHR9fShyKDApKTtmdW5jdGlvbiBuKGUpe3JldHVybihuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBzKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1uKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIHUoZSl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9dmFyIGk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe3ZhciByO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbiksKHI9byh0aGlzLHUobikuY2FsbCh0aGlzKSkpLmNvbnRhaW5lcj1lLHIucGFyYW1zPXQsci53aWR0aD0wLHIuaGVpZ2h0PXQuaGVpZ2h0KnIucGFyYW1zLnBpeGVsUmF0aW8sci5sYXN0UG9zPTAsci53cmFwcGVyPW51bGwscn12YXIgdCxyLGk7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZsKGUsdCl9KG4sYS5PYnNlcnZlciksdD1uLChyPVt7a2V5Olwic3R5bGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBhLnN0eWxlKGUsdCl9fSx7a2V5OlwiY3JlYXRlV3JhcHBlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53cmFwcGVyPXRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ3YXZlXCIpKSx0aGlzLnN0eWxlKHRoaXMud3JhcHBlcix7ZGlzcGxheTpcImJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHVzZXJTZWxlY3Q6XCJub25lXCIsd2Via2l0VXNlclNlbGVjdDpcIm5vbmVcIixoZWlnaHQ6dGhpcy5wYXJhbXMuaGVpZ2h0K1wicHhcIn0pLCh0aGlzLnBhcmFtcy5maWxsUGFyZW50fHx0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpJiZ0aGlzLnN0eWxlKHRoaXMud3JhcHBlcix7d2lkdGg6XCIxMDAlXCIsb3ZlcmZsb3dYOnRoaXMucGFyYW1zLmhpZGVTY3JvbGxiYXI/XCJoaWRkZW5cIjpcImF1dG9cIixvdmVyZmxvd1k6XCJoaWRkZW5cIn0pLHRoaXMuc2V0dXBXcmFwcGVyRXZlbnRzKCl9fSx7a2V5OlwiaGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpeyF0JiZlLnByZXZlbnREZWZhdWx0KCk7dmFyIHIsbj1lLnRhcmdldFRvdWNoZXM/ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFg6ZS5jbGllbnRYLGk9dGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGE9dGhpcy53aWR0aCxzPXRoaXMuZ2V0V2lkdGgoKTtyZXR1cm4hdGhpcy5wYXJhbXMuZmlsbFBhcmVudCYmYTxzPzE8KHI9KG4taS5sZWZ0KSoodGhpcy5wYXJhbXMucGl4ZWxSYXRpby9hKXx8MCkmJihyPTEpOnI9KG4taS5sZWZ0K3RoaXMud3JhcHBlci5zY3JvbGxMZWZ0KS90aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGh8fDAscn19LHtrZXk6XCJzZXR1cFdyYXBwZXJFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGUpe3ZhciB0PW4ud3JhcHBlci5vZmZzZXRIZWlnaHQtbi53cmFwcGVyLmNsaWVudEhlaWdodDtpZigwIT10KXt2YXIgcj1uLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoZS5jbGllbnRZPj1yLmJvdHRvbS10KXJldHVybn1uLnBhcmFtcy5pbnRlcmFjdCYmbi5maXJlRXZlbnQoXCJjbGlja1wiLGUsbi5oYW5kbGVFdmVudChlKSl9KSx0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGZ1bmN0aW9uKGUpe3JldHVybiBuLmZpcmVFdmVudChcInNjcm9sbFwiLGUpfSl9fSx7a2V5OlwiZHJhd1BlYWtzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbil7dGhpcy5zZXRXaWR0aCh0KXx8dGhpcy5jbGVhcldhdmUoKSx0aGlzLnBhcmFtcy5iYXJXaWR0aD90aGlzLmRyYXdCYXJzKGUsMCxyLG4pOnRoaXMuZHJhd1dhdmUoZSwwLHIsbil9fSx7a2V5OlwicmVzZXRTY3JvbGxcIix2YWx1ZTpmdW5jdGlvbigpe251bGwhPT10aGlzLndyYXBwZXImJih0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdD0wKX19LHtrZXk6XCJyZWNlbnRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCplO3RoaXMucmVjZW50ZXJPblBvc2l0aW9uKHQsITApfX0se2tleTpcInJlY2VudGVyT25Qb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy53cmFwcGVyLnNjcm9sbExlZnQsbj1+fih0aGlzLndyYXBwZXIuY2xpZW50V2lkdGgvMiksaT10aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGgtdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoLGE9ZS1uLHM9YS1yO2lmKDAhPWkpe2lmKCF0JiYtbjw9cyYmczxuKXthPXIrKHM9TWF0aC5tYXgoLTUsTWF0aC5taW4oNSxzKSkpfShhPU1hdGgubWF4KDAsTWF0aC5taW4oaSxhKSkpIT1yJiYodGhpcy53cmFwcGVyLnNjcm9sbExlZnQ9YSl9fX0se2tleTpcImdldFNjcm9sbFhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucGFyYW1zLnBpeGVsUmF0aW8sdD1NYXRoLnJvdW5kKHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0KmUpO2lmKHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCl7dmFyIHI9fn4odGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoKmUtdGhpcy5nZXRXaWR0aCgpKTt0PU1hdGgubWluKHIsTWF0aC5tYXgoMCx0KSl9cmV0dXJuIHR9fSx7a2V5OlwiZ2V0V2lkdGhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoKnRoaXMucGFyYW1zLnBpeGVsUmF0aW8pfX0se2tleTpcInNldFdpZHRoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud2lkdGghPWUmJih0aGlzLndpZHRoPWUsdGhpcy5wYXJhbXMuZmlsbFBhcmVudHx8dGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50P3RoaXMuc3R5bGUodGhpcy53cmFwcGVyLHt3aWR0aDpcIlwifSk6dGhpcy5zdHlsZSh0aGlzLndyYXBwZXIse3dpZHRoOn5+KHRoaXMud2lkdGgvdGhpcy5wYXJhbXMucGl4ZWxSYXRpbykrXCJweFwifSksdGhpcy51cGRhdGVTaXplKCksITApfX0se2tleTpcInNldEhlaWdodFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlIT10aGlzLmhlaWdodCYmKHRoaXMuaGVpZ2h0PWUsdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIse2hlaWdodDp+fih0aGlzLmhlaWdodC90aGlzLnBhcmFtcy5waXhlbFJhdGlvKStcInB4XCJ9KSx0aGlzLnVwZGF0ZVNpemUoKSwhMCl9fSx7a2V5OlwicHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0xL3RoaXMucGFyYW1zLnBpeGVsUmF0aW8scj1NYXRoLnJvdW5kKGUqdGhpcy53aWR0aCkqdDtpZihyPHRoaXMubGFzdFBvc3x8ci10aGlzLmxhc3RQb3M+PXQpe2lmKHRoaXMubGFzdFBvcz1yLHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCYmdGhpcy5wYXJhbXMuYXV0b0NlbnRlcil7dmFyIG49fn4odGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoKmUpO3RoaXMucmVjZW50ZXJPblBvc2l0aW9uKG4pfXRoaXMudXBkYXRlUHJvZ3Jlc3Mocil9fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudW5BbGwoKSx0aGlzLndyYXBwZXImJih0aGlzLndyYXBwZXIucGFyZW50Tm9kZT09dGhpcy5jb250YWluZXImJnRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlciksdGhpcy53cmFwcGVyPW51bGwpfX0se2tleTpcInVwZGF0ZUN1cnNvclwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInVwZGF0ZVNpemVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJkcmF3QmFyc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe319LHtrZXk6XCJkcmF3V2F2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe319LHtrZXk6XCJjbGVhcldhdmVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJ1cGRhdGVQcm9ncmVzc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe319XSkmJnModC5wcm90b3R5cGUsciksaSYmcyh0LGkpLG59KCk7dC5kZWZhdWx0PWksZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4sYT0obj1yKDMpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07IWZ1bmN0aW9uKGUpe3tpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikpe3ZhciBuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUscik6e307bi5nZXR8fG4uc2V0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsbik6dFtyXT1lW3JdfXQuZGVmYXVsdD1lfX0ocigwKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4oaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09aSh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXJldHVybiBlO3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0oZSk6dH1mdW5jdGlvbiB1KGUsdCxyKXtyZXR1cm4odT1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5nZXQ/UmVmbGVjdC5nZXQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWZ1bmN0aW9uKGUsdCl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJm51bGwhPT0oZT1sKGUpKTspO3JldHVybiBlfShlLHQpO2lmKG4pe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtyZXR1cm4gaS5nZXQ/aS5nZXQuY2FsbChyKTppLnZhbHVlfX0pKGUsdCxyfHxlKX1mdW5jdGlvbiBsKGUpe3JldHVybihsPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuKGM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfXZhciBoPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSl7dmFyIHQ7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxuKSwodD1vKHRoaXMsbChuKS5jYWxsKHRoaXMsZSkpKS5wYXJhbXM9ZSx0Lm1lZGlhPXtjdXJyZW50VGltZTowLGR1cmF0aW9uOjAscGF1c2VkOiEwLHBsYXliYWNrUmF0ZToxLHBsYXk6ZnVuY3Rpb24oKXt9LHBhdXNlOmZ1bmN0aW9uKCl7fSx2b2x1bWU6MH0sdC5tZWRpYVR5cGU9ZS5tZWRpYVR5cGUudG9Mb3dlckNhc2UoKSx0LmVsZW1lbnRQb3NpdGlvbj1lLmVsZW1lbnRQb3NpdGlvbix0LnBlYWtzPW51bGwsdC5wbGF5YmFja1JhdGU9MSx0LnZvbHVtZT0xLHQuYnVmZmVyPW51bGwsdC5vblBsYXlFbmQ9bnVsbCx0fXZhciB0LHIsaTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJmMoZSx0KX0obixhLmRlZmF1bHQpLHQ9biwocj1be2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGFyYW1zLmF1ZGlvUmF0ZSksdGhpcy5jcmVhdGVUaW1lcigpfX0se2tleTpcImNyZWF0ZVRpbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMub24oXCJwbGF5XCIsZnVuY3Rpb24gZSgpe3QuaXNQYXVzZWQoKXx8KHQuZmlyZUV2ZW50KFwiYXVkaW9wcm9jZXNzXCIsdC5nZXRDdXJyZW50VGltZSgpKSwod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkoZSkpfSksdGhpcy5vbihcInBhdXNlXCIsZnVuY3Rpb24oKXt0LmZpcmVFdmVudChcImF1ZGlvcHJvY2Vzc1wiLHQuZ2V0Q3VycmVudFRpbWUoKSl9KX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1lZGlhVHlwZSk7aS5jb250cm9scz10aGlzLnBhcmFtcy5tZWRpYUNvbnRyb2xzLGkuYXV0b3BsYXk9dGhpcy5wYXJhbXMuYXV0b3BsYXl8fCExLGkucHJlbG9hZD1udWxsPT1uP1wiYXV0b1wiOm4saS5zcmM9ZSxpLnN0eWxlLndpZHRoPVwiMTAwJVwiO3ZhciBhPXQucXVlcnlTZWxlY3Rvcih0aGlzLm1lZGlhVHlwZSk7YSYmdC5yZW1vdmVDaGlsZChhKSx0LmFwcGVuZENoaWxkKGkpLHRoaXMuX2xvYWQoaSxyKX19LHtrZXk6XCJsb2FkRWx0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtlLmNvbnRyb2xzPXRoaXMucGFyYW1zLm1lZGlhQ29udHJvbHMsZS5hdXRvcGxheT10aGlzLnBhcmFtcy5hdXRvcGxheXx8ITEsdGhpcy5fbG9hZChlLHQpfX0se2tleTpcIl9sb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO1wiZnVuY3Rpb25cIj09dHlwZW9mIGUubG9hZCYmZS5sb2FkKCksZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbigpe3IuZmlyZUV2ZW50KFwiZXJyb3JcIixcIkVycm9yIGxvYWRpbmcgbWVkaWEgZWxlbWVudFwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIixmdW5jdGlvbigpe3IuZmlyZUV2ZW50KFwiY2FucGxheVwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcImZpbmlzaFwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlcIixmdW5jdGlvbigpe3IuZmlyZUV2ZW50KFwicGxheVwiKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsZnVuY3Rpb24oKXtyLmZpcmVFdmVudChcInBhdXNlXCIpfSksdGhpcy5tZWRpYT1lLHRoaXMucGVha3M9dCx0aGlzLm9uUGxheUVuZD1udWxsLHRoaXMuYnVmZmVyPW51bGwsdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wbGF5YmFja1JhdGUpLHRoaXMuc2V0Vm9sdW1lKHRoaXMudm9sdW1lKX19LHtrZXk6XCJpc1BhdXNlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMubWVkaWF8fHRoaXMubWVkaWEucGF1c2VkfX0se2tleTpcImdldER1cmF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmV4cGxpY2l0RHVyYXRpb24pcmV0dXJuIHRoaXMuZXhwbGljaXREdXJhdGlvbjt2YXIgZT0odGhpcy5idWZmZXJ8fHRoaXMubWVkaWEpLmR1cmF0aW9uO3JldHVybiAxLzA8PWUmJihlPXRoaXMubWVkaWEuc2Vla2FibGUuZW5kKDApKSxlfX0se2tleTpcImdldEN1cnJlbnRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZWRpYSYmdGhpcy5tZWRpYS5jdXJyZW50VGltZX19LHtrZXk6XCJnZXRQbGF5ZWRQZXJjZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKS90aGlzLmdldER1cmF0aW9uKCl8fDB9fSx7a2V5OlwiZ2V0UGxheWJhY2tSYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGV8fHRoaXMubWVkaWEucGxheWJhY2tSYXRlfX0se2tleTpcInNldFBsYXliYWNrUmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucGxheWJhY2tSYXRlPWV8fDEsdGhpcy5tZWRpYS5wbGF5YmFja1JhdGU9dGhpcy5wbGF5YmFja1JhdGV9fSx7a2V5Olwic2Vla1RvXCIsdmFsdWU6ZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKHRoaXMubWVkaWEuY3VycmVudFRpbWU9ZSksdGhpcy5jbGVhclBsYXlFbmQoKX19LHtrZXk6XCJwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLnNlZWtUbyhlKTt2YXIgcj10aGlzLm1lZGlhLnBsYXkoKTtyZXR1cm4gdCYmdGhpcy5zZXRQbGF5RW5kKHQpLHJ9fSx7a2V5OlwicGF1c2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3JldHVybiB0aGlzLm1lZGlhJiYoZT10aGlzLm1lZGlhLnBhdXNlKCkpLHRoaXMuY2xlYXJQbGF5RW5kKCksZX19LHtrZXk6XCJzZXRQbGF5RW5kXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dGhpczt0aGlzLl9vblBsYXlFbmQ9ZnVuY3Rpb24oZSl7dDw9ZSYmKHIucGF1c2UoKSxyLnNlZWtUbyh0KSl9LHRoaXMub24oXCJhdWRpb3Byb2Nlc3NcIix0aGlzLl9vblBsYXlFbmQpfX0se2tleTpcImNsZWFyUGxheUVuZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fb25QbGF5RW5kJiYodGhpcy51bihcImF1ZGlvcHJvY2Vzc1wiLHRoaXMuX29uUGxheUVuZCksdGhpcy5fb25QbGF5RW5kPW51bGwpfX0se2tleTpcImdldFBlYWtzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLmJ1ZmZlcj91KGwobi5wcm90b3R5cGUpLFwiZ2V0UGVha3NcIix0aGlzKS5jYWxsKHRoaXMsZSx0LHIpOnRoaXMucGVha3N8fFtdfX0se2tleTpcInNldFNpbmtJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlP3RoaXMubWVkaWEuc2V0U2lua0lkP3RoaXMubWVkaWEuc2V0U2lua0lkKGUpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNldFNpbmtJZCBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlclwiKSk6UHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXZpY2VJZDogXCIrZSkpfX0se2tleTpcImdldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudm9sdW1lfHx0aGlzLm1lZGlhLnZvbHVtZX19LHtrZXk6XCJzZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnZvbHVtZT1lLHRoaXMubWVkaWEudm9sdW1lPXRoaXMudm9sdW1lfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGF1c2UoKSx0aGlzLnVuQWxsKCksdGhpcy5wYXJhbXMucmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95JiZ0aGlzLm1lZGlhJiZ0aGlzLm1lZGlhLnBhcmVudE5vZGUmJnRoaXMubWVkaWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1lZGlhKSx0aGlzLm1lZGlhPW51bGx9fV0pJiZzKHQucHJvdG90eXBlLHIpLGkmJnModCxpKSxufSgpO3QuZGVmYXVsdD1oLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5jbGVhclBlYWtDYWNoZSgpfXZhciB0LHIsbjtyZXR1cm4gdD1lLChyPVt7a2V5OlwiY2xlYXJQZWFrQ2FjaGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGVha0NhY2hlUmFuZ2VzPVtdLHRoaXMucGVha0NhY2hlTGVuZ3RoPS0xfX0se2tleTpcImFkZFJhbmdlVG9QZWFrQ2FjaGVcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7ZSE9dGhpcy5wZWFrQ2FjaGVMZW5ndGgmJih0aGlzLmNsZWFyUGVha0NhY2hlKCksdGhpcy5wZWFrQ2FjaGVMZW5ndGg9ZSk7Zm9yKHZhciBuPVtdLGk9MDtpPHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aCYmdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV08dDspaSsrO2ZvcihpJTI9PTAmJm4ucHVzaCh0KTtpPHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aCYmdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV08PXI7KW4ucHVzaCh0aGlzLnBlYWtDYWNoZVJhbmdlc1tpXSksaSsrO2klMj09MCYmbi5wdXNoKHIpLG49bi5maWx0ZXIoZnVuY3Rpb24oZSx0LHIpe3JldHVybiAwPT10P2UhPXJbdCsxXTp0PT1yLmxlbmd0aC0xP2UhPXJbdC0xXTplIT1yW3QtMV0mJmUhPXJbdCsxXX0pLHRoaXMucGVha0NhY2hlUmFuZ2VzPXRoaXMucGVha0NhY2hlUmFuZ2VzLmNvbmNhdChuKSx0aGlzLnBlYWtDYWNoZVJhbmdlcz10aGlzLnBlYWtDYWNoZVJhbmdlcy5zb3J0KGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUtdH0pLmZpbHRlcihmdW5jdGlvbihlLHQscil7cmV0dXJuIDA9PXQ/ZSE9clt0KzFdOnQ9PXIubGVuZ3RoLTE/ZSE9clt0LTFdOmUhPXJbdC0xXSYmZSE9clt0KzFdfSk7dmFyIGE9W107Zm9yKGk9MDtpPG4ubGVuZ3RoO2krPTIpYS5wdXNoKFtuW2ldLG5baSsxXV0pO3JldHVybiBhfX0se2tleTpcImdldENhY2hlUmFuZ2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PVtdO2ZvcihlPTA7ZTx0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGg7ZSs9Mil0LnB1c2goW3RoaXMucGVha0NhY2hlUmFuZ2VzW2VdLHRoaXMucGVha0NhY2hlUmFuZ2VzW2UrMV1dKTtyZXR1cm4gdH19XSkmJmkodC5wcm90b3R5cGUsciksbiYmaSh0LG4pLGV9KCk7dC5kZWZhdWx0PW4sZS5leHBvcnRzPXQuZGVmYXVsdH1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci5taW4uanMubWFwIiwiLyoqXG4gKiAoU2luZ2xlKSBSZWdpb24gcGx1Z2luIGNsYXNzXG4gKlxuICogTXVzdCBiZSB0dXJuZWQgaW50byBhbiBvYnNlcnZlciBiZWZvcmUgaW5zdGFudGlhdGluZy4gVGhpcyBpcyBkb25lIGluXG4gKiBSZWdpb25zUGx1Z2luIChtYWluIHBsdWdpbiBjbGFzcylcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKi9cbmNsYXNzIFJlZ2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCB3cykge1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIgPSB3cztcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3MuZHJhd2VyLndyYXBwZXI7XG4gICAgICAgIHRoaXMudXRpbCA9IHdzLnV0aWw7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLnV0aWwuc3R5bGU7XG5cbiAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZCA9PSBudWxsID8gd3MudXRpbC5nZXRJZCgpIDogcGFyYW1zLmlkO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gTnVtYmVyKHBhcmFtcy5zdGFydCkgfHwgMDtcbiAgICAgICAgdGhpcy5lbmQgPVxuICAgICAgICAgICAgcGFyYW1zLmVuZCA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAvLyBzbWFsbCBtYXJrZXItbGlrZSByZWdpb25cbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgK1xuICAgICAgICAgICAgICAgICAgKDQgLyB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGgpICogdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKClcbiAgICAgICAgICAgICAgICA6IE51bWJlcihwYXJhbXMuZW5kKTtcbiAgICAgICAgdGhpcy5yZXNpemUgPVxuICAgICAgICAgICAgcGFyYW1zLnJlc2l6ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4ocGFyYW1zLnJlc2l6ZSk7XG4gICAgICAgIHRoaXMuZHJhZyA9IHBhcmFtcy5kcmFnID09PSB1bmRlZmluZWQgPyB0cnVlIDogQm9vbGVhbihwYXJhbXMuZHJhZyk7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ocGFyYW1zLmxvb3ApO1xuICAgICAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8ICdyZ2JhKDAsIDAsIDAsIDAuMSknO1xuICAgICAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YSB8fCB7fTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBwYXJhbXMubWF4TGVuZ3RoO1xuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IHBhcmFtcy5taW5MZW5ndGg7XG4gICAgICAgIHRoaXMuX29uUmVkcmF3ID0gKCkgPT4gdGhpcy51cGRhdGVSZW5kZXIoKTtcblxuICAgICAgICB0aGlzLnNjcm9sbCA9IHBhcmFtcy5zY3JvbGwgIT09IGZhbHNlICYmIHdzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBwYXJhbXMuc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSBwYXJhbXMuc2Nyb2xsVGhyZXNob2xkIHx8IDEwO1xuXG4gICAgICAgIHRoaXMuYmluZEluT3V0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5vbignem9vbScsIHRoaXMuX29uUmVkcmF3KTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLm9uKCdyZWRyYXcnLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jcmVhdGVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyogVXBkYXRlIHJlZ2lvbiBwYXJhbXMuICovXG4gICAgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBOdW1iZXIocGFyYW1zLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IE51bWJlcihwYXJhbXMuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgdGhpcy5sb29wID0gQm9vbGVhbihwYXJhbXMubG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT0gcGFyYW1zLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPSBwYXJhbXMucmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IEJvb2xlYW4ocGFyYW1zLnJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT0gcGFyYW1zLmRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZyA9IEJvb2xlYW4ocGFyYW1zLmRyYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWF4TGVuZ3RoID0gTnVtYmVyKHBhcmFtcy5tYXhMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWluTGVuZ3RoID0gTnVtYmVyKHBhcmFtcy5taW5MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9IHBhcmFtcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBwYXJhbXMuYXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cGRhdGUnKTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXVwZGF0ZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgYSBzaW5nbGUgcmVnaW9uLiAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlbW92ZScpO1xuICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCd6b29tJywgdGhpcy5fb25SZWRyYXcpO1xuICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCdyZWRyYXcnLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgICAgICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tcmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogUGxheSB0aGUgYXVkaW8gcmVnaW9uLiAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5wbGF5KHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsYXknKTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXBsYXknLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKiBQbGF5IHRoZSByZWdpb24gaW4gbG9vcC4gKi9cbiAgICBwbGF5TG9vcCgpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIHRoaXMub25jZSgnb3V0JywgKCkgPT4gdGhpcy5wbGF5TG9vcCgpKTtcbiAgICB9XG5cbiAgICAvKiBSZW5kZXIgYSByZWdpb24gYXMgYSBET00gZWxlbWVudC4gKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVnaW9uJyk7XG4gICAgICAgIHJlZ2lvbkVsLmNsYXNzTmFtZSA9ICd3YXZlc3VyZmVyLXJlZ2lvbic7XG4gICAgICAgIHJlZ2lvbkVsLnRpdGxlID0gdGhpcy5mb3JtYXRUaW1lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgcmVnaW9uRWwuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgdGhpcy5pZCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBhdHRybmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJlZ2lvbkVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAnZGF0YS1yZWdpb24tJyArIGF0dHJuYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRybmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aDtcbiAgICAgICAgdGhpcy5zdHlsZShyZWdpb25FbCwge1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIHRvcDogJzBweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogUmVzaXplIGhhbmRsZXMgKi9cbiAgICAgICAgaWYgKHRoaXMucmVzaXplKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVMZWZ0ID0gcmVnaW9uRWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaGFuZGxlJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVSaWdodCA9IHJlZ2lvbkVsLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hhbmRsZScpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFuZGxlTGVmdC5jbGFzc05hbWUgPSAnd2F2ZXN1cmZlci1oYW5kbGUgd2F2ZXN1cmZlci1oYW5kbGUtc3RhcnQnO1xuICAgICAgICAgICAgaGFuZGxlUmlnaHQuY2xhc3NOYW1lID0gJ3dhdmVzdXJmZXItaGFuZGxlIHdhdmVzdXJmZXItaGFuZGxlLWVuZCc7XG4gICAgICAgICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnY29sLXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgbGVmdDogJzBweCcsXG4gICAgICAgICAgICAgICAgdG9wOiAnMHB4JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzElJyxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzRweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN0eWxlKGhhbmRsZUxlZnQsIGNzcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKGhhbmRsZVJpZ2h0LCBjc3MpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZShoYW5kbGVSaWdodCwge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICcxMDAlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQocmVnaW9uRWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcigpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudHMocmVnaW9uRWwpO1xuICAgIH1cblxuICAgIGZvcm1hdFRpbWUoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gKHN0YXJ0ID09IGVuZCA/IFtzdGFydF0gOiBbc3RhcnQsIGVuZF0pXG4gICAgICAgICAgICAubWFwKHRpbWUgPT5cbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHRpbWUgJSAzNjAwKSAvIDYwKSwgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgICAgICAoJzAwJyArIE1hdGguZmxvb3IodGltZSAlIDYwKSkuc2xpY2UoLTIpIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICBdLmpvaW4oJzonKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJy0nKTtcbiAgICB9XG5cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud2lkdGggLyB0aGlzLndhdmVzdXJmZXIucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLyogVXBkYXRlIGVsZW1lbnQncyBwb3NpdGlvbiwgd2lkdGgsIGNvbG9yLiAqL1xuICAgIHVwZGF0ZVJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgZHVyID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmQgPiBkdXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZHVyO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGR1ciAtICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgodGhpcy5zdGFydCArIHRoaXMubWluTGVuZ3RoLCB0aGlzLmVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0ICsgdGhpcy5tYXhMZW5ndGgsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCB3aWR0aCB2YWx1ZXMgb2YgdGhlIHJlZ2lvbiBzdWNoIHRoYXRcbiAgICAgICAgICAgIC8vIG5vIGdhcHMgYXBwZWFyIGJldHdlZW4gcmVnaW9ucy5cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLnJvdW5kKCh0aGlzLnN0YXJ0IC8gZHVyKSAqIHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbldpZHRoID0gTWF0aC5yb3VuZCgodGhpcy5lbmQgLyBkdXIpICogd2lkdGgpIC0gbGVmdDtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVnaW9uV2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IHRoaXMuZHJhZyA/ICdtb3ZlJyA6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cm5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcmVnaW9uLScgKyBhdHRybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJuYW1lXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IHRoaXMuZm9ybWF0VGltZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBCaW5kIGF1ZGlvIGV2ZW50cy4gKi9cbiAgICBiaW5kSW5PdXQoKSB7XG4gICAgICAgIHRoaXMuZmlyZWRJbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpcmVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3Qgb25Qcm9jZXNzID0gdGltZSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMuZmlyZWRPdXQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVkSW4gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zdGFydCA+PSBNYXRoLnJvdW5kKHRpbWUgKiAxMDApIC8gMTAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kIDw9IE1hdGgucm91bmQodGltZSAqIDEwMCkgLyAxMDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVkSW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnb3V0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW91dCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmZpcmVkSW4gJiYgdGhpcy5zdGFydCA8PSB0aW1lICYmIHRoaXMuZW5kID4gdGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZWRJbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlZE91dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCdpbicpO1xuICAgICAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1pbicsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLm9uKCdhdWRpb3Byb2Nlc3MnLCBvblByb2Nlc3MpO1xuXG4gICAgICAgIHRoaXMub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLnVuKCdhdWRpb3Byb2Nlc3MnLCBvblByb2Nlc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBMb29wIHBsYXliYWNrLiAqL1xuICAgICAgICB0aGlzLm9uKCdvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLnBsYXkodGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIEJpbmQgRE9NIGV2ZW50cy4gKi9cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ21vdXNlZW50ZXInLCBlKTtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1tb3VzZWVudGVyJywgdGhpcywgZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnbW91c2VsZWF2ZScsIGUpO1xuICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW1vdXNlbGVhdmUnLCB0aGlzLCBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnY2xpY2snLCBlKTtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jbGljaycsIHRoaXMsIGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1kYmxjbGljaycsIHRoaXMsIGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBEcmFnIG9yIHJlc2l6ZSBvbiBtb3VzZW1vdmUuICovXG4gICAgICAgICh0aGlzLmRyYWcgfHwgdGhpcy5yZXNpemUpICYmXG4gICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsU3BlZWQgPSB0aGlzLnNjcm9sbFNwZWVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoSWQ7XG4gICAgICAgICAgICAgICAgbGV0IGRyYWc7XG4gICAgICAgICAgICAgICAgbGV0IG1heFNjcm9sbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVzaXplO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlclJlY3Q7XG5cbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VTY3JvbGwgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxEaXJlY3Rpb24gfHwgKCFkcmFnICYmICFyZXNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGxldCBzY3JvbGxMZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ICsgc2Nyb2xsU3BlZWQgKiBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2Nyb2xsLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc2Nyb2xsTGVmdClcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZSkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGRyYWdnaW5nIG9yIHJlc2l6aW5nXG4gICAgICAgICAgICAgICAgICAgIGRyYWcgPyB0aGlzLm9uRHJhZyhkZWx0YSkgOiB0aGlzLm9uUmVzaXplKGRlbHRhLCByZXNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGVhdFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VTY3JvbGwoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbkRvd24gPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoSWQgPSBlLnRhcmdldFRvdWNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCB0cnVlKSAqIGR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGZvciBzY3JvbGwgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIG1heFNjcm9sbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggLSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJSZWN0ID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2hhbmRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3YXZlc3VyZmVyLWhhbmRsZS1zdGFydCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUgPSAnc3RhcnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUgPSAnZW5kJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uVXAgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWcgfHwgcmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51dGlsLnByZXZlbnRDbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3VwZGF0ZS1lbmQnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi11cGRhdGUtZW5kJywgdGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uTW92ZSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXRUb3VjaGVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllciAhPSB0b3VjaElkXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWcgfHwgcmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlKSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZyAmJiBkcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZWQgfHwgISFkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRHJhZyhkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplICYmIHJlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVkIHx8ICEhZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZShkZWx0YSwgcmVzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGhyZXNob2xkIGlzIG5vdCBiZXR3ZWVuIHRoZSBtb3VzZSBhbmQgdGhlIGNvbnRhaW5lciBlZGdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpcyBiZXR3ZWVuIHRoZSByZWdpb24gYW5kIHRoZSBjb250YWluZXIgZWRnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdpb25SZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHJlZ2lvblJlY3QubGVmdCAtIHdyYXBwZXJSZWN0LmxlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgb2xkVGltZSAmJiB4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSA+IG9sZFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyByZWdpb25SZWN0LndpZHRoIDw9IHdyYXBwZXJSZWN0LnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgd2UgYXJlIHN0aWxsIGJleW9uZCB0aGUgdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzY3JvbGxEaXJlY3Rpb24gPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA+IHNjcm9sbFRocmVzaG9sZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzY3JvbGxEaXJlY3Rpb24gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgcmVnaW9uUmVjdC53aWR0aCA8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJSZWN0LnJpZ2h0IC0gc2Nyb2xsVGhyZXNob2xkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3VzZSBiYXNlZCB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBlLmNsaWVudFggLSB3cmFwcGVyUmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA8PSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA+PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlclJlY3QucmlnaHQgLSBzY3JvbGxUaHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiAmJiBlZGdlU2Nyb2xsKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvd24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb3duKTtcblxuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbk1vdmUpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25VcCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblVwKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uTW92ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndhdmVzdXJmZXIub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25VcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIG9uRHJhZyhkZWx0YSkge1xuICAgICAgICBjb25zdCBtYXhFbmQgPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuZW5kICsgZGVsdGEgPiBtYXhFbmQgfHwgdGhpcy5zdGFydCArIGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgKyBkZWx0YSxcbiAgICAgICAgICAgIGVuZDogdGhpcy5lbmQgKyBkZWx0YVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZShkZWx0YSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbih0aGlzLnN0YXJ0ICsgZGVsdGEsIHRoaXMuZW5kKSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWF4KHRoaXMuc3RhcnQgKyBkZWx0YSwgdGhpcy5lbmQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5taW4odGhpcy5lbmQgKyBkZWx0YSwgdGhpcy5zdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBNYXRoLm1heCh0aGlzLmVuZCArIGRlbHRhLCB0aGlzLnN0YXJ0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVnaW9uc1BsdWdpblBhcmFtc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZHJhZ1NlbGVjdGlvbiBFbmFibGUgY3JlYXRpbmcgcmVnaW9ucyBieSBkcmFnZ2luZyB3aWhcbiAqIHRoZSBtb3VzZVxuICogQHByb3BlcnR5IHs/UmVnaW9uUGFyYW1zW119IHJlZ2lvbnMgUmVnaW9ucyB0aGF0IHNob3VsZCBiZSBhZGRlZCB1cG9uXG4gKiBpbml0aWFsaXNhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsb3A9MiBUaGUgc2Vuc2l0aXZpdHkgb2YgdGhlIG1vdXNlIGRyYWdnaW5nXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZWZlckluaXQgU2V0IHRvIHRydWUgdG8gbWFudWFsbHkgY2FsbFxuICogYGluaXRQbHVnaW4oJ3JlZ2lvbnMnKWBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZ2lvblBhcmFtc1xuICogQGRlc2MgVGhlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXNjcmliZSBhIHJlZ2lvbi5cbiAqIEBleGFtcGxlIHdhdmVzdXJmZXIuYWRkUmVnaW9uKHJlZ2lvblBhcmFtcyk7XG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQ94oaScmFuZG9tIFRoZSBpZCBvZiB0aGUgcmVnaW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnQ9MCBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiAoaW4gc2Vjb25kcykuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kPTAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVnaW9uIChpbiBzZWNvbmRzKS5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGxvb3AgV2hldGhlciB0byBsb29wIHRoZSByZWdpb24gd2hlbiBwbGF5ZWQgYmFjay5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZHJhZz10cnVlIEFsbG93L2Rpc3NhbGxvdyBkcmFnZ2luZyB0aGUgcmVnaW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSByZXNpemU9dHJ1ZSBBbGxvdy9kaXNzYWxsb3cgcmVzaXppbmcgdGhlIHJlZ2lvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3I9J3JnYmEoMCwgMCwgMCwgMC4xKSddIEhUTUwgY29sb3IgY29kZS5cbiAqL1xuXG4vKipcbiAqIFJlZ2lvbnMgYXJlIHZpc3VhbCBvdmVybGF5cyBvbiB3YXZlZm9ybSB0aGF0IGNhbiBiZSB1c2VkIHRvIHBsYXkgYW5kIGxvb3BcbiAqIHBvcnRpb25zIG9mIGF1ZGlvLiBSZWdpb25zIGNhbiBiZSBkcmFnZ2VkIGFuZCByZXNpemVkLlxuICpcbiAqIFZpc3VhbCBjdXN0b21pemF0aW9uIGlzIHBvc3NpYmxlIHZpYSBDU1MgKHVzaW5nIHRoZSBzZWxlY3RvcnNcbiAqIGAud2F2ZXN1cmZlci1yZWdpb25gIGFuZCBgLndhdmVzdXJmZXItaGFuZGxlYCkuXG4gKlxuICogQGltcGxlbWVudHMge1BsdWdpbkNsYXNzfVxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBlczZcbiAqIGltcG9ydCBSZWdpb25zUGx1Z2luIGZyb20gJ3dhdmVzdXJmZXIucmVnaW9ucy5qcyc7XG4gKlxuICogLy8gY29tbW9uanNcbiAqIHZhciBSZWdpb25zUGx1Z2luID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5yZWdpb25zLmpzJyk7XG4gKlxuICogLy8gaWYgeW91IGFyZSB1c2luZyA8c2NyaXB0PiB0YWdzXG4gKiB2YXIgUmVnaW9uc1BsdWdpbiA9IHdpbmRvdy5XYXZlU3VyZmVyLnJlZ2lvbnM7XG4gKlxuICogLy8gLi4uIGluaXRpYWxpc2luZyB3YXZlc3VyZmVyIHdpdGggdGhlIHBsdWdpblxuICogdmFyIHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZSh7XG4gKiAgIC8vIHdhdmVzdXJmZXIgb3B0aW9ucyAuLi5cbiAqICAgcGx1Z2luczogW1xuICogICAgIFJlZ2lvbnNQbHVnaW4uY3JlYXRlKHtcbiAqICAgICAgIC8vIHBsdWdpbiBvcHRpb25zIC4uLlxuICogICAgIH0pXG4gKiAgIF1cbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWdpb25zUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBSZWdpb25zIHBsdWdpbiBkZWZpbml0aW9uIGZhY3RvcnlcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGNyZWF0ZSBhIHBsdWdpbiBkZWZpbml0aW9uIHdoaWNoIGNhbiBiZVxuICAgICAqIHVzZWQgYnkgd2F2ZXN1cmZlciB0byBjb3JyZWN0bHkgaW5zdGFudGlhdGUgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaW9uc1BsdWdpblBhcmFtc30gcGFyYW1zIHBhcmFtZXRlcnMgdXNlIHRvIGluaXRpYWxpc2UgdGhlIHBsdWdpblxuICAgICAqIEByZXR1cm4ge1BsdWdpbkRlZmluaXRpb259IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBsdWdpblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAncmVnaW9ucycsXG4gICAgICAgICAgICBkZWZlckluaXQ6IHBhcmFtcyAmJiBwYXJhbXMuZGVmZXJJbml0ID8gcGFyYW1zLmRlZmVySW5pdCA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBzdGF0aWNQcm9wczoge1xuICAgICAgICAgICAgICAgIGluaXRSZWdpb25zKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnRGVwcmVjYXRlZCBpbml0UmVnaW9ucyEgVXNlIHdhdmVzdXJmZXIuaW5pdFBsdWdpbnMoXCJyZWdpb25zXCIpIGluc3RlYWQhJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQbHVnaW4oJ3JlZ2lvbnMnKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWRkUmVnaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdC5yZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQbHVnaW4oJ3JlZ2lvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25zLmFkZChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgY2xlYXJSZWdpb25zKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbnMgJiYgdGhpcy5yZWdpb25zLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGVuYWJsZURyYWdTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0LnJlZ2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBsdWdpbigncmVnaW9ucycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaW9ucy5lbmFibGVEcmFnU2VsZWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBkaXNhYmxlRHJhZ1NlbGVjdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25zLmRpc2FibGVEcmFnU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBSZWdpb25zUGx1Z2luXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocGFyYW1zLCB3cykge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyID0gd3M7XG4gICAgICAgIHRoaXMudXRpbCA9IHdzLnV0aWw7XG5cbiAgICAgICAgLy8gdHVybiB0aGUgcGx1Z2luIGluc3RhbmNlIGludG8gYW4gb2JzZXJ2ZXJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJQcm90b3R5cGVLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXG4gICAgICAgICAgICB0aGlzLnV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlXG4gICAgICAgICk7XG4gICAgICAgIG9ic2VydmVyUHJvdG90eXBlS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBSZWdpb24ucHJvdG90eXBlW2tleV0gPSB0aGlzLnV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIuUmVnaW9uID0gUmVnaW9uO1xuXG4gICAgICAgIC8vIElkLWJhc2VkIGhhc2ggb2YgcmVnaW9ucy5cbiAgICAgICAgdGhpcy5saXN0ID0ge307XG4gICAgICAgIHRoaXMuX29uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLndyYXBwZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbXMucmVnaW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLnJlZ2lvbnMuZm9yRWFjaChyZWdpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChyZWdpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZURyYWdTZWxlY3Rpb24odGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdzIGlzIHJlYWR5XG4gICAgICAgIGlmICh0aGlzLndhdmVzdXJmZXIuaXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5fb25SZWFkeSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5vbigncmVhZHknLCB0aGlzLl9vblJlYWR5KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIudW4oJ3JlYWR5JywgdGhpcy5fb25SZWFkeSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZURyYWdTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKiBBZGQgYSByZWdpb24uICovXG4gICAgYWRkKHBhcmFtcykge1xuICAgICAgICBjb25zdCByZWdpb24gPSBuZXcgdGhpcy53YXZlc3VyZmVyLlJlZ2lvbihwYXJhbXMsIHRoaXMud2F2ZXN1cmZlcik7XG5cbiAgICAgICAgdGhpcy5saXN0W3JlZ2lvbi5pZF0gPSByZWdpb247XG5cbiAgICAgICAgcmVnaW9uLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W3JlZ2lvbi5pZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWdpb247XG4gICAgfVxuXG4gICAgLyogUmVtb3ZlIGFsbCByZWdpb25zLiAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3QpLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0W2lkXS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZW5hYmxlRHJhZ1NlbGVjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgc2xvcCA9IHBhcmFtcy5zbG9wIHx8IDI7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBzY3JvbGwgPVxuICAgICAgICAgICAgcGFyYW1zLnNjcm9sbCAhPT0gZmFsc2UgJiYgdGhpcy53YXZlc3VyZmVyLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbFNwZWVkID0gcGFyYW1zLnNjcm9sbFNwZWVkIHx8IDE7XG4gICAgICAgIGNvbnN0IHNjcm9sbFRocmVzaG9sZCA9IHBhcmFtcy5zY3JvbGxUaHJlc2hvbGQgfHwgMTA7XG4gICAgICAgIGxldCBkcmFnO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgbGV0IG1heFNjcm9sbDtcbiAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICBsZXQgcmVnaW9uO1xuICAgICAgICBsZXQgdG91Y2hJZDtcbiAgICAgICAgbGV0IHB4TW92ZSA9IDA7XG4gICAgICAgIGxldCBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgIGxldCB3cmFwcGVyUmVjdDtcblxuICAgICAgICAvLyBTY3JvbGwgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuICAgICAgICBjb25zdCBlZGdlU2Nyb2xsID0gZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlZ2lvbiB8fCAhc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICBsZXQgc2Nyb2xsTGVmdCA9XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnNjcm9sbExlZnQgKyBzY3JvbGxTcGVlZCAqIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIG1heFNjcm9sbCxcbiAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBzY3JvbGxMZWZ0KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHJhbmdlXG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgcmVnaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWluKGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWF4KGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgbW9yZSB0byBzY3JvbGwgYW5kIHJlcGVhdFxuICAgICAgICAgICAgaWYgKHNjcm9sbExlZnQgPCBtYXhTY3JvbGwgJiYgc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVNjcm9sbChlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBldmVudERvd24gPSBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgdG91Y2hJZCA9IGUudGFyZ2V0VG91Y2hlcyA/IGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gU3RvcmUgZm9yIHNjcm9sbCBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIG1heFNjcm9sbCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAtIHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHdyYXBwZXJSZWN0ID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBkcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCB0cnVlKTtcbiAgICAgICAgICAgIHJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnREb3duKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBldmVudERvd24pO1xuICAgICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBldmVudERvd24pO1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50RG93bik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50VXAgPSBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHB4TW92ZSA9IDA7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGlsLnByZXZlbnRDbGljaygpO1xuICAgICAgICAgICAgICAgIHJlZ2lvbi5maXJlRXZlbnQoJ3VwZGF0ZS1lbmQnLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tdXBkYXRlLWVuZCcsIHJlZ2lvbiwgZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZ2lvbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRVcCk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50VXApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnRVcCk7XG4gICAgICAgIHRoaXMub24oJ2Rpc2FibGUtZHJhZy1zZWxlY3Rpb24nLCAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudFVwKTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnRNb3ZlID0gZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKytweE1vdmUgPD0gc2xvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXIgIT0gdG91Y2hJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLmFkZChwYXJhbXMgfHwge30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgcmVnaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWluKGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWF4KGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBlbmFibGVkXG4gICAgICAgICAgICBpZiAoc2Nyb2xsICYmIGNvbnRhaW5lci5jbGllbnRXaWR0aCA8IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRocmVzaG9sZCBiYXNlZCBvbiBtb3VzZVxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSB3cmFwcGVyUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh4IDw9IHNjcm9sbFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPj0gd3JhcHBlclJlY3QucmlnaHQgLSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gJiYgZWRnZVNjcm9sbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudE1vdmUpO1xuICAgICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnRNb3ZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzYWJsZURyYWdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyogR2V0IGN1cnJlbnQgcmVnaW9uXG4gICAgICogIFRoZSBzbWFsbGVzdCByZWdpb24gdGhhdCBjb250YWlucyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqICBJZiBzZXZlcmFsIHN1Y2ggcmVnaW9ucyBleGlzdCwgd2UgdGFrZSB0aGUgZmlyc3QuXG4gICAgICogIFJldHVybiBudWxsIGlmIG5vbmUgZXhpc3QuICovXG4gICAgZ2V0Q3VycmVudFJlZ2lvbigpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMud2F2ZXN1cmZlci5nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0KS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IHRoaXMubGlzdFtpZF07XG4gICAgICAgICAgICBpZiAoY3VyLnN0YXJ0IDw9IHRpbWUgJiYgY3VyLmVuZCA+PSB0aW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtaW4gfHwgY3VyLmVuZCAtIGN1ci5zdGFydCA8IG1pbi5lbmQgLSBtaW4uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY3VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGxpYlxuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG4vLyBpbml0aWFsIHN0YXRlXG5jb25zdCBpbml0aWFsID0ge1xuXHRudW1iZXI6IDBcbn07XG5cbi8vIGFjdGlvblxuY29uc3Qgc2V0ID0gbnVtYmVyID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgJ2NvdW50ZXInLCB7bnVtYmVyfSk7XG5jb25zdCBpbmNyID0gKCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCAnY291bnRlcicsIHtudW1iZXI6IHN0YXRlLmNvdW50ZXIubnVtYmVyICsgMX0pO1xuY29uc3QgZGVjciA9ICgpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgJ2NvdW50ZXInLCB7bnVtYmVyOiBzdGF0ZS5jb3VudGVyLm51bWJlciAtIDF9KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGluaXRpYWwsXG5cdHNldCxcblx0aW5jcixcblx0ZGVjclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgYXJyfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbi8vIG5hbWVzcGFjZXM9XG5jb25zdCBjb3VudGVyID0gcmVxdWlyZSgnLi9jb3VudGVyJyk7XG5jb25zdCBtaWRpTWFwID0gcmVxdWlyZSgnLi9taWRpLW1hcCcpO1xuXG4vLyBpbml0aWFsXG5jb25zdCBpbml0aWFsID0ge1xuXHRtb2RlOiAxLFxuXHRzdHQ6IGZhbHNlLFxuXHRzdHRNaWM6IGZhbHNlLFxuXHRxdWVyeTogJycsXG5cdHNlc3Npb246IHtcblx0XHRzYW1wbGU6ICdhc3NldHMvTGF0aW5FdGhub0VsZWt0cm9Hcm9vdmUubXAzJyxcblx0XHRwbGF5aW5nOiBmYWxzZSxcblx0XHRmb2N1c2VkOiBbMCwgMF0sXG5cdFx0cGFkczoge31cblx0fSxcblx0c2FtcGxlczoge1xuXHRcdGxpc3Q6IFtdLFxuXHRcdHF1ZXJ5OiB7XG5cdFx0XHRwYWdlOiAxLFxuXHRcdFx0cGF0dGVybjogJycsXG5cdFx0XHRzb3VyY2U6ICdmcmVlc291bmQnLFxuXHRcdFx0bGltaXQ6IDEyXG5cdFx0fVxuXHR9LFxuXHRyYWNrOiB7XG5cdFx0dmNmOiB7XG5cdFx0XHRvbjogZmFsc2UsXG5cdFx0XHRleHBhbmRlZDogdHJ1ZSxcblx0XHRcdHR5cGU6ICdsb3dwYXNzJyxcblx0XHRcdGN1dG9mZjogMC42NCxcblx0XHRcdHJlc29uYW5jZTogMCxcblx0XHRcdGdhaW46IDBcblx0XHR9LFxuXHRcdHJldmVyYjoge1xuXHRcdFx0b246IGZhbHNlLFxuXHRcdFx0c2Vjb25kczogMyxcblx0XHRcdGRlY2F5OiAyLFxuXHRcdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0XHRkcnk6IDAuOCxcblx0XHRcdHdldDogMC43XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBhY3Rpb25zXG5jb25zdCBzZXQgPSAoa2V5LCB2YWx1ZSkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBrZXksIHZhbHVlKTtcbmNvbnN0IHRvZ2dsZSA9IGtleSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIGtleSwgIW9iai5zdWIoc3RhdGUsIGtleSkpO1xuY29uc3QgYXJyVG9nZ2xlID0gKGtleSwgdmFsdWUpID0+IHN0YXRlID0+XG5cdG9iai5wYXRjaChzdGF0ZSwga2V5LFxuXHRcdGFyci50b2dnbGUob2JqLnN1YihzdGF0ZSwga2V5KSwgdmFsdWUpXG5cdCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbml0aWFsLFxuXHQvLyBuYW1lc3BhY2VzXG5cdG1pZGlNYXAsXG5cdC8vIGFjdGlvbnNcblx0c2V0LFxuXHR0b2dnbGUsXG5cdGFyclRvZ2dsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG4vLyB1dGlsXG5jb25zdCB7b2JqLCBhcnJ9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxuY29uc3QgYXJyTW9kID0gKGEsIHAsIHYpID0+IFtdLmNvbmNhdChcblx0YS5zbGljZSgwLCBwWzBdKSxcblx0W3AubGVuZ3RoID09PSAxID8gdiA6IGFyck1vZChhW3BbMF1dLCBwLnNsaWNlKDEpLCB2KV0sXG5cdGEuc2xpY2UocFswXSArIDEpXG4pO1xuXG5jb25zdCBpbml0aWFsID0ge1xuXHRkZXZpY2VzOiB7XG5cdFx0aW5wdXRzOiBbXSxcblx0XHRvdXRwdXRzOiBbXVxuXHR9LFxuXHRzZXR0aW5nczoge1xuXHRcdG1pZGlSb3V0ZVRvQWN0aXZlOiB0cnVlXG5cdH0sXG5cdGNsb2NrOiB7XG5cdFx0aW46IFtdLFxuXHRcdG91dDogW11cblx0fSxcblx0ZGF0YToge1xuXHRcdGluOiBbXSxcblx0XHRvdXQ6IFtdXG5cdH0sXG5cdHBpdGNoOiAwLFxuXHRjaGFubmVsczoge1xuXHR9LFxuXHRtYXA6IFtcblx0XHRbJ2NvbnRyb2xsZXInLCAyMCwgWydpbnN0cnVtZW50JywgJ3ZjZicsICdjdXRvZmYnXV0sXG5cdFx0Wydjb250cm9sbGVyJywgMjEsIFsnaW5zdHJ1bWVudCcsICd2Y2YnLCAncmVzb25hbmNlJ11dLFxuXHRcdFsnY29udHJvbGxlcicsIDIyLCBbJ3N0dWRpbycsICdicG0nXSwgNjAsIDIwMCwgMF0sXG5cdFx0Wydjb250cm9sbGVyJywgMjMsIFsnc3R1ZGlvJywgJ3ZvbHVtZSddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNCwgWydpbnN0cnVtZW50JywgJ2VnJywgJ2F0dGFjayddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNSwgWydpbnN0cnVtZW50JywgJ2VnJywgJ2RlY2F5J11dLFxuXHRcdFsnY29udHJvbGxlcicsIDI2LCBbJ2luc3RydW1lbnQnLCAnZWcnLCAnc3VzdGFpbiddXSxcblx0XHRbJ2NvbnRyb2xsZXInLCAyNywgWydpbnN0cnVtZW50JywgJ2VnJywgJ3JlbGVhc2UnXV1cblx0XVxufTtcblxuY29uc3QgY29ubmVjdCA9IGRldmljZXMgPT5cblx0c3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCAnbWlkaU1hcCcsIHtcblx0XHRkZXZpY2VzLFxuXHRcdGRhdGE6IHtcblx0XHRcdC4uLnN0YXRlLm1pZGlNYXAuZGF0YSxcblx0XHRcdGluOiBzdGF0ZS5taWRpTWFwLmRhdGEuaW4uaW5kZXhPZihkZXZpY2VzLmlucHV0cy5maW5kSW5kZXgoZGV2ID0+IGRldi5uYW1lLm1hdGNoKC9NUEttaW5pMi8pKSkgPT09IC0xXG5cdFx0XHRcdD8gYXJyLmFkZChzdGF0ZS5taWRpTWFwLmRhdGEuaW4sIGRldmljZXMuaW5wdXRzLmZpbmRJbmRleChkZXYgPT4gZGV2Lm5hbWUubWF0Y2goL01QS21pbmkyLykpKVxuXHRcdFx0XHQ6IHN0YXRlLm1pZGlNYXAuZGF0YS5pblxuXHRcdH1cblx0fSk7XG5cbmNvbnN0IHRvZ2dsZUNsb2NrID0gKGluT3V0LCBpbmRleCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ21pZGlNYXAnLCAnY2xvY2snLCBpbk91dF0sXG5cdGFyci50b2dnbGUob2JqLnN1YihzdGF0ZSwgWydtaWRpTWFwJywgJ2Nsb2NrJ10pW2luT3V0XSwgaW5kZXgpXG4pO1xuXG5jb25zdCB0b2dnbGVEYXRhID0gKGluT3V0LCBpbmRleCkgPT4gc3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ21pZGlNYXAnLCAnZGF0YScsIGluT3V0XSxcblx0YXJyLnRvZ2dsZShvYmouc3ViKHN0YXRlLCBbJ21pZGlNYXAnLCAnZGF0YScsIGluT3V0XSksIGluZGV4KVxuKTtcblxuY29uc3Qgbm90ZU9uID0gKGRldmljZSA9IDAsIGNoYW5uZWwsIG5vdGUsIHZlbG9jaXR5ID0gMCkgPT4gc3RhdGUgPT4gY2hhbm5lbCAhPT0gdW5kZWZpbmVkID8gKFxuXHQvLyBjb25zb2xlLmxvZyhzdGF0ZS5taWRpTWFwLmNoYW5uZWxzLCBvYmouc3ViKHN0YXRlLCBbJ21pZGlNYXAnLCAnY2hhbm5lbHMnLCBjaGFubmVsLCBub3RlXSksIGNoYW5uZWwsIG5vdGUsIHZlbG9jaXR5KSxcblx0dmVsb2NpdHkgIT09IDBcblx0XHQ/IG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJywgZGV2aWNlLCBjaGFubmVsLCBub3RlXSwgdmVsb2NpdHkpXG5cdFx0OiBvYmoucGF0Y2goc3RhdGUsIFsnbWlkaU1hcCcsICdjaGFubmVscycsIGRldmljZV0sIHtcblx0XHRcdFtjaGFubmVsXTogb2JqLmZpbHRlcihcblx0XHRcdFx0b2JqLnN1YihzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJywgZGV2aWNlLCBjaGFubmVsXSkgfHwge30sXG5cdFx0XHRcdChrZXksIHZhbHVlKSA9PiBrZXkgIT09IG5vdGUpXG5cdFx0fSlcblx0KSA6IHN0YXRlO1xuXG5jb25zdCBwYW5pYyA9ICgpID0+IHN0YXRlID0+XG5cdG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJywgJ2NoYW5uZWxzJ10sIHt9KTtcblxuY29uc3QgbW9kaWZ5ID0gKHAsIHYpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydtaWRpTWFwJ10sIHtcblx0bWFwOiBhcnJNb2Qoc3RhdGUubWlkaU1hcC5tYXAsIHAsIHYpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGluaXRpYWwsXG5cdGNvbm5lY3QsXG5cdHRvZ2dsZUNsb2NrLFxuXHR0b2dnbGVEYXRhLFxuXHRub3RlT24sXG5cdHBhbmljLFxuXHRtb2RpZnlcbn07XG4iLCJcbmltcG9ydCBSZWdpb25zUGx1Z2luIGZyb20gJ3dhdmVzdXJmZXIuanMvc3JjL3BsdWdpbi9yZWdpb25zLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0V1NSZWdpb25zUGx1Z2luIGV4dGVuZHMgUmVnaW9uc1BsdWdpbiB7XG5cdC8vIGNvbnN0cnVjdG9yKHBhcmFtcywgd3MpIHtcblx0Ly8gXHRzdXBlcihwYXJhbXMsIHdzKTtcblx0Ly8gfVxuXHRzdGF0aWMgY3JlYXRlKHBhcmFtcykge1xuXHRcdGNvbnN0IHtzdGF0aWNQcm9wc30gPSBSZWdpb25zUGx1Z2luLmNyZWF0ZShwYXJhbXMpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiAncmVnaW9ucycsXG5cdFx0XHRkZWZlckluaXQ6IHBhcmFtcyAmJiBwYXJhbXMuZGVmZXJJbml0ID8gcGFyYW1zLmRlZmVySW5pdCA6IGZhbHNlLFxuXHRcdFx0cGFyYW1zLFxuXHRcdFx0c3RhdGljUHJvcHMsXG5cdFx0XHRpbnN0YW5jZTogRXh0V1NSZWdpb25zUGx1Z2luXG5cdFx0fTtcblx0fVxuXHRhZGQocGFyYW1zKSB7XG5cdFx0Ly8gY29uc29sZS5sb2codGhpcy5wYXJhbXMpO1xuXHRcdGlmICh0aGlzLnBhcmFtcy5zaW5nbGVSZWdpb24gPT09IHRydWUpIHtcblx0XHRcdHRoaXMuY2xlYXIoKTtcblx0XHR9XG5cblx0XHRjb25zdCByZWdpb24gPSBuZXcgdGhpcy53YXZlc3VyZmVyLlJlZ2lvbihwYXJhbXMsIHRoaXMud2F2ZXN1cmZlcik7XG5cblx0XHR0aGlzLmxpc3RbcmVnaW9uLmlkXSA9IHJlZ2lvbjtcblxuXHRcdHJlZ2lvbi5vbigncmVtb3ZlJywgKCkgPT4ge1xuXHRcdFx0ZGVsZXRlIHRoaXMubGlzdFtyZWdpb24uaWRdO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJlZ2lvbjtcblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG4vLyBpYmxva3pcbmNvbnN0IHZkb20gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuY29uc3Qge29iaiwgYXJyfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbi8vIGFwcFxuY29uc3QgYXBwID0gcmVxdWlyZSgnLi91dGlsL2FwcCcpO1xubGV0IGFjdGlvbnMgPSBhcHAuYWRhcHQocmVxdWlyZSgnLi9hY3Rpb25zJykpO1xubGV0IHVpID0gcmVxdWlyZSgnLi91aScpO1xubGV0IGFjdGlvbnMkO1xuY29uc3Qgc3RhdGUkID0gbmV3IFJ4LkJlaGF2aW9yU3ViamVjdCgpO1xuLy8gc2VydmljZXNcbi8vIHdhdmVzdXJmZXJcbmxldCB3YXZlc3VyZmVyID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy93YXZlc3VyZmVyLmpzJyk7XG4vLyBzYW1wbGVzIC0gYXVkaW9jb21tb25zXG5sZXQgc2FtcGxlcyA9IHJlcXVpcmUoJy4vc2VydmljZXMvc2FtcGxlcy5qcycpO1xuYWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3NhbXBsZXMnLCBzYW1wbGVzLmFjdGlvbnMpO1xuLy8gcGFkc1xubGV0IHBhZHMgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3BhZHMuanMnKTtcbmFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdwYWRzJywgcGFkcy5hY3Rpb25zKTtcbi8vIG1pZGlcbmxldCBtaWRpID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9taWRpLmpzJyk7XG5hY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnbWlkaScsIG1pZGkuYWN0aW9ucyk7XG4vLyBzdHQgLSBzcGVhY2ggdG8gdGV4dFxubGV0IHN0dCA9IHJlcXVpcmUoJy4vc2VydmljZXMvc3R0LmpzJyk7XG4vLyBjb250cm9sXG5sZXQgY29udHJvbCA9IHJlcXVpcmUoJy4vc2VydmljZXMvY29udHJvbC5qcycpO1xuYWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ2NvbnRyb2wnLCBjb250cm9sLmFjdGlvbnMpO1xuXG4vLyBob3QgcmVsb2FkaW5nXG5pZiAobW9kdWxlLmhvdCkge1xuXHQvLyBhY3Rpb25zXG5cdGFjdGlvbnMkID0gJC5mcm9tRXZlbnRQYXR0ZXJuKFxuICAgIGggPT4gbW9kdWxlLmhvdC5hY2NlcHQoXCIuL2FjdGlvbnNcIiwgaClcblx0KS5mbGF0TWFwKCgpID0+IHtcblx0XHRhY3Rpb25zID0gYXBwLmFkYXB0KHJlcXVpcmUoJy4vYWN0aW9ucycpKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAncGFkcycsIHBhZHMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3NhbXBsZXMnLCBzYW1wbGVzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdtaWRpJywgbWlkaS5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnY29udHJvbCcsIGNvbnRyb2wuYWN0aW9ucyk7XG5cdFx0cmV0dXJuIGFjdGlvbnMuc3RyZWFtLnN0YXJ0V2l0aChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pLm1lcmdlKGFjdGlvbnMuc3RyZWFtKTtcblx0Ly8gdWlcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3VpXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHVpID0gcmVxdWlyZSgnLi91aScpO1xuXHRcdGFjdGlvbnMuc3RyZWFtLm9uTmV4dChzdGF0ZSA9PiBzdGF0ZSk7XG5cdH0pO1xuXHQvLyBzZXJ2aWNlc1xuXHQvLyB3YXZlc3VyZmVyXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9zZXJ2aWNlcy93YXZlc3VyZmVyLmpzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHdhdmVzdXJmZXIudW5ob29rKCk7XG5cdFx0d2F2ZXN1cmZlciA9IHJlcXVpcmUoJy4vc2VydmljZXMvd2F2ZXN1cmZlci5qcycpO1xuXHRcdHdhdmVzdXJmZXIuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG5cdC8vIHNhbXBsZXNcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NlcnZpY2VzL3NhbXBsZXMuanNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0c2FtcGxlcy51bmhvb2soKTtcblx0XHRzYW1wbGVzID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9zYW1wbGVzLmpzJyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hZGFwdChyZXF1aXJlKCcuL2FjdGlvbnMnKSk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3BhZHMnLCBwYWRzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdzYW1wbGVzJywgc2FtcGxlcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnbWlkaScsIG1pZGkuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ2NvbnRyb2wnLCBjb250cm9sLmFjdGlvbnMpO1xuXHRcdHNhbXBsZXMuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG5cdC8vIHBhZHNcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NlcnZpY2VzL3BhZHMuanNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0cGFkcy51bmhvb2soKTtcblx0XHRwYWRzID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9wYWRzLmpzJyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hZGFwdChyZXF1aXJlKCcuL2FjdGlvbnMnKSk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3BhZHMnLCBwYWRzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdzYW1wbGVzJywgc2FtcGxlcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnbWlkaScsIG1pZGkuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ2NvbnRyb2wnLCBjb250cm9sLmFjdGlvbnMpO1xuXHRcdHBhZHMuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG5cdC8vIG1pZGlcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NlcnZpY2VzL21pZGkuanNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0bWlkaS51bmhvb2soKTtcblx0XHRtaWRpID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9taWRpLmpzJyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hZGFwdChyZXF1aXJlKCcuL2FjdGlvbnMnKSk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3BhZHMnLCBwYWRzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdzYW1wbGVzJywgc2FtcGxlcy5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnbWlkaScsIG1pZGkuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ2NvbnRyb2wnLCBjb250cm9sLmFjdGlvbnMpO1xuXHRcdG1pZGkuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5cdFx0YWN0aW9ucy5zdHJlYW0ub25OZXh0KHN0YXRlID0+IHN0YXRlKTtcblx0fSk7XG5cdC8vIHN0dFxuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vc2VydmljZXMvc3R0LmpzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHN0dC51bmhvb2soKTtcblx0XHRzdHQgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3N0dC5qcycpO1xuXHRcdHN0dC5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcblx0Ly8gY29udHJvbFxuXHRtb2R1bGUuaG90LmFjY2VwdChcIi4vc2VydmljZXMvY29udHJvbC5qc1wiLCBmdW5jdGlvbigpIHtcblx0XHRjb250cm9sLnVuaG9vaygpO1xuXHRcdGNvbnRyb2wgPSByZXF1aXJlKCcuL3NlcnZpY2VzL2NvbnRyb2wuanMnKTtcblx0XHRhY3Rpb25zID0gYXBwLmFkYXB0KHJlcXVpcmUoJy4vYWN0aW9ucycpKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAncGFkcycsIHBhZHMuYWN0aW9ucyk7XG5cdFx0YWN0aW9ucyA9IGFwcC5hdHRhY2goYWN0aW9ucywgJ3NhbXBsZXMnLCBzYW1wbGVzLmFjdGlvbnMpO1xuXHRcdGFjdGlvbnMgPSBhcHAuYXR0YWNoKGFjdGlvbnMsICdtaWRpJywgbWlkaS5hY3Rpb25zKTtcblx0XHRhY3Rpb25zID0gYXBwLmF0dGFjaChhY3Rpb25zLCAnY29udHJvbCcsIGNvbnRyb2wuYWN0aW9ucyk7XG5cdFx0Y29udHJvbC5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcblx0XHRhY3Rpb25zLnN0cmVhbS5vbk5leHQoc3RhdGUgPT4gc3RhdGUpO1xuXHR9KTtcbn0gZWxzZSB7XG5cdGFjdGlvbnMkID0gYWN0aW9ucy5zdHJlYW07XG59XG5cbi8vIGFjdGlvbnMgLT4gc3RhdGVcbmFjdGlvbnMkXG5cdC5tYXAoYWN0aW9uID0+IChcblx0XHRhY3Rpb24ucGF0aCAmJiBjb25zb2xlLmxvZyhhY3Rpb24ucGF0aC5qb2luKCcuJyksIGFjdGlvbi5wYXlsb2FkKSxcblx0XHRjb25zb2xlLmxvZyhhY3Rpb24pLFxuXHRcdGFjdGlvblxuXHQpKVxuXHQuc3RhcnRXaXRoKCgpID0+IGFjdGlvbnMuaW5pdGlhbClcblx0LnNjYW4oKHN0YXRlLCBjaGFuZ2UpID0+IGNoYW5nZShzdGF0ZSksIHt9KVxuXHQubWFwKHN0YXRlID0+IChjb25zb2xlLmxvZyhzdGF0ZSksIHN0YXRlKSlcblx0LnN1YnNjcmliZShzdGF0ZSA9PiBzdGF0ZSQub25OZXh0KHN0YXRlKSk7XG5cbi8vIHN0YXRlIC0+IHVpXG5jb25zdCB1aSQgPSBzdGF0ZSQubWFwKHN0YXRlID0+IHVpKHtzdGF0ZSwgYWN0aW9uc30pKTtcbnZkb20ucGF0Y2hTdHJlYW0odWkkLCAnI3VpJyk7XG5cbndhdmVzdXJmZXIuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5zYW1wbGVzLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xucGFkcy5ob29rKHtzdGF0ZSQsIGFjdGlvbnN9KTtcbm1pZGkuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5zdHQuaG9vayh7c3RhdGUkLCBhY3Rpb25zfSk7XG5jb250cm9sLmhvb2soe3N0YXRlJCwgYWN0aW9uc30pO1xuXG4vLyBsaXZlcmVsb2FkIGltcGwuXG5pZiAobW9kdWxlLmhvdCkge1xuXHRkb2N1bWVudC53cml0ZShgPHNjcmlwdCBzcmM9XCJodHRwOi8vJHsobG9jYXRpb24uaG9zdCB8fCAnbG9jYWxob3N0Jykuc3BsaXQoJzonKVswXX1gICtcblx0YDozNTcyOS9saXZlcmVsb2FkLmpzP3NuaXB2ZXI9MVwiPjwvc2NyaXB0PmApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3QgZ2FtZXBhZCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2FtZXBhZCcpO1xuXG5sZXQgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge31cbn07XG5cbmNvbnN0IHBsYXkgPSB1cmwgPT4ge1xuXHRsZXQgYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdBVURJTycpO1xuXHRhbi5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgdHJ1ZSk7XG5cdGFuLnNyYyA9IHVybDtcbn07XG5cbmNvbnN0IGtleU1hcCA9IFtcblx0Wyc3JywgJzgnLCAnOScsICcwJ10sXG5cdFsndScsICdpJywgJ28nLCAncCddLFxuXHRbJ2onLCAnaycsICdsJywgJzsnXSxcblx0WydtJywgJywnLCAnLicsICcvJ11cbl07XG5cbmNvbnN0IGdldEluZGV4ID0ga2V5ID0+IGtleU1hcC5yZWR1Y2UoXG5cdChwMSwgY29scywgcm93KSA9PiBwMS5yb3cgPT09IC0xID8gY29scy5yZWR1Y2UoXG5cdFx0KHAyLCBtYXBLZXksIGNvbCkgPT4ga2V5ID09PSBtYXBLZXlcblx0XHRcdD8gKHtyb3csIGNvbH0pXG5cdFx0XHQ6IHAyLFxuXHRcdHAxXG5cdCkgOiBwMSxcblx0e3JvdzogLTEsIGNvbDogLTF9XG4pO1xuXG5sZXQgdW5ob29rID0gKCkgPT4ge307XG5jb25zdCBob29rID0gKHtzdGF0ZSQsIGFjdGlvbnN9KSA9PiB7XG5cdGxldCBzdWJzID0gW107XG5cblx0Z2FtZXBhZC5jaGFuZ2VzKClcblx0XHQubWFwKHBhZHMgPT4gKGNvbnNvbGUubG9nKHtwYWRzfSksIHBhZHMpKVxuXHRcdC53aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIChwYWRzLCBzdGF0ZSkgPT4gKHtwYWRzLCBzdGF0ZX0pKVxuXHRcdC5zdWJzY3JpYmUoKHtwYWRzLCBzdGF0ZX0pID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKHBhZHNbMF0pO1xuXHRcdFx0aWYgKHBhZHNbMF0pIHtcblx0XHRcdFx0aWYgKHBhZHNbMF0uYXhlc1sxXSA9PT0gLTEpIGFjdGlvbnMuc2FtcGxlcy5wcmV2KCk7XG5cdFx0XHRcdC8vIGlmIChwYWRzWzBdLmF4ZXNbMF0gPiAwKSBhY3Rpb25zLm1vdmUoJ3JpZ2h0Jyk7XG5cdFx0XHRcdGlmIChwYWRzWzBdLmF4ZXNbMV0gPT09IDEpIGFjdGlvbnMuc2FtcGxlcy5uZXh0KCk7XG5cdFx0XHRcdC8vIGlmIChwYWRzWzBdLmF4ZXNbMF0gPCAwKSBhY3Rpb25zLm1vdmUoJ2xlZnQnKTtcblx0XHRcdFx0aWYgKHBhZHNbMF0uYnV0dG9uc1s4XS5wcmVzc2VkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0aWYgKHN0YXRlLnNhbXBsZXMubGlzdFtzdGF0ZS5zYW1wbGVzLmluZGV4XSkgcGxheShzdGF0ZS5zYW1wbGVzLmxpc3Rbc3RhdGUuc2FtcGxlcy5pbmRleF0uc291bmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYWRzWzBdLmJ1dHRvbnNbM10ucHJlc3NlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGxldCBzYW1wbGUgPSBzdGF0ZS5zYW1wbGVzLmxpc3Rbc3RhdGUuc2FtcGxlcy5pbmRleF07XG5cdFx0XHRcdFx0aWYgKHNhbXBsZSkgYWN0aW9ucy5wYWRzLmxvYWQoc2FtcGxlLCBzYW1wbGUuc291bmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYWRzWzBdLmJ1dHRvbnNbMF0ucHJlc3NlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGFjdGlvbnMuc2V0KCdzdHRNaWMnLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFkc1swXS5idXR0b25zWzFdLnByZXNzZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRhY3Rpb25zLnNldCgnbW9kZScsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYWRzWzBdLmJ1dHRvbnNbMl0ucHJlc3NlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGFjdGlvbnMuc2V0KCdtb2RlJywgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHQkLmZyb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nKVxuXHRcdC5maWx0ZXIoZXYgPT5cblx0XHRcdFsnaW5wdXQnLCAndGV4dGFyZWEnXS5pbmRleE9mKGV2LnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMVxuXHRcdFx0fHwgZXYudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiBldi50YXJnZXQudHlwZSA9PT0gJ3JhbmdlJ1xuXHRcdClcblx0XHQud2l0aExhdGVzdEZyb20oc3RhdGUkLCAoZXYsIHN0YXRlKSA9PiAoe2V2LCBzdGF0ZX0pKVxuXHRcdC5zdWJzY3JpYmUoKHtldiwgc3RhdGV9KSA9PiB7XG5cdFx0XHRpZiAoZXYua2V5ID4gMCAmJiBldi5rZXkgPCA0KSB7XG5cdFx0XHRcdGFjdGlvbnMuc2V0KCdtb2RlJywgcGFyc2VJbnQoZXYua2V5LCAxMCkgLSAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBwb3MgPSBnZXRJbmRleChldi5rZXkpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhldi5rZXksIGV2LnRhcmdldCwgcG9zKTtcblx0XHRcdFx0aWYgKHBvcy5yb3cgIT09IC0xKSB7XG5cdFx0XHRcdFx0YWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW1xuXHRcdFx0XHRcdFx0cG9zLnJvdywgcG9zLmNvbFxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRcdGlmIChzdGF0ZS5tb2RlID09PSAyKVxuXHRcdFx0XHRcdFx0YWN0aW9ucy5taWRpLnRyaWdnZXIocG9zLnJvdywgcG9zLmNvbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IG1pZGkgPSByZXF1aXJlKCcuLi91dGlsL21pZGknKTtcbmNvbnN0IHBvY2tldCA9IHJlcXVpcmUoJy4uL3V0aWwvcG9ja2V0Jyk7XG5jb25zdCBhID0gcmVxdWlyZSgnLi4vdXRpbC9hdWRpbycpO1xuY29uc3Qgc2FtcGxlciA9IHJlcXVpcmUoJy4uL3V0aWwvYXVkaW8vc291cmNlcy9zYW1wbGVyJyk7XG5cbmxldCByZXZlcmIgPSBhLmNvbm5lY3QoYS5jcmVhdGUoJ3JldmVyYicsIHtcblx0b246IGZhbHNlLFxuXHR3ZXQ6IDAuMSxcblx0ZHJ5OiAwLjlcbn0pLCBhLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXG5sZXQgdmNmID0gYS5jb25uZWN0KGEuY3JlYXRlKCd2Y2YnLCB7XG5cdG9uOiBmYWxzZSxcblx0dHlwZTogJ2xvd3Bhc3MnLFxuXHRjdXRvZmY6IDAuNjQsXG5cdHJlc29uYW5jZTogMCxcblx0Z2FpbjogMFxufSksIHJldmVyYik7XG5cbmNvbnN0IHJhY2sgPSB7XG59O1xuXG5jb25zdCBnZXRJZHMgPSAoaW5wdXRzLCBpbmRleGVzKSA9PiBpbnB1dHNcblx0Lm1hcChpbnAgPT4gaW5wLmlkKVxuXHQuZmlsdGVyKChpZCwgaSkgPT4gaW5kZXhlcy5pbmRleE9mKGkpID4gLTEpO1xuXG5jb25zdCB0cmlnZ2VyID0gKHJvdywgY29sKSA9PiBzdGF0ZSA9PiB7XG5cdGxldCBzYW1wbGVJZCA9IG9iai5zdWIoc3RhdGUsIFsncGFkcycsICdtYXAnLCByb3csIGNvbCwgJ2lkJ10pO1xuXHRpZiAoc2FtcGxlSWQpIHtcblx0XHRsZXQgaW5zdCA9IHNhbXBsZXIuY2xvbmUocG9ja2V0LmdldChcblx0XHRcdFsnc2FtcGxlQmFuaycsIHNhbXBsZUlkXVxuXHRcdCkpO1xuXHRcdGluc3QgPSBhLmNvbm5lY3QoaW5zdCwgc3RhdGUucmFjay52Y2Yub25cblx0XHRcdD8gdmNmXG5cdFx0XHQ6IHN0YXRlLnJhY2sucmV2ZXJiLm9uXG5cdFx0XHRcdD8gcmV2ZXJiXG5cdFx0XHRcdDogYS5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRhLnN0YXJ0KGluc3QpO1xuXHR9XG5cdHJldHVybiBzdGF0ZTtcbn07XG5cbmxldCBhY3Rpb25zID0ge1xuXHRpbml0aWFsOiB7fSxcblx0dHJpZ2dlclxufTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXG5cdGNvbnN0IHtkZXZpY2VzJCwgbXNnJH0gPSBtaWRpLmluaXQoKTtcblxuXHQvLyBhdWRpbyByYWNrXG5cdHN1YnMucHVzaChcblx0XHRzdGF0ZSQuZGlzdGluY3RVbnRpbENoYW5nZWQoc3RhdGUgPT4gc3RhdGUucmFjaylcblx0XHRcdC5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuXHRcdFx0XHRyZXZlcmIgPSBhLnVwZGF0ZShyZXZlcmIsIHN0YXRlLnJhY2sucmV2ZXJiKTtcblx0XHRcdFx0dmNmID0gYS51cGRhdGUodmNmLCBzdGF0ZS5yYWNrLnZjZik7XG5cdFx0XHRcdGlmIChzdGF0ZS5yYWNrLnJldmVyYi5vbikge1xuXHRcdFx0XHRcdHZjZiA9IGEuZGlzY29ubmVjdCh2Y2YpO1xuXHRcdFx0XHRcdHZjZiA9IGEuY29ubmVjdCh2Y2YsIHJldmVyYik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmNmID0gYS5kaXNjb25uZWN0KHZjZik7XG5cdFx0XHRcdFx0dmNmID0gYS5jb25uZWN0KHZjZiwgYS5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0KTtcblxuXHQvLyBtaWRpIGRldmljZSBhY2Nlc3Ncblx0c3Vicy5wdXNoKFxuXHRcdGRldmljZXMkLnN1YnNjcmliZShkYXRhID0+IGFjdGlvbnMubWlkaU1hcC5jb25uZWN0KGRhdGEpKVxuXHQpO1xuXG5cdGNvbnN0IHBhcnNlZE1pZGlNc2ckID0gbXNnJFxuXHRcdC5tYXAocmF3ID0+ICh7bXNnOiBtaWRpLnBhcnNlTWlkaU1zZyhyYXcubXNnKSwgcmF3fSkpXG5cdFx0Ly8gLm1hcChkYXRhID0+IChjb25zb2xlLmxvZyhkYXRhKSwgZGF0YSkpXG5cdFx0LnNoYXJlKCk7XG5cblx0Ly8gbWlkaSBtZXNzYWdlc1xuXHRzdWJzLnB1c2goXG5cdFx0cGFyc2VkTWlkaU1zZyRcblx0XHRcdC5tYXAobWlkaURhdGEgPT4gKGNvbnNvbGUubG9nKHttaWRpRGF0YX0pLCBtaWRpRGF0YSkpXG5cdFx0XHQvLyAuZmlsdGVyKCh7bXNnfSkgPT4gWydub3RlT24nLCAnbm90ZU9mZiddLmluZGV4T2YobXNnLnN0YXRlKSA+IC0xKVxuXHRcdFx0LmZpbHRlcigoe21zZ30pID0+XG5cdFx0XHRcdG1zZy5zdGF0ZSA9PT0gJ2NvbnRyb2xsZXInIHx8IG1zZy5zdGF0ZSA9PT0gJ25vdGVPbidcblx0XHRcdClcblx0XHRcdC53aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIChtaWRpRGF0YSwgc3RhdGUpID0+IChPYmplY3QuYXNzaWduKHt9LCBtaWRpRGF0YSwge3N0YXRlfSkpKVxuXHRcdFx0Ly8gLmZpbHRlcigoe3Jhdywgc3RhdGV9KSA9PiAoXG5cdFx0XHQvLyBcdC8vIGNvbnNvbGUubG9nKHJhdy5pbnB1dC5pZCwgc3RhdGUubWlkaU1hcC5kZXZpY2VzLmlucHV0cywgc3RhdGUubWlkaU1hcC5kYXRhLmluKSxcblx0XHRcdC8vIFx0Z2V0SWRzKHN0YXRlLm1pZGlNYXAuZGV2aWNlcy5pbnB1dHMsIHN0YXRlLm1pZGlNYXAuZGF0YS5pbikuaW5kZXhPZihcblx0XHRcdC8vIFx0XHRyYXcuaW5wdXQuaWRcblx0XHRcdC8vIFx0KSA+IC0xXG5cdFx0XHQvLyApKVxuXHRcdFx0LnN1YnNjcmliZSgoe3JhdywgbXNnLCBzdGF0ZX0pID0+IHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coc3RhdGUubWlkaU1hcC5kZXZpY2VzLmlucHV0cywgcmF3LmlucHV0KTtcblx0XHRcdFx0Ly8gdHJha3RvclxuXHRcdFx0XHRpZiAobXNnLmNoYW5uZWwgPT09IDEzICYmIG1zZy5zdGF0ZSA9PT0gJ2NvbnRyb2xsZXInICYmIG1zZy52YWx1ZSA9PT0gMSkge1xuXHRcdFx0XHRcdGlmIChtc2cuY29udHJvbGxlciA+PSAxMCAmJiBtc2cuY29udHJvbGxlciA8PSAyNikge1xuXHRcdFx0XHRcdFx0Y29uc3QgY29sID0gKG1zZy5jb250cm9sbGVyIC0gMTApICUgNDtcblx0XHRcdFx0XHRcdGNvbnN0IHJvdyA9ICgobXNnLmNvbnRyb2xsZXIgLSAxMCAtIGNvbCkgLyA0KTtcblx0XHRcdFx0XHRcdGxldCBzYW1wbGVJZCA9IG9iai5zdWIoc3RhdGUsIFsncGFkcycsICdtYXAnLCByb3csIGNvbF0pO1xuXHRcdFx0XHRcdFx0Ly8gbGV0IGluc3Q7XG5cdFx0XHRcdFx0XHRhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbXG5cdFx0XHRcdFx0XHRcdHJvdywgY29sXG5cdFx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRcdGlmIChzdGF0ZS5tb2RlID09PSAyKVxuXHRcdFx0XHRcdFx0XHR0cmlnZ2VyKHJvdywgY29sKShzdGF0ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtc2cuY29udHJvbGxlciA+PSAzNyAmJiBtc2cuY29udHJvbGxlciA8PSAzOSkge1xuXHRcdFx0XHRcdFx0YWN0aW9ucy5zZXQoJ21vZGUnLCBtc2cuY29udHJvbGxlciAtIDM3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1zZy5jaGFubmVsID09PSAxMCAmJiBtc2cuc3RhdGUgPT09ICdub3RlT24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgY29sID0gKG1zZy5ub3RlLm51bWJlciAtIDYwKSAlIDQ7XG5cdFx0XHRcdFx0Y29uc3Qgcm93ID0gKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAvIDQgK1xuXHRcdFx0XHRcdFx0KCgobXNnLm5vdGUubnVtYmVyIC0gNjAgLSBjb2wpIC8gNCAlIDIgPT09IDEpXG5cdFx0XHRcdFx0XHRcdD8gLTEgOiAxKTtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygobXNnLm5vdGUubnVtYmVyIC0gNjAgLSBjb2wpIC8gNCwgKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAlIDIsIHJvdywgY29sKTtcblx0XHRcdFx0XHRhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbXG5cdFx0XHRcdFx0XHRyb3csIGNvbFxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRcdGlmIChzdGF0ZS5tb2RlID09PSAyKVxuXHRcdFx0XHRcdFx0dHJpZ2dlcihyb3csIGNvbCkoc3RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtc2cuY2hhbm5lbCA9PT0gMTEgJiYgbXNnLnN0YXRlID09PSAnbm90ZU9uJykge1xuXHRcdFx0XHRcdGNvbnN0IGNvbCA9IChtc2cubm90ZS5udW1iZXIgLSA1NSkgJSAxMDtcblx0XHRcdFx0XHRjb25zdCByb3cgPSAobXNnLm5vdGUubnVtYmVyIC0gNTUgLSBjb2wpIC8gMTA7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coKG1zZy5ub3RlLm51bWJlciAtIDYwIC0gY29sKSAvIDQsIChtc2cubm90ZS5udW1iZXIgLSA2MCAtIGNvbCkgJSAyLCByb3csIGNvbCk7XG5cdFx0XHRcdFx0YWN0aW9ucy5zZXQoWydwYWRzJywgJ2ZvY3VzZWQnXSwgW1xuXHRcdFx0XHRcdFx0cm93LCBjb2xcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRpZiAoc3RhdGUubW9kZSA9PT0gMilcblx0XHRcdFx0XHRcdHRyaWdnZXIocm93LCBjb2wpKHN0YXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0KTtcblxuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuXG5jb25zdCB7b2JqLCBmbn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuY29uc3QgcG9ja2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9wb2NrZXQnKTtcbmNvbnN0IGZpbGUgPSByZXF1aXJlKCcuLi91dGlsL2ZpbGUnKTtcbmNvbnN0IHtjb250ZXh0fSA9IHJlcXVpcmUoJy4uL3V0aWwvYXVkaW8nKTtcbmNvbnN0IHNhbXBsZXIgPSByZXF1aXJlKCcuLi91dGlsL2F1ZGlvL3NvdXJjZXMvc2FtcGxlcicpO1xuXG5jb25zdCBsb2FkID0gKHNhbXBsZSwgdXJsKSA9PiAkLmZyb21Qcm9taXNlKGZldGNoKHVybC5yZXBsYWNlKCdodHRwOi8vJywgJy8vJykpXG5cdC50aGVuKHJlcyA9PiByZXMuYXJyYXlCdWZmZXIoKSkpXG5cdC5jb25jYXRNYXAoYnVmZmVyID0+ICQuZnJvbUNhbGxiYWNrKGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhLCBjb250ZXh0KShidWZmZXIpKVxuXHQubWFwKGJ1ZmZlciA9PiAoe1xuXHRcdHNhbXBsZSxcblx0XHRub2RlOiBzYW1wbGVyLmNyZWF0ZSh1cmwsIGJ1ZmZlcilcblx0fSkpXG5cdC5tYXAoKHtzYW1wbGUsIG5vZGV9KSA9PiAoXG5cdFx0cG9ja2V0LnB1dChbJ3NhbXBsZUJhbmsnLCBzYW1wbGUuaWRdLCBub2RlKSxcblx0XHRzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIFsncGFkcycsICdtYXAnLCAuLi5zdGF0ZS5wYWRzLmZvY3VzZWRdLCBzYW1wbGUpXG5cdCkpO1xuXG5jb25zdCBhY3Rpb25zID0ge1xuXHRpbml0aWFsOiB7XG5cdFx0Zm9jdXNlZDogWzAsIDBdLFxuXHRcdG1hcDoge31cblx0fSxcblx0bG9hZFxufTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXG5cdHVuaG9vayA9ICgpID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViLmRpc3Bvc2UoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0YWN0aW9ucyxcblx0aG9vayxcblx0dW5ob29rOiAoKSA9PiB1bmhvb2soKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGxpYlxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5cbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCBwb2NrZXQgPSByZXF1aXJlKCcuLi91dGlsL3BvY2tldCcpO1xuXG5jb25zdCB1cmwgPSBgaHR0cHM6Ly9tMi5hdWRpb2NvbW1vbnMub3JnL2FwaS9hdWRpb2NsaXBzYDtcblxuY29uc3Qgc2VhcmNoID0gKHtwYXR0ZXJuLCBzb3VyY2UgPSAnZnJlZXNvdW5kJywgbGltaXQgPSAxMiwgcGFnZSA9IDF9KSA9PlxuXHRyZXF1ZXN0LmdldChgJHt1cmx9L3NlYXJjaGApXG5cdFx0LnF1ZXJ5KHtwYXR0ZXJuLCBzb3VyY2UsIGxpbWl0LCBwYWdlfSlcblx0XHQudGhlbihyZXMgPT4gcmVzLmJvZHkucmVzdWx0cylcblx0XHQudGhlbihyZXN1bHRzID0+IChjb25zb2xlLmxvZyhyZXN1bHRzKSwgcmVzdWx0cykpXG5cdFx0LnRoZW4ocmVzdWx0cyA9PiByZXN1bHRzWzBdLm1lbWJlcnMubWFwKFxuXHRcdFx0bSA9PiAoe1xuXHRcdFx0XHRpZDogbS5jb250ZW50WydAaWQnXSxcblx0XHRcdFx0bmFtZTogbS5jb250ZW50LnRpdGxlLFxuXHRcdFx0XHRhdXRob3I6IG0uY29udGVudC5hdXRob3IucmVwbGFjZSgnZnJlZXNvdW5kLXVzZXJzOicsICcnKSxcblx0XHRcdFx0c291bmQ6IG0uY29udGVudC5hdmFpbGFibGVBc1swXS5sb2NhdG9yLFxuXHRcdFx0XHRpbWFnZTogbS5jb250ZW50LmltYWdlc1swXS5sb2NhdG9yLFxuXHRcdFx0XHRsaWNlbnNlOiBtLmNvbnRlbnQubGljZW5zZSxcblx0XHRcdFx0ZHVyYXRpb246IG0uY29udGVudC5kdXJhdGlvblxuXHRcdFx0fSlcblx0XHQpKVxuXHRcdC50aGVuKGxpc3QgPT4gKFxuXHRcdFx0c3RhdGUgPT4gb2JqLnBhdGNoKHN0YXRlLCBbJ3NhbXBsZXMnXSwge1xuXHRcdFx0XHRsaXN0OiBwYWdlID4gMSA/IFtdLmNvbmNhdChzdGF0ZS5zYW1wbGVzLmxpc3QsIGxpc3QpIDogbGlzdCxcblx0XHRcdFx0cXVlcnk6IHtwYXR0ZXJuLCBzb3VyY2UsIGxpbWl0LCBwYWdlfX0pXG5cdFx0KSk7XG5cbmNvbnN0IG5leHQgPSAoKSA9PiBzdGF0ZSA9PiBvYmoucGF0Y2goc3RhdGUsIFsnc2FtcGxlcyddLCB7XG5cdGluZGV4OiBzdGF0ZS5zYW1wbGVzLmluZGV4IDwgc3RhdGUuc2FtcGxlcy5saXN0Lmxlbmd0aCAtIDFcblx0XHQ/IHN0YXRlLnNhbXBsZXMuaW5kZXggKyAxXG5cdFx0OiBzdGF0ZS5zYW1wbGVzLmluZGV4XG59KTtcblxuY29uc3QgcHJldiA9ICgpID0+IHN0YXRlID0+IG9iai5wYXRjaChzdGF0ZSwgWydzYW1wbGVzJ10sIHtcblx0aW5kZXg6IHN0YXRlLnNhbXBsZXMuaW5kZXggPiAwID8gc3RhdGUuc2FtcGxlcy5pbmRleCAtIDEgOiBzdGF0ZS5zYW1wbGVzLmluZGV4XG59KTtcblxuY29uc3QgYWN0aW9ucyA9IHtcblx0aW5pdGlhbDoge1xuXHRcdGxpc3Q6IFtdLFxuXHRcdGluZGV4OiAwXG5cdH0sXG5cdHNlYXJjaCxcblx0bmV4dCxcblx0cHJldlxufTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXHR1bmhvb2sgPSAoKSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1Yi5kaXNwb3NlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFjdGlvbnMsXG5cdGhvb2ssXG5cdHVuaG9vazogKCkgPT4gdW5ob29rKClcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBsaWJcbmNvbnN0IFJ4ID0gcmVxdWlyZSgncngnKTtcbmNvbnN0ICQgPSBSeC5PYnNlcnZhYmxlO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcblxuY29uc3QgU3BlZWNoU0RLID0gd2luZG93LlNwZWVjaFNESztcblxuY29uc3Qgc3Vic2NyaXB0aW9uS2V5ID0gJ2M2MzA1N2UxMjE5NDQxNDg5YzFiNDMxMzI2ODVjNGI4JztcbmNvbnN0IHJlZ2lvbiA9ICd3ZXN0dXMnO1xuY29uc3QgdXJsID0gYGh0dHBzOi8vJHtyZWdpb259LmFwaS5jb2duaXRpdmUubWljcm9zb2Z0LmNvbS9zdHMvdjEuMC9pc3N1ZVRva2VuYDtcblxuY29uc3QgaW5pdCA9IHRva2VuID0+IHtcblx0bGV0IHNwZWVjaENvbmZpZyA9IFNwZWVjaFNESy5TcGVlY2hDb25maWcuZnJvbUF1dGhvcml6YXRpb25Ub2tlbih0b2tlbiwgcmVnaW9uKTtcblx0c3BlZWNoQ29uZmlnLnNwZWVjaFJlY29nbml0aW9uTGFuZ3VhZ2UgPSBcImVuLUdCXCI7XG5cdGxldCBhdWRpb0NvbmZpZyA9IFNwZWVjaFNESy5BdWRpb0NvbmZpZy5mcm9tRGVmYXVsdE1pY3JvcGhvbmVJbnB1dCgpO1xuXHRsZXQgcmVjb2duaXplciA9IG5ldyBTcGVlY2hTREsuU3BlZWNoUmVjb2duaXplcihzcGVlY2hDb25maWcsIGF1ZGlvQ29uZmlnKTtcblx0cmV0dXJuIHJlY29nbml6ZXI7XG59O1xuXG5jb25zdCByZWNvZ25pemUgPSByZWNvZ25pemVyID0+XG5cdCQuZnJvbUNhbGxiYWNrKHJlY29nbml6ZXIucmVjb2duaXplT25jZUFzeW5jLCByZWNvZ25pemVyKSgpXG5cdC5tYXAocmVzID0+IChjb25zb2xlLmxvZyhyZXMpLCByZXMpKTtcblxubGV0IHVuaG9vayA9ICgpID0+IHt9O1xuY29uc3QgaG9vayA9ICh7c3RhdGUkLCBhY3Rpb25zfSkgPT4ge1xuXHRsZXQgc3VicyA9IFtdO1xuXG5cdHJlcXVlc3Rcblx0XHQucG9zdCh1cmwpXG5cdFx0LnNldCh7XG5cdFx0XHQnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRcdFx0J09jcC1BcGltLVN1YnNjcmlwdGlvbi1LZXknOiBzdWJzY3JpcHRpb25LZXlcblx0XHR9KVxuXHRcdC50aGVuKHJlcyA9PiBhY3Rpb25zLnNldCgnc3R0JywgcmVzLnRleHQpKTtcblxuXHRzdGF0ZSQuZGlzdGluY3RVbnRpbENoYW5nZWQoc3RhdGUgPT4gc3RhdGUuc3R0ICsgJyAnICsgc3RhdGUuc3R0TWljKVxuXHRcdC5maWx0ZXIoc3RhdGUgPT4gc3RhdGUuc3R0ICYmIHN0YXRlLnN0dE1pYylcblx0XHQubWFwKHN0YXRlID0+IGluaXQoc3RhdGUuc3R0KSlcblx0XHQuZmxhdE1hcChyZWNvZ25pemUpXG5cdFx0LnN1YnNjcmliZShyZXMgPT4ge1xuXHRcdFx0bGV0IHBhdHRlcm4gPSByZXMucHJpdlRleHQucmVwbGFjZSgvXFwuJC8sICcnKTtcblx0XHRcdGFjdGlvbnMuc2FtcGxlcy5zZWFyY2goe3BhdHRlcm59KTtcblx0XHRcdGFjdGlvbnMuc2V0KCdzdHRNaWMnLCBmYWxzZSk7XG5cdFx0fSk7XG5cblx0dW5ob29rID0gKCkgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIuZGlzcG9zZSgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRob29rLFxuXHR1bmhvb2s6ICgpID0+IHVuaG9vaygpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3QgV2F2ZVN1cmZlciA9IHJlcXVpcmUoJ3dhdmVzdXJmZXIuanMnKTtcbi8vIHdpbmRvdy5XYXZlU3VyZmVyID0gV2F2ZVN1cmZlcjtcbmNvbnN0IFRpbWVsaW5lUGx1Z2luID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnRpbWVsaW5lLm1pbi5qcycpO1xuY29uc3QgRXh0V1NSZWdpb25zUGx1Z2luID0gcmVxdWlyZSgnLi4vZXh0L3dzL3JlZ2lvbnMuanMnKS5kZWZhdWx0O1xuLy8gY29uc29sZS5sb2coUmVnaW9uc1BsdWdpbik7XG4vLyByZXF1aXJlKCd3YXZlc3VyZmVyL3BsdWdpbi93YXZlc3VyZmVyLnRpbWVsaW5lLmpzJyk7XG4vLyBXYXZlU3VyZmVyID0gd2luZG93LldhdmVTdXJmZXI7XG5cbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHBvY2tldCA9IHJlcXVpcmUoJy4uL3V0aWwvcG9ja2V0Jyk7XG5cbmNvbnN0IGluaXQgPSBjb250YWluZXIgPT4ge1xuXHRjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cdGxldCB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUoe1xuXHRcdGNvbnRhaW5lcjogJyN3YXZlZm9ybScsXG5cdFx0d2F2ZUNvbG9yOiAnIzAwMCcsXG5cdFx0cHJvZ3Jlc3NDb2xvcjogJyMxMTE1MTYnLFxuXHRcdHBsdWdpbnM6IFtcblx0XHRcdFRpbWVsaW5lUGx1Z2luLmNyZWF0ZSh7XG5cdFx0XHRcdGNvbnRhaW5lcjogJyN3YXZlLXRpbWVsaW5lJ1xuXHRcdFx0XHQvLyBkZWZlckluaXQ6IHRydWUgLy8gc3RvcCB0aGUgcGx1Z2luIGZyb20gaW5pdGlhbGlzaW5nIGltbWVkaWF0ZWx5XG5cdFx0XHR9KSxcblx0XHRcdEV4dFdTUmVnaW9uc1BsdWdpbi5jcmVhdGUoe1xuXHRcdFx0XHRkcmFnU2VsZWN0aW9uOiB0cnVlLFxuXHRcdFx0XHRzaW5nbGVSZWdpb246IHRydWVcblx0XHRcdFx0Ly8gcGx1Z2luIG9wdGlvbnMgLi4uXG5cdFx0XHR9KVxuXHRcdF1cblx0fSk7XG5cdC8vIHdhdmVzdXJmZXIubG9hZCgnYXNzZXRzL0xhdGluRXRobm9FbGVrdHJvR3Jvb3ZlLm1wMycpO1xuXHRyZXR1cm4gd2F2ZXN1cmZlcjtcbn07XG5cbmNvbnN0IGxvYWQgPSAoe3dhdmVzdXJmZXIsIHNhbXBsZX0pID0+IHtcblx0Y29uc29sZS5sb2cod2F2ZXN1cmZlciwgc2FtcGxlLCBwb2NrZXQpO1xuXHRpZiAoc2FtcGxlWzBdID09PSAndXJsJykgd2F2ZXN1cmZlci5sb2FkKHNhbXBsZVsxXSk7XG5cdGVsc2UgaWYgKHNhbXBsZVsxXSlcblx0XHR3YXZlc3VyZmVyLmxvYWREZWNvZGVkQnVmZmVyKFxuXHRcdFx0cG9ja2V0LmdldChbJ3NhbXBsZUJhbmsnLCBzYW1wbGVbMV1dKS5vdXRwdXQuYnVmZmVyXG5cdFx0KTtcblx0cmV0dXJuIHdhdmVzdXJmZXI7XG59O1xuXG5sZXQgdW5ob29rID0gKCkgPT4ge307XG5jb25zdCBob29rID0gKHtzdGF0ZSQsIGFjdGlvbnN9KSA9PiB7XG5cdGxldCBzdWJzID0gW107XG5cblx0bGV0IHdhdmVzdXJmZXIkID0gJC5pbnRlcnZhbCgxMDApXG5cdFx0Lm1hcCgoKSA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd2F2ZWZvcm0nKSlcblx0XHQuZGlzdGluY3RVbnRpbENoYW5nZWQoZWwgPT4gZWwpXG5cdFx0LmZpbHRlcihlbCA9PiBlbClcblx0XHQubWFwKGluaXQpO1xuXG5cdGxldCBzYW1wbGVDaGFuZ2UkID0gc3RhdGUkXG5cdFx0LmRpc3RpbmN0VW50aWxDaGFuZ2VkKHN0YXRlID0+XG5cdFx0XHRzdGF0ZS5wYWRzLmZvY3VzZWQudG9TdHJpbmcoKSArXG5cdFx0XHRcdCcgJyArIG9iai5zdWIoc3RhdGUucGFkcywgWydtYXAnLCAuLi5zdGF0ZS5wYWRzLmZvY3VzZWQsICdpZCddKVxuXHRcdClcblx0XHQubWFwKHN0YXRlID0+IChbJ2lkJywgb2JqLnN1YihzdGF0ZS5wYWRzLm1hcCwgWy4uLnN0YXRlLnBhZHMuZm9jdXNlZCwgJ2lkJ10pXSkpXG5cdFx0LnN0YXJ0V2l0aCgoWyd1cmwnLCAnYXNzZXRzL0xhdGluRXRobm9FbGVrdHJvR3Jvb3ZlLm1wMyddKSk7XG5cblx0d2F2ZXN1cmZlciRcblx0XHQuZmxhdE1hcCh3YXZlc3VyZmVyID0+XG5cdFx0XHQkLm1lcmdlKFxuXHRcdFx0XHRzYW1wbGVDaGFuZ2UkXG5cdFx0XHRcdFx0Lm1hcChzYW1wbGUgPT4gd2F2ZXN1cmZlciA9PiBsb2FkKHt3YXZlc3VyZmVyLCBzYW1wbGV9KSksXG5cdFx0XHRcdHN0YXRlJFxuXHRcdFx0XHRcdC5kaXN0aW5jdFVudGlsQ2hhbmdlZChzdGF0ZSA9PiBzdGF0ZS5zZXNzaW9uLnBsYXlpbmcpXG5cdFx0XHRcdFx0Lm1hcChzdGF0ZSA9PiB3YXZlc3VyZmVyID0+ICh3YXZlc3VyZmVyLnBsYXlQYXVzZSgpLCB3YXZlc3VyZmVyKSlcblx0XHRcdClcblx0XHRcdC5zY2FuKCh3YXZlc3VyZmVyLCByZWR1Y2VyKSA9PiByZWR1Y2VyKHdhdmVzdXJmZXIpLCB3YXZlc3VyZmVyKVxuXHRcdClcblx0XHQuc3Vic2NyaWJlKGRhdGEgPT4ge30pO1xuXG5cdHVuaG9vayA9ICgpID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViLmRpc3Bvc2UoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aG9vayxcblx0dW5ob29rOiAoKSA9PiB1bmhvb2soKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuXHRzZWN0aW9uLCBzcGFuLCBhLCBkaXYsIHByZSwgaW1nLCBpLFxuXHRmb3JtLCBpbnB1dCwgYnV0dG9uLCBsYWJlbCwgc2VsZWN0LCBvcHRpb24sXG5cdHVsLCBsaSwgdGFibGUsIHRib2R5LCB0aGVhZCwgdHIsIHRkLCB0aFxufSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG5cbmNvbnN0IGZvcm1VdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtJyk7XG5jb25zdCB7Zm4sIG9ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG5jb25zdCBwbGF5ID0gdXJsID0+IHtcblx0bGV0IGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQVVESU8nKTtcblx0YW4uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIHRydWUpO1xuXHRhbi5zcmMgPSB1cmw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7c3RhdGUsIGFjdGlvbnN9KSA9PiBzZWN0aW9uKCcjYm9hcmQnLCBbXS5jb25jYXQoXG5cdGZvcm0oJyNib2FyZC1zZWFyY2gnLCB7XG5cdFx0b246IHtcblx0XHRcdHN1Ym1pdDogZXYgPT4ge1xuXHRcdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRsZXQgZGF0YSA9IGZvcm1VdGlsLnRvRGF0YShldi50YXJnZXQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhkYXRhKTtcblx0XHRcdFx0YWN0aW9ucy5zYW1wbGVzLnNlYXJjaChkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIFtcblx0XHRpbnB1dChgW3R5cGU9XCJoaWRkZW5cIl1bbmFtZT1cInBhZ2VcIl1bdmFsdWU9MV1gKSxcblx0XHRpbnB1dChgI2JvYXJkLXNlYXJjaC1wYXR0ZXJuW25hbWU9XCJwYXR0ZXJuXCJdW3BsYWNlaG9sZGVyPVwiUXVlcnlcIl1gLCB7XG5cdFx0XHRhdHRyczoge1xuXHRcdFx0XHR2YWx1ZTogc3RhdGUuc2FtcGxlcy5xdWVyeS5wYXR0ZXJuXG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0c2VsZWN0KGBbbmFtZT1cInNvdXJjZVwiXWAsIFsnZnJlZXNvdW5kJywgJ2phbWVuZG8nLCAnZXVyb3BlYW5hJ10ubWFwKFxuXHRcdFx0cyA9PiBvcHRpb24oYFt2YWx1ZT1cIiR7c31cIl1gLCBzKVxuXHRcdCkpLFxuXHRcdGJ1dHRvbignU2VhcmNoJylcblx0XSksXG5cdChzdGF0ZS5zYW1wbGVzLmxpc3QubGVuZ3RoID4gMCkgPyB1bCgnI2JvYXJkLXNhbXBsZXMnLCBbXS5jb25jYXQoXG5cdFx0c3RhdGUuc2FtcGxlcy5saXN0Lm1hcCgoc2FtcGxlLCBpbmRleCkgPT5cblx0XHRcdGxpKHtcblx0XHRcdFx0Y2xhc3M6IHtcblx0XHRcdFx0XHRzZWxlY3RlZDogaW5kZXggPT09IHN0YXRlLnNhbXBsZXMuaW5kZXhcblx0XHRcdFx0fVxuXHRcdFx0fSwgW1xuXHRcdFx0XHRpbWcoYC53YXZlW3NyYz1cIiR7c2FtcGxlLmltYWdlfVwiXWApLFxuXHRcdFx0XHRzcGFuKCcubmFtZScsIHtcblx0XHRcdFx0XHRvbjoge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICgpID0+IGFjdGlvbnMuc2V0KFsnc2FtcGxlcycsICdpbmRleCddLCBpbmRleClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHNhbXBsZS5uYW1lKSxcblx0XHRcdFx0YShgLmF1dGhvclt0aXRsZT1cIiR7c2FtcGxlLmF1dGhvcn1cIl1gLCBpKCcuZmEuZmEtdXNlcicpKSxcblx0XHRcdFx0c3BhbignLmR1cmF0aW9uJywgYCR7KHNhbXBsZS5kdXJhdGlvbiAvIDEwMDApLnRvRml4ZWQoMil9IHNgKSxcblx0XHRcdFx0YShgLmxpY2Vuc2VbdGFyZ2V0PVwiX2JsYW5rXCJdW2hyZWY9XCIke3NhbXBsZS5saWNlbnNlfVwiXWAsXG5cdFx0XHRcdFx0Zm4ucGlwZShcblx0XHRcdFx0XHRcdCgpID0+IHNhbXBsZS5saWNlbnNlLnJlcGxhY2UoJ2h0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnLycsICcnKSxcblx0XHRcdFx0XHRcdGxpY2Vuc2UgPT4gb2JqLnN3aXRjaChsaWNlbnNlLCB7XG5cdFx0XHRcdFx0XHRcdCdkZWZhdWx0JzogbGljZW5zZSxcblx0XHRcdFx0XHRcdFx0J2xpY2Vuc2VzL2J5LzMuMC8nOiBbXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLWNjLmNjLTJ4YCksXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLWJ5LmNjLTJ4YClcblx0XHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdFx0J3B1YmxpY2RvbWFpbi96ZXJvLzEuMC8nOiBbXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLWNjLmNjLTJ4YCksXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLXplcm8uY2MtMnhgKVxuXHRcdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0XHQnbGljZW5zZXMvYnktbmMvMy4wLyc6IFtcblx0XHRcdFx0XHRcdFx0XHRpKGAuY2MuY2MtY2MuY2MtMnhgKSxcblx0XHRcdFx0XHRcdFx0XHRpKGAuY2MuY2MtYnkuY2MtMnhgKSxcblx0XHRcdFx0XHRcdFx0XHRpKGAuY2MuY2MtbmMuY2MtMnhgKVxuXHRcdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0XHQnbGljZW5zZXMvc2FtcGxpbmcrLzEuMC8nOiBbXG5cdFx0XHRcdFx0XHRcdFx0aShgLmNjLmNjLWNjLmNjLTJ4YClcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQpKClcblx0XHRcdFx0KSxcblx0XHRcdFx0c3BhbignLmNvbnRyb2xzJywgW1xuXHRcdFx0XHRcdGJ1dHRvbih7XG5cdFx0XHRcdFx0XHRvbjoge1xuXHRcdFx0XHRcdFx0XHRjbGljazogKCkgPT4gcGxheShzYW1wbGUuc291bmQpLFxuXHRcdFx0XHRcdFx0XHR0b3VjaHN0YXJ0OiAoKSA9PiBwbGF5KHNhbXBsZS5zb3VuZClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBpKCcuZmEuZmEtcGxheScpKSxcblx0XHRcdFx0XHRidXR0b24oe1xuXHRcdFx0XHRcdFx0b246IHtcblx0XHRcdFx0XHRcdFx0Y2xpY2s6IGV2ID0+IGFjdGlvbnMucGFkcy5sb2FkKHNhbXBsZSwgc2FtcGxlLnNvdW5kKSxcblx0XHRcdFx0XHRcdFx0dG91Y2hzdGFydDogZXYgPT4gYWN0aW9ucy5wYWRzLmxvYWQoc2FtcGxlLCBzYW1wbGUuc291bmQpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgaSgnLmZhLmZhLXBsdXMnKSlcblx0XHRcdFx0XSlcblx0XHRcdF0pKSxcblx0XHRsaShidXR0b24oYC5mdWxsYCwge1xuXHRcdFx0b246IHtcblx0XHRcdFx0Y2xpY2s6ICgpID0+IGFjdGlvbnMuc2FtcGxlcy5zZWFyY2goey4uLnN0YXRlLnNhbXBsZXMucXVlcnksIHBhZ2U6IHN0YXRlLnNhbXBsZXMucXVlcnkucGFnZSArIDF9KVxuXHRcdFx0fVxuXHRcdH0sICdMb2FkIG1vcmUgc2FtcGxlcy4uLicpKVxuXHQpKSA6IFtdXG4pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuXHRzZWN0aW9uLCBidXR0b24sIHNwYW4sIGhlYWRlciwgaDEsXG5cdHVsLCBsaSwgaSwgaW1nXG59ID0gcmVxdWlyZSgnaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe3N0YXRlLCBhY3Rpb25zfSkgPT4gaGVhZGVyKFtcblx0dWwoJy5sZWZ0JywgW1xuXHRcdGxpKGJ1dHRvbih7XG5cdFx0XHRvbjoge1xuXHRcdFx0XHRjbGljazogKCkgPT4gYWN0aW9ucy5zZXQoJ21vZGUnLCAwKVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdHNlbGVjdGVkOiBzdGF0ZS5tb2RlID09PSAwXG5cdFx0XHR9XG5cdFx0fSwgaW1nKGBbc3JjPVwiYXNzZXRzL2ljb25zL21pZGkuc3ZnXCJdYCkpKSxcblx0XHRsaShidXR0b24oe1xuXHRcdFx0b246IHtcblx0XHRcdFx0Y2xpY2s6ICgpID0+IGFjdGlvbnMuc2V0KCdtb2RlJywgMSlcblx0XHRcdH0sXG5cdFx0XHRjbGFzczoge1xuXHRcdFx0XHRzZWxlY3RlZDogc3RhdGUubW9kZSA9PT0gMVxuXHRcdFx0fVxuXHRcdH0sIGkoJy5mYS5mYS1lZGl0JykpKSxcblx0XHRsaShidXR0b24oe1xuXHRcdFx0b246IHtcblx0XHRcdFx0Y2xpY2s6ICgpID0+IGFjdGlvbnMuc2V0KCdtb2RlJywgMilcblx0XHRcdH0sXG5cdFx0XHRjbGFzczoge1xuXHRcdFx0XHRzZWxlY3RlZDogc3RhdGUubW9kZSA9PT0gMlxuXHRcdFx0fVxuXHRcdH0sIGkoJy5mYS5mYS1tdXNpYycpKSlcblx0XSksXG5cdGgxKCd4QW1wbFInKSxcblx0dWwoJy5yaWdodCcsIFtcblx0XHRsaShidXR0b24oe1xuXHRcdFx0b246IHtcblx0XHRcdFx0Y2xpY2s6ICgpID0+IGFjdGlvbnMuc2V0KCdzdHRNaWMnLCB0cnVlKVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzOiB7XG5cdFx0XHRcdHNlbGVjdGVkOiBzdGF0ZS5zdHRNaWNcblx0XHRcdH1cblx0XHR9LCBpKCcuZmEuZmEtdm9sdW1lLWNvbnRyb2wtcGhvbmUnKSkpXG5cdF0pXG5dKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG9tXG5jb25zdCB7XG5cdGgxLCBhLCBkaXYsIGksXG5cdHNlY3Rpb24sIGJ1dHRvbiwgc3BhblxufSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG4vLyBjb21wb25lbnRzXG5jb25zdCBoZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlcicpO1xuY29uc3QgYm9hcmQgPSByZXF1aXJlKCcuL2JvYXJkJyk7XG5jb25zdCBwYWRzID0gcmVxdWlyZSgnLi9wYWRzJyk7XG5jb25zdCByYWNrID0gcmVxdWlyZSgnLi9yYWNrJyk7XG4vLyBjb25zdCBjb3VudGVyID0gcmVxdWlyZSgnLi9jb3VudGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtzdGF0ZSwgYWN0aW9uc30pID0+IHNlY3Rpb24oJyN1aScsIFtcblx0aGVhZGVyKHtzdGF0ZSwgYWN0aW9uc30pLFxuXHRzZWN0aW9uKCcud2F2ZWZvcm0nLCBbXG5cdFx0ZGl2KCcjd2F2ZS10aW1lbGluZScpLFxuXHRcdGRpdignI3dhdmVmb3JtJyksXG5cdFx0YnV0dG9uKHtcblx0XHRcdG9uOiB7XG5cdFx0XHRcdGNsaWNrOiAoKSA9PiBhY3Rpb25zLnRvZ2dsZShbJ3Nlc3Npb24nLCAncGxheWluZyddKVxuXHRcdFx0fVxuXHRcdH0sIGkoYC5mYS5mYS0ke3N0YXRlLnNlc3Npb24ucGxheWluZyA/ICdwYXVzZScgOiAncGxheSd9YCkpXG5cdF0pLFxuXHRib2FyZCh7c3RhdGUsIGFjdGlvbnN9KSxcblx0cGFkcyh7c3RhdGUsIGFjdGlvbnN9KSxcblx0cmFjayh7c3RhdGUsIGFjdGlvbnN9KVxuXSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0c2VjdGlvbiwgc3BhbiwgYSwgZGl2LCBwcmUsIGltZywgaSxcblx0Zm9ybSwgaW5wdXQsIGJ1dHRvbiwgbGFiZWwsXG5cdHVsLCBsaSwgdGFibGUsIHRib2R5LCB0aGVhZCwgdHIsIHRkLCB0aFxufSA9IHJlcXVpcmUoJ2libG9rei1zbmFiYmRvbS1oZWxwZXJzJyk7XG5cbmNvbnN0IHtvYmp9ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe3N0YXRlLCBhY3Rpb25zfSkgPT4gc2VjdGlvbignI3BhZHMnLFxuXHRkaXYoJy5yb3dzJywgQXJyYXkoNCkuZmlsbCh7fSkubWFwKChhLCByb3cpID0+XG5cdFx0ZGl2KCcuY29scycsIEFycmF5KDQpLmZpbGwoe30pLm1hcCgoYSwgY29sKSA9PlxuXHRcdFx0YnV0dG9uKCcucGFkJywge1xuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdC4uLihvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2wsICdpZCddKVxuXHRcdFx0XHRcdFx0PyB7YmFja2dyb3VuZEltYWdlOiBgdXJsKCR7b2JqLnN1YihzdGF0ZSwgWydwYWRzJywgJ21hcCcsIHJvdywgY29sLCAnaW1hZ2UnXSl9KWB9XG5cdFx0XHRcdFx0XHQ6IHt9KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbGFzczoge1xuXHRcdFx0XHRcdGZvY3VzZWQ6IHN0YXRlLnBhZHMuZm9jdXNlZFswXSA9PT0gcm93ICYmIHN0YXRlLnBhZHMuZm9jdXNlZFsxXSA9PT0gY29sLFxuXHRcdFx0XHRcdGFzc2lnbmVkOiBvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2wsICdpZCddKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRvbjoge1xuXHRcdFx0XHRcdGZvY3VzOiAoKSA9PiBhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbcm93LCBjb2xdKSxcblx0XHRcdFx0XHRtb3VzZWRvd246ICgpID0+IChcblx0XHRcdFx0XHRcdHN0YXRlLm1vZGUgPT09IDIgJiYgYWN0aW9ucy5taWRpLnRyaWdnZXIocm93LCBjb2wpLFxuXHRcdFx0XHRcdFx0c3RhdGUubW9kZSA9PT0gMSAmJiBhY3Rpb25zLnNldChbJ3BhZHMnLCAnZm9jdXNlZCddLCBbcm93LCBjb2xdKVxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0dG91Y2hzdGFydDogKCkgPT4gKFxuXHRcdFx0XHRcdFx0c3RhdGUubW9kZSA9PT0gMiAmJiBhY3Rpb25zLm1pZGkudHJpZ2dlcihyb3csIGNvbCksXG5cdFx0XHRcdFx0XHRzdGF0ZS5tb2RlID09PSAxICYmIGFjdGlvbnMuc2V0KFsncGFkcycsICdmb2N1c2VkJ10sIFtyb3csIGNvbF0pXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9XG5cdFx0XHR9LCBvYmouc3ViKHN0YXRlLCBbJ3BhZHMnLCAnbWFwJywgcm93LCBjb2wsICduYW1lJ10pIHx8ICcnKVxuXHRcdCkpXG5cdCkpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG5cdHNlY3Rpb24sIHNwYW4sIGEsIGRpdiwgcHJlLCBpbWcsIGksXG5cdGZvcm0sIGlucHV0LCBidXR0b24sIGxhYmVsLFxuXHR1bCwgbGksIHRhYmxlLCB0Ym9keSwgdGhlYWQsIHRyLCB0ZCwgdGhcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCB2Y2YgPSByZXF1aXJlKCcuL3ZjZicpO1xuY29uc3QgcmV2ZXJiID0gcmVxdWlyZSgnLi9yZXZlcmInKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe3N0YXRlLCBhY3Rpb25zfSkgPT4gc2VjdGlvbignI3JhY2snLCBbXS5jb25jYXQoXG5cdHZjZih7XG5cdFx0bmFtZTogJ3ZjZicsXG5cdFx0cHJvcHM6IHN0YXRlLnJhY2sudmNmLFxuXHRcdHVwZGF0ZTogKHBhdGgsIHZhbHVlKSA9PiBhY3Rpb25zLnNldChbXS5jb25jYXQoWydyYWNrJywgJ3ZjZiddLCBwYXRoKSwgdmFsdWUpXG5cdH0pLFxuXHRyZXZlcmIoe1xuXHRcdG5hbWU6ICdyZXZlcmInLFxuXHRcdHByb3BzOiBzdGF0ZS5yYWNrLnJldmVyYixcblx0XHR1cGRhdGU6IChwYXRoLCB2YWx1ZSkgPT4gYWN0aW9ucy5zZXQoW10uY29uY2F0KFsncmFjaycsICdyZXZlcmInXSwgcGF0aCksIHZhbHVlKVxuXHR9KVxuKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0ZGl2LCBoMiwgc3BhbiwgcCwgdWwsIGxpLCBociwgYnV0dG9uLCBicixcblx0Zm9ybSwgbGFiZWwsIGlucHV0LCBmaWVsZHNldCwgbGVnZW5kLCBpLCBpbWdcbn0gPSByZXF1aXJlKCdpYmxva3otc25hYmJkb20taGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7bmFtZSA9ICdyZXZlcmInLCBwcm9wcywgdXBkYXRlfSkgPT4gZmllbGRzZXQoW1xuXHRsZWdlbmQoW1xuXHRcdHNwYW4oJy5vbicsIFtcblx0XHRcdG5hbWUudG9VcHBlckNhc2UoKVxuXHRcdF0pXG5cdF0pLFxuXHRkaXYoJy5vbi1zd2l0Y2guZmEnLCB7XG5cdFx0b246IHtjbGljazogZXYgPT4gdXBkYXRlKCdvbicsICFwcm9wcy5vbil9LFxuXHRcdGNsYXNzOiB7XG5cdFx0XHQnZmEtY2lyY2xlLXRoaW4nOiAhcHJvcHMub24sXG5cdFx0XHQnb24nOiBwcm9wcy5vbixcblx0XHRcdCdmYS1jaXJjbGUnOiBwcm9wcy5vblxuXHRcdH1cblx0fSksXG5cdGRpdihbXG5cdFx0bGFiZWwoYFNlY29uZHNgKSxcblx0XHQnICcsXG5cdFx0Ly8gc3BhbignLnJpZ2h0JywgYCR7cHJvcHMuc2Vjb25kc31gKSxcblx0XHRpbnB1dCgnW3R5cGU9XCJudW1iZXJcIl0nLCB7XG5cdFx0XHRhdHRyczoge21pbjogMSwgbWF4OiA1MCwgc3RlcDogMC4wMX0sXG5cdFx0XHRwcm9wczoge3ZhbHVlOiBwcm9wcy5zZWNvbmRzfSxcblx0XHRcdG9uOiB7Y2hhbmdlOiBldiA9PiB1cGRhdGUoJ3NlY29uZHMnLCBwYXJzZUZsb2F0KGV2LnRhcmdldC52YWx1ZSkpfVxuXHRcdH0pLFxuXHRcdCcgJyxcblx0XHRsYWJlbChgRGVjYXlgKSxcblx0XHQvLyBzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5kZWNheX1gKSxcblx0XHQnICcsXG5cdFx0aW5wdXQoJ1t0eXBlPVwibnVtYmVyXCJdJywge1xuXHRcdFx0YXR0cnM6IHttaW46IDAsIG1heDogMTAwLCBzdGVwOiAwLjAxfSxcblx0XHRcdHByb3BzOiB7dmFsdWU6IHByb3BzLmRlY2F5fSxcblx0XHRcdG9uOiB7Y2hhbmdlOiBldiA9PiB1cGRhdGUoJ2RlY2F5JywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHR9KSxcblx0XHQnICcsXG5cdFx0Lypcblx0XHRsYWJlbChgUmV2ZXJzZWApLFxuXHRcdC8vIHNwYW4oJy5yaWdodCcsIGAke3Byb3BzLnJldmVyc2V9YCksXG5cdFx0JyAnLFxuXHRcdGJ1dHRvbignLmZhJywge1xuXHRcdFx0Y2xhc3M6IHtcblx0XHRcdFx0J2ZhLXRvZ2dsZS1vbic6IHByb3BzLnJldmVyc2UsXG5cdFx0XHRcdCdmYS10b2dnbGUtb2ZmJzogIXByb3BzLnJldmVyc2Vcblx0XHRcdH0sXG5cdFx0XHRvbjoge1xuXHRcdFx0XHRjbGljazogKCkgPT4gdXBkYXRlKCdyZXZlcnNlJywgIXByb3BzLnJldmVyc2UpXG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0Ki9cblx0XHRicigpLFxuXHRcdGxhYmVsKGBEcnlgKSxcblx0XHRzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5kcnl9YCksXG5cdFx0aW5wdXQoJ1t0eXBlPVwicmFuZ2VcIl0nLCB7XG5cdFx0XHRhdHRyczoge21pbjogMCwgbWF4OiAxLCBzdGVwOiAwLjAxfSxcblx0XHRcdHByb3BzOiB7dmFsdWU6IHByb3BzLmRyeX0sXG5cdFx0XHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCdkcnknLCBwYXJzZUZsb2F0KGV2LnRhcmdldC52YWx1ZSkpfVxuXHRcdH0pLFxuXHRcdGxhYmVsKGBXZXRgKSxcblx0XHRzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy53ZXR9YCksXG5cdFx0aW5wdXQoJ1t0eXBlPVwicmFuZ2VcIl0nLCB7XG5cdFx0XHRhdHRyczoge21pbjogMCwgbWF4OiAxLCBzdGVwOiAwLjAxfSxcblx0XHRcdHByb3BzOiB7dmFsdWU6IHByb3BzLndldH0sXG5cdFx0XHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCd3ZXQnLCBwYXJzZUZsb2F0KGV2LnRhcmdldC52YWx1ZSkpfVxuXHRcdH0pXG5cdFx0Ly8gbGFiZWwoYEdhaW5gKSxcblx0XHQvLyBzcGFuKCcucmlnaHQnLCBgJHtwcm9wcy5nYWlufWApLFxuXHRcdC8vIGlucHV0KCdbdHlwZT1cInJhbmdlXCJdJywge1xuXHRcdC8vIFx0YXR0cnM6IHttaW46IDAsIG1heDogMSwgc3RlcDogMC4wMDV9LFxuXHRcdC8vIFx0cHJvcHM6IHt2YWx1ZTogcHJvcHMuZ2Fpbn0sXG5cdFx0Ly8gXHRvbjoge2NoYW5nZTogZXYgPT4gdXBkYXRlKCdnYWluJywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHQvLyB9KVxuXHRdKVxuXSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcblx0ZGl2LCBoMiwgc3BhbiwgcCwgdWwsIGxpLCBociwgYnV0dG9uLCBiciwgYSxcblx0Zm9ybSwgbGFiZWwsIGlucHV0LCBmaWVsZHNldCwgbGVnZW5kLCBpLCBpbWcsXG5cdHNlbGVjdCwgb3B0aW9uXG59ID0gcmVxdWlyZSgnaWJsb2t6LXNuYWJiZG9tLWhlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoe25hbWUgPSAncmV2ZXJiJywgcHJvcHMsIHVwZGF0ZX0pID0+IGZpZWxkc2V0KFtcblx0bGVnZW5kKFtcblx0XHRzcGFuKCcub24nLCBbXG5cdFx0XHRuYW1lLnRvVXBwZXJDYXNlKClcblx0XHRdKVxuXHRdKSxcblx0ZGl2KCcub24tc3dpdGNoLmZhJywge1xuXHRcdG9uOiB7Y2xpY2s6IGV2ID0+IHVwZGF0ZSgnb24nLCAhcHJvcHMub24pfSxcblx0XHRjbGFzczoge1xuXHRcdFx0J2ZhLWNpcmNsZS10aGluJzogIXByb3BzLm9uLFxuXHRcdFx0J29uJzogcHJvcHMub24sXG5cdFx0XHQnZmEtY2lyY2xlJzogcHJvcHMub25cblx0XHR9XG5cdH0pLFxuXHRkaXYoW1xuXHRcdGRpdihbXG5cdFx0XHRsYWJlbChgVHlwZWApLFxuXHRcdFx0c2VsZWN0KHtcblx0XHRcdFx0b246IHtjaGFuZ2U6IGV2ID0+IHVwZGF0ZSgndHlwZScsIGV2LnRhcmdldC52YWx1ZSl9XG5cdFx0XHR9LCBbXG5cdFx0XHRcdCdsb3dwYXNzJywgJ2hpZ2hwYXNzJ1xuXHRcdFx0XHQvLyAnYmFuZHBhc3MnLCAnbG93c2hlbGYnLCAnaGlnaHNoZWxmJywgJ3BlYWtpbmcnLCAnbm90Y2gnLCAnYWxscGFzcydcblx0XHRcdF0ubWFwKHR5cGUgPT5cblx0XHRcdFx0b3B0aW9uKHtcblx0XHRcdFx0XHRhdHRyczoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHR5cGVcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZDogcHJvcHMudHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdHlwZSlcblx0XHRcdCkpXG5cdFx0XSksXG5cdFx0ZGl2KFtcblx0XHRcdGxhYmVsKGBDdXRvZmZgKSxcblx0XHRcdHNwYW4oJy5yaWdodCcsIGAke3Byb3BzLmN1dG9mZn1gKSxcblx0XHRcdGlucHV0KCdbdHlwZT1cInJhbmdlXCJdJywge1xuXHRcdFx0XHRhdHRyczoge21pbjogMCwgbWF4OiAxLCBzdGVwOiAwLjAxfSxcblx0XHRcdFx0cHJvcHM6IHt2YWx1ZTogcHJvcHMuY3V0b2ZmfSxcblx0XHRcdFx0b246IHtjaGFuZ2U6IGV2ID0+IHVwZGF0ZSgnY3V0b2ZmJywgcGFyc2VGbG9hdChldi50YXJnZXQudmFsdWUpKX1cblx0XHRcdH0pXG5cdFx0XSksXG5cdFx0bGFiZWwoYFJlc29uYW5jZWApLFxuXHRcdHNwYW4oJy5yaWdodCcsIGAke3Byb3BzLnJlc29uYW5jZX1gKSxcblx0XHRpbnB1dCgnW3R5cGU9XCJyYW5nZVwiXScsIHtcblx0XHRcdGF0dHJzOiB7bWluOiAwLCBtYXg6IDEsIHN0ZXA6IDAuMDF9LFxuXHRcdFx0cHJvcHM6IHt2YWx1ZTogcHJvcHMucmVzb25hbmNlfSxcblx0XHRcdG9uOiB7Y2hhbmdlOiBldiA9PiB1cGRhdGUoJ3Jlc29uYW5jZScsIHBhcnNlRmxvYXQoZXYudGFyZ2V0LnZhbHVlKSl9XG5cdFx0fSlcblx0XHQvLyBsYWJlbChgR2FpbmApLFxuXHRcdC8vIHNwYW4oJy5yaWdodCcsIGAke3Byb3BzLmdhaW59YCksXG5cdFx0Ly8gaW5wdXQoJ1t0eXBlPVwicmFuZ2VcIl0nLCB7XG5cdFx0Ly8gXHRhdHRyczoge21pbjogMCwgbWF4OiAxLCBzdGVwOiAwLjAwNX0sXG5cdFx0Ly8gXHRwcm9wczoge3ZhbHVlOiBwcm9wcy5nYWlufSxcblx0XHQvLyBcdG9uOiB7Y2hhbmdlOiBldiA9PiB1cGRhdGUoJ2dhaW4nLCBwYXJzZUZsb2F0KGV2LnRhcmdldC52YWx1ZSkpfVxuXHRcdC8vIH0pXG5cdF0pXG5dKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGliXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3Qge2Fyciwgb2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IG9ic2VydmUgPSBzb3VyY2UgPT4gKHNvdXJjZSBpbnN0YW5jZW9mIFJ4Lk9ic2VydmFibGUpXG4gID8gc291cmNlXG4gIDogKHNvdXJjZS50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgPyBSeC5PYnNlcnZhYmxlLmZyb21Qcm9taXNlKHNvdXJjZSlcbiAgICA6IFJ4Lk9ic2VydmFibGUuanVzdChzb3VyY2UpO1xuXG5jb25zdCBhZGFwdCA9IChvLCBwID0gW10pID0+IE9iamVjdC5rZXlzKG8pLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnaW5pdGlhbCcpLnJlZHVjZSgobzIsIGtleSkgPT4gT2JqZWN0LmFzc2lnbih7fSwgbzIsXG5cdChvW2tleV0gaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgb2JqLmtleVZhbHVlKGtleSwgZnVuY3Rpb24oKSB7XG5cdFx0b2JzZXJ2ZShcblx0XHRcdG9ba2V5XS5hcHBseShudWxsLCBBcnJheS5mcm9tKGFyZ3VtZW50cykpXG5cdFx0KS5zdWJzY3JpYmUocmVzcCA9PiBvMi5zdHJlYW0ub25OZXh0KE9iamVjdC5hc3NpZ24ocmVzcCwge1xuXHRcdFx0cGF0aDogW10uY29uY2F0KHAsIGtleSksXG5cdFx0XHRwYXlsb2FkOiBBcnJheS5mcm9tKGFyZ3VtZW50cylcblx0XHR9KSkpO1xuXHR9KSB8fCAob1trZXldIGluc3RhbmNlb2YgT2JqZWN0KSAmJiAoKCkgPT4ge1xuXHRcdGxldCBvMyA9IGFkYXB0KG9ba2V5XSwgW10uY29uY2F0KHAsIGtleSkpO1xuXHRcdG8zLnN0cmVhbS5zdWJzY3JpYmUocmVzcCA9PiBvMi5zdHJlYW0ub25OZXh0KHJlc3ApKTtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRpbml0aWFsOiBPYmplY3QuYXNzaWduKHt9LCBvMi5pbml0aWFsLCBvYmoua2V5VmFsdWUoa2V5LCBvMy5pbml0aWFsKSlcblx0XHR9LCBvYmoua2V5VmFsdWUoa2V5LCBvMykpO1xuXHR9KSgpIHx8IG9iai5rZXlWYWx1ZShrZXksIG9ba2V5XSlcbiksIHtzdHJlYW06IG5ldyBSeC5TdWJqZWN0KCksIGluaXRpYWw6IG8uaW5pdGlhbCB8fCB7fX0pO1xuXG5jb25zdCBhdHRhY2ggPSAodHJlZSwgcGF0aCwgbm9kZSkgPT4gW2FkYXB0KG5vZGUsIHBhdGgpXS5tYXAoYWRhcHRlZE5vZGUgPT4gKFxuXHRhZGFwdGVkTm9kZS5zdHJlYW0uc3Vic2NyaWJlKHJlc3AgPT4gdHJlZS5zdHJlYW0ub25OZXh0KHJlc3ApKSxcblx0T2JqZWN0LmFzc2lnbih7fSwgb2JqLnBhdGNoKHRyZWUsIHBhdGgsIGFkYXB0ZWROb2RlKSwge1xuXHRcdGluaXRpYWw6IG9iai5wYXRjaCh0cmVlLmluaXRpYWwsIHBhdGgsIGFkYXB0ZWROb2RlLmluaXRpYWwpXG5cdH0pXG4pKS5wb3AoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFkYXB0LFxuXHRhdHRhY2hcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCB7Y29udGV4dCwgY3JlYXRlOiBfY3JlYXRlLCBzZXQsIGNoYWluLCBkdXJhdGlvbiwgY2hEYXRhLCBzY2hlZHVsZX0gPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmNvbnN0IGNyZWF0ZSA9IHByZWZzID0+IFt7XG5cdHByZWZzOiBPYmplY3QuYXNzaWduKHtcblx0XHR2b2x1bWU6IDAuNDEsXG5cdFx0YXR0YWNrOiAwLjMxLFxuXHRcdGRlY2F5OiAwLjE2LFxuXHRcdHN1c3RhaW46IDAuOCxcblx0XHRyZWxlYXNlOiAwLjIxXG5cdH0sIHByZWZzKSxcblx0dGhyb3VnaDogX2NyZWF0ZSgnZ2FpbicpXG59XS5tYXAobiA9PiAoXG5cdHNldChuLnRocm91Z2guZ2FpbiwgJ3ZhbHVlJywgMCksXG5cdG5cbikpLnBvcCgpO1xuXG5jb25zdCB1cGRhdGUgPSAobiwgcHJlZnMpID0+IChcblx0c2V0KG4sICdwcmVmcycsIE9iamVjdC5hc3NpZ24oe30sIG4ucHJlZnMsIHByZWZzKSksXG5cdG5cbik7XG5cbmNvbnN0IG5vdGVPbiA9IChub2RlLCB2ZWxvY2l0eSwgdGltZSkgPT4ge1xuXHRjb25zdCBub3cgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuXHR0aW1lID0gKHRpbWUgfHwgbm93KSArIDAuMDAwMTtcblxuXHRub2RlLnRocm91Z2guZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XG5cblx0Y29uc3QgY2hhbmdlcyA9IFtdLmNvbmNhdChcblx0XHQvLyBhdHRhY2tcblx0XHQobm9kZS5wcmVmcy5hdHRhY2sgPiAwKVxuXHRcdFx0PyBbWzAsIHRpbWVdLCBbdmVsb2NpdHkgKiBub2RlLnByZWZzLnZvbHVtZSwgbm9kZS5wcmVmcy5hdHRhY2tdXVxuXHRcdFx0OiBbW3ZlbG9jaXR5ICogbm9kZS5wcmVmcy52b2x1bWUsIHRpbWVdXSxcblx0XHQvLyBkZWNheVxuXHRcdChub2RlLnByZWZzLmRlY2F5ID4gMClcblx0XHRcdD8gW1tub2RlLnByZWZzLnN1c3RhaW4gKiB2ZWxvY2l0eSAqIG5vZGUucHJlZnMudm9sdW1lLCBub2RlLnByZWZzLmRlY2F5XV0gOiBbXVxuXHQpLnJlZHVjZSgoYSwgYykgPT4gW1tdLmNvbmNhdChhWzBdLCBjWzBdKSwgW10uY29uY2F0KGFbMV0sIGNbMV0pXSwgW1tdLCBbXV0pO1xuXG5cdHNjaGVkdWxlKG5vZGUudGhyb3VnaCwgJ2dhaW4nLCBjaGFuZ2VzWzBdLCBjaGFuZ2VzWzFdKTtcblx0cmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBub3RlT2ZmID0gKG5vZGUsIHRpbWUpID0+IHtcblx0Y29uc3Qgbm93ID0gY29udGV4dC5jdXJyZW50VGltZTtcblx0dGltZSA9IHRpbWUgfHwgbm93ICsgMC4wMDAxO1xuXG5cdHNldFRpbWVvdXQoKCkgPT4gKFxuXHRcdG5vZGUudGhyb3VnaC5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKSxcblx0XHRub2RlLnRocm91Z2guZ2Fpbi5zZXRWYWx1ZUN1cnZlQXRUaW1lKG5ldyBGbG9hdDMyQXJyYXkoW25vZGUudGhyb3VnaC5nYWluLnZhbHVlLCAwXSksXG5cdFx0XHRcdHRpbWUsIG5vZGUucHJlZnMucmVsZWFzZSA+IDAgJiYgbm9kZS5wcmVmcy5yZWxlYXNlIHx8IDAuMDAwMDEpXG5cdCksICh0aW1lIC0gbm93KSAqIDEwMDApO1xuXHRyZXR1cm4gbm9kZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGUsXG5cdHVwZGF0ZSxcblx0bm90ZU9uLFxuXHRub3RlT2ZmXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7b2JqLCBmbn0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG5jb25zdCBjb250ZXh0ID0gbmV3IChcblx0d2luZG93LkF1ZGlvQ29udGV4dFxuXHR8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0XG5cdHx8IHdpbmRvdy5tb3pBdWRpb0NvbnRleHRcblx0fHwgd2luZG93Lm9BdWRpb0NvbnRleHRcblx0fHwgd2luZG93Lm1zQXVkaW9Db250ZXh0XG4pKCk7XG5cbmNvbnN0IHNldCA9IChvLCBrLCB2KSA9PiAob1trXSA9IHYpO1xuY29uc3QgaXNTZXQgPSB2ID0+IHYgIT09IHVuZGVmaW5lZDtcbmNvbnN0IGlzR2V0ID0gdiA9PiBpc1NldCh2KSA/IHYgOiBudWxsO1xuXG5jb25zdCBhcHBseSA9IChvMSwgbzIpID0+IE9iamVjdC5rZXlzKG8yKVxuXHQucmVkdWNlKChvLCBrKSA9PiBzZXQobywgaywgbzJba10pLCBvMSk7XG5cbmNvbnN0IGNyZWF0ZSA9ICh0eXBlLCAuLi5hcmdzKSA9PiAoXG5cdC8vIGNvbnNvbGUubG9nKHR5cGUpLFxuXHRvYmouc3dpdGNoKHR5cGUsIHtcblx0XHRvc2NpbGxhdG9yOiAoKSA9PiBjb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoLi4uYXJncyksXG5cdFx0Z2FpbjogKCkgPT4gY29udGV4dC5jcmVhdGVHYWluKC4uLmFyZ3MpLFxuXHRcdGJpcXVhZEZpbHRlcjogKCkgPT4gY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoLi4uYXJncyksXG5cdFx0Y29udm9sdmVyOiAoKSA9PiBjb250ZXh0LmNyZWF0ZUNvbnZvbHZlciguLi5hcmdzKSxcblx0XHRidWZmZXI6ICgpID0+IGNvbnRleHQuY3JlYXRlQnVmZmVyKC4uLmFyZ3MpLFxuXHRcdGJ1ZmZlclNvdXJjZTogKCkgPT4gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoLi4uYXJncylcblx0fSkoKSk7XG5cbmNvbnN0IHVwZGF0ZSA9IChub2RlLCBwcmVmcykgPT4gYXBwbHkobm9kZSwgcHJlZnMpO1xuXG5jb25zdCBjb25uZWN0ID0gKG4xLCBuMikgPT4gKFxuXHQvLyBjb25zb2xlLmxvZyhuMSwgbjIpLFxuXHRuMS5jb25uZWN0KG4yKSxcblx0bjFcbik7XG5jb25zdCBkaXNjb25uZWN0ID0gKG4xLCBuMikgPT4ge1xuXHQvLyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGNvbm5lY3RlZFxuXHR0cnkge1xuXHRcdG4xLmRpc2Nvbm5lY3QobjIpO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRjb25zb2xlLmxvZyhlcnIpO1xuXHR9XG5cdHJldHVybiBuMTtcbn07XG5cbmNvbnN0IGNoYWluID0gKC4uLm5vZGVzKSA9PiAoXG5cdG5vZGVzLmZvckVhY2goKG4sIGkpID0+IGlzU2V0KG5vZGVzW2kgKyAxXSkgJiYgY29ubmVjdChuLCBub2Rlc1tpICsgMV0pKSxcblx0bm9kZXNbMF1cbik7XG5cbmNvbnN0IHVuY2hhaW4gPSAoLi4ubm9kZXMpID0+IChcblx0bm9kZXMuc2xpY2UoKS5yZXZlcnNlKClcblx0XHQuZm9yRWFjaCgobiwgaSkgPT4gaXNTZXQobm9kZXNbaSAtIDFdKSAmJiBkaXNjb25uZWN0KG5vZGVzW2kgLSAxXSwgbikpLFxuXHRub2Rlc1swXVxuKTtcblxuY29uc3QgZHVyYXRpb24gPSBzZWNvbmRzID0+IGNvbnRleHQuc2FtcGxlUmF0ZSAqIHNlY29uZHM7XG5jb25zdCBjaERhdGEgPSAobm9kZSwgLi4uYXJncykgPT4gKFxuXHQvLyBjb25zb2xlLmxvZyhub2RlLCBhcmdzKSxcblx0bm9kZS5nZXRDaGFubmVsRGF0YSguLi5hcmdzKVxuKTtcblxuY29uc3Qgc2NoZWR1bGUgPSAobm9kZSwgcHJlZiwgdmFsdWVzLCB0aW1lcykgPT4gKHZhbHVlcy5sZW5ndGggPT09IDEpXG5cdD8gbm9kZVtwcmVmXS5zZXRWYWx1ZUF0VGltZSh2YWx1ZXNbMF0sIHRpbWVzWzBdKVxuXHQ6IChub2RlW3ByZWZdLnNldFZhbHVlQ3VydmVBdFRpbWUobmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMuc2xpY2UoMCwgMikpLCB0aW1lc1swXSwgdGltZXNbMV0pLFxuXHRcdCh2YWx1ZXMubGVuZ3RoID4gMikgJiYgc2NoZWR1bGUobm9kZSwgcHJlZiwgdmFsdWVzLnNsaWNlKDEpLCBbdGltZXNbMF0gKyB0aW1lc1sxXV0uY29uY2F0KHRpbWVzLnNsaWNlKDIpKSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y29udGV4dCxcblx0c2V0LFxuXHRpc1NldCxcblx0aXNHZXQsXG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRjb25uZWN0LFxuXHRkaXNjb25uZWN0LFxuXHRjaGFpbixcblx0dW5jaGFpbixcblx0Ly8gdXRpbFxuXHRkdXJhdGlvbixcblx0Y2hEYXRhLFxuXHRzY2hlZHVsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHtjb250ZXh0LCBjcmVhdGU6IF9jcmVhdGUsIHNldCwgY2hhaW4sIGR1cmF0aW9uLCBjaERhdGF9ID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5jb25zdCBjcmVhdGUgPSBwcmVmcyA9PiBbe1xuXHRwcmVmczogT2JqZWN0LmFzc2lnbih7XG5cdFx0dHlwZTogJ3Nhd3Rvb3RoJyxcblx0XHRmcmVxdWVuY3k6IDUsXG5cdFx0Z2FpbjogMTVcblx0fSwgcHJlZnMpLFxuXHRlZmZlY3Q6IF9jcmVhdGUoJ29zY2lsbGF0b3InKSxcblx0b3V0cHV0OiBfY3JlYXRlKCdnYWluJylcbn1dLm1hcChuID0+IChcblx0Y2hhaW4obi5lZmZlY3QsIG4ub3V0cHV0KSxcblx0c2V0KG4uZWZmZWN0LmZyZXF1ZW5jeSwgJ3ZhbHVlJywgbi5wcmVmcy5mcmVxdWVuY3kpLFxuXHRzZXQobi5vdXRwdXQuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy5nYWluKSxcblx0c2V0KG4uZWZmZWN0LCAndHlwZScsIG4ucHJlZnMudHlwZSksXG5cdG5cbikpLnBvcCgpO1xuXG5jb25zdCB1cGRhdGUgPSAobiwgcHJlZnMpID0+IChcblx0c2V0KG4sICdwcmVmcycsIE9iamVjdC5hc3NpZ24oe30sIG4ucHJlZnMsIHByZWZzKSksXG5cdHNldChuLmVmZmVjdC5mcmVxdWVuY3ksICd2YWx1ZScsIG4ucHJlZnMuZnJlcXVlbmN5KSxcblx0c2V0KG4ub3V0cHV0LmdhaW4sICd2YWx1ZScsIG4ucHJlZnMuZ2FpbiksXG5cdHNldChuLmVmZmVjdCwgJ3R5cGUnLCBuLnByZWZzLnR5cGUpLFxuXHRuXG4pO1xuXG5jb25zdCBzdGFydCA9IChuLCAuLi5hcmdzKSA9PiAoXG5cdG4uZWZmZWN0LnN0YXJ0KCksXG5cdG5cbik7XG5cbi8vIGNvbnN0IGNsb25lID0gbiA9PiBjcmVhdGUobnVsbCwgbi5vdXRwdXQuYnVmZmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRzdGFydFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29iaiwgZm59ID0gcmVxdWlyZSgnaWJsb2t6LWRhdGEnKTtcbmNvbnN0IHtjb250ZXh0LCBjcmVhdGU6IF9jcmVhdGUsIHNldCwgY2hhaW4sIGR1cmF0aW9uLCBjaERhdGF9ID0gcmVxdWlyZSgnLi4vY29yZScpO1xuLy8gY29uc3Qge2NvbnRleHR9ID0gY29yZTtcblxuY29uc3QgYnVpbGRJbXB1bHNlID0gKHtzZWNvbmRzLCBkZWNheX0pID0+IHtcblx0bGV0IGltcHVsc2UgPSBfY3JlYXRlKCdidWZmZXInLCAyLCBkdXJhdGlvbihzZWNvbmRzKSwgY29udGV4dC5zYW1wbGVSYXRlKTtcblx0bGV0IGNoYW5uZWxEYXRhID0gW1xuXHRcdGNoRGF0YShpbXB1bHNlLCAwKSxcblx0XHRjaERhdGEoaW1wdWxzZSwgMSlcblx0XTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkdXJhdGlvbihzZWNvbmRzKTsgaSsrKSB7XG5cdFx0Y2hhbm5lbERhdGFbMF1baV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBpIC8gZHVyYXRpb24oc2Vjb25kcyksIGRlY2F5KTtcblx0XHRjaGFubmVsRGF0YVsxXVtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIGkgLyBkdXJhdGlvbihzZWNvbmRzKSwgZGVjYXkpO1xuXHR9XG5cdHJldHVybiBpbXB1bHNlO1xufTtcblxuY29uc3QgY3JlYXRlID0gcHJlZnMgPT4gW3tcblx0cHJlZnM6IE9iamVjdC5hc3NpZ24oe3NlY29uZHM6IDMsIGRlY2F5OiAyLCB3ZXQ6IDAsIGRyeTogMX0sIHByZWZzKSxcblx0aW5wdXQ6IF9jcmVhdGUoJ2dhaW4nKSxcblx0b3V0cHV0OiBfY3JlYXRlKCdnYWluJyksXG5cdGVmZmVjdDogX2NyZWF0ZSgnY29udm9sdmVyJyksXG5cdHdldDogX2NyZWF0ZSgnZ2FpbicpLFxuXHRkcnk6IF9jcmVhdGUoJ2dhaW4nKVxufV0ubWFwKG4gPT4gKFxuXHRjaGFpbihuLmlucHV0LCBuLmRyeSwgbi5vdXRwdXQpLFxuXHRjaGFpbihuLmlucHV0LCBuLmVmZmVjdCwgbi53ZXQsIG4ub3V0cHV0KSxcblx0c2V0KG4uZHJ5LmdhaW4sICd2YWx1ZScsIG4ucHJlZnMuZHJ5KSxcblx0c2V0KG4ud2V0LmdhaW4sICd2YWx1ZScsIG4ucHJlZnMud2V0KSxcblx0c2V0KG4uZWZmZWN0LCAnYnVmZmVyJywgYnVpbGRJbXB1bHNlKG4ucHJlZnMpKSxcblx0blxuKVxuXHQvLyBuXG5cblx0Lypcblx0bi5pbnB1dC5jb25uZWN0KG4uZWZmZWN0KTtcblx0bi5lZmZlY3QuY29ubmVjdChuLndldCk7XG5cdG4ud2V0LmNvbm5lY3Qobi5vdXRwdXQpO1xuXG5cdG4uaW5wdXQuY29ubmVjdChuLmRyeSk7XG5cdG4uZHJ5LmNvbm5lY3Qobi5vdXRwdXQpO1xuXHQqL1xuXHQvKlxuXHRuLmRyeS5nYWluLnZhbHVlID0gbi5wcmVmcy5kcnk7XG5cdG4ud2V0LmdhaW4udmFsdWUgPSBuLnByZWZzLndldDtcblx0bi5lZmZlY3QuYnVmZmVyID0gYnVpbGRJbXB1bHNlKG4ucHJlZnMpO1xuXHQqL1xuXHQvLyBzZXQobi53ZXQuZ2FpbiwgJ3ZhbHVlJywgbi5wcmVmcy53ZXQpLFxuXHQvLyBzZXQobi5lZmZlY3QsICdidWZmZXInLCBidWlsZEltcHVsc2Uobi5wcmVmcykpLFxuXHQvLyByZXR1cm4gbjtcbikucG9wKCk7XG5cbmNvbnN0IHVwZGF0ZSA9IChuLCBwcmVmcykgPT4gKFxuLy9cdGNvbnNvbGUubG9nKHByZWZzLCBuLnByZWZzKSxcblx0KG4ucHJlZnMuc2Vjb25kcyAhPT0gcHJlZnMuc2Vjb25kcyB8fCBuLnByZWZzLmRlY2F5ICE9PSBwcmVmcy5kZWNheSlcblx0XHQmJiBzZXQobi5lZmZlY3QsICdidWZmZXInLCBidWlsZEltcHVsc2Uobi5wcmVmcykpLFxuXHQobi5wcmVmcy5kcnkgIT09IHByZWZzLmRyeSlcblx0XHQmJiBzZXQobi5kcnkuZ2FpbiwgJ3ZhbHVlJywgcHJlZnMuZHJ5KSxcblx0KG4ucHJlZnMud2V0ICE9PSBwcmVmcy53ZXQpXG5cdFx0JiYgc2V0KG4ud2V0LmdhaW4sICd2YWx1ZScsIHByZWZzLndldCksXG5cdHNldChuLCAncHJlZnMnLCBPYmplY3QuYXNzaWduKHt9LCBuLnByZWZzLCBwcmVmcykpLFxuXHRuXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlLFxuXHR1cGRhdGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmNvbnN0IHtcblx0Y29udGV4dCwgc2V0LCBpc1NldCwgaXNHZXQsXG5cdHNjaGVkdWxlOiBfc2NoZWR1bGUsXG5cdGNyZWF0ZTogX2NyZWF0ZSxcblx0Y29ubmVjdDogX2Nvbm5lY3QsIGRpc2Nvbm5lY3Q6IF9kaXNjb25uZWN0XG59ID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbmNvbnN0IHJldmVyYiA9IHJlcXVpcmUoJy4vZWZmZWN0cy9yZXZlcmInKTtcbmNvbnN0IGxmbyA9IHJlcXVpcmUoJy4vZWZmZWN0cy9sZm8nKTtcbmNvbnN0IGFkc3IgPSByZXF1aXJlKCcuL2NvbnRyb2xzL2Fkc3InKTtcblxuY29uc3QgY3JlYXRlID0gKHR5cGUsIHByZWZzID0ge30sIGN0eCA9IGNvbnRleHQpID0+IE9iamVjdC5hc3NpZ24oe30sXG5cdG9iai5zd2l0Y2godHlwZSwge1xuXHRcdHZjbzogKCkgPT4gKHtvdXRwdXQ6IF9jcmVhdGUoJ29zY2lsbGF0b3InKX0pLFxuXHRcdHZjYTogKCkgPT4gKHt0aHJvdWdoOiBfY3JlYXRlKCdnYWluJyl9KSxcblx0XHR2Y2Y6ICgpID0+ICh7dGhyb3VnaDogX2NyZWF0ZSgnYmlxdWFkRmlsdGVyJyl9KSxcblx0XHRsZm86ICgpID0+IGxmby5jcmVhdGUocHJlZnMpLFxuXHRcdHJldmVyYjogKCkgPT4gcmV2ZXJiLmNyZWF0ZShwcmVmcyksXG5cdFx0YWRzcjogKCkgPT4gYWRzci5jcmVhdGUocHJlZnMpXG5cdH0pKCksXG5cdHt0eXBlLCBvdXQ6IFtdfVxuKTtcblxuY29uc3QgY3V0b2ZmVG9GcmVxID0gY3V0b2ZmID0+IHtcblx0Y29uc3QgbWluVmFsdWUgPSA0MDtcblx0Y29uc3QgbWF4VmFsdWUgPSBjb250ZXh0LnNhbXBsZVJhdGUgLyAyO1xuXHQvLyBMb2dhcml0aG0gKGJhc2UgMikgdG8gY29tcHV0ZSBob3cgbWFueSBvY3RhdmVzIGZhbGwgaW4gdGhlIHJhbmdlLlxuXHR2YXIgbnVtYmVyT2ZPY3RhdmVzID0gTWF0aC5sb2cobWF4VmFsdWUgLyBtaW5WYWx1ZSkgLyBNYXRoLkxOMjtcblx0Ly8gQ29tcHV0ZSBhIG11bHRpcGxpZXIgZnJvbSAwIHRvIDEgYmFzZWQgb24gYW4gZXhwb25lbnRpYWwgc2NhbGUuXG5cdHZhciBtdWx0aXBsaWVyID0gTWF0aC5wb3coMiwgbnVtYmVyT2ZPY3RhdmVzICogKGN1dG9mZiAtIDEuMCkpO1xuXHQvLyBHZXQgYmFjayB0byB0aGUgZnJlcXVlbmN5IHZhbHVlIGJldHdlZW4gbWluIGFuZCBtYXguXG5cdHJldHVybiBtYXhWYWx1ZSAqIG11bHRpcGxpZXI7XG59O1xuXG5jb25zdCB1cGRhdGUgPSAobm9kZSwgcHJlZnMpID0+IG9iai5zd2l0Y2gobm9kZS50eXBlLCB7XG5cdHZjbzogKCkgPT4gKFxuXHRcdGlzU2V0KHByZWZzLnR5cGUpICYmIHNldChub2RlLm91dHB1dCwgJ3R5cGUnLCBwcmVmcy50eXBlKSxcblx0XHRpc1NldChwcmVmcy5mcmVxKSAmJiBzZXQobm9kZS5vdXRwdXQuZnJlcXVlbmN5LCAndmFsdWUnLCBwcmVmcy5mcmVxKSxcblx0XHRpc1NldChwcmVmcy5kZXR1bmUpICYmIHNldChub2RlLm91dHB1dC5kZXR1bmUsICd2YWx1ZScsIHByZWZzLmRldHVuZSksXG5cdFx0T2JqZWN0LmFzc2lnbihub2RlLCB7cHJlZnN9KVxuXHQpLFxuXHR2Y2E6ICgpID0+IChcblx0XHRpc1NldChwcmVmcy5nYWluKSAmJiBzZXQobm9kZS50aHJvdWdoLmdhaW4sICd2YWx1ZScsIHByZWZzLmdhaW4pLFxuXHRcdE9iamVjdC5hc3NpZ24obm9kZSwge3ByZWZzfSlcblx0KSxcblx0dmNmOiAoKSA9PiAoXG5cdFx0aXNTZXQocHJlZnMudHlwZSkgJiYgc2V0KG5vZGUudGhyb3VnaCwgJ3R5cGUnLCBwcmVmcy50eXBlKSxcblx0XHRpc1NldChwcmVmcy5jdXRvZmYpXG5cdFx0XHQmJiBfc2NoZWR1bGUobm9kZS50aHJvdWdoLCAnZnJlcXVlbmN5JywgW2N1dG9mZlRvRnJlcShwcmVmcy5jdXRvZmYpXSwgW2NvbnRleHQuY3VycmVudFRpbWUgKyAwLjAwMDFdKSxcblx0XHRcdC8vIHNldChub2RlLnRocm91Z2guZnJlcXVlbmN5LCAndmFsdWUnLCBjdXRvZmZUb0ZyZXEocHJlZnMuY3V0b2ZmKSksXG5cdFx0aXNTZXQocHJlZnMucmVzb25hbmNlKVxuXHRcdFx0JiYgX3NjaGVkdWxlKG5vZGUudGhyb3VnaCwgJ1EnLCBbcHJlZnMucmVzb25hbmNlICogMzBdLCBbY29udGV4dC5jdXJyZW50VGltZSArIDAuMDAwMV0pLFxuXHRcdE9iamVjdC5hc3NpZ24obm9kZSwge3ByZWZzfSlcblx0KSxcblx0cmV2ZXJiOiAoKSA9PiByZXZlcmIudXBkYXRlKG5vZGUsIHByZWZzKSxcblx0YWRzcjogKCkgPT4gYWRzci51cGRhdGUobm9kZSwgcHJlZnMpLFxuXHRsZm86ICgpID0+IGxmby51cGRhdGUobm9kZSwgcHJlZnMpXG59KSgpO1xuXG5jb25zdCBjb25uZWN0ID0gKG5vZGUxLCBub2RlMikgPT4gIShub2RlMS5vdXQgJiYgbm9kZTEub3V0LmluZGV4T2Yobm9kZTIpID4gLTEpXG5cdD8gKF9jb25uZWN0KFxuXHRcdFx0Ly8gaW5wdXRcblx0XHRcdGlzR2V0KG5vZGUxLm91dHB1dClcblx0XHRcdHx8IGlzR2V0KG5vZGUxLnRocm91Z2gpXG5cdFx0XHR8fCBpc1NldChub2RlMS5jb25uZWN0KSAmJiBub2RlMSxcblx0XHRcdC8vIG91dHB1dFxuXHRcdFx0KG5vZGUyIGluc3RhbmNlb2YgQXVkaW9QYXJhbSkgJiYgbm9kZTJcblx0XHRcdHx8IGlzR2V0KG5vZGUyLmlucHV0KVxuXHRcdFx0fHwgaXNHZXQobm9kZTIudGhyb3VnaClcblx0XHRcdHx8IG5vZGUyXG5cdFx0KSxcblx0XHRPYmplY3QuYXNzaWduKHt9LCBub2RlMSwge1xuXHRcdFx0b3V0OiBbXS5jb25jYXQobm9kZTEub3V0IHx8IFtdLCBbbm9kZTJdKVxuXHRcdH0pKVxuXHQ6IG5vZGUxO1xuXG5jb25zdCBkaXNjb25uZWN0ID0gKG5vZGUxLCBub2RlMikgPT4gKFxuXHQvLyAoY29uc29sZS5sb2coJ2Rpc3Njb25uZWN0aW5nJywgbm9kZTEsIG5vZGUyKSksXG5cdChub2RlMS5vdXQuaW5kZXhPZihub2RlMikgPiAtMSlcblx0PyAoX2Rpc2Nvbm5lY3QoXG5cdFx0XHQvLyBpbnB1dFxuXHRcdFx0aXNHZXQobm9kZTEub3V0cHV0KVxuXHRcdFx0fHwgaXNHZXQobm9kZTEudGhyb3VnaClcblx0XHRcdHx8IGlzU2V0KG5vZGUxLmNvbm5lY3QpICYmIG5vZGUxLFxuXHRcdFx0Ly8gb3V0cHV0XG5cdFx0XHQobm9kZTIgaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSAmJiBub2RlMlxuXHRcdFx0fHwgaXNHZXQobm9kZTIuaW5wdXQpXG5cdFx0XHR8fCBpc0dldChub2RlMi50aHJvdWdoKVxuXHRcdFx0fHwgbm9kZTJcblx0XHQpLFxuXHRcdE9iamVjdC5hc3NpZ24oe30sIG5vZGUxLCB7XG5cdFx0XHRvdXQ6IFtdLmNvbmNhdChcblx0XHRcdFx0bm9kZTEub3V0LnNsaWNlKDAsIG5vZGUxLm91dC5pbmRleE9mKG5vZGUyKSksXG5cdFx0XHRcdG5vZGUxLm91dC5zbGljZShub2RlMS5vdXQuaW5kZXhPZihub2RlMikgKyAxKVxuXHRcdFx0KVxuXHRcdH0pKVxuXHQ6ICh0eXBlb2Ygbm9kZTIgPT09ICd1bmRlZmluZWQnKVxuXHRcdD8gbm9kZTEub3V0LnJlZHVjZSgobm9kZTEsIHByZXZOb2RlKSA9PiBkaXNjb25uZWN0KG5vZGUxLCBwcmV2Tm9kZSksIG5vZGUxKVxuXHRcdDogbm9kZTFcbik7XG5cbmNvbnN0IHJlcm91dGUgPSAobm9kZTEsIG5vZGUyKSA9PiAobm9kZTEub3V0ICYmIG5vZGUxLm91dC5pbmRleE9mKG5vZGUyKSA9PT0gLTEpXG5cdD8gY29ubmVjdChkaXNjb25uZWN0KG5vZGUxKSwgbm9kZTIpXG5cdDogbm9kZTE7XG5cbmNvbnN0IGNoYWluID0gKC4uLm5vZGVzKSA9PiAoXG5cdG5vZGVzLmZvckVhY2goKG4sIGkpID0+IGlzU2V0KG5baSArIDFdKSAmJiBjb25uZWN0KG4sIG5vZGVzW2kgKyAxXSkpLFxuXHRub2Rlc1swXVxuKTtcblxuY29uc3QgdW5jaGFpbiA9ICguLi5ub2RlcykgPT4gKFxuXHRub2Rlcy5zbGljZSgpLnJldmVyc2UoKVxuXHRcdC5mb3JFYWNoKChuLCBpKSA9PiBpc1NldChuW2kgLSAxXSkgJiYgZGlzY29ubmVjdChub2Rlc1tpIC0gMV0sIG4pKSxcblx0bm9kZXNbMF1cbik7XG5cbmNvbnN0IHN0YXJ0ID0gKG5vZGUsIC4uLmFyZ3MpID0+IChub2RlLnR5cGUgPT09ICdsZm8nICYmIGxmby5zdGFydChub2RlLCAuLi5hcmdzKSB8fCBub2RlLm91dHB1dC5zdGFydCguLi5hcmdzKSwgbm9kZSk7XG5cbmNvbnN0IHN0b3AgPSAobm9kZSwgLi4uYXJncykgPT4gKG5vZGUub3V0cHV0LnN0b3AoLi4uYXJncyksIG5vZGUpO1xuXG5jb25zdCBzY2hlZHVsZSA9IChub2RlLCBwcmVmLCB2YWx1ZXMsIHRpbWVzKSA9PiAodmFsdWVzLmxlbmd0aCA9PT0gMSlcblx0PyBub2RlLnRocm91Z2hbcHJlZl0uc2V0VmFsdWVBdFRpbWUodmFsdWVzWzBdLCB0aW1lc1swXSlcblx0OiAobm9kZS50aHJvdWdoW3ByZWZdLnNldFZhbHVlQ3VydmVBdFRpbWUobmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMuc2xpY2UoMCwgMikpLCB0aW1lc1swXSwgdGltZXNbMV0pLFxuXHRcdCh2YWx1ZXMubGVuZ3RoID4gMikgJiYgc2NoZWR1bGUobm9kZSwgcHJlZiwgdmFsdWVzLnNsaWNlKDEpLCBbdGltZXNbMF0gKyB0aW1lc1sxXV0uY29uY2F0KHRpbWVzLnNsaWNlKDIpKSkpO1xuXG5jb25zdCBub3RlVG9GcmVxdWVuY3kgPSBmdW5jdGlvbihub3RlKSB7XG5cdHZhciBub3RlcyA9IFsnQScsICdBIycsICdCJywgJ0MnLCAnQyMnLCAnRCcsICdEIycsICdFJywgJ0YnLCAnRiMnLCAnRycsICdHIyddO1xuXHR2YXIga2V5TnVtYmVyO1xuXHR2YXIgb2N0YXZlO1xuXG5cdGlmIChub3RlLmxlbmd0aCA9PT0gMykge1xuXHRcdG9jdGF2ZSA9IG5vdGUuY2hhckF0KDIpO1xuXHR9IGVsc2Uge1xuXHRcdG9jdGF2ZSA9IG5vdGUuY2hhckF0KDEpO1xuXHR9XG5cblx0a2V5TnVtYmVyID0gbm90ZXMuaW5kZXhPZihub3RlLnNsaWNlKDAsIC0xKSk7XG5cblx0aWYgKGtleU51bWJlciA8IDMpIHtcblx0XHRrZXlOdW1iZXIgPSBrZXlOdW1iZXIgKyAxMiArICgob2N0YXZlIC0gMSkgKiAxMikgKyAxO1xuXHR9IGVsc2Uge1xuXHRcdGtleU51bWJlciA9IGtleU51bWJlciArICgob2N0YXZlIC0gMSkgKiAxMikgKyAxO1xuXHR9XG5cblx0cmV0dXJuIDQ0MCAqIE1hdGgucG93KDIsIChrZXlOdW1iZXIgLSA0OSkgLyAxMik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y29udGV4dCxcblx0Y3JlYXRlLFxuXHR1cGRhdGUsXG5cdHNjaGVkdWxlLFxuXHRjb25uZWN0LFxuXHRkaXNjb25uZWN0LFxuXHRyZXJvdXRlLFxuXHRjaGFpbixcblx0dW5jaGFpbixcblx0bm90ZVRvRnJlcXVlbmN5LFxuXHRzdGFydCxcblx0c3RvcCxcblx0dmNvOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCd2Y28nLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0dmNmOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCd2Y2YnLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0bGZvOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCdsZm8nLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0dmNhOiBwcmVmcyA9PiB1cGRhdGUoY3JlYXRlKCd2Y2EnLCB7fSwgY29udGV4dCksIHByZWZzKSxcblx0YWRzcjogcHJlZnMgPT4gY3JlYXRlKCdhZHNyJywgcHJlZnMsIGNvbnRleHQpLFxuXHRub3RlT246IGFkc3Iubm90ZU9uLFxuXHRub3RlT2ZmOiBhZHNyLm5vdGVPZmZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtvYmosIGZufSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5jb25zdCB7Y29udGV4dCwgY3JlYXRlOiBfY3JlYXRlLCBzZXQsIGNoYWluLCBkdXJhdGlvbiwgY2hEYXRhfSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuY29uc3QgY3JlYXRlID0gKGZpbGUsIGJ1ZmZlcikgPT4gW3tcblx0b3V0cHV0OiBfY3JlYXRlKCdidWZmZXJTb3VyY2UnKVxufV0ubWFwKG4gPT4gKFxuXHQoIWJ1ZmZlcilcblx0XHQ/IGZldGNoKGZpbGUpXG5cdFx0XHQudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG5cdFx0XHQudGhlbihidWZmZXIgPT4gY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYnVmZmVyLFxuXHRcdFx0XHRidWZmZXIgPT4gc2V0KG4ub3V0cHV0LCAnYnVmZmVyJywgYnVmZmVyKVxuXHRcdFx0KSlcblx0XHQ6IHNldChuLm91dHB1dCwgJ2J1ZmZlcicsIGJ1ZmZlciksXG5cdFx0bikpLnBvcCgpO1xuXG5jb25zdCB1cGRhdGUgPSAoKSA9PiB7XG5cbn07XG5cbmNvbnN0IGNsb25lID0gbiA9PiBjcmVhdGUobnVsbCwgbi5vdXRwdXQuYnVmZmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZSxcblx0dXBkYXRlLFxuXHRjbG9uZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5jb25zdCBmaWxlU2F2ZXIgPSByZXF1aXJlKCdmaWxlLXNhdmVyJyk7XG5jb25zdCBqc1ppcCA9IHJlcXVpcmUoXCJqc3ppcFwiKTtcbmNvbnN0IHtmbiwgb2JqfSA9IHJlcXVpcmUoXCJpYmxva3otZGF0YVwiKTtcblxuY29uc3QgbG9hZCA9IChmaWxlLCByZWFkQXMgPSAndGV4dCcpID0+ICQuY3JlYXRlKHN0cmVhbSA9PiB7XG5cdGNvbnN0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ZnIub25sb2FkID0gZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBjb25zb2xlLmxvZyhyZWFkQXMsIGV2LnRhcmdldC5yZXN1bHQpO1xuXHRcdHN0cmVhbS5vbk5leHQoXG5cdFx0XHRyZWFkQXMgPT09ICdqc29uJ1xuXHRcdFx0XHQ/IEpTT04ucGFyc2UoZXYudGFyZ2V0LnJlc3VsdClcblx0XHRcdFx0OiBldi50YXJnZXQucmVzdWx0XG5cdFx0KTtcblx0XHRzdHJlYW0ub25Db21wbGV0ZWQoKTtcblx0fTtcblx0Ly8gY29uc29sZS5sb2coZmlsZSwgcmVhZEFzKTtcblx0KCh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpXG5cdFx0PyAkLmZyb21Qcm9taXNlKGZldGNoKGZpbGUpKS5mbGF0TWFwKHJlcyA9PiByZXMuYmxvYigpKVxuXHRcdDogJC5qdXN0KGZpbGUpKVxuXHRcdC5zdWJzY3JpYmUoZiA9PiBmbi5zd2l0Y2gocmVhZEFzLCB7XG5cdFx0XHRhcnJheUJ1ZmZlcjogZiA9PiBmci5yZWFkQXNBcnJheUJ1ZmZlcihmKSxcblx0XHRcdGRlZmF1bHQ6IGYgPT4gZnIucmVhZEFzVGV4dChmKVxuXHRcdH0pKGYpKTtcbn0pO1xuXG5jb25zdCBsb2FkWmlwID0gZmlsZSA9PiBsb2FkKGZpbGUsICdhcnJheUJ1ZmZlcicpXG5cdC5mbGF0TWFwKGRhdGEgPT4gJC5mcm9tUHJvbWlzZShqc1ppcC5sb2FkQXN5bmMoZGF0YSkpKVxuXHQuZmxhdE1hcCh6ZiA9PiAkLmNvbmNhdChcblx0XHRPYmplY3Qua2V5cyh6Zi5maWxlcylcblx0XHRcdC5maWx0ZXIoayA9PiAhemYuZmlsZXNba10uZGlyKVxuXHRcdFx0Ly8gLm1hcChrID0+IChjb25zb2xlLmxvZyhrKSwgaykpXG5cdFx0XHQubWFwKGsgPT4gJC5mcm9tUHJvbWlzZSh6Zi5maWxlc1trXS5hc3luYygnYXJyYXlidWZmZXInKSkubWFwKHYgPT4gKHtrLCB2fSkpKVxuXHRcdCkucmVkdWNlKChvLCB7aywgdn0pID0+IG9iai5wYXRjaChvLCBrLCB2KSwge30pXG5cdCk7XG5cbmNvbnN0IHNhdmUgPSAoZmlsZU5hbWUsIGNvbnRlbnQpID0+IGZpbGVTYXZlci5zYXZlQXMoXG5cdG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShjb250ZW50KV0sIHt0eXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD11dGYtOFwifSksXG5cdGZpbGVOYW1lXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bG9hZCxcblx0bG9hZFppcCxcblx0c2F2ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge29ian0gPSByZXF1aXJlKCdpYmxva3otZGF0YScpO1xuXG5jb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5cbmNvbnN0IGFycmlmeSA9IG8gPT4gbyBpbnN0YW5jZW9mIE9iamVjdFxuICA/ICEobyBpbnN0YW5jZW9mIEFycmF5KSAmJiBrZXlzKG8pLmZpbHRlcihrID0+IGsubWF0Y2goL14tP1swLTkuXSskLykpLmxlbmd0aCA9PT0ga2V5cyhvKS5sZW5ndGhcbiAgICA/IGtleXMobykubWFwKGsgPT4gYXJyaWZ5KG9ba10pKVxuICAgIDoga2V5cyhvKS5yZWR1Y2UoKG8yLCBrKSA9PiBvYmoucGF0Y2gobzIsIGssIGFycmlmeShvW2tdKSksIHt9KVxuICA6IG87XG5cbmNvbnN0IHRvRGF0YSA9IGZvcm0gPT4gYXJyaWZ5KEFycmF5LmZyb20oZm9ybS5lbGVtZW50cylcbiAgLy8gLm1hcChlbCA9PiAoY29uc29sZS5sb2coZWwubmFtZSksIGVsKSlcbiAgLmZpbHRlcihlbCA9PiBlbC5uYW1lICE9PSB1bmRlZmluZWQgJiYgZWwubmFtZSAhPT0gJycpXG4gIC5yZWR1Y2UoKG8sIGVsKSA9PiBvYmoucGF0Y2gobywgZWwubmFtZS5zcGxpdCgnLicpLFxuICAgIGVsLnR5cGUgJiYgZWwudHlwZSA9PT0gJ251bWJlcidcbiAgICAgID8gTnVtYmVyKGVsLnZhbHVlKVxuICAgICAgOiBlbC52YWx1ZVxuICApLCB7fSkpO1xuXG5jb25zdCBjbGVhciA9IGZvcm0gPT4gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICAuZm9yRWFjaChlbCA9PiAoZWwudmFsdWUgPSBudWxsKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR0b0RhdGEsXG5cdGNsZWFyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG5jb25zdCBwYXJzZVBhZCA9IHBhZCA9PiBwYWQgJiYgKHtcblx0YXhlczogcGFkLmF4ZXMsXG5cdGJ1dHRvbnM6IHBhZC5idXR0b25zLm1hcChidXR0b24gPT4gKHtcblx0XHRwcmVzc2VkOiBidXR0b24ucHJlc3NlZCxcblx0XHR2YWx1ZTogYnV0dG9uLnZhbHVlXG5cdH0pKSxcblx0Y29ubmVjdGVkOiBwYWQuY29ubmVjdGVkLFxuXHRpZDogcGFkLmlkLFxuXHRpbmRleDogcGFkLmluZGV4LFxuXHRtYXBwaW5nOiBwYWQubWFwcGluZyxcblx0dGltZXN0YW1wOiBwYWQudGltZXN0YW1wXG59KSB8fCBwYWQ7XG5cbmNvbnN0IGxpc3QgPSAoKSA9PiBBcnJheS5mcm9tKG5hdmlnYXRvci5nZXRHYW1lcGFkcygpIHx8IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpIHx8IFtdKVxuXHQubWFwKHBhcnNlUGFkKTtcblxuY29uc3QgY2hhbmdlcyA9ICgpID0+IHRpbWUuZnJhbWUoKVxuXHQubWFwKGxpc3QpXG5cdC5kaXN0aW5jdFVudGlsQ2hhbmdlZChwYWRzID0+IHBhZHMpXG5cdC8vXHRwYWRzLnJlZHVjZSgociwgcGFkKSA9PiAhcGFkICYmIHIgfHwgKHIgKyAocGFkLmF4ZXMgfHwgJycpICsgKHBhZC5idXR0b25zIHx8ICcnKSksICcnKSlcblx0LnNoYXJlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRsaXN0LFxuXHRjaGFuZ2VzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3Qga2V5cyA9IFsnQycsICdDIycsICdEJywgJ0QjJywgJ0UnLCAnRicsICdGIycsICdHJywgJ0cjJywgJ0EnLCAnQSMnLCAnQiddO1xuXG5jb25zdCBudW1iZXJUb05vdGUgPSBudW1iZXIgPT4gKHtcblx0a2V5OiBrZXlzW251bWJlciAlIDEyXSxcblx0b2N0YXZlOiBwYXJzZUludCgobnVtYmVyIC0gbnVtYmVyICUgMTIpIC8gMTIsIDEwKSAtIDEsXG5cdG51bWJlclxufSk7XG5cbmNvbnN0IG5vdGVUb051bWJlciA9IG5vdGUgPT4gKFxuXHRrZXlzLmluZGV4T2Yobm90ZS5yZXBsYWNlKC9bMC05XSsvLCAnJykpICtcblx0KHBhcnNlSW50KG5vdGUucmVwbGFjZSgvW0EtWiNiXSsvLCAnJyksIDEwKSArIDEpICogMTJcbik7XG5cbmNvbnN0IHBhcnNlTWlkaU1zZyA9IGV2ZW50ID0+IHtcblx0Ly8gTWFzayBvZmYgdGhlIGxvd2VyIG5pYmJsZSAoTUlESSBjaGFubmVsLCB3aGljaCB3ZSBkb24ndCBjYXJlIGFib3V0KVxuXG5cdGNvbnN0IHN0YXR1cyA9IGV2ZW50LmRhdGFbMF0gJiAweGYwO1xuXHRjb25zdCBiaW5hcnkgPSBldmVudC5kYXRhWzBdLnRvU3RyaW5nKDIpO1xuXHRjb25zdCBjaGFubmVsID0gZXZlbnQuZGF0YVswXSAtIHN0YXR1cyArIDE7XG5cdGxldCBtc2cgPSB7fTtcblxuXHRzd2l0Y2ggKGJpbmFyeS5zbGljZSgwLCA0KSkge1xuXHRcdC8vIG5vdGVvZmZcblx0XHRjYXNlIFwiMTAwMFwiOlxuXHRcdFx0bXNnID0ge1xuXHRcdFx0XHRzdGF0ZTogJ25vdGVPZmYnLFxuXHRcdFx0XHRub3RlOiBudW1iZXJUb05vdGUoZXZlbnQuZGF0YVsxXSlcblx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHQvLyBub3Rlb25cblx0XHRjYXNlIFwiMTAwMVwiOlxuXHRcdFx0bXNnID0gKGV2ZW50LmRhdGFbMl0gIT09IDApIC8vIGlmIHZlbG9jaXR5ICE9IDAsIHRoaXMgaXMgYSBub3RlLW9uIG1lc3NhZ2Vcblx0XHRcdFx0PyB7XG5cdFx0XHRcdFx0c3RhdGU6ICdub3RlT24nLFxuXHRcdFx0XHRcdG5vdGU6IG51bWJlclRvTm90ZShldmVudC5kYXRhWzFdKSxcblx0XHRcdFx0XHR2ZWxvY2l0eTogcGFyc2VGbG9hdCgoZXZlbnQuZGF0YVsyXSAvIDEyNykudG9GaXhlZCgyKSlcblx0XHRcdFx0fVxuXHRcdFx0XHQ6IHsgLy8gaWYgdmVsb2NpdHkgPT0gMCwgZmFsbCB0aHJ1OiBpdCdzIGEgbm90ZS1vZmYuXHRNSURJJ3Mgd2VpcmQsIHlhJ2xsLlxuXHRcdFx0XHRcdHN0YXRlOiAnbm90ZU9mZicsXG5cdFx0XHRcdFx0bm90ZTogbnVtYmVyVG9Ob3RlKGV2ZW50LmRhdGFbMV0pXG5cdFx0XHRcdH07XG5cdFx0XHRicmVhaztcblx0XHQvLyBwaXRjaCB3aGVlbFxuXHRcdGNhc2UgXCIxMTEwXCI6XG5cdFx0XHRtc2cgPSB7XG5cdFx0XHRcdHN0YXRlOiAncGl0Y2hCZW5kJyxcblx0XHRcdFx0cGl0Y2hWYWx1ZTogKGV2ZW50LmRhdGFbMl0gPT09IDY0KSA/IDAgOiBwYXJzZUZsb2F0KChldmVudC5kYXRhWzJdIC8gNjMuNSAtIDEpLnRvRml4ZWQoMikpXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdFx0Ly8gY29udHJvbGxlclxuXHRcdGNhc2UgXCIxMDExXCI6XG5cdFx0XHRtc2cgPSB7XG5cdFx0XHRcdHN0YXRlOiBcImNvbnRyb2xsZXJcIixcblx0XHRcdFx0Y29udHJvbGxlcjogZXZlbnQuZGF0YVsxXSxcblx0XHRcdFx0dmFsdWU6IHBhcnNlRmxvYXQoKGV2ZW50LmRhdGFbMl0gLyAxMjcpLnRvRml4ZWQoMikpXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIjExMDBcIjpcblx0XHRcdG1zZyA9IHtcblx0XHRcdFx0c3RhdGU6IFwiYmFua1NlbGVjdFwiLFxuXHRcdFx0XHRiYW5rOiBldmVudC5kYXRhWzFdXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdG1zZyA9IHtcblx0XHRcdFx0c3RhdGU6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbXNnLCB7XG5cdFx0YmluYXJ5LFxuXHRcdHN0YXR1cyxcblx0XHRjaGFubmVsLFxuXHRcdGRhdGE6IGV2ZW50LmRhdGFcblx0fSk7XG59O1xuLy9cbi8vIGNvbnN0IGhvb2tVcE1JRElJbnB1dCA9IG1pZGlBY2Nlc3MgPT4ge1xuLy8gXHR2YXIgaGF2ZUF0TGVhc3RPbmVEZXZpY2UgPSBmYWxzZTtcbi8vIFx0dmFyIGlucHV0cyA9IG1pZGlBY2Nlc3MuaW5wdXRzLnZhbHVlcygpO1xuLy8gXHRmb3IgKHZhciBpbnB1dCA9IGlucHV0cy5uZXh0KCk7IGlucHV0ICYmICFpbnB1dC5kb25lOyBpbnB1dCA9IGlucHV0cy5uZXh0KCkpIHtcbi8vIFx0XHRpbnB1dC52YWx1ZS5vbm1pZGltZXNzYWdlID0gTUlESU1lc3NhZ2VFdmVudEhhbmRsZXI7XG4vLyBcdFx0aGF2ZUF0TGVhc3RPbmVEZXZpY2UgPSB0cnVlO1xuLy8gXHR9XG4vLyB9O1xuLy9cbi8vIGNvbnN0IG9uTUlESUluaXQgPSBtaWRpID0+IHtcbi8vIFx0aG9va1VwTUlESUlucHV0KG1pZGkpO1xuLy8gXHRtaWRpLm9uc3RhdGVjaGFuZ2UgPSBob29rVXBNSURJSW5wdXQ7XG4vLyB9O1xuLy9cbi8vIGNvbnN0IG9uTUlESVJlamVjdCA9IGVyciA9PlxuLy8gXHRjb25zb2xlLmxvZyhlcnIsICdUaGUgTUlESSBzeXN0ZW0gZmFpbGVkIHRvIHN0YXJ0LicpO1xuLy9cbi8vIChuYXZpZ2F0b3IucmVxdWVzdE1JRElBY2Nlc3MpXG4vLyBcdFx0JiYgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCkudGhlbihvbk1JRElJbml0LCBvbk1JRElSZWplY3QpO1xuXG5jb25zdCBwYXJzZUFjY2VzcyA9IGFjY2VzcyA9PiB7XG5cdGxldCBpbnB1dHMgPSBbXTtcblx0bGV0IG91dHB1dHMgPSBbXTtcblxuXHQvLyBjb25zb2xlLmxvZyhhY2Nlc3MpO1xuXG5cdGFjY2Vzcy5pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dHMucHVzaChpbnB1dCkpO1xuXHRhY2Nlc3Mub3V0cHV0cy5mb3JFYWNoKG91dHB1dCA9PiBvdXRwdXRzLnB1c2gob3V0cHV0KSk7XG5cdHJldHVybiB7YWNjZXNzLCBpbnB1dHMsIG91dHB1dHN9O1xufTtcblxuY29uc3QgaW5pdCA9ICgpID0+IHtcblx0Y29uc3QgZGV2aWNlcyQgPSBuZXcgUnguU3ViamVjdCgpO1xuXHQkLmZyb21Qcm9taXNlKG5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2VzcygpKVxuXHRcdC5mbGF0TWFwKGFjY2VzcyA9PiAkLmNyZWF0ZShzdHJlYW0gPT4ge1xuXHRcdFx0YWNjZXNzLm9uc3RhdGVjaGFuZ2UgPSBjb25uZWN0aW9uID0+IHN0cmVhbS5vbk5leHQoY29ubmVjdGlvbi5jdXJyZW50VGFyZ2V0KTtcblx0XHR9KS5zdGFydFdpdGgoYWNjZXNzKSlcblx0XHQubWFwKHBhcnNlQWNjZXNzKVxuXHRcdC8vIC5tYXAoZGF0YSA9PiAoY29uc29sZS5sb2coJ21pZGkgYWNjZXNzJywgZGF0YSksIGRhdGEpKVxuXHRcdC5zdWJzY3JpYmUoZGV2aWNlID0+IGRldmljZXMkLm9uTmV4dChkZXZpY2UpKTtcblx0XHQvLyAuc2hhcmUoKTtcblxuXHRjb25zdCBtc2ckID0gbmV3IFJ4LlN1YmplY3QoKTtcblx0ZGV2aWNlcyQuZmxhdE1hcChcblx0XHQoe2FjY2VzcywgaW5wdXRzfSkgPT4gaW5wdXRzLnJlZHVjZShcblx0XHRcdFx0KG1zZ1N0cmVhbSwgaW5wdXQpID0+IG1zZ1N0cmVhbS5tZXJnZShcblx0XHRcdFx0XHQkLmZyb21FdmVudFBhdHRlcm4oaCA9PiB7XG5cdFx0XHRcdFx0XHRpbnB1dC5vbm1pZGltZXNzYWdlID0gaDtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5tYXAobXNnID0+ICh7YWNjZXNzLCBpbnB1dCwgbXNnfSkpXG5cdFx0XHRcdCksICQuZW1wdHkoKVxuXHRcdFx0KVxuXHQpLnN1YnNjcmliZShtc2cgPT4gbXNnJC5vbk5leHQobXNnKSk7XG5cblx0cmV0dXJuIHtcblx0XHRkZXZpY2VzJCxcblx0XHRtc2ckXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0aW5pdCxcblx0bnVtYmVyVG9Ob3RlLFxuXHRub3RlVG9OdW1iZXIsXG5cdHBhcnNlTWlkaU1zZ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUnggPSByZXF1aXJlKCdyeCcpO1xuY29uc3QgJCA9IFJ4Lk9ic2VydmFibGU7XG5jb25zdCB7b2JqfSA9IHJlcXVpcmUoJ2libG9rei1kYXRhJyk7XG5cbmxldCBwb2NrZXQ7XG5cbmxldCByZWR1Y2VycyQgPSBuZXcgUnguU3ViamVjdCgpO1xubGV0IHBvY2tldCQgPSBuZXcgUnguQmVoYXZpb3JTdWJqZWN0KHt9KTtcblxucmVkdWNlcnMkXG5cdC5zY2FuKChwb2NrZXQsIHJlZHVjZSkgPT4gcmVkdWNlKHBvY2tldCksIHt9KVxuXHQuc3Vic2NyaWJlKHBvY2tldCA9PiBwb2NrZXQkLm9uTmV4dChwb2NrZXQpKTtcblxucG9ja2V0JC5zdWJzY3JpYmUoX3BvY2tldCA9PiB7XG5cdC8vIGNvbnNvbGUubG9nKHtwb2NrZXR9KTtcblx0cG9ja2V0ID0gX3BvY2tldDtcbn0pO1xuXG5jb25zdCBwdXQgPSAocGF0aCwgdmFsKSA9PiByZWR1Y2VycyQub25OZXh0KHBvY2tldCA9PiBvYmoucGF0Y2gocG9ja2V0LCBwYXRoLCB2YWwpKTtcbmNvbnN0IGdldCA9IHBhdGggPT4gb2JqLnN1Yihwb2NrZXQsIHBhdGgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cHV0LFxuXHRnZXQsXG5cdHJlZHVjZXJzJCxcblx0c3RyZWFtOiBwb2NrZXQkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSeCA9IHJlcXVpcmUoJ3J4Jyk7XG5jb25zdCAkID0gUnguT2JzZXJ2YWJsZTtcblxuY29uc3QgcmFmID0gcmVxdWlyZSgncmFmJyk7XG5cbmNvbnN0IHRpY2sgPSBjYiA9PiByYWYoZnVuY3Rpb24oZHQpIHtcblx0Y2IoZHQpO1xuXHR0aWNrKGNiKTtcbn0pO1xuXG5jb25zdCBmcmFtZSA9ICgpID0+ICQuY3JlYXRlKFxuXHRvYnMgPT4gdGljayhkdCA9PiBvYnMub25OZXh0KGR0KSlcbilcblx0LmZpbHRlcihkdCA9PiBkdCAhPT0gMClcblx0LnNoYXJlKCk7XG5cbmNvbnN0IGxvb3AgPSAoc3RhdGUkLCBub2RlKSA9PiBmcmFtZShub2RlKS53aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIChkdCwgc3RhdGUpID0+ICh7ZHQsIHN0YXRlfSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0ZnJhbWUsXG5cdGxvb3Bcbn07XG4iXX0=
